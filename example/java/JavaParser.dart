//
// This is the grammar specification from the Final Draft of the generic spec.
//
////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2007 IBM Corporation.
// All rights reserved. This program and the accompanying materials
// are made available under the terms of the Eclipse Public License v1.0
// which accompanies this distribution, and is available at
// http://www.eclipse.org/legal/epl-v10.html
//
//Contributors:
//    Philippe Charles (pcharles@us.ibm.com) - initial API and implementation

////////////////////////////////////////////////////////////////////////////////


    //#line 146 "btParserTemplateS.gi

import 'package:lpg2/lpg2.dart';
import 'dart:io';
import 'JavaParserprs.dart';
import 'JavaParsersym.dart';

    //#line 18 "GJavaParser.g


    //#line 155 "btParserTemplateS.gi

class JavaParser extends Object implements RuleAction
{
      PrsStream prsStream = PrsStream();
    
      bool unimplementedSymbolsWarning = false;

      static  ParseTable prsTable  = JavaParserprs();
      ParseTable getParseTable()  { return JavaParser.prsTable; }

      late BacktrackingParser btParser;
      BacktrackingParser getParser(){ return btParser; }

      void setResult(Object? object1){ btParser.setSym1(object1); }
      Object? getRhsSym(int i){ return btParser.getSym(i); }

     int getRhsTokenIndex(int i)  { return btParser.getToken(i); }
     IToken getRhsIToken(int i)   { return prsStream.getIToken(getRhsTokenIndex(i)); }
    
     int getRhsFirstTokenIndex(int i)   { return btParser.getFirstToken(i); }
     IToken getRhsFirstIToken(int i)  { return prsStream.getIToken(getRhsFirstTokenIndex(i)); }

     int getRhsLastTokenIndex(int i)  { return btParser.getLastToken(i); }
     IToken getRhsLastIToken(int i)  { return prsStream.getIToken(getRhsLastTokenIndex(i)); }

     int getLeftSpan() { return btParser.getFirstToken(); }
     IToken getLeftIToken()   { return prsStream.getIToken(getLeftSpan()); }

     int getRightSpan() { return btParser.getLastToken(); }
     IToken getRightIToken() { return prsStream.getIToken(getRightSpan()); }

     int getRhsErrorTokenIndex(int i)  
     {
        var index = btParser.getToken(i);
        var err = prsStream.getIToken(index);
        return (err is ErrorToken ? index : 0);
     }
     ErrorToken? getRhsErrorIToken(int i)  
    {
        var index = btParser.getToken(i);
        var err = prsStream.getIToken(index);
        return err as ErrorToken?;
    }

    void  reset(ILexStream lexStream)   
    {
        prsStream.resetLexStream(lexStream);
        btParser.reset(prsStream);

        try
        {
            prsStream.remapTerminalSymbols(orderedTerminalSymbols(), JavaParser.prsTable.getEoftSymbol());
        } 
        on NullExportedSymbolsException{}
        on UnimplementedTerminalsException catch (e)
        {
            if (unimplementedSymbolsWarning) {
                var unimplemented_symbols = e.getSymbols();
                stdout.writeln("The Lexer will not scan the following token(s):");
                for (var i  = 0; i < unimplemented_symbols!.size(); i++)
                {
                    int id = unimplemented_symbols.get(i);
                    stdout.writeln("    " + JavaParsersym.orderedTerminalSymbols[id]);               
                }
                stdout.writeln();
            }
        }
        on UndefinedEofSymbolException catch (e)
        {
            throw (UndefinedEofSymbolException
                ("The Lexer does not implement the Eof symbol " +
                JavaParsersym.orderedTerminalSymbols[JavaParser.prsTable.getEoftSymbol()]));
        }

    }
    
    JavaParser([ILexStream? lexStream])
    {
        try
        {
            btParser = BacktrackingParser(null, JavaParser.prsTable, this);
        }
        on  NotBacktrackParseTableException
        {
            throw (NotBacktrackParseTableException
                ("Regenerate JavaParserprs.dart with -BACKTRACK option"));
        }
        on BadParseSymFileException
        {
            throw (BadParseSymFileException("Bad Parser Symbol File -- JavaParsersym.dart"));
        }

        if(lexStream != null){
          reset(lexStream);
        }
    }
    
   
    
    int numTokenKinds(){ return JavaParsersym.numTokenKinds; }
    List<String>  orderedTerminalSymbols()  { return JavaParsersym.orderedTerminalSymbols; }
    String  getTokenKindName(int kind)   { return JavaParsersym.orderedTerminalSymbols[kind]; }
    int  getEOFTokenKind() { return JavaParser.prsTable.getEoftSymbol(); }
    IPrsStream getIPrsStream(){ return prsStream; }


    Ast? parser([int error_repair_count = 0 ,Monitor?  monitor])
    {
        btParser.setMonitor(monitor);
        
        try{
            return btParser.fuzzyParse(error_repair_count) as Ast?;
        }
        on BadParseException catch(e){
            prsStream.reset(e.error_token); // point to error token
            var diagnoseParser = DiagnoseParser(prsStream, JavaParser.prsTable);
            diagnoseParser.diagnose(e.error_token);
        }
        return null;
    }

    //
    // Additional entry points, if any
    //
    
   
    Ast?  parseClassBodyDeclarationsopt([Monitor? monitor, int error_repair_count= 0]) 
    {
        btParser.setMonitor(monitor);
        
        try
        {
            return btParser.fuzzyParseEntry(JavaParsersym.TK_ClassBodyDeclarationsoptMarker, error_repair_count) as Ast?;
        }
        on BadParseException catch(e)
        {
            prsStream.reset(e.error_token); // point to error token
            var diagnoseParser = DiagnoseParser(prsStream, JavaParser.prsTable);
            diagnoseParser.diagnoseEntry(JavaParsersym.TK_ClassBodyDeclarationsoptMarker, e.error_token);
        }

        return null;
    }

   
    Ast?  parseLPGUserAction([Monitor? monitor, int error_repair_count= 0]) 
    {
        btParser.setMonitor(monitor);
        
        try
        {
            return btParser.fuzzyParseEntry(JavaParsersym.TK_LPGUserActionMarker, error_repair_count) as Ast?;
        }
        on BadParseException catch(e)
        {
            prsStream.reset(e.error_token); // point to error token
            var diagnoseParser = DiagnoseParser(prsStream, JavaParser.prsTable);
            diagnoseParser.diagnoseEntry(JavaParsersym.TK_LPGUserActionMarker, e.error_token);
        }

        return null;
    }


    //#line 185 "GJavaParser.g


    
    //#line 285 "btParserTemplateS.gi

    
    void ruleAction(int ruleNumber ) 
    {
        switch (ruleNumber)
        {

            //
            // Rule 3:  identifier ::= IDENTIFIER
            //
            case 3: {
               //#line 184 "GJavaParser.g"
                setResult(
                    //#line 184 GJavaParser.g
                    identifier(this, getRhsIToken(1))
                //#line 184 GJavaParser.g
                );
            break;
            }
            //
            // Rule 4:  LPGUserAction ::= BlockStatementsopt
            //
            case 4:
                break;
            //
            // Rule 5:  LPGUserAction ::= %BeginAction BlockStatementsopt %EndAction
            //
            case 5: {
               //#line 190 "GJavaParser.g"
                setResult(
                    //#line 190 GJavaParser.g
                    LPGUserAction0(getLeftIToken(), getRightIToken(),
                                   //#line 190 GJavaParser.g
                                   AstToken(getRhsIToken(1)),
                                   //#line 190 GJavaParser.g
                                   getRhsSym(2) as Ast?,
                                   //#line 190 GJavaParser.g
                                   AstToken(getRhsIToken(3)))
                //#line 190 GJavaParser.g
                );
            break;
            }
            //
            // Rule 6:  LPGUserAction ::= $BeginJava BlockStatementsopt $EndJava
            //
            case 6: {
               //#line 191 "GJavaParser.g"
                setResult(
                    //#line 191 GJavaParser.g
                    LPGUserAction1(getLeftIToken(), getRightIToken(),
                                   //#line 191 GJavaParser.g
                                   AstToken(getRhsIToken(1)),
                                   //#line 191 GJavaParser.g
                                   getRhsSym(2) as Ast?,
                                   //#line 191 GJavaParser.g
                                   AstToken(getRhsIToken(3)))
                //#line 191 GJavaParser.g
                );
            break;
            }
            //
            // Rule 7:  LPGUserAction ::= $NoAction
            //
            case 7: {
               //#line 192 "GJavaParser.g"
                setResult(
                    //#line 192 GJavaParser.g
                    LPGUserAction2(getRhsIToken(1))
                //#line 192 GJavaParser.g
                );
            break;
            }
            //
            // Rule 8:  LPGUserAction ::= $NullAction
            //
            case 8: {
               //#line 193 "GJavaParser.g"
                setResult(
                    //#line 193 GJavaParser.g
                    LPGUserAction3(getRhsIToken(1))
                //#line 193 GJavaParser.g
                );
            break;
            }
            //
            // Rule 9:  LPGUserAction ::= $BadAction
            //
            case 9: {
               //#line 194 "GJavaParser.g"
                setResult(
                    //#line 194 GJavaParser.g
                    LPGUserAction4(getRhsIToken(1))
                //#line 194 GJavaParser.g
                );
            break;
            }
            //
            // Rule 10:  Type ::= PrimitiveType
            //
            case 10:
                break;
            //
            // Rule 11:  Type ::= ReferenceType
            //
            case 11:
                break;
            //
            // Rule 12:  PrimitiveType ::= NumericType
            //
            case 12:
                break;
            //
            // Rule 13:  PrimitiveType ::= boolean
            //
            case 13: {
               //#line 203 "GJavaParser.g"
                setResult(
                    //#line 203 GJavaParser.g
                    PrimitiveType(getRhsIToken(1))
                //#line 203 GJavaParser.g
                );
            break;
            }
            //
            // Rule 14:  NumericType ::= IntegralType
            //
            case 14:
                break;
            //
            // Rule 15:  NumericType ::= FloatingPointType
            //
            case 15:
                break;
            //
            // Rule 16:  IntegralType ::= byte
            //
            case 16: {
               //#line 208 "GJavaParser.g"
                setResult(
                    //#line 208 GJavaParser.g
                    IntegralType0(getRhsIToken(1))
                //#line 208 GJavaParser.g
                );
            break;
            }
            //
            // Rule 17:  IntegralType ::= short
            //
            case 17: {
               //#line 209 "GJavaParser.g"
                setResult(
                    //#line 209 GJavaParser.g
                    IntegralType1(getRhsIToken(1))
                //#line 209 GJavaParser.g
                );
            break;
            }
            //
            // Rule 18:  IntegralType ::= int
            //
            case 18: {
               //#line 210 "GJavaParser.g"
                setResult(
                    //#line 210 GJavaParser.g
                    IntegralType2(getRhsIToken(1))
                //#line 210 GJavaParser.g
                );
            break;
            }
            //
            // Rule 19:  IntegralType ::= long
            //
            case 19: {
               //#line 211 "GJavaParser.g"
                setResult(
                    //#line 211 GJavaParser.g
                    IntegralType3(getRhsIToken(1))
                //#line 211 GJavaParser.g
                );
            break;
            }
            //
            // Rule 20:  IntegralType ::= char
            //
            case 20: {
               //#line 212 "GJavaParser.g"
                setResult(
                    //#line 212 GJavaParser.g
                    IntegralType4(getRhsIToken(1))
                //#line 212 GJavaParser.g
                );
            break;
            }
            //
            // Rule 21:  FloatingPointType ::= float
            //
            case 21: {
               //#line 214 "GJavaParser.g"
                setResult(
                    //#line 214 GJavaParser.g
                    FloatingPointType0(getRhsIToken(1))
                //#line 214 GJavaParser.g
                );
            break;
            }
            //
            // Rule 22:  FloatingPointType ::= double
            //
            case 22: {
               //#line 215 "GJavaParser.g"
                setResult(
                    //#line 215 GJavaParser.g
                    FloatingPointType1(getRhsIToken(1))
                //#line 215 GJavaParser.g
                );
            break;
            }
            //
            // Rule 23:  ReferenceType ::= ClassOrInterfaceType
            //
            case 23:
                break;
            //
            // Rule 24:  ReferenceType ::= TypeVariable
            //
            case 24:
                break;
            //
            // Rule 25:  ReferenceType ::= ArrayType
            //
            case 25:
                break;
            //
            // Rule 26:  ClassOrInterfaceType ::= ClassType
            //
            case 26:
                break;
            //
            // Rule 27:  ClassType ::= TypeName TypeArgumentsopt
            //
            case 27: {
               //#line 227 "GJavaParser.g"
                setResult(
                    //#line 227 GJavaParser.g
                    ClassType(getLeftIToken(), getRightIToken(),
                              //#line 227 GJavaParser.g
                              getRhsSym(1) as Ast,
                              //#line 227 GJavaParser.g
                              getRhsSym(2) as TypeArguments?)
                //#line 227 GJavaParser.g
                );
            break;
            }
            //
            // Rule 28:  InterfaceType ::= TypeName TypeArgumentsopt
            //
            case 28: {
               //#line 229 "GJavaParser.g"
                setResult(
                    //#line 229 GJavaParser.g
                    InterfaceType(getLeftIToken(), getRightIToken(),
                                  //#line 229 GJavaParser.g
                                  getRhsSym(1) as Ast,
                                  //#line 229 GJavaParser.g
                                  getRhsSym(2) as TypeArguments?)
                //#line 229 GJavaParser.g
                );
            break;
            }
            //
            // Rule 29:  TypeName ::= identifier
            //
            case 29:
                break;
            //
            // Rule 30:  TypeName ::= TypeName . identifier
            //
            case 30: {
               //#line 232 "GJavaParser.g"
                setResult(
                    //#line 232 GJavaParser.g
                    TypeName(getLeftIToken(), getRightIToken(),
                             //#line 232 GJavaParser.g
                             getRhsSym(1) as Ast,
                             //#line 232 GJavaParser.g
                             AstToken(getRhsIToken(2)),
                             //#line 232 GJavaParser.g
                             getRhsSym(3) as identifier)
                //#line 232 GJavaParser.g
                );
            break;
            }
            //
            // Rule 31:  ClassName ::= TypeName
            //
            case 31:
                break;
            //
            // Rule 32:  TypeVariable ::= identifier
            //
            case 32:
                break;
            //
            // Rule 33:  ArrayType ::= Type [ ]
            //
            case 33: {
               //#line 238 "GJavaParser.g"
                setResult(
                    //#line 238 GJavaParser.g
                    ArrayType(getLeftIToken(), getRightIToken(),
                              //#line 238 GJavaParser.g
                              getRhsSym(1) as Ast,
                              //#line 238 GJavaParser.g
                              AstToken(getRhsIToken(2)),
                              //#line 238 GJavaParser.g
                              AstToken(getRhsIToken(3)))
                //#line 238 GJavaParser.g
                );
            break;
            }
            //
            // Rule 34:  TypeParameter ::= TypeVariable TypeBoundopt
            //
            case 34: {
               //#line 240 "GJavaParser.g"
                setResult(
                    //#line 240 GJavaParser.g
                    TypeParameter(getLeftIToken(), getRightIToken(),
                                  //#line 240 GJavaParser.g
                                  getRhsSym(1) as identifier,
                                  //#line 240 GJavaParser.g
                                  getRhsSym(2) as TypeBound?)
                //#line 240 GJavaParser.g
                );
            break;
            }
            //
            // Rule 35:  TypeBound ::= extends ClassOrInterfaceType AdditionalBoundListopt
            //
            case 35: {
               //#line 242 "GJavaParser.g"
                setResult(
                    //#line 242 GJavaParser.g
                    TypeBound(getLeftIToken(), getRightIToken(),
                              //#line 242 GJavaParser.g
                              AstToken(getRhsIToken(1)),
                              //#line 242 GJavaParser.g
                              getRhsSym(2) as ClassType,
                              //#line 242 GJavaParser.g
                              getRhsSym(3) as Ast?)
                //#line 242 GJavaParser.g
                );
            break;
            }
            //
            // Rule 36:  AdditionalBoundList ::= AdditionalBound
            //
            case 36:
                break;
            //
            // Rule 37:  AdditionalBoundList ::= AdditionalBoundList AdditionalBound
            //
            case 37: {
               //#line 245 "GJavaParser.g"
                setResult(
                    //#line 245 GJavaParser.g
                    AdditionalBoundList(getLeftIToken(), getRightIToken(),
                                        //#line 245 GJavaParser.g
                                        getRhsSym(1) as Ast,
                                        //#line 245 GJavaParser.g
                                        getRhsSym(2) as AdditionalBound)
                //#line 245 GJavaParser.g
                );
            break;
            }
            //
            // Rule 38:  AdditionalBound ::= & InterfaceType
            //
            case 38: {
               //#line 247 "GJavaParser.g"
                setResult(
                    //#line 247 GJavaParser.g
                    AdditionalBound(getLeftIToken(), getRightIToken(),
                                    //#line 247 GJavaParser.g
                                    AstToken(getRhsIToken(1)),
                                    //#line 247 GJavaParser.g
                                    getRhsSym(2) as InterfaceType)
                //#line 247 GJavaParser.g
                );
            break;
            }
            //
            // Rule 39:  TypeArguments ::= < ActualTypeArgumentList >
            //
            case 39: {
               //#line 249 "GJavaParser.g"
                setResult(
                    //#line 249 GJavaParser.g
                    TypeArguments(getLeftIToken(), getRightIToken(),
                                  //#line 249 GJavaParser.g
                                  AstToken(getRhsIToken(1)),
                                  //#line 249 GJavaParser.g
                                  getRhsSym(2) as Ast,
                                  //#line 249 GJavaParser.g
                                  AstToken(getRhsIToken(3)))
                //#line 249 GJavaParser.g
                );
            break;
            }
            //
            // Rule 40:  ActualTypeArgumentList ::= ActualTypeArgument
            //
            case 40:
                break;
            //
            // Rule 41:  ActualTypeArgumentList ::= ActualTypeArgumentList , ActualTypeArgument
            //
            case 41: {
               //#line 252 "GJavaParser.g"
                setResult(
                    //#line 252 GJavaParser.g
                    ActualTypeArgumentList(getLeftIToken(), getRightIToken(),
                                           //#line 252 GJavaParser.g
                                           getRhsSym(1) as Ast,
                                           //#line 252 GJavaParser.g
                                           AstToken(getRhsIToken(2)),
                                           //#line 252 GJavaParser.g
                                           getRhsSym(3) as Ast)
                //#line 252 GJavaParser.g
                );
            break;
            }
            //
            // Rule 42:  ActualTypeArgument ::= ReferenceType
            //
            case 42:
                break;
            //
            // Rule 43:  ActualTypeArgument ::= Wildcard
            //
            case 43:
                break;
            //
            // Rule 44:  Wildcard ::= ? WildcardBoundsOpt
            //
            case 44: {
               //#line 257 "GJavaParser.g"
                setResult(
                    //#line 257 GJavaParser.g
                    Wildcard(getLeftIToken(), getRightIToken(),
                             //#line 257 GJavaParser.g
                             AstToken(getRhsIToken(1)),
                             //#line 257 GJavaParser.g
                             getRhsSym(2) as Ast?)
                //#line 257 GJavaParser.g
                );
            break;
            }
            //
            // Rule 45:  WildcardBounds ::= extends ReferenceType
            //
            case 45: {
               //#line 259 "GJavaParser.g"
                setResult(
                    //#line 259 GJavaParser.g
                    WildcardBounds0(getLeftIToken(), getRightIToken(),
                                    //#line 259 GJavaParser.g
                                    AstToken(getRhsIToken(1)),
                                    //#line 259 GJavaParser.g
                                    getRhsSym(2) as Ast)
                //#line 259 GJavaParser.g
                );
            break;
            }
            //
            // Rule 46:  WildcardBounds ::= super ReferenceType
            //
            case 46: {
               //#line 260 "GJavaParser.g"
                setResult(
                    //#line 260 GJavaParser.g
                    WildcardBounds1(getLeftIToken(), getRightIToken(),
                                    //#line 260 GJavaParser.g
                                    AstToken(getRhsIToken(1)),
                                    //#line 260 GJavaParser.g
                                    getRhsSym(2) as Ast)
                //#line 260 GJavaParser.g
                );
            break;
            }
            //
            // Rule 47:  PackageName ::= identifier
            //
            case 47:
                break;
            //
            // Rule 48:  PackageName ::= PackageName . identifier
            //
            case 48: {
               //#line 267 "GJavaParser.g"
                setResult(
                    //#line 267 GJavaParser.g
                    PackageName(getLeftIToken(), getRightIToken(),
                                //#line 267 GJavaParser.g
                                getRhsSym(1) as Ast,
                                //#line 267 GJavaParser.g
                                AstToken(getRhsIToken(2)),
                                //#line 267 GJavaParser.g
                                getRhsSym(3) as identifier)
                //#line 267 GJavaParser.g
                );
            break;
            }
            //
            // Rule 49:  ExpressionName ::= identifier
            //
            case 49:
                break;
            //
            // Rule 50:  ExpressionName ::= AmbiguousName . identifier
            //
            case 50: {
               //#line 276 "GJavaParser.g"
                setResult(
                    //#line 276 GJavaParser.g
                    ExpressionName(getLeftIToken(), getRightIToken(),
                                   //#line 276 GJavaParser.g
                                   getRhsSym(1) as Ast,
                                   //#line 276 GJavaParser.g
                                   AstToken(getRhsIToken(2)),
                                   //#line 276 GJavaParser.g
                                   getRhsSym(3) as identifier)
                //#line 276 GJavaParser.g
                );
            break;
            }
            //
            // Rule 51:  MethodName ::= identifier
            //
            case 51:
                break;
            //
            // Rule 52:  MethodName ::= AmbiguousName . identifier
            //
            case 52: {
               //#line 279 "GJavaParser.g"
                setResult(
                    //#line 279 GJavaParser.g
                    MethodName(getLeftIToken(), getRightIToken(),
                               //#line 279 GJavaParser.g
                               getRhsSym(1) as Ast,
                               //#line 279 GJavaParser.g
                               AstToken(getRhsIToken(2)),
                               //#line 279 GJavaParser.g
                               getRhsSym(3) as identifier)
                //#line 279 GJavaParser.g
                );
            break;
            }
            //
            // Rule 53:  PackageOrTypeName ::= identifier
            //
            case 53:
                break;
            //
            // Rule 54:  PackageOrTypeName ::= PackageOrTypeName . identifier
            //
            case 54: {
               //#line 282 "GJavaParser.g"
                setResult(
                    //#line 282 GJavaParser.g
                    PackageOrTypeName(getLeftIToken(), getRightIToken(),
                                      //#line 282 GJavaParser.g
                                      getRhsSym(1) as Ast,
                                      //#line 282 GJavaParser.g
                                      AstToken(getRhsIToken(2)),
                                      //#line 282 GJavaParser.g
                                      getRhsSym(3) as identifier)
                //#line 282 GJavaParser.g
                );
            break;
            }
            //
            // Rule 55:  AmbiguousName ::= identifier
            //
            case 55:
                break;
            //
            // Rule 56:  AmbiguousName ::= AmbiguousName . identifier
            //
            case 56: {
               //#line 285 "GJavaParser.g"
                setResult(
                    //#line 285 GJavaParser.g
                    AmbiguousName(getLeftIToken(), getRightIToken(),
                                  //#line 285 GJavaParser.g
                                  getRhsSym(1) as Ast,
                                  //#line 285 GJavaParser.g
                                  AstToken(getRhsIToken(2)),
                                  //#line 285 GJavaParser.g
                                  getRhsSym(3) as identifier)
                //#line 285 GJavaParser.g
                );
            break;
            }
            //
            // Rule 57:  CompilationUnit ::= PackageDeclarationopt ImportDeclarationsopt TypeDeclarationsopt
            //
            case 57: {
               //#line 289 "GJavaParser.g"
                setResult(
                    //#line 289 GJavaParser.g
                    CompilationUnit(getLeftIToken(), getRightIToken(),
                                    //#line 289 GJavaParser.g
                                    getRhsSym(1) as PackageDeclaration?,
                                    //#line 289 GJavaParser.g
                                    getRhsSym(2) as Ast?,
                                    //#line 289 GJavaParser.g
                                    getRhsSym(3) as Ast?)
                //#line 289 GJavaParser.g
                );
            break;
            }
            //
            // Rule 58:  ImportDeclarations ::= ImportDeclaration
            //
            case 58:
                break;
            //
            // Rule 59:  ImportDeclarations ::= ImportDeclarations ImportDeclaration
            //
            case 59: {
               //#line 292 "GJavaParser.g"
                setResult(
                    //#line 292 GJavaParser.g
                    ImportDeclarations(getLeftIToken(), getRightIToken(),
                                       //#line 292 GJavaParser.g
                                       getRhsSym(1) as Ast,
                                       //#line 292 GJavaParser.g
                                       getRhsSym(2) as Ast)
                //#line 292 GJavaParser.g
                );
            break;
            }
            //
            // Rule 60:  TypeDeclarations ::= TypeDeclaration
            //
            case 60:
                break;
            //
            // Rule 61:  TypeDeclarations ::= TypeDeclarations TypeDeclaration
            //
            case 61: {
               //#line 295 "GJavaParser.g"
                setResult(
                    //#line 295 GJavaParser.g
                    TypeDeclarations(getLeftIToken(), getRightIToken(),
                                     //#line 295 GJavaParser.g
                                     getRhsSym(1) as Ast,
                                     //#line 295 GJavaParser.g
                                     getRhsSym(2) as Ast)
                //#line 295 GJavaParser.g
                );
            break;
            }
            //
            // Rule 62:  PackageDeclaration ::= Annotationsopt package PackageName ;
            //
            case 62: {
               //#line 297 "GJavaParser.g"
                setResult(
                    //#line 297 GJavaParser.g
                    PackageDeclaration(getLeftIToken(), getRightIToken(),
                                       //#line 297 GJavaParser.g
                                       getRhsSym(1) as Ast?,
                                       //#line 297 GJavaParser.g
                                       AstToken(getRhsIToken(2)),
                                       //#line 297 GJavaParser.g
                                       getRhsSym(3) as Ast,
                                       //#line 297 GJavaParser.g
                                       AstToken(getRhsIToken(4)))
                //#line 297 GJavaParser.g
                );
            break;
            }
            //
            // Rule 63:  ImportDeclaration ::= SingleTypeImportDeclaration
            //
            case 63:
                break;
            //
            // Rule 64:  ImportDeclaration ::= TypeImportOnDemandDeclaration
            //
            case 64:
                break;
            //
            // Rule 65:  ImportDeclaration ::= SingleStaticImportDeclaration
            //
            case 65:
                break;
            //
            // Rule 66:  ImportDeclaration ::= StaticImportOnDemandDeclaration
            //
            case 66:
                break;
            //
            // Rule 67:  SingleTypeImportDeclaration ::= import TypeName ;
            //
            case 67: {
               //#line 304 "GJavaParser.g"
                setResult(
                    //#line 304 GJavaParser.g
                    SingleTypeImportDeclaration(getLeftIToken(), getRightIToken(),
                                                //#line 304 GJavaParser.g
                                                AstToken(getRhsIToken(1)),
                                                //#line 304 GJavaParser.g
                                                getRhsSym(2) as Ast,
                                                //#line 304 GJavaParser.g
                                                AstToken(getRhsIToken(3)))
                //#line 304 GJavaParser.g
                );
            break;
            }
            //
            // Rule 68:  TypeImportOnDemandDeclaration ::= import PackageOrTypeName . * ;
            //
            case 68: {
               //#line 306 "GJavaParser.g"
                setResult(
                    //#line 306 GJavaParser.g
                    TypeImportOnDemandDeclaration(getLeftIToken(), getRightIToken(),
                                                  //#line 306 GJavaParser.g
                                                  AstToken(getRhsIToken(1)),
                                                  //#line 306 GJavaParser.g
                                                  getRhsSym(2) as Ast,
                                                  //#line 306 GJavaParser.g
                                                  AstToken(getRhsIToken(3)),
                                                  //#line 306 GJavaParser.g
                                                  AstToken(getRhsIToken(4)),
                                                  //#line 306 GJavaParser.g
                                                  AstToken(getRhsIToken(5)))
                //#line 306 GJavaParser.g
                );
            break;
            }
            //
            // Rule 69:  SingleStaticImportDeclaration ::= import static TypeName . identifier ;
            //
            case 69: {
               //#line 308 "GJavaParser.g"
                setResult(
                    //#line 308 GJavaParser.g
                    SingleStaticImportDeclaration(getLeftIToken(), getRightIToken(),
                                                  //#line 308 GJavaParser.g
                                                  AstToken(getRhsIToken(1)),
                                                  //#line 308 GJavaParser.g
                                                  AstToken(getRhsIToken(2)),
                                                  //#line 308 GJavaParser.g
                                                  getRhsSym(3) as Ast,
                                                  //#line 308 GJavaParser.g
                                                  AstToken(getRhsIToken(4)),
                                                  //#line 308 GJavaParser.g
                                                  getRhsSym(5) as identifier,
                                                  //#line 308 GJavaParser.g
                                                  AstToken(getRhsIToken(6)))
                //#line 308 GJavaParser.g
                );
            break;
            }
            //
            // Rule 70:  StaticImportOnDemandDeclaration ::= import static TypeName . * ;
            //
            case 70: {
               //#line 310 "GJavaParser.g"
                setResult(
                    //#line 310 GJavaParser.g
                    StaticImportOnDemandDeclaration(getLeftIToken(), getRightIToken(),
                                                    //#line 310 GJavaParser.g
                                                    AstToken(getRhsIToken(1)),
                                                    //#line 310 GJavaParser.g
                                                    AstToken(getRhsIToken(2)),
                                                    //#line 310 GJavaParser.g
                                                    getRhsSym(3) as Ast,
                                                    //#line 310 GJavaParser.g
                                                    AstToken(getRhsIToken(4)),
                                                    //#line 310 GJavaParser.g
                                                    AstToken(getRhsIToken(5)),
                                                    //#line 310 GJavaParser.g
                                                    AstToken(getRhsIToken(6)))
                //#line 310 GJavaParser.g
                );
            break;
            }
            //
            // Rule 71:  TypeDeclaration ::= ClassDeclaration
            //
            case 71:
                break;
            //
            // Rule 72:  TypeDeclaration ::= InterfaceDeclaration
            //
            case 72:
                break;
            //
            // Rule 73:  TypeDeclaration ::= ;
            //
            case 73: {
               //#line 314 "GJavaParser.g"
                setResult(
                    //#line 314 GJavaParser.g
                    TypeDeclaration(getRhsIToken(1))
                //#line 314 GJavaParser.g
                );
            break;
            }
            //
            // Rule 74:  ClassDeclaration ::= NormalClassDeclaration
            //
            case 74:
                break;
            //
            // Rule 75:  ClassDeclaration ::= EnumDeclaration
            //
            case 75:
                break;
            //
            // Rule 76:  NormalClassDeclaration ::= ClassModifiersopt class identifier TypeParametersopt Superopt Interfacesopt ClassBody
            //
            case 76: {
               //#line 321 "GJavaParser.g"
                setResult(
                    //#line 321 GJavaParser.g
                    NormalClassDeclaration(getLeftIToken(), getRightIToken(),
                                           //#line 321 GJavaParser.g
                                           getRhsSym(1) as Ast?,
                                           //#line 321 GJavaParser.g
                                           AstToken(getRhsIToken(2)),
                                           //#line 321 GJavaParser.g
                                           getRhsSym(3) as identifier,
                                           //#line 321 GJavaParser.g
                                           getRhsSym(4) as TypeParameters?,
                                           //#line 321 GJavaParser.g
                                           getRhsSym(5) as Super?,
                                           //#line 321 GJavaParser.g
                                           getRhsSym(6) as Interfaces?,
                                           //#line 321 GJavaParser.g
                                           getRhsSym(7) as ClassBody)
                //#line 321 GJavaParser.g
                );
            break;
            }
            //
            // Rule 77:  ClassModifiers ::= ClassModifier
            //
            case 77:
                break;
            //
            // Rule 78:  ClassModifiers ::= ClassModifiers ClassModifier
            //
            case 78: {
               //#line 324 "GJavaParser.g"
                setResult(
                    //#line 324 GJavaParser.g
                    ClassModifiers(getLeftIToken(), getRightIToken(),
                                   //#line 324 GJavaParser.g
                                   getRhsSym(1) as Ast,
                                   //#line 324 GJavaParser.g
                                   getRhsSym(2) as Ast)
                //#line 324 GJavaParser.g
                );
            break;
            }
            //
            // Rule 79:  ClassModifier ::= Annotation
            //
            case 79:
                break;
            //
            // Rule 80:  ClassModifier ::= public
            //
            case 80: {
               //#line 327 "GJavaParser.g"
                setResult(
                    //#line 327 GJavaParser.g
                    ClassModifier0(getRhsIToken(1))
                //#line 327 GJavaParser.g
                );
            break;
            }
            //
            // Rule 81:  ClassModifier ::= protected
            //
            case 81: {
               //#line 328 "GJavaParser.g"
                setResult(
                    //#line 328 GJavaParser.g
                    ClassModifier1(getRhsIToken(1))
                //#line 328 GJavaParser.g
                );
            break;
            }
            //
            // Rule 82:  ClassModifier ::= private
            //
            case 82: {
               //#line 329 "GJavaParser.g"
                setResult(
                    //#line 329 GJavaParser.g
                    ClassModifier2(getRhsIToken(1))
                //#line 329 GJavaParser.g
                );
            break;
            }
            //
            // Rule 83:  ClassModifier ::= abstract
            //
            case 83: {
               //#line 330 "GJavaParser.g"
                setResult(
                    //#line 330 GJavaParser.g
                    ClassModifier3(getRhsIToken(1))
                //#line 330 GJavaParser.g
                );
            break;
            }
            //
            // Rule 84:  ClassModifier ::= static
            //
            case 84: {
               //#line 331 "GJavaParser.g"
                setResult(
                    //#line 331 GJavaParser.g
                    ClassModifier4(getRhsIToken(1))
                //#line 331 GJavaParser.g
                );
            break;
            }
            //
            // Rule 85:  ClassModifier ::= final
            //
            case 85: {
               //#line 332 "GJavaParser.g"
                setResult(
                    //#line 332 GJavaParser.g
                    ClassModifier5(getRhsIToken(1))
                //#line 332 GJavaParser.g
                );
            break;
            }
            //
            // Rule 86:  ClassModifier ::= strictfp
            //
            case 86: {
               //#line 333 "GJavaParser.g"
                setResult(
                    //#line 333 GJavaParser.g
                    ClassModifier6(getRhsIToken(1))
                //#line 333 GJavaParser.g
                );
            break;
            }
            //
            // Rule 87:  TypeParameters ::= < TypeParameterList >
            //
            case 87: {
               //#line 335 "GJavaParser.g"
                setResult(
                    //#line 335 GJavaParser.g
                    TypeParameters(getLeftIToken(), getRightIToken(),
                                   //#line 335 GJavaParser.g
                                   AstToken(getRhsIToken(1)),
                                   //#line 335 GJavaParser.g
                                   getRhsSym(2) as Ast,
                                   //#line 335 GJavaParser.g
                                   AstToken(getRhsIToken(3)))
                //#line 335 GJavaParser.g
                );
            break;
            }
            //
            // Rule 88:  TypeParameterList ::= TypeParameter
            //
            case 88:
                break;
            //
            // Rule 89:  TypeParameterList ::= TypeParameterList , TypeParameter
            //
            case 89: {
               //#line 338 "GJavaParser.g"
                setResult(
                    //#line 338 GJavaParser.g
                    TypeParameterList(getLeftIToken(), getRightIToken(),
                                      //#line 338 GJavaParser.g
                                      getRhsSym(1) as Ast,
                                      //#line 338 GJavaParser.g
                                      AstToken(getRhsIToken(2)),
                                      //#line 338 GJavaParser.g
                                      getRhsSym(3) as TypeParameter)
                //#line 338 GJavaParser.g
                );
            break;
            }
            //
            // Rule 90:  Super ::= extends ClassType
            //
            case 90: {
               //#line 340 "GJavaParser.g"
                setResult(
                    //#line 340 GJavaParser.g
                    Super(getLeftIToken(), getRightIToken(),
                          //#line 340 GJavaParser.g
                          AstToken(getRhsIToken(1)),
                          //#line 340 GJavaParser.g
                          getRhsSym(2) as ClassType)
                //#line 340 GJavaParser.g
                );
            break;
            }
            //
            // Rule 91:  Interfaces ::= implements InterfaceTypeList
            //
            case 91: {
               //#line 347 "GJavaParser.g"
                setResult(
                    //#line 347 GJavaParser.g
                    Interfaces(getLeftIToken(), getRightIToken(),
                               //#line 347 GJavaParser.g
                               AstToken(getRhsIToken(1)),
                               //#line 347 GJavaParser.g
                               getRhsSym(2) as Ast)
                //#line 347 GJavaParser.g
                );
            break;
            }
            //
            // Rule 92:  InterfaceTypeList ::= InterfaceType
            //
            case 92:
                break;
            //
            // Rule 93:  InterfaceTypeList ::= InterfaceTypeList , InterfaceType
            //
            case 93: {
               //#line 350 "GJavaParser.g"
                setResult(
                    //#line 350 GJavaParser.g
                    InterfaceTypeList(getLeftIToken(), getRightIToken(),
                                      //#line 350 GJavaParser.g
                                      getRhsSym(1) as Ast,
                                      //#line 350 GJavaParser.g
                                      AstToken(getRhsIToken(2)),
                                      //#line 350 GJavaParser.g
                                      getRhsSym(3) as InterfaceType)
                //#line 350 GJavaParser.g
                );
            break;
            }
            //
            // Rule 94:  ClassBody ::= { ClassBodyDeclarationsopt }
            //
            case 94: {
               //#line 357 "GJavaParser.g"
                setResult(
                    //#line 357 GJavaParser.g
                    ClassBody(getLeftIToken(), getRightIToken(),
                              //#line 357 GJavaParser.g
                              AstToken(getRhsIToken(1)),
                              //#line 357 GJavaParser.g
                              getRhsSym(2) as Ast?,
                              //#line 357 GJavaParser.g
                              AstToken(getRhsIToken(3)))
                //#line 357 GJavaParser.g
                );
            break;
            }
            //
            // Rule 95:  ClassBodyDeclarations ::= ClassBodyDeclaration
            //
            case 95:
                break;
            //
            // Rule 96:  ClassBodyDeclarations ::= ClassBodyDeclarations ClassBodyDeclaration
            //
            case 96: {
               //#line 360 "GJavaParser.g"
                setResult(
                    //#line 360 GJavaParser.g
                    ClassBodyDeclarations(getLeftIToken(), getRightIToken(),
                                          //#line 360 GJavaParser.g
                                          getRhsSym(1) as Ast,
                                          //#line 360 GJavaParser.g
                                          getRhsSym(2) as Ast)
                //#line 360 GJavaParser.g
                );
            break;
            }
            //
            // Rule 97:  ClassBodyDeclaration ::= ClassMemberDeclaration
            //
            case 97:
                break;
            //
            // Rule 98:  ClassBodyDeclaration ::= InstanceInitializer
            //
            case 98:
                break;
            //
            // Rule 99:  ClassBodyDeclaration ::= StaticInitializer
            //
            case 99:
                break;
            //
            // Rule 100:  ClassBodyDeclaration ::= ConstructorDeclaration
            //
            case 100:
                break;
            //
            // Rule 101:  ClassMemberDeclaration ::= FieldDeclaration
            //
            case 101:
                break;
            //
            // Rule 102:  ClassMemberDeclaration ::= MethodDeclaration
            //
            case 102:
                break;
            //
            // Rule 103:  ClassMemberDeclaration ::= ClassDeclaration
            //
            case 103:
                break;
            //
            // Rule 104:  ClassMemberDeclaration ::= InterfaceDeclaration
            //
            case 104:
                break;
            //
            // Rule 105:  ClassMemberDeclaration ::= ;
            //
            case 105: {
               //#line 371 "GJavaParser.g"
                setResult(
                    //#line 371 GJavaParser.g
                    ClassMemberDeclaration(getRhsIToken(1))
                //#line 371 GJavaParser.g
                );
            break;
            }
            //
            // Rule 106:  FieldDeclaration ::= FieldModifiersopt Type VariableDeclarators ;
            //
            case 106: {
               //#line 373 "GJavaParser.g"
                setResult(
                    //#line 373 GJavaParser.g
                    FieldDeclaration(getLeftIToken(), getRightIToken(),
                                     //#line 373 GJavaParser.g
                                     getRhsSym(1) as Ast?,
                                     //#line 373 GJavaParser.g
                                     getRhsSym(2) as Ast,
                                     //#line 373 GJavaParser.g
                                     getRhsSym(3) as Ast,
                                     //#line 373 GJavaParser.g
                                     AstToken(getRhsIToken(4)))
                //#line 373 GJavaParser.g
                );
            break;
            }
            //
            // Rule 107:  VariableDeclarators ::= VariableDeclarator
            //
            case 107:
                break;
            //
            // Rule 108:  VariableDeclarators ::= VariableDeclarators , VariableDeclarator
            //
            case 108: {
               //#line 376 "GJavaParser.g"
                setResult(
                    //#line 376 GJavaParser.g
                    VariableDeclarators(getLeftIToken(), getRightIToken(),
                                        //#line 376 GJavaParser.g
                                        getRhsSym(1) as Ast,
                                        //#line 376 GJavaParser.g
                                        AstToken(getRhsIToken(2)),
                                        //#line 376 GJavaParser.g
                                        getRhsSym(3) as Ast)
                //#line 376 GJavaParser.g
                );
            break;
            }
            //
            // Rule 109:  VariableDeclarator ::= VariableDeclaratorId
            //
            case 109:
                break;
            //
            // Rule 110:  VariableDeclarator ::= VariableDeclaratorId = VariableInitializer
            //
            case 110: {
               //#line 379 "GJavaParser.g"
                setResult(
                    //#line 379 GJavaParser.g
                    VariableDeclarator(getLeftIToken(), getRightIToken(),
                                       //#line 379 GJavaParser.g
                                       getRhsSym(1) as Ast,
                                       //#line 379 GJavaParser.g
                                       AstToken(getRhsIToken(2)),
                                       //#line 379 GJavaParser.g
                                       getRhsSym(3) as Ast)
                //#line 379 GJavaParser.g
                );
            break;
            }
            //
            // Rule 111:  VariableDeclaratorId ::= identifier
            //
            case 111:
                break;
            //
            // Rule 112:  VariableDeclaratorId ::= VariableDeclaratorId [ ]
            //
            case 112: {
               //#line 382 "GJavaParser.g"
                setResult(
                    //#line 382 GJavaParser.g
                    VariableDeclaratorId(getLeftIToken(), getRightIToken(),
                                         //#line 382 GJavaParser.g
                                         getRhsSym(1) as Ast,
                                         //#line 382 GJavaParser.g
                                         AstToken(getRhsIToken(2)),
                                         //#line 382 GJavaParser.g
                                         AstToken(getRhsIToken(3)))
                //#line 382 GJavaParser.g
                );
            break;
            }
            //
            // Rule 113:  VariableInitializer ::= Expression
            //
            case 113:
                break;
            //
            // Rule 114:  VariableInitializer ::= ArrayInitializer
            //
            case 114:
                break;
            //
            // Rule 115:  FieldModifiers ::= FieldModifier
            //
            case 115:
                break;
            //
            // Rule 116:  FieldModifiers ::= FieldModifiers FieldModifier
            //
            case 116: {
               //#line 388 "GJavaParser.g"
                setResult(
                    //#line 388 GJavaParser.g
                    FieldModifiers(getLeftIToken(), getRightIToken(),
                                   //#line 388 GJavaParser.g
                                   getRhsSym(1) as Ast,
                                   //#line 388 GJavaParser.g
                                   getRhsSym(2) as Ast)
                //#line 388 GJavaParser.g
                );
            break;
            }
            //
            // Rule 117:  FieldModifier ::= Annotation
            //
            case 117:
                break;
            //
            // Rule 118:  FieldModifier ::= public
            //
            case 118: {
               //#line 391 "GJavaParser.g"
                setResult(
                    //#line 391 GJavaParser.g
                    FieldModifier0(getRhsIToken(1))
                //#line 391 GJavaParser.g
                );
            break;
            }
            //
            // Rule 119:  FieldModifier ::= protected
            //
            case 119: {
               //#line 392 "GJavaParser.g"
                setResult(
                    //#line 392 GJavaParser.g
                    FieldModifier1(getRhsIToken(1))
                //#line 392 GJavaParser.g
                );
            break;
            }
            //
            // Rule 120:  FieldModifier ::= private
            //
            case 120: {
               //#line 393 "GJavaParser.g"
                setResult(
                    //#line 393 GJavaParser.g
                    FieldModifier2(getRhsIToken(1))
                //#line 393 GJavaParser.g
                );
            break;
            }
            //
            // Rule 121:  FieldModifier ::= static
            //
            case 121: {
               //#line 394 "GJavaParser.g"
                setResult(
                    //#line 394 GJavaParser.g
                    FieldModifier3(getRhsIToken(1))
                //#line 394 GJavaParser.g
                );
            break;
            }
            //
            // Rule 122:  FieldModifier ::= final
            //
            case 122: {
               //#line 395 "GJavaParser.g"
                setResult(
                    //#line 395 GJavaParser.g
                    FieldModifier4(getRhsIToken(1))
                //#line 395 GJavaParser.g
                );
            break;
            }
            //
            // Rule 123:  FieldModifier ::= transient
            //
            case 123: {
               //#line 396 "GJavaParser.g"
                setResult(
                    //#line 396 GJavaParser.g
                    FieldModifier5(getRhsIToken(1))
                //#line 396 GJavaParser.g
                );
            break;
            }
            //
            // Rule 124:  FieldModifier ::= volatile
            //
            case 124: {
               //#line 397 "GJavaParser.g"
                setResult(
                    //#line 397 GJavaParser.g
                    FieldModifier6(getRhsIToken(1))
                //#line 397 GJavaParser.g
                );
            break;
            }
            //
            // Rule 125:  MethodDeclaration ::= MethodHeader MethodBody
            //
            case 125: {
               //#line 399 "GJavaParser.g"
                setResult(
                    //#line 399 GJavaParser.g
                    MethodDeclaration(getLeftIToken(), getRightIToken(),
                                      //#line 399 GJavaParser.g
                                      getRhsSym(1) as MethodHeader,
                                      //#line 399 GJavaParser.g
                                      getRhsSym(2) as Ast)
                //#line 399 GJavaParser.g
                );
            break;
            }
            //
            // Rule 126:  MethodHeader ::= MethodModifiersopt TypeParametersopt ResultType MethodDeclarator Throwsopt
            //
            case 126: {
               //#line 401 "GJavaParser.g"
                setResult(
                    //#line 401 GJavaParser.g
                    MethodHeader(getLeftIToken(), getRightIToken(),
                                 //#line 401 GJavaParser.g
                                 getRhsSym(1) as Ast?,
                                 //#line 401 GJavaParser.g
                                 getRhsSym(2) as TypeParameters?,
                                 //#line 401 GJavaParser.g
                                 getRhsSym(3) as Ast,
                                 //#line 401 GJavaParser.g
                                 getRhsSym(4) as Ast,
                                 //#line 401 GJavaParser.g
                                 getRhsSym(5) as Throws?)
                //#line 401 GJavaParser.g
                );
            break;
            }
            //
            // Rule 127:  ResultType ::= Type
            //
            case 127:
                break;
            //
            // Rule 128:  ResultType ::= void
            //
            case 128: {
               //#line 404 "GJavaParser.g"
                setResult(
                    //#line 404 GJavaParser.g
                    ResultType(getRhsIToken(1))
                //#line 404 GJavaParser.g
                );
            break;
            }
            //
            // Rule 129:  MethodDeclarator ::= identifier ( FormalParameterListopt )
            //
            case 129: {
               //#line 406 "GJavaParser.g"
                setResult(
                    //#line 406 GJavaParser.g
                    MethodDeclarator0(getLeftIToken(), getRightIToken(),
                                      //#line 406 GJavaParser.g
                                      getRhsSym(1) as identifier,
                                      //#line 406 GJavaParser.g
                                      AstToken(getRhsIToken(2)),
                                      //#line 406 GJavaParser.g
                                      getRhsSym(3) as Ast?,
                                      //#line 406 GJavaParser.g
                                      AstToken(getRhsIToken(4)))
                //#line 406 GJavaParser.g
                );
            break;
            }
            //
            // Rule 130:  MethodDeclarator ::= MethodDeclarator [ ]
            //
            case 130: {
               //#line 408 "GJavaParser.g"
                setResult(
                    //#line 408 GJavaParser.g
                    MethodDeclarator1(getLeftIToken(), getRightIToken(),
                                      //#line 408 GJavaParser.g
                                      getRhsSym(1) as Ast,
                                      //#line 408 GJavaParser.g
                                      AstToken(getRhsIToken(2)),
                                      //#line 408 GJavaParser.g
                                      AstToken(getRhsIToken(3)))
                //#line 408 GJavaParser.g
                );
            break;
            }
            //
            // Rule 131:  FormalParameterList ::= LastFormalParameter
            //
            case 131:
                break;
            //
            // Rule 132:  FormalParameterList ::= FormalParameters , LastFormalParameter
            //
            case 132: {
               //#line 411 "GJavaParser.g"
                setResult(
                    //#line 411 GJavaParser.g
                    FormalParameterList(getLeftIToken(), getRightIToken(),
                                        //#line 411 GJavaParser.g
                                        getRhsSym(1) as Ast,
                                        //#line 411 GJavaParser.g
                                        AstToken(getRhsIToken(2)),
                                        //#line 411 GJavaParser.g
                                        getRhsSym(3) as LastFormalParameter)
                //#line 411 GJavaParser.g
                );
            break;
            }
            //
            // Rule 133:  FormalParameters ::= FormalParameter
            //
            case 133:
                break;
            //
            // Rule 134:  FormalParameters ::= FormalParameters , FormalParameter
            //
            case 134: {
               //#line 414 "GJavaParser.g"
                setResult(
                    //#line 414 GJavaParser.g
                    FormalParameters(getLeftIToken(), getRightIToken(),
                                     //#line 414 GJavaParser.g
                                     getRhsSym(1) as Ast,
                                     //#line 414 GJavaParser.g
                                     AstToken(getRhsIToken(2)),
                                     //#line 414 GJavaParser.g
                                     getRhsSym(3) as FormalParameter)
                //#line 414 GJavaParser.g
                );
            break;
            }
            //
            // Rule 135:  FormalParameter ::= VariableModifiersopt Type VariableDeclaratorId
            //
            case 135: {
               //#line 416 "GJavaParser.g"
                setResult(
                    //#line 416 GJavaParser.g
                    FormalParameter(getLeftIToken(), getRightIToken(),
                                    //#line 416 GJavaParser.g
                                    getRhsSym(1) as Ast?,
                                    //#line 416 GJavaParser.g
                                    getRhsSym(2) as Ast,
                                    //#line 416 GJavaParser.g
                                    getRhsSym(3) as Ast)
                //#line 416 GJavaParser.g
                );
            break;
            }
            //
            // Rule 136:  VariableModifiers ::= VariableModifier
            //
            case 136:
                break;
            //
            // Rule 137:  VariableModifiers ::= VariableModifiers VariableModifier
            //
            case 137: {
               //#line 419 "GJavaParser.g"
                setResult(
                    //#line 419 GJavaParser.g
                    VariableModifiers(getLeftIToken(), getRightIToken(),
                                      //#line 419 GJavaParser.g
                                      getRhsSym(1) as Ast,
                                      //#line 419 GJavaParser.g
                                      getRhsSym(2) as Ast)
                //#line 419 GJavaParser.g
                );
            break;
            }
            //
            // Rule 138:  VariableModifier ::= final
            //
            case 138: {
               //#line 421 "GJavaParser.g"
                setResult(
                    //#line 421 GJavaParser.g
                    VariableModifier(getRhsIToken(1))
                //#line 421 GJavaParser.g
                );
            break;
            }
            //
            // Rule 139:  VariableModifier ::= Annotations
            //
            case 139:
                break;
            //
            // Rule 140:  LastFormalParameter ::= VariableModifiersopt Type ...opt VariableDeclaratorId
            //
            case 140: {
               //#line 424 "GJavaParser.g"
                setResult(
                    //#line 424 GJavaParser.g
                    LastFormalParameter(getLeftIToken(), getRightIToken(),
                                        //#line 424 GJavaParser.g
                                        getRhsSym(1) as Ast?,
                                        //#line 424 GJavaParser.g
                                        getRhsSym(2) as Ast,
                                        //#line 424 GJavaParser.g
                                        getRhsSym(3) as Ellipsisopt?,
                                        //#line 424 GJavaParser.g
                                        getRhsSym(4) as Ast)
                //#line 424 GJavaParser.g
                );
            break;
            }
            //
            // Rule 141:  MethodModifiers ::= MethodModifier
            //
            case 141:
                break;
            //
            // Rule 142:  MethodModifiers ::= MethodModifiers MethodModifier
            //
            case 142: {
               //#line 433 "GJavaParser.g"
                setResult(
                    //#line 433 GJavaParser.g
                    MethodModifiers(getLeftIToken(), getRightIToken(),
                                    //#line 433 GJavaParser.g
                                    getRhsSym(1) as Ast,
                                    //#line 433 GJavaParser.g
                                    getRhsSym(2) as Ast)
                //#line 433 GJavaParser.g
                );
            break;
            }
            //
            // Rule 143:  MethodModifier ::= Annotations
            //
            case 143:
                break;
            //
            // Rule 144:  MethodModifier ::= public
            //
            case 144: {
               //#line 436 "GJavaParser.g"
                setResult(
                    //#line 436 GJavaParser.g
                    MethodModifier0(getRhsIToken(1))
                //#line 436 GJavaParser.g
                );
            break;
            }
            //
            // Rule 145:  MethodModifier ::= protected
            //
            case 145: {
               //#line 437 "GJavaParser.g"
                setResult(
                    //#line 437 GJavaParser.g
                    MethodModifier1(getRhsIToken(1))
                //#line 437 GJavaParser.g
                );
            break;
            }
            //
            // Rule 146:  MethodModifier ::= private
            //
            case 146: {
               //#line 438 "GJavaParser.g"
                setResult(
                    //#line 438 GJavaParser.g
                    MethodModifier2(getRhsIToken(1))
                //#line 438 GJavaParser.g
                );
            break;
            }
            //
            // Rule 147:  MethodModifier ::= abstract
            //
            case 147: {
               //#line 439 "GJavaParser.g"
                setResult(
                    //#line 439 GJavaParser.g
                    MethodModifier3(getRhsIToken(1))
                //#line 439 GJavaParser.g
                );
            break;
            }
            //
            // Rule 148:  MethodModifier ::= static
            //
            case 148: {
               //#line 440 "GJavaParser.g"
                setResult(
                    //#line 440 GJavaParser.g
                    MethodModifier4(getRhsIToken(1))
                //#line 440 GJavaParser.g
                );
            break;
            }
            //
            // Rule 149:  MethodModifier ::= final
            //
            case 149: {
               //#line 441 "GJavaParser.g"
                setResult(
                    //#line 441 GJavaParser.g
                    MethodModifier5(getRhsIToken(1))
                //#line 441 GJavaParser.g
                );
            break;
            }
            //
            // Rule 150:  MethodModifier ::= synchronized
            //
            case 150: {
               //#line 442 "GJavaParser.g"
                setResult(
                    //#line 442 GJavaParser.g
                    MethodModifier6(getRhsIToken(1))
                //#line 442 GJavaParser.g
                );
            break;
            }
            //
            // Rule 151:  MethodModifier ::= native
            //
            case 151: {
               //#line 443 "GJavaParser.g"
                setResult(
                    //#line 443 GJavaParser.g
                    MethodModifier7(getRhsIToken(1))
                //#line 443 GJavaParser.g
                );
            break;
            }
            //
            // Rule 152:  MethodModifier ::= strictfp
            //
            case 152: {
               //#line 444 "GJavaParser.g"
                setResult(
                    //#line 444 GJavaParser.g
                    MethodModifier8(getRhsIToken(1))
                //#line 444 GJavaParser.g
                );
            break;
            }
            //
            // Rule 153:  Throws ::= throws ExceptionTypeList
            //
            case 153: {
               //#line 446 "GJavaParser.g"
                setResult(
                    //#line 446 GJavaParser.g
                    Throws(getLeftIToken(), getRightIToken(),
                           //#line 446 GJavaParser.g
                           AstToken(getRhsIToken(1)),
                           //#line 446 GJavaParser.g
                           getRhsSym(2) as Ast)
                //#line 446 GJavaParser.g
                );
            break;
            }
            //
            // Rule 154:  ExceptionTypeList ::= ExceptionType
            //
            case 154:
                break;
            //
            // Rule 155:  ExceptionTypeList ::= ExceptionTypeList , ExceptionType
            //
            case 155: {
               //#line 449 "GJavaParser.g"
                setResult(
                    //#line 449 GJavaParser.g
                    ExceptionTypeList(getLeftIToken(), getRightIToken(),
                                      //#line 449 GJavaParser.g
                                      getRhsSym(1) as Ast,
                                      //#line 449 GJavaParser.g
                                      AstToken(getRhsIToken(2)),
                                      //#line 449 GJavaParser.g
                                      getRhsSym(3) as Ast)
                //#line 449 GJavaParser.g
                );
            break;
            }
            //
            // Rule 156:  ExceptionType ::= ClassType
            //
            case 156:
                break;
            //
            // Rule 157:  ExceptionType ::= TypeVariable
            //
            case 157:
                break;
            //
            // Rule 158:  MethodBody ::= Block
            //
            case 158:
                break;
            //
            // Rule 159:  MethodBody ::= ;
            //
            case 159: {
               //#line 455 "GJavaParser.g"
                setResult(
                    //#line 455 GJavaParser.g
                    MethodBody(getRhsIToken(1))
                //#line 455 GJavaParser.g
                );
            break;
            }
            //
            // Rule 160:  InstanceInitializer ::= Block
            //
            case 160:
                break;
            //
            // Rule 161:  StaticInitializer ::= static Block
            //
            case 161: {
               //#line 459 "GJavaParser.g"
                setResult(
                    //#line 459 GJavaParser.g
                    StaticInitializer(getLeftIToken(), getRightIToken(),
                                      //#line 459 GJavaParser.g
                                      AstToken(getRhsIToken(1)),
                                      //#line 459 GJavaParser.g
                                      getRhsSym(2) as Block)
                //#line 459 GJavaParser.g
                );
            break;
            }
            //
            // Rule 162:  ConstructorDeclaration ::= ConstructorModifiersopt ConstructorDeclarator Throwsopt ConstructorBody
            //
            case 162: {
               //#line 461 "GJavaParser.g"
                setResult(
                    //#line 461 GJavaParser.g
                    ConstructorDeclaration(getLeftIToken(), getRightIToken(),
                                           //#line 461 GJavaParser.g
                                           getRhsSym(1) as Ast?,
                                           //#line 461 GJavaParser.g
                                           getRhsSym(2) as ConstructorDeclarator,
                                           //#line 461 GJavaParser.g
                                           getRhsSym(3) as Throws?,
                                           //#line 461 GJavaParser.g
                                           getRhsSym(4) as ConstructorBody)
                //#line 461 GJavaParser.g
                );
            break;
            }
            //
            // Rule 163:  ConstructorDeclarator ::= TypeParametersopt SimpleTypeName ( FormalParameterListopt )
            //
            case 163: {
               //#line 463 "GJavaParser.g"
                setResult(
                    //#line 463 GJavaParser.g
                    ConstructorDeclarator(getLeftIToken(), getRightIToken(),
                                          //#line 463 GJavaParser.g
                                          getRhsSym(1) as TypeParameters?,
                                          //#line 463 GJavaParser.g
                                          getRhsSym(2) as identifier,
                                          //#line 463 GJavaParser.g
                                          AstToken(getRhsIToken(3)),
                                          //#line 463 GJavaParser.g
                                          getRhsSym(4) as Ast?,
                                          //#line 463 GJavaParser.g
                                          AstToken(getRhsIToken(5)))
                //#line 463 GJavaParser.g
                );
            break;
            }
            //
            // Rule 164:  SimpleTypeName ::= identifier
            //
            case 164:
                break;
            //
            // Rule 165:  ConstructorModifiers ::= ConstructorModifier
            //
            case 165:
                break;
            //
            // Rule 166:  ConstructorModifiers ::= ConstructorModifiers ConstructorModifier
            //
            case 166: {
               //#line 468 "GJavaParser.g"
                setResult(
                    //#line 468 GJavaParser.g
                    ConstructorModifiers(getLeftIToken(), getRightIToken(),
                                         //#line 468 GJavaParser.g
                                         getRhsSym(1) as Ast,
                                         //#line 468 GJavaParser.g
                                         getRhsSym(2) as Ast)
                //#line 468 GJavaParser.g
                );
            break;
            }
            //
            // Rule 167:  ConstructorModifier ::= Annotations
            //
            case 167:
                break;
            //
            // Rule 168:  ConstructorModifier ::= public
            //
            case 168: {
               //#line 471 "GJavaParser.g"
                setResult(
                    //#line 471 GJavaParser.g
                    ConstructorModifier0(getRhsIToken(1))
                //#line 471 GJavaParser.g
                );
            break;
            }
            //
            // Rule 169:  ConstructorModifier ::= protected
            //
            case 169: {
               //#line 472 "GJavaParser.g"
                setResult(
                    //#line 472 GJavaParser.g
                    ConstructorModifier1(getRhsIToken(1))
                //#line 472 GJavaParser.g
                );
            break;
            }
            //
            // Rule 170:  ConstructorModifier ::= private
            //
            case 170: {
               //#line 473 "GJavaParser.g"
                setResult(
                    //#line 473 GJavaParser.g
                    ConstructorModifier2(getRhsIToken(1))
                //#line 473 GJavaParser.g
                );
            break;
            }
            //
            // Rule 171:  ConstructorBody ::= { ExplicitConstructorInvocationopt BlockStatementsopt }
            //
            case 171: {
               //#line 475 "GJavaParser.g"
                setResult(
                    //#line 475 GJavaParser.g
                    ConstructorBody(getLeftIToken(), getRightIToken(),
                                    //#line 475 GJavaParser.g
                                    AstToken(getRhsIToken(1)),
                                    //#line 475 GJavaParser.g
                                    getRhsSym(2) as Ast?,
                                    //#line 475 GJavaParser.g
                                    getRhsSym(3) as Ast?,
                                    //#line 475 GJavaParser.g
                                    AstToken(getRhsIToken(4)))
                //#line 475 GJavaParser.g
                );
            break;
            }
            //
            // Rule 172:  ExplicitConstructorInvocation ::= TypeArgumentsopt this ( ArgumentListopt ) ;
            //
            case 172: {
               //#line 477 "GJavaParser.g"
                setResult(
                    //#line 477 GJavaParser.g
                    ExplicitConstructorInvocation0(getLeftIToken(), getRightIToken(),
                                                   //#line 477 GJavaParser.g
                                                   getRhsSym(1) as TypeArguments?,
                                                   //#line 477 GJavaParser.g
                                                   AstToken(getRhsIToken(2)),
                                                   //#line 477 GJavaParser.g
                                                   AstToken(getRhsIToken(3)),
                                                   //#line 477 GJavaParser.g
                                                   getRhsSym(4) as Ast?,
                                                   //#line 477 GJavaParser.g
                                                   AstToken(getRhsIToken(5)),
                                                   //#line 477 GJavaParser.g
                                                   AstToken(getRhsIToken(6)))
                //#line 477 GJavaParser.g
                );
            break;
            }
            //
            // Rule 173:  ExplicitConstructorInvocation ::= TypeArgumentsopt super ( ArgumentListopt ) ;
            //
            case 173: {
               //#line 478 "GJavaParser.g"
                setResult(
                    //#line 478 GJavaParser.g
                    ExplicitConstructorInvocation1(getLeftIToken(), getRightIToken(),
                                                   //#line 478 GJavaParser.g
                                                   getRhsSym(1) as TypeArguments?,
                                                   //#line 478 GJavaParser.g
                                                   AstToken(getRhsIToken(2)),
                                                   //#line 478 GJavaParser.g
                                                   AstToken(getRhsIToken(3)),
                                                   //#line 478 GJavaParser.g
                                                   getRhsSym(4) as Ast?,
                                                   //#line 478 GJavaParser.g
                                                   AstToken(getRhsIToken(5)),
                                                   //#line 478 GJavaParser.g
                                                   AstToken(getRhsIToken(6)))
                //#line 478 GJavaParser.g
                );
            break;
            }
            //
            // Rule 174:  ExplicitConstructorInvocation ::= Primary . TypeArgumentsopt super ( ArgumentListopt ) ;
            //
            case 174: {
               //#line 479 "GJavaParser.g"
                setResult(
                    //#line 479 GJavaParser.g
                    ExplicitConstructorInvocation2(getLeftIToken(), getRightIToken(),
                                                   //#line 479 GJavaParser.g
                                                   getRhsSym(1) as Ast,
                                                   //#line 479 GJavaParser.g
                                                   AstToken(getRhsIToken(2)),
                                                   //#line 479 GJavaParser.g
                                                   getRhsSym(3) as TypeArguments?,
                                                   //#line 479 GJavaParser.g
                                                   AstToken(getRhsIToken(4)),
                                                   //#line 479 GJavaParser.g
                                                   AstToken(getRhsIToken(5)),
                                                   //#line 479 GJavaParser.g
                                                   getRhsSym(6) as Ast?,
                                                   //#line 479 GJavaParser.g
                                                   AstToken(getRhsIToken(7)),
                                                   //#line 479 GJavaParser.g
                                                   AstToken(getRhsIToken(8)))
                //#line 479 GJavaParser.g
                );
            break;
            }
            //
            // Rule 175:  EnumDeclaration ::= ClassModifiersopt enum identifier Interfacesopt EnumBody
            //
            case 175: {
               //#line 481 "GJavaParser.g"
                setResult(
                    //#line 481 GJavaParser.g
                    EnumDeclaration(getLeftIToken(), getRightIToken(),
                                    //#line 481 GJavaParser.g
                                    getRhsSym(1) as Ast?,
                                    //#line 481 GJavaParser.g
                                    AstToken(getRhsIToken(2)),
                                    //#line 481 GJavaParser.g
                                    getRhsSym(3) as identifier,
                                    //#line 481 GJavaParser.g
                                    getRhsSym(4) as Interfaces?,
                                    //#line 481 GJavaParser.g
                                    getRhsSym(5) as EnumBody)
                //#line 481 GJavaParser.g
                );
            break;
            }
            //
            // Rule 176:  EnumBody ::= { EnumConstantsopt ,opt EnumBodyDeclarationsopt }
            //
            case 176: {
               //#line 483 "GJavaParser.g"
                setResult(
                    //#line 483 GJavaParser.g
                    EnumBody(getLeftIToken(), getRightIToken(),
                             //#line 483 GJavaParser.g
                             AstToken(getRhsIToken(1)),
                             //#line 483 GJavaParser.g
                             getRhsSym(2) as Ast?,
                             //#line 483 GJavaParser.g
                             getRhsSym(3) as Commaopt?,
                             //#line 483 GJavaParser.g
                             getRhsSym(4) as EnumBodyDeclarations?,
                             //#line 483 GJavaParser.g
                             AstToken(getRhsIToken(5)))
                //#line 483 GJavaParser.g
                );
            break;
            }
            //
            // Rule 177:  EnumConstants ::= EnumConstant
            //
            case 177:
                break;
            //
            // Rule 178:  EnumConstants ::= EnumConstants , EnumConstant
            //
            case 178: {
               //#line 486 "GJavaParser.g"
                setResult(
                    //#line 486 GJavaParser.g
                    EnumConstants(getLeftIToken(), getRightIToken(),
                                  //#line 486 GJavaParser.g
                                  getRhsSym(1) as Ast,
                                  //#line 486 GJavaParser.g
                                  AstToken(getRhsIToken(2)),
                                  //#line 486 GJavaParser.g
                                  getRhsSym(3) as Ast)
                //#line 486 GJavaParser.g
                );
            break;
            }
            //
            // Rule 179:  EnumConstant ::= Annotationsopt identifier Argumentsopt ClassBodyopt
            //
            case 179: {
               //#line 488 "GJavaParser.g"
                setResult(
                    //#line 488 GJavaParser.g
                    EnumConstant(getLeftIToken(), getRightIToken(),
                                 //#line 488 GJavaParser.g
                                 getRhsSym(1) as Ast?,
                                 //#line 488 GJavaParser.g
                                 getRhsSym(2) as identifier,
                                 //#line 488 GJavaParser.g
                                 getRhsSym(3) as Arguments?,
                                 //#line 488 GJavaParser.g
                                 getRhsSym(4) as ClassBody?)
                //#line 488 GJavaParser.g
                );
            break;
            }
            //
            // Rule 180:  Arguments ::= ( ArgumentListopt )
            //
            case 180: {
               //#line 490 "GJavaParser.g"
                setResult(
                    //#line 490 GJavaParser.g
                    Arguments(getLeftIToken(), getRightIToken(),
                              //#line 490 GJavaParser.g
                              AstToken(getRhsIToken(1)),
                              //#line 490 GJavaParser.g
                              getRhsSym(2) as Ast?,
                              //#line 490 GJavaParser.g
                              AstToken(getRhsIToken(3)))
                //#line 490 GJavaParser.g
                );
            break;
            }
            //
            // Rule 181:  EnumBodyDeclarations ::= ; ClassBodyDeclarationsopt
            //
            case 181: {
               //#line 492 "GJavaParser.g"
                setResult(
                    //#line 492 GJavaParser.g
                    EnumBodyDeclarations(getLeftIToken(), getRightIToken(),
                                         //#line 492 GJavaParser.g
                                         AstToken(getRhsIToken(1)),
                                         //#line 492 GJavaParser.g
                                         getRhsSym(2) as Ast?)
                //#line 492 GJavaParser.g
                );
            break;
            }
            //
            // Rule 182:  InterfaceDeclaration ::= NormalInterfaceDeclaration
            //
            case 182:
                break;
            //
            // Rule 183:  InterfaceDeclaration ::= AnnotationTypeDeclaration
            //
            case 183:
                break;
            //
            // Rule 184:  NormalInterfaceDeclaration ::= InterfaceModifiersopt interface identifier TypeParametersopt ExtendsInterfacesopt InterfaceBody
            //
            case 184: {
               //#line 499 "GJavaParser.g"
                setResult(
                    //#line 499 GJavaParser.g
                    NormalInterfaceDeclaration(getLeftIToken(), getRightIToken(),
                                               //#line 499 GJavaParser.g
                                               getRhsSym(1) as Ast?,
                                               //#line 499 GJavaParser.g
                                               AstToken(getRhsIToken(2)),
                                               //#line 499 GJavaParser.g
                                               getRhsSym(3) as identifier,
                                               //#line 499 GJavaParser.g
                                               getRhsSym(4) as TypeParameters?,
                                               //#line 499 GJavaParser.g
                                               getRhsSym(5) as Ast?,
                                               //#line 499 GJavaParser.g
                                               getRhsSym(6) as InterfaceBody)
                //#line 499 GJavaParser.g
                );
            break;
            }
            //
            // Rule 185:  InterfaceModifiers ::= InterfaceModifier
            //
            case 185:
                break;
            //
            // Rule 186:  InterfaceModifiers ::= InterfaceModifiers InterfaceModifier
            //
            case 186: {
               //#line 502 "GJavaParser.g"
                setResult(
                    //#line 502 GJavaParser.g
                    InterfaceModifiers(getLeftIToken(), getRightIToken(),
                                       //#line 502 GJavaParser.g
                                       getRhsSym(1) as Ast,
                                       //#line 502 GJavaParser.g
                                       getRhsSym(2) as Ast)
                //#line 502 GJavaParser.g
                );
            break;
            }
            //
            // Rule 187:  InterfaceModifier ::= Annotation
            //
            case 187:
                break;
            //
            // Rule 188:  InterfaceModifier ::= public
            //
            case 188: {
               //#line 505 "GJavaParser.g"
                setResult(
                    //#line 505 GJavaParser.g
                    InterfaceModifier0(getRhsIToken(1))
                //#line 505 GJavaParser.g
                );
            break;
            }
            //
            // Rule 189:  InterfaceModifier ::= protected
            //
            case 189: {
               //#line 506 "GJavaParser.g"
                setResult(
                    //#line 506 GJavaParser.g
                    InterfaceModifier1(getRhsIToken(1))
                //#line 506 GJavaParser.g
                );
            break;
            }
            //
            // Rule 190:  InterfaceModifier ::= private
            //
            case 190: {
               //#line 507 "GJavaParser.g"
                setResult(
                    //#line 507 GJavaParser.g
                    InterfaceModifier2(getRhsIToken(1))
                //#line 507 GJavaParser.g
                );
            break;
            }
            //
            // Rule 191:  InterfaceModifier ::= abstract
            //
            case 191: {
               //#line 508 "GJavaParser.g"
                setResult(
                    //#line 508 GJavaParser.g
                    InterfaceModifier3(getRhsIToken(1))
                //#line 508 GJavaParser.g
                );
            break;
            }
            //
            // Rule 192:  InterfaceModifier ::= static
            //
            case 192: {
               //#line 509 "GJavaParser.g"
                setResult(
                    //#line 509 GJavaParser.g
                    InterfaceModifier4(getRhsIToken(1))
                //#line 509 GJavaParser.g
                );
            break;
            }
            //
            // Rule 193:  InterfaceModifier ::= strictfp
            //
            case 193: {
               //#line 510 "GJavaParser.g"
                setResult(
                    //#line 510 GJavaParser.g
                    InterfaceModifier5(getRhsIToken(1))
                //#line 510 GJavaParser.g
                );
            break;
            }
            //
            // Rule 194:  ExtendsInterfaces ::= extends InterfaceType
            //
            case 194: {
               //#line 512 "GJavaParser.g"
                setResult(
                    //#line 512 GJavaParser.g
                    ExtendsInterfaces0(getLeftIToken(), getRightIToken(),
                                       //#line 512 GJavaParser.g
                                       AstToken(getRhsIToken(1)),
                                       //#line 512 GJavaParser.g
                                       getRhsSym(2) as InterfaceType)
                //#line 512 GJavaParser.g
                );
            break;
            }
            //
            // Rule 195:  ExtendsInterfaces ::= ExtendsInterfaces , InterfaceType
            //
            case 195: {
               //#line 513 "GJavaParser.g"
                setResult(
                    //#line 513 GJavaParser.g
                    ExtendsInterfaces1(getLeftIToken(), getRightIToken(),
                                       //#line 513 GJavaParser.g
                                       getRhsSym(1) as Ast,
                                       //#line 513 GJavaParser.g
                                       AstToken(getRhsIToken(2)),
                                       //#line 513 GJavaParser.g
                                       getRhsSym(3) as InterfaceType)
                //#line 513 GJavaParser.g
                );
            break;
            }
            //
            // Rule 196:  InterfaceBody ::= { InterfaceMemberDeclarationsopt }
            //
            case 196: {
               //#line 520 "GJavaParser.g"
                setResult(
                    //#line 520 GJavaParser.g
                    InterfaceBody(getLeftIToken(), getRightIToken(),
                                  //#line 520 GJavaParser.g
                                  AstToken(getRhsIToken(1)),
                                  //#line 520 GJavaParser.g
                                  getRhsSym(2) as Ast?,
                                  //#line 520 GJavaParser.g
                                  AstToken(getRhsIToken(3)))
                //#line 520 GJavaParser.g
                );
            break;
            }
            //
            // Rule 197:  InterfaceMemberDeclarations ::= InterfaceMemberDeclaration
            //
            case 197:
                break;
            //
            // Rule 198:  InterfaceMemberDeclarations ::= InterfaceMemberDeclarations InterfaceMemberDeclaration
            //
            case 198: {
               //#line 523 "GJavaParser.g"
                setResult(
                    //#line 523 GJavaParser.g
                    InterfaceMemberDeclarations(getLeftIToken(), getRightIToken(),
                                                //#line 523 GJavaParser.g
                                                getRhsSym(1) as Ast,
                                                //#line 523 GJavaParser.g
                                                getRhsSym(2) as Ast)
                //#line 523 GJavaParser.g
                );
            break;
            }
            //
            // Rule 199:  InterfaceMemberDeclaration ::= ConstantDeclaration
            //
            case 199:
                break;
            //
            // Rule 200:  InterfaceMemberDeclaration ::= AbstractMethodDeclaration
            //
            case 200:
                break;
            //
            // Rule 201:  InterfaceMemberDeclaration ::= ClassDeclaration
            //
            case 201:
                break;
            //
            // Rule 202:  InterfaceMemberDeclaration ::= InterfaceDeclaration
            //
            case 202:
                break;
            //
            // Rule 203:  InterfaceMemberDeclaration ::= ;
            //
            case 203: {
               //#line 529 "GJavaParser.g"
                setResult(
                    //#line 529 GJavaParser.g
                    InterfaceMemberDeclaration(getRhsIToken(1))
                //#line 529 GJavaParser.g
                );
            break;
            }
            //
            // Rule 204:  ConstantDeclaration ::= ConstantModifiersopt Type VariableDeclarators
            //
            case 204: {
               //#line 531 "GJavaParser.g"
                setResult(
                    //#line 531 GJavaParser.g
                    ConstantDeclaration(getLeftIToken(), getRightIToken(),
                                        //#line 531 GJavaParser.g
                                        getRhsSym(1) as Ast?,
                                        //#line 531 GJavaParser.g
                                        getRhsSym(2) as Ast,
                                        //#line 531 GJavaParser.g
                                        getRhsSym(3) as Ast)
                //#line 531 GJavaParser.g
                );
            break;
            }
            //
            // Rule 205:  ConstantModifiers ::= ConstantModifier
            //
            case 205:
                break;
            //
            // Rule 206:  ConstantModifiers ::= ConstantModifiers ConstantModifier
            //
            case 206: {
               //#line 534 "GJavaParser.g"
                setResult(
                    //#line 534 GJavaParser.g
                    ConstantModifiers(getLeftIToken(), getRightIToken(),
                                      //#line 534 GJavaParser.g
                                      getRhsSym(1) as Ast,
                                      //#line 534 GJavaParser.g
                                      getRhsSym(2) as Ast)
                //#line 534 GJavaParser.g
                );
            break;
            }
            //
            // Rule 207:  ConstantModifier ::= Annotation
            //
            case 207:
                break;
            //
            // Rule 208:  ConstantModifier ::= public
            //
            case 208: {
               //#line 537 "GJavaParser.g"
                setResult(
                    //#line 537 GJavaParser.g
                    ConstantModifier0(getRhsIToken(1))
                //#line 537 GJavaParser.g
                );
            break;
            }
            //
            // Rule 209:  ConstantModifier ::= static
            //
            case 209: {
               //#line 538 "GJavaParser.g"
                setResult(
                    //#line 538 GJavaParser.g
                    ConstantModifier1(getRhsIToken(1))
                //#line 538 GJavaParser.g
                );
            break;
            }
            //
            // Rule 210:  ConstantModifier ::= final
            //
            case 210: {
               //#line 539 "GJavaParser.g"
                setResult(
                    //#line 539 GJavaParser.g
                    ConstantModifier2(getRhsIToken(1))
                //#line 539 GJavaParser.g
                );
            break;
            }
            //
            // Rule 211:  AbstractMethodDeclaration ::= AbstractMethodModifiersopt TypeParametersopt ResultType MethodDeclarator Throwsopt ;
            //
            case 211: {
               //#line 541 "GJavaParser.g"
                setResult(
                    //#line 541 GJavaParser.g
                    AbstractMethodDeclaration(getLeftIToken(), getRightIToken(),
                                              //#line 541 GJavaParser.g
                                              getRhsSym(1) as Ast?,
                                              //#line 541 GJavaParser.g
                                              getRhsSym(2) as TypeParameters?,
                                              //#line 541 GJavaParser.g
                                              getRhsSym(3) as Ast,
                                              //#line 541 GJavaParser.g
                                              getRhsSym(4) as Ast,
                                              //#line 541 GJavaParser.g
                                              getRhsSym(5) as Throws?,
                                              //#line 541 GJavaParser.g
                                              AstToken(getRhsIToken(6)))
                //#line 541 GJavaParser.g
                );
            break;
            }
            //
            // Rule 212:  AbstractMethodModifiers ::= AbstractMethodModifier
            //
            case 212:
                break;
            //
            // Rule 213:  AbstractMethodModifiers ::= AbstractMethodModifiers AbstractMethodModifier
            //
            case 213: {
               //#line 544 "GJavaParser.g"
                setResult(
                    //#line 544 GJavaParser.g
                    AbstractMethodModifiers(getLeftIToken(), getRightIToken(),
                                            //#line 544 GJavaParser.g
                                            getRhsSym(1) as Ast,
                                            //#line 544 GJavaParser.g
                                            getRhsSym(2) as Ast)
                //#line 544 GJavaParser.g
                );
            break;
            }
            //
            // Rule 214:  AbstractMethodModifier ::= Annotations
            //
            case 214:
                break;
            //
            // Rule 215:  AbstractMethodModifier ::= public
            //
            case 215: {
               //#line 547 "GJavaParser.g"
                setResult(
                    //#line 547 GJavaParser.g
                    AbstractMethodModifier0(getRhsIToken(1))
                //#line 547 GJavaParser.g
                );
            break;
            }
            //
            // Rule 216:  AbstractMethodModifier ::= abstract
            //
            case 216: {
               //#line 548 "GJavaParser.g"
                setResult(
                    //#line 548 GJavaParser.g
                    AbstractMethodModifier1(getRhsIToken(1))
                //#line 548 GJavaParser.g
                );
            break;
            }
            //
            // Rule 217:  AnnotationTypeDeclaration ::= InterfaceModifiersopt @ interface identifier AnnotationTypeBody
            //
            case 217: {
               //#line 550 "GJavaParser.g"
                setResult(
                    //#line 550 GJavaParser.g
                    AnnotationTypeDeclaration(getLeftIToken(), getRightIToken(),
                                              //#line 550 GJavaParser.g
                                              getRhsSym(1) as Ast?,
                                              //#line 550 GJavaParser.g
                                              AstToken(getRhsIToken(2)),
                                              //#line 550 GJavaParser.g
                                              AstToken(getRhsIToken(3)),
                                              //#line 550 GJavaParser.g
                                              getRhsSym(4) as identifier,
                                              //#line 550 GJavaParser.g
                                              getRhsSym(5) as AnnotationTypeBody)
                //#line 550 GJavaParser.g
                );
            break;
            }
            //
            // Rule 218:  AnnotationTypeBody ::= { AnnotationTypeElementDeclarationsopt }
            //
            case 218: {
               //#line 552 "GJavaParser.g"
                setResult(
                    //#line 552 GJavaParser.g
                    AnnotationTypeBody(getLeftIToken(), getRightIToken(),
                                       //#line 552 GJavaParser.g
                                       AstToken(getRhsIToken(1)),
                                       //#line 552 GJavaParser.g
                                       getRhsSym(2) as Ast?,
                                       //#line 552 GJavaParser.g
                                       AstToken(getRhsIToken(3)))
                //#line 552 GJavaParser.g
                );
            break;
            }
            //
            // Rule 219:  AnnotationTypeElementDeclarations ::= AnnotationTypeElementDeclaration
            //
            case 219:
                break;
            //
            // Rule 220:  AnnotationTypeElementDeclarations ::= AnnotationTypeElementDeclarations AnnotationTypeElementDeclaration
            //
            case 220: {
               //#line 555 "GJavaParser.g"
                setResult(
                    //#line 555 GJavaParser.g
                    AnnotationTypeElementDeclarations(getLeftIToken(), getRightIToken(),
                                                      //#line 555 GJavaParser.g
                                                      getRhsSym(1) as Ast,
                                                      //#line 555 GJavaParser.g
                                                      getRhsSym(2) as Ast)
                //#line 555 GJavaParser.g
                );
            break;
            }
            //
            // Rule 221:  AnnotationTypeElementDeclaration ::= AbstractMethodModifiersopt Type identifier ( ) DefaultValueopt ;
            //
            case 221: {
               //#line 557 "GJavaParser.g"
                setResult(
                    //#line 557 GJavaParser.g
                    AnnotationTypeElementDeclaration0(getLeftIToken(), getRightIToken(),
                                                      //#line 557 GJavaParser.g
                                                      getRhsSym(1) as Ast?,
                                                      //#line 557 GJavaParser.g
                                                      getRhsSym(2) as Ast,
                                                      //#line 557 GJavaParser.g
                                                      getRhsSym(3) as identifier,
                                                      //#line 557 GJavaParser.g
                                                      AstToken(getRhsIToken(4)),
                                                      //#line 557 GJavaParser.g
                                                      AstToken(getRhsIToken(5)),
                                                      //#line 557 GJavaParser.g
                                                      getRhsSym(6) as DefaultValue?,
                                                      //#line 557 GJavaParser.g
                                                      AstToken(getRhsIToken(7)))
                //#line 557 GJavaParser.g
                );
            break;
            }
            //
            // Rule 222:  AnnotationTypeElementDeclaration ::= ConstantDeclaration
            //
            case 222:
                break;
            //
            // Rule 223:  AnnotationTypeElementDeclaration ::= ClassDeclaration
            //
            case 223:
                break;
            //
            // Rule 224:  AnnotationTypeElementDeclaration ::= InterfaceDeclaration
            //
            case 224:
                break;
            //
            // Rule 225:  AnnotationTypeElementDeclaration ::= EnumDeclaration
            //
            case 225:
                break;
            //
            // Rule 226:  AnnotationTypeElementDeclaration ::= AnnotationTypeDeclaration
            //
            case 226:
                break;
            //
            // Rule 227:  AnnotationTypeElementDeclaration ::= ;
            //
            case 227: {
               //#line 563 "GJavaParser.g"
                setResult(
                    //#line 563 GJavaParser.g
                    AnnotationTypeElementDeclaration1(getRhsIToken(1))
                //#line 563 GJavaParser.g
                );
            break;
            }
            //
            // Rule 228:  DefaultValue ::= default ElementValue
            //
            case 228: {
               //#line 565 "GJavaParser.g"
                setResult(
                    //#line 565 GJavaParser.g
                    DefaultValue(getLeftIToken(), getRightIToken(),
                                 //#line 565 GJavaParser.g
                                 AstToken(getRhsIToken(1)),
                                 //#line 565 GJavaParser.g
                                 getRhsSym(2) as Ast)
                //#line 565 GJavaParser.g
                );
            break;
            }
            //
            // Rule 229:  Annotations ::= Annotation
            //
            case 229:
                break;
            //
            // Rule 230:  Annotations ::= Annotations Annotation
            //
            case 230: {
               //#line 568 "GJavaParser.g"
                setResult(
                    //#line 568 GJavaParser.g
                    Annotations(getLeftIToken(), getRightIToken(),
                                //#line 568 GJavaParser.g
                                getRhsSym(1) as Ast,
                                //#line 568 GJavaParser.g
                                getRhsSym(2) as Ast)
                //#line 568 GJavaParser.g
                );
            break;
            }
            //
            // Rule 231:  Annotation ::= NormalAnnotation
            //
            case 231:
                break;
            //
            // Rule 232:  Annotation ::= MarkerAnnotation
            //
            case 232:
                break;
            //
            // Rule 233:  Annotation ::= SingleElementAnnotation
            //
            case 233:
                break;
            //
            // Rule 234:  NormalAnnotation ::= @ TypeName ( ElementValuePairsopt )
            //
            case 234: {
               //#line 574 "GJavaParser.g"
                setResult(
                    //#line 574 GJavaParser.g
                    NormalAnnotation(getLeftIToken(), getRightIToken(),
                                     //#line 574 GJavaParser.g
                                     AstToken(getRhsIToken(1)),
                                     //#line 574 GJavaParser.g
                                     getRhsSym(2) as Ast,
                                     //#line 574 GJavaParser.g
                                     AstToken(getRhsIToken(3)),
                                     //#line 574 GJavaParser.g
                                     getRhsSym(4) as Ast?,
                                     //#line 574 GJavaParser.g
                                     AstToken(getRhsIToken(5)))
                //#line 574 GJavaParser.g
                );
            break;
            }
            //
            // Rule 235:  ElementValuePairs ::= ElementValuePair
            //
            case 235:
                break;
            //
            // Rule 236:  ElementValuePairs ::= ElementValuePairs , ElementValuePair
            //
            case 236: {
               //#line 577 "GJavaParser.g"
                setResult(
                    //#line 577 GJavaParser.g
                    ElementValuePairs(getLeftIToken(), getRightIToken(),
                                      //#line 577 GJavaParser.g
                                      getRhsSym(1) as Ast,
                                      //#line 577 GJavaParser.g
                                      AstToken(getRhsIToken(2)),
                                      //#line 577 GJavaParser.g
                                      getRhsSym(3) as ElementValuePair)
                //#line 577 GJavaParser.g
                );
            break;
            }
            //
            // Rule 237:  ElementValuePair ::= SimpleName = ElementValue
            //
            case 237: {
               //#line 579 "GJavaParser.g"
                setResult(
                    //#line 579 GJavaParser.g
                    ElementValuePair(getLeftIToken(), getRightIToken(),
                                     //#line 579 GJavaParser.g
                                     getRhsSym(1) as identifier,
                                     //#line 579 GJavaParser.g
                                     AstToken(getRhsIToken(2)),
                                     //#line 579 GJavaParser.g
                                     getRhsSym(3) as Ast)
                //#line 579 GJavaParser.g
                );
            break;
            }
            //
            // Rule 238:  SimpleName ::= identifier
            //
            case 238:
                break;
            //
            // Rule 239:  ElementValue ::= ConditionalExpression
            //
            case 239:
                break;
            //
            // Rule 240:  ElementValue ::= Annotation
            //
            case 240:
                break;
            //
            // Rule 241:  ElementValue ::= ElementValueArrayInitializer
            //
            case 241:
                break;
            //
            // Rule 242:  ElementValueArrayInitializer ::= { ElementValuesopt ,opt }
            //
            case 242: {
               //#line 587 "GJavaParser.g"
                setResult(
                    //#line 587 GJavaParser.g
                    ElementValueArrayInitializer(getLeftIToken(), getRightIToken(),
                                                 //#line 587 GJavaParser.g
                                                 AstToken(getRhsIToken(1)),
                                                 //#line 587 GJavaParser.g
                                                 getRhsSym(2) as Ast?,
                                                 //#line 587 GJavaParser.g
                                                 getRhsSym(3) as Commaopt?,
                                                 //#line 587 GJavaParser.g
                                                 AstToken(getRhsIToken(4)))
                //#line 587 GJavaParser.g
                );
            break;
            }
            //
            // Rule 243:  ElementValues ::= ElementValue
            //
            case 243:
                break;
            //
            // Rule 244:  ElementValues ::= ElementValues , ElementValue
            //
            case 244: {
               //#line 590 "GJavaParser.g"
                setResult(
                    //#line 590 GJavaParser.g
                    ElementValues(getLeftIToken(), getRightIToken(),
                                  //#line 590 GJavaParser.g
                                  getRhsSym(1) as Ast,
                                  //#line 590 GJavaParser.g
                                  AstToken(getRhsIToken(2)),
                                  //#line 590 GJavaParser.g
                                  getRhsSym(3) as Ast)
                //#line 590 GJavaParser.g
                );
            break;
            }
            //
            // Rule 245:  MarkerAnnotation ::= @ TypeName
            //
            case 245: {
               //#line 592 "GJavaParser.g"
                setResult(
                    //#line 592 GJavaParser.g
                    MarkerAnnotation(getLeftIToken(), getRightIToken(),
                                     //#line 592 GJavaParser.g
                                     AstToken(getRhsIToken(1)),
                                     //#line 592 GJavaParser.g
                                     getRhsSym(2) as Ast)
                //#line 592 GJavaParser.g
                );
            break;
            }
            //
            // Rule 246:  SingleElementAnnotation ::= @ TypeName ( ElementValue )
            //
            case 246: {
               //#line 594 "GJavaParser.g"
                setResult(
                    //#line 594 GJavaParser.g
                    SingleElementAnnotation(getLeftIToken(), getRightIToken(),
                                            //#line 594 GJavaParser.g
                                            AstToken(getRhsIToken(1)),
                                            //#line 594 GJavaParser.g
                                            getRhsSym(2) as Ast,
                                            //#line 594 GJavaParser.g
                                            AstToken(getRhsIToken(3)),
                                            //#line 594 GJavaParser.g
                                            getRhsSym(4) as Ast,
                                            //#line 594 GJavaParser.g
                                            AstToken(getRhsIToken(5)))
                //#line 594 GJavaParser.g
                );
            break;
            }
            //
            // Rule 247:  ArrayInitializer ::= { VariableInitializersopt ,opt }
            //
            case 247: {
               //#line 598 "GJavaParser.g"
                setResult(
                    //#line 598 GJavaParser.g
                    ArrayInitializer(getLeftIToken(), getRightIToken(),
                                     //#line 598 GJavaParser.g
                                     AstToken(getRhsIToken(1)),
                                     //#line 598 GJavaParser.g
                                     getRhsSym(2) as Ast?,
                                     //#line 598 GJavaParser.g
                                     getRhsSym(3) as Commaopt?,
                                     //#line 598 GJavaParser.g
                                     AstToken(getRhsIToken(4)))
                //#line 598 GJavaParser.g
                );
            break;
            }
            //
            // Rule 248:  VariableInitializers ::= VariableInitializer
            //
            case 248:
                break;
            //
            // Rule 249:  VariableInitializers ::= VariableInitializers , VariableInitializer
            //
            case 249: {
               //#line 601 "GJavaParser.g"
                setResult(
                    //#line 601 GJavaParser.g
                    VariableInitializers(getLeftIToken(), getRightIToken(),
                                         //#line 601 GJavaParser.g
                                         getRhsSym(1) as Ast,
                                         //#line 601 GJavaParser.g
                                         AstToken(getRhsIToken(2)),
                                         //#line 601 GJavaParser.g
                                         getRhsSym(3) as Ast)
                //#line 601 GJavaParser.g
                );
            break;
            }
            //
            // Rule 250:  Block ::= { BlockStatementsopt }
            //
            case 250: {
               //#line 617 "GJavaParser.g"
                setResult(
                    //#line 617 GJavaParser.g
                    Block(getLeftIToken(), getRightIToken(),
                          //#line 617 GJavaParser.g
                          AstToken(getRhsIToken(1)),
                          //#line 617 GJavaParser.g
                          getRhsSym(2) as Ast?,
                          //#line 617 GJavaParser.g
                          AstToken(getRhsIToken(3)))
                //#line 617 GJavaParser.g
                );
            break;
            }
            //
            // Rule 251:  BlockStatements ::= BlockStatement
            //
            case 251:
                break;
            //
            // Rule 252:  BlockStatements ::= BlockStatements BlockStatement
            //
            case 252: {
               //#line 620 "GJavaParser.g"
                setResult(
                    //#line 620 GJavaParser.g
                    BlockStatements(getLeftIToken(), getRightIToken(),
                                    //#line 620 GJavaParser.g
                                    getRhsSym(1) as Ast,
                                    //#line 620 GJavaParser.g
                                    getRhsSym(2) as Ast)
                //#line 620 GJavaParser.g
                );
            break;
            }
            //
            // Rule 253:  BlockStatement ::= LocalVariableDeclarationStatement
            //
            case 253:
                break;
            //
            // Rule 254:  BlockStatement ::= ClassDeclaration
            //
            case 254:
                break;
            //
            // Rule 255:  BlockStatement ::= Statement
            //
            case 255:
                break;
            //
            // Rule 256:  LocalVariableDeclarationStatement ::= LocalVariableDeclaration ;
            //
            case 256: {
               //#line 626 "GJavaParser.g"
                setResult(
                    //#line 626 GJavaParser.g
                    LocalVariableDeclarationStatement(getLeftIToken(), getRightIToken(),
                                                      //#line 626 GJavaParser.g
                                                      getRhsSym(1) as LocalVariableDeclaration,
                                                      //#line 626 GJavaParser.g
                                                      AstToken(getRhsIToken(2)))
                //#line 626 GJavaParser.g
                );
            break;
            }
            //
            // Rule 257:  LocalVariableDeclaration ::= VariableModifiersopt Type VariableDeclarators
            //
            case 257: {
               //#line 628 "GJavaParser.g"
                setResult(
                    //#line 628 GJavaParser.g
                    LocalVariableDeclaration(getLeftIToken(), getRightIToken(),
                                             //#line 628 GJavaParser.g
                                             getRhsSym(1) as Ast?,
                                             //#line 628 GJavaParser.g
                                             getRhsSym(2) as Ast,
                                             //#line 628 GJavaParser.g
                                             getRhsSym(3) as Ast)
                //#line 628 GJavaParser.g
                );
            break;
            }
            //
            // Rule 258:  Statement ::= StatementWithoutTrailingSubstatement
            //
            case 258:
                break;
            //
            // Rule 259:  Statement ::= LabeledStatement
            //
            case 259:
                break;
            //
            // Rule 260:  Statement ::= IfThenStatement
            //
            case 260:
                break;
            //
            // Rule 261:  Statement ::= IfThenElseStatement
            //
            case 261:
                break;
            //
            // Rule 262:  Statement ::= WhileStatement
            //
            case 262:
                break;
            //
            // Rule 263:  Statement ::= ForStatement
            //
            case 263:
                break;
            //
            // Rule 264:  StatementWithoutTrailingSubstatement ::= Block
            //
            case 264:
                break;
            //
            // Rule 265:  StatementWithoutTrailingSubstatement ::= EmptyStatement
            //
            case 265:
                break;
            //
            // Rule 266:  StatementWithoutTrailingSubstatement ::= ExpressionStatement
            //
            case 266:
                break;
            //
            // Rule 267:  StatementWithoutTrailingSubstatement ::= AssertStatement
            //
            case 267:
                break;
            //
            // Rule 268:  StatementWithoutTrailingSubstatement ::= SwitchStatement
            //
            case 268:
                break;
            //
            // Rule 269:  StatementWithoutTrailingSubstatement ::= DoStatement
            //
            case 269:
                break;
            //
            // Rule 270:  StatementWithoutTrailingSubstatement ::= BreakStatement
            //
            case 270:
                break;
            //
            // Rule 271:  StatementWithoutTrailingSubstatement ::= ContinueStatement
            //
            case 271:
                break;
            //
            // Rule 272:  StatementWithoutTrailingSubstatement ::= ReturnStatement
            //
            case 272:
                break;
            //
            // Rule 273:  StatementWithoutTrailingSubstatement ::= SynchronizedStatement
            //
            case 273:
                break;
            //
            // Rule 274:  StatementWithoutTrailingSubstatement ::= ThrowStatement
            //
            case 274:
                break;
            //
            // Rule 275:  StatementWithoutTrailingSubstatement ::= TryStatement
            //
            case 275:
                break;
            //
            // Rule 276:  StatementNoShortIf ::= StatementWithoutTrailingSubstatement
            //
            case 276:
                break;
            //
            // Rule 277:  StatementNoShortIf ::= LabeledStatementNoShortIf
            //
            case 277:
                break;
            //
            // Rule 278:  StatementNoShortIf ::= IfThenElseStatementNoShortIf
            //
            case 278:
                break;
            //
            // Rule 279:  StatementNoShortIf ::= WhileStatementNoShortIf
            //
            case 279:
                break;
            //
            // Rule 280:  StatementNoShortIf ::= ForStatementNoShortIf
            //
            case 280:
                break;
            //
            // Rule 281:  IfThenStatement ::= if ( Expression ) Statement
            //
            case 281: {
               //#line 671 "GJavaParser.g"
                setResult(
                    //#line 671 GJavaParser.g
                    IfThenStatement(getLeftIToken(), getRightIToken(),
                                    //#line 671 GJavaParser.g
                                    AstToken(getRhsIToken(1)),
                                    //#line 671 GJavaParser.g
                                    AstToken(getRhsIToken(2)),
                                    //#line 671 GJavaParser.g
                                    getRhsSym(3) as Ast,
                                    //#line 671 GJavaParser.g
                                    AstToken(getRhsIToken(4)),
                                    //#line 671 GJavaParser.g
                                    getRhsSym(5) as Ast)
                //#line 671 GJavaParser.g
                );
            break;
            }
            //
            // Rule 282:  IfThenElseStatement ::= if ( Expression ) StatementNoShortIf else Statement
            //
            case 282: {
               //#line 673 "GJavaParser.g"
                setResult(
                    //#line 673 GJavaParser.g
                    IfThenElseStatement(getLeftIToken(), getRightIToken(),
                                        //#line 673 GJavaParser.g
                                        AstToken(getRhsIToken(1)),
                                        //#line 673 GJavaParser.g
                                        AstToken(getRhsIToken(2)),
                                        //#line 673 GJavaParser.g
                                        getRhsSym(3) as Ast,
                                        //#line 673 GJavaParser.g
                                        AstToken(getRhsIToken(4)),
                                        //#line 673 GJavaParser.g
                                        getRhsSym(5) as Ast,
                                        //#line 673 GJavaParser.g
                                        AstToken(getRhsIToken(6)),
                                        //#line 673 GJavaParser.g
                                        getRhsSym(7) as Ast)
                //#line 673 GJavaParser.g
                );
            break;
            }
            //
            // Rule 283:  IfThenElseStatementNoShortIf ::= if ( Expression ) StatementNoShortIf else StatementNoShortIf
            //
            case 283: {
               //#line 675 "GJavaParser.g"
                setResult(
                    //#line 675 GJavaParser.g
                    IfThenElseStatementNoShortIf(getLeftIToken(), getRightIToken(),
                                                 //#line 675 GJavaParser.g
                                                 AstToken(getRhsIToken(1)),
                                                 //#line 675 GJavaParser.g
                                                 AstToken(getRhsIToken(2)),
                                                 //#line 675 GJavaParser.g
                                                 getRhsSym(3) as Ast,
                                                 //#line 675 GJavaParser.g
                                                 AstToken(getRhsIToken(4)),
                                                 //#line 675 GJavaParser.g
                                                 getRhsSym(5) as Ast,
                                                 //#line 675 GJavaParser.g
                                                 AstToken(getRhsIToken(6)),
                                                 //#line 675 GJavaParser.g
                                                 getRhsSym(7) as Ast)
                //#line 675 GJavaParser.g
                );
            break;
            }
            //
            // Rule 284:  EmptyStatement ::= ;
            //
            case 284: {
               //#line 677 "GJavaParser.g"
                setResult(
                    //#line 677 GJavaParser.g
                    EmptyStatement(getRhsIToken(1))
                //#line 677 GJavaParser.g
                );
            break;
            }
            //
            // Rule 285:  LabeledStatement ::= identifier : Statement
            //
            case 285: {
               //#line 679 "GJavaParser.g"
                setResult(
                    //#line 679 GJavaParser.g
                    LabeledStatement(getLeftIToken(), getRightIToken(),
                                     //#line 679 GJavaParser.g
                                     getRhsSym(1) as identifier,
                                     //#line 679 GJavaParser.g
                                     AstToken(getRhsIToken(2)),
                                     //#line 679 GJavaParser.g
                                     getRhsSym(3) as Ast)
                //#line 679 GJavaParser.g
                );
            break;
            }
            //
            // Rule 286:  LabeledStatementNoShortIf ::= identifier : StatementNoShortIf
            //
            case 286: {
               //#line 681 "GJavaParser.g"
                setResult(
                    //#line 681 GJavaParser.g
                    LabeledStatementNoShortIf(getLeftIToken(), getRightIToken(),
                                              //#line 681 GJavaParser.g
                                              getRhsSym(1) as identifier,
                                              //#line 681 GJavaParser.g
                                              AstToken(getRhsIToken(2)),
                                              //#line 681 GJavaParser.g
                                              getRhsSym(3) as Ast)
                //#line 681 GJavaParser.g
                );
            break;
            }
            //
            // Rule 287:  ExpressionStatement ::= StatementExpression ;
            //
            case 287: {
               //#line 683 "GJavaParser.g"
                setResult(
                    //#line 683 GJavaParser.g
                    ExpressionStatement(getLeftIToken(), getRightIToken(),
                                        //#line 683 GJavaParser.g
                                        getRhsSym(1) as Ast,
                                        //#line 683 GJavaParser.g
                                        AstToken(getRhsIToken(2)))
                //#line 683 GJavaParser.g
                );
            break;
            }
            //
            // Rule 288:  StatementExpression ::= Assignment
            //
            case 288:
                break;
            //
            // Rule 289:  StatementExpression ::= PreIncrementExpression
            //
            case 289:
                break;
            //
            // Rule 290:  StatementExpression ::= PreDecrementExpression
            //
            case 290:
                break;
            //
            // Rule 291:  StatementExpression ::= PostIncrementExpression
            //
            case 291:
                break;
            //
            // Rule 292:  StatementExpression ::= PostDecrementExpression
            //
            case 292:
                break;
            //
            // Rule 293:  StatementExpression ::= MethodInvocation
            //
            case 293:
                break;
            //
            // Rule 294:  StatementExpression ::= ClassInstanceCreationExpression
            //
            case 294:
                break;
            //
            // Rule 295:  AssertStatement ::= assert Expression ;
            //
            case 295: {
               //#line 702 "GJavaParser.g"
                setResult(
                    //#line 702 GJavaParser.g
                    AssertStatement0(getLeftIToken(), getRightIToken(),
                                     //#line 702 GJavaParser.g
                                     AstToken(getRhsIToken(1)),
                                     //#line 702 GJavaParser.g
                                     getRhsSym(2) as Ast,
                                     //#line 702 GJavaParser.g
                                     AstToken(getRhsIToken(3)))
                //#line 702 GJavaParser.g
                );
            break;
            }
            //
            // Rule 296:  AssertStatement ::= assert Expression : Expression ;
            //
            case 296: {
               //#line 703 "GJavaParser.g"
                setResult(
                    //#line 703 GJavaParser.g
                    AssertStatement1(getLeftIToken(), getRightIToken(),
                                     //#line 703 GJavaParser.g
                                     AstToken(getRhsIToken(1)),
                                     //#line 703 GJavaParser.g
                                     getRhsSym(2) as Ast,
                                     //#line 703 GJavaParser.g
                                     AstToken(getRhsIToken(3)),
                                     //#line 703 GJavaParser.g
                                     getRhsSym(4) as Ast,
                                     //#line 703 GJavaParser.g
                                     AstToken(getRhsIToken(5)))
                //#line 703 GJavaParser.g
                );
            break;
            }
            //
            // Rule 297:  SwitchStatement ::= switch ( Expression ) SwitchBlock
            //
            case 297: {
               //#line 705 "GJavaParser.g"
                setResult(
                    //#line 705 GJavaParser.g
                    SwitchStatement(getLeftIToken(), getRightIToken(),
                                    //#line 705 GJavaParser.g
                                    AstToken(getRhsIToken(1)),
                                    //#line 705 GJavaParser.g
                                    AstToken(getRhsIToken(2)),
                                    //#line 705 GJavaParser.g
                                    getRhsSym(3) as Ast,
                                    //#line 705 GJavaParser.g
                                    AstToken(getRhsIToken(4)),
                                    //#line 705 GJavaParser.g
                                    getRhsSym(5) as SwitchBlock)
                //#line 705 GJavaParser.g
                );
            break;
            }
            //
            // Rule 298:  SwitchBlock ::= { SwitchBlockStatementGroupsopt SwitchLabelsopt }
            //
            case 298: {
               //#line 707 "GJavaParser.g"
                setResult(
                    //#line 707 GJavaParser.g
                    SwitchBlock(getLeftIToken(), getRightIToken(),
                                //#line 707 GJavaParser.g
                                AstToken(getRhsIToken(1)),
                                //#line 707 GJavaParser.g
                                getRhsSym(2) as Ast?,
                                //#line 707 GJavaParser.g
                                getRhsSym(3) as Ast?,
                                //#line 707 GJavaParser.g
                                AstToken(getRhsIToken(4)))
                //#line 707 GJavaParser.g
                );
            break;
            }
            //
            // Rule 299:  SwitchBlockStatementGroups ::= SwitchBlockStatementGroup
            //
            case 299:
                break;
            //
            // Rule 300:  SwitchBlockStatementGroups ::= SwitchBlockStatementGroups SwitchBlockStatementGroup
            //
            case 300: {
               //#line 710 "GJavaParser.g"
                setResult(
                    //#line 710 GJavaParser.g
                    SwitchBlockStatementGroups(getLeftIToken(), getRightIToken(),
                                               //#line 710 GJavaParser.g
                                               getRhsSym(1) as Ast,
                                               //#line 710 GJavaParser.g
                                               getRhsSym(2) as SwitchBlockStatementGroup)
                //#line 710 GJavaParser.g
                );
            break;
            }
            //
            // Rule 301:  SwitchBlockStatementGroup ::= SwitchLabels BlockStatements
            //
            case 301: {
               //#line 712 "GJavaParser.g"
                setResult(
                    //#line 712 GJavaParser.g
                    SwitchBlockStatementGroup(getLeftIToken(), getRightIToken(),
                                              //#line 712 GJavaParser.g
                                              getRhsSym(1) as Ast,
                                              //#line 712 GJavaParser.g
                                              getRhsSym(2) as Ast)
                //#line 712 GJavaParser.g
                );
            break;
            }
            //
            // Rule 302:  SwitchLabels ::= SwitchLabel
            //
            case 302:
                break;
            //
            // Rule 303:  SwitchLabels ::= SwitchLabels SwitchLabel
            //
            case 303: {
               //#line 715 "GJavaParser.g"
                setResult(
                    //#line 715 GJavaParser.g
                    SwitchLabels(getLeftIToken(), getRightIToken(),
                                 //#line 715 GJavaParser.g
                                 getRhsSym(1) as Ast,
                                 //#line 715 GJavaParser.g
                                 getRhsSym(2) as Ast)
                //#line 715 GJavaParser.g
                );
            break;
            }
            //
            // Rule 304:  SwitchLabel ::= case ConstantExpression :
            //
            case 304: {
               //#line 717 "GJavaParser.g"
                setResult(
                    //#line 717 GJavaParser.g
                    SwitchLabel0(getLeftIToken(), getRightIToken(),
                                 //#line 717 GJavaParser.g
                                 AstToken(getRhsIToken(1)),
                                 //#line 717 GJavaParser.g
                                 getRhsSym(2) as Ast,
                                 //#line 717 GJavaParser.g
                                 AstToken(getRhsIToken(3)))
                //#line 717 GJavaParser.g
                );
            break;
            }
            //
            // Rule 305:  SwitchLabel ::= case EnumConstant :
            //
            case 305: {
               //#line 718 "GJavaParser.g"
                setResult(
                    //#line 718 GJavaParser.g
                    SwitchLabel1(getLeftIToken(), getRightIToken(),
                                 //#line 718 GJavaParser.g
                                 AstToken(getRhsIToken(1)),
                                 //#line 718 GJavaParser.g
                                 getRhsSym(2) as Ast,
                                 //#line 718 GJavaParser.g
                                 AstToken(getRhsIToken(3)))
                //#line 718 GJavaParser.g
                );
            break;
            }
            //
            // Rule 306:  SwitchLabel ::= default :
            //
            case 306: {
               //#line 719 "GJavaParser.g"
                setResult(
                    //#line 719 GJavaParser.g
                    SwitchLabel2(getLeftIToken(), getRightIToken(),
                                 //#line 719 GJavaParser.g
                                 AstToken(getRhsIToken(1)),
                                 //#line 719 GJavaParser.g
                                 AstToken(getRhsIToken(2)))
                //#line 719 GJavaParser.g
                );
            break;
            }
            //
            // Rule 307:  EnumConstant ::= identifier
            //
            case 307:
                break;
            //
            // Rule 308:  WhileStatement ::= while ( Expression ) Statement
            //
            case 308: {
               //#line 723 "GJavaParser.g"
                setResult(
                    //#line 723 GJavaParser.g
                    WhileStatement(getLeftIToken(), getRightIToken(),
                                   //#line 723 GJavaParser.g
                                   AstToken(getRhsIToken(1)),
                                   //#line 723 GJavaParser.g
                                   AstToken(getRhsIToken(2)),
                                   //#line 723 GJavaParser.g
                                   getRhsSym(3) as Ast,
                                   //#line 723 GJavaParser.g
                                   AstToken(getRhsIToken(4)),
                                   //#line 723 GJavaParser.g
                                   getRhsSym(5) as Ast)
                //#line 723 GJavaParser.g
                );
            break;
            }
            //
            // Rule 309:  WhileStatementNoShortIf ::= while ( Expression ) StatementNoShortIf
            //
            case 309: {
               //#line 725 "GJavaParser.g"
                setResult(
                    //#line 725 GJavaParser.g
                    WhileStatementNoShortIf(getLeftIToken(), getRightIToken(),
                                            //#line 725 GJavaParser.g
                                            AstToken(getRhsIToken(1)),
                                            //#line 725 GJavaParser.g
                                            AstToken(getRhsIToken(2)),
                                            //#line 725 GJavaParser.g
                                            getRhsSym(3) as Ast,
                                            //#line 725 GJavaParser.g
                                            AstToken(getRhsIToken(4)),
                                            //#line 725 GJavaParser.g
                                            getRhsSym(5) as Ast)
                //#line 725 GJavaParser.g
                );
            break;
            }
            //
            // Rule 310:  DoStatement ::= do Statement while ( Expression ) ;
            //
            case 310: {
               //#line 727 "GJavaParser.g"
                setResult(
                    //#line 727 GJavaParser.g
                    DoStatement(getLeftIToken(), getRightIToken(),
                                //#line 727 GJavaParser.g
                                AstToken(getRhsIToken(1)),
                                //#line 727 GJavaParser.g
                                getRhsSym(2) as Ast,
                                //#line 727 GJavaParser.g
                                AstToken(getRhsIToken(3)),
                                //#line 727 GJavaParser.g
                                AstToken(getRhsIToken(4)),
                                //#line 727 GJavaParser.g
                                getRhsSym(5) as Ast,
                                //#line 727 GJavaParser.g
                                AstToken(getRhsIToken(6)),
                                //#line 727 GJavaParser.g
                                AstToken(getRhsIToken(7)))
                //#line 727 GJavaParser.g
                );
            break;
            }
            //
            // Rule 311:  ForStatement ::= BasicForStatement
            //
            case 311:
                break;
            //
            // Rule 312:  ForStatement ::= EnhancedForStatement
            //
            case 312:
                break;
            //
            // Rule 313:  BasicForStatement ::= for ( ForInitopt ; Expressionopt ; ForUpdateopt ) Statement
            //
            case 313: {
               //#line 732 "GJavaParser.g"
                setResult(
                    //#line 732 GJavaParser.g
                    BasicForStatement(getLeftIToken(), getRightIToken(),
                                      //#line 732 GJavaParser.g
                                      AstToken(getRhsIToken(1)),
                                      //#line 732 GJavaParser.g
                                      AstToken(getRhsIToken(2)),
                                      //#line 732 GJavaParser.g
                                      getRhsSym(3) as Ast?,
                                      //#line 732 GJavaParser.g
                                      AstToken(getRhsIToken(4)),
                                      //#line 732 GJavaParser.g
                                      getRhsSym(5) as Ast?,
                                      //#line 732 GJavaParser.g
                                      AstToken(getRhsIToken(6)),
                                      //#line 732 GJavaParser.g
                                      getRhsSym(7) as Ast?,
                                      //#line 732 GJavaParser.g
                                      AstToken(getRhsIToken(8)),
                                      //#line 732 GJavaParser.g
                                      getRhsSym(9) as Ast)
                //#line 732 GJavaParser.g
                );
            break;
            }
            //
            // Rule 314:  ForStatementNoShortIf ::= for ( ForInitopt ; Expressionopt ; ForUpdateopt ) StatementNoShortIf
            //
            case 314: {
               //#line 734 "GJavaParser.g"
                setResult(
                    //#line 734 GJavaParser.g
                    ForStatementNoShortIf(getLeftIToken(), getRightIToken(),
                                          //#line 734 GJavaParser.g
                                          AstToken(getRhsIToken(1)),
                                          //#line 734 GJavaParser.g
                                          AstToken(getRhsIToken(2)),
                                          //#line 734 GJavaParser.g
                                          getRhsSym(3) as Ast?,
                                          //#line 734 GJavaParser.g
                                          AstToken(getRhsIToken(4)),
                                          //#line 734 GJavaParser.g
                                          getRhsSym(5) as Ast?,
                                          //#line 734 GJavaParser.g
                                          AstToken(getRhsIToken(6)),
                                          //#line 734 GJavaParser.g
                                          getRhsSym(7) as Ast?,
                                          //#line 734 GJavaParser.g
                                          AstToken(getRhsIToken(8)),
                                          //#line 734 GJavaParser.g
                                          getRhsSym(9) as Ast)
                //#line 734 GJavaParser.g
                );
            break;
            }
            //
            // Rule 315:  ForInit ::= StatementExpressionList
            //
            case 315:
                break;
            //
            // Rule 316:  ForInit ::= LocalVariableDeclaration
            //
            case 316:
                break;
            //
            // Rule 317:  ForUpdate ::= StatementExpressionList
            //
            case 317:
                break;
            //
            // Rule 318:  StatementExpressionList ::= StatementExpression
            //
            case 318:
                break;
            //
            // Rule 319:  StatementExpressionList ::= StatementExpressionList , StatementExpression
            //
            case 319: {
               //#line 742 "GJavaParser.g"
                setResult(
                    //#line 742 GJavaParser.g
                    StatementExpressionList(getLeftIToken(), getRightIToken(),
                                            //#line 742 GJavaParser.g
                                            getRhsSym(1) as Ast,
                                            //#line 742 GJavaParser.g
                                            AstToken(getRhsIToken(2)),
                                            //#line 742 GJavaParser.g
                                            getRhsSym(3) as Ast)
                //#line 742 GJavaParser.g
                );
            break;
            }
            //
            // Rule 320:  EnhancedForStatement ::= for ( FormalParameter : Expression ) Statement
            //
            case 320: {
               //#line 744 "GJavaParser.g"
                setResult(
                    //#line 744 GJavaParser.g
                    EnhancedForStatement(getLeftIToken(), getRightIToken(),
                                         //#line 744 GJavaParser.g
                                         AstToken(getRhsIToken(1)),
                                         //#line 744 GJavaParser.g
                                         AstToken(getRhsIToken(2)),
                                         //#line 744 GJavaParser.g
                                         getRhsSym(3) as FormalParameter,
                                         //#line 744 GJavaParser.g
                                         AstToken(getRhsIToken(4)),
                                         //#line 744 GJavaParser.g
                                         getRhsSym(5) as Ast,
                                         //#line 744 GJavaParser.g
                                         AstToken(getRhsIToken(6)),
                                         //#line 744 GJavaParser.g
                                         getRhsSym(7) as Ast)
                //#line 744 GJavaParser.g
                );
            break;
            }
            //
            // Rule 321:  BreakStatement ::= break identifieropt ;
            //
            case 321: {
               //#line 746 "GJavaParser.g"
                setResult(
                    //#line 746 GJavaParser.g
                    BreakStatement(getLeftIToken(), getRightIToken(),
                                   //#line 746 GJavaParser.g
                                   AstToken(getRhsIToken(1)),
                                   //#line 746 GJavaParser.g
                                   getRhsSym(2) as identifier?,
                                   //#line 746 GJavaParser.g
                                   AstToken(getRhsIToken(3)))
                //#line 746 GJavaParser.g
                );
            break;
            }
            //
            // Rule 322:  ContinueStatement ::= continue identifieropt ;
            //
            case 322: {
               //#line 748 "GJavaParser.g"
                setResult(
                    //#line 748 GJavaParser.g
                    ContinueStatement(getLeftIToken(), getRightIToken(),
                                      //#line 748 GJavaParser.g
                                      AstToken(getRhsIToken(1)),
                                      //#line 748 GJavaParser.g
                                      getRhsSym(2) as identifier?,
                                      //#line 748 GJavaParser.g
                                      AstToken(getRhsIToken(3)))
                //#line 748 GJavaParser.g
                );
            break;
            }
            //
            // Rule 323:  ReturnStatement ::= return Expressionopt ;
            //
            case 323: {
               //#line 750 "GJavaParser.g"
                setResult(
                    //#line 750 GJavaParser.g
                    ReturnStatement(getLeftIToken(), getRightIToken(),
                                    //#line 750 GJavaParser.g
                                    AstToken(getRhsIToken(1)),
                                    //#line 750 GJavaParser.g
                                    getRhsSym(2) as Ast?,
                                    //#line 750 GJavaParser.g
                                    AstToken(getRhsIToken(3)))
                //#line 750 GJavaParser.g
                );
            break;
            }
            //
            // Rule 324:  ThrowStatement ::= throw Expression ;
            //
            case 324: {
               //#line 752 "GJavaParser.g"
                setResult(
                    //#line 752 GJavaParser.g
                    ThrowStatement(getLeftIToken(), getRightIToken(),
                                   //#line 752 GJavaParser.g
                                   AstToken(getRhsIToken(1)),
                                   //#line 752 GJavaParser.g
                                   getRhsSym(2) as Ast,
                                   //#line 752 GJavaParser.g
                                   AstToken(getRhsIToken(3)))
                //#line 752 GJavaParser.g
                );
            break;
            }
            //
            // Rule 325:  SynchronizedStatement ::= synchronized ( Expression ) Block
            //
            case 325: {
               //#line 754 "GJavaParser.g"
                setResult(
                    //#line 754 GJavaParser.g
                    SynchronizedStatement(getLeftIToken(), getRightIToken(),
                                          //#line 754 GJavaParser.g
                                          AstToken(getRhsIToken(1)),
                                          //#line 754 GJavaParser.g
                                          AstToken(getRhsIToken(2)),
                                          //#line 754 GJavaParser.g
                                          getRhsSym(3) as Ast,
                                          //#line 754 GJavaParser.g
                                          AstToken(getRhsIToken(4)),
                                          //#line 754 GJavaParser.g
                                          getRhsSym(5) as Block)
                //#line 754 GJavaParser.g
                );
            break;
            }
            //
            // Rule 326:  TryStatement ::= try Block Catches
            //
            case 326: {
               //#line 756 "GJavaParser.g"
                setResult(
                    //#line 756 GJavaParser.g
                    TryStatement0(getLeftIToken(), getRightIToken(),
                                  //#line 756 GJavaParser.g
                                  AstToken(getRhsIToken(1)),
                                  //#line 756 GJavaParser.g
                                  getRhsSym(2) as Block,
                                  //#line 756 GJavaParser.g
                                  getRhsSym(3) as Ast)
                //#line 756 GJavaParser.g
                );
            break;
            }
            //
            // Rule 327:  TryStatement ::= try Block Catchesopt Finally
            //
            case 327: {
               //#line 757 "GJavaParser.g"
                setResult(
                    //#line 757 GJavaParser.g
                    TryStatement1(getLeftIToken(), getRightIToken(),
                                  //#line 757 GJavaParser.g
                                  AstToken(getRhsIToken(1)),
                                  //#line 757 GJavaParser.g
                                  getRhsSym(2) as Block,
                                  //#line 757 GJavaParser.g
                                  getRhsSym(3) as Ast?,
                                  //#line 757 GJavaParser.g
                                  getRhsSym(4) as Finally)
                //#line 757 GJavaParser.g
                );
            break;
            }
            //
            // Rule 328:  Catches ::= CatchClause
            //
            case 328:
                break;
            //
            // Rule 329:  Catches ::= Catches CatchClause
            //
            case 329: {
               //#line 760 "GJavaParser.g"
                setResult(
                    //#line 760 GJavaParser.g
                    Catches(getLeftIToken(), getRightIToken(),
                            //#line 760 GJavaParser.g
                            getRhsSym(1) as Ast,
                            //#line 760 GJavaParser.g
                            getRhsSym(2) as CatchClause)
                //#line 760 GJavaParser.g
                );
            break;
            }
            //
            // Rule 330:  CatchClause ::= catch ( FormalParameter ) Block
            //
            case 330: {
               //#line 762 "GJavaParser.g"
                setResult(
                    //#line 762 GJavaParser.g
                    CatchClause(getLeftIToken(), getRightIToken(),
                                //#line 762 GJavaParser.g
                                AstToken(getRhsIToken(1)),
                                //#line 762 GJavaParser.g
                                AstToken(getRhsIToken(2)),
                                //#line 762 GJavaParser.g
                                getRhsSym(3) as FormalParameter,
                                //#line 762 GJavaParser.g
                                AstToken(getRhsIToken(4)),
                                //#line 762 GJavaParser.g
                                getRhsSym(5) as Block)
                //#line 762 GJavaParser.g
                );
            break;
            }
            //
            // Rule 331:  Finally ::= finally Block
            //
            case 331: {
               //#line 764 "GJavaParser.g"
                setResult(
                    //#line 764 GJavaParser.g
                    Finally(getLeftIToken(), getRightIToken(),
                            //#line 764 GJavaParser.g
                            AstToken(getRhsIToken(1)),
                            //#line 764 GJavaParser.g
                            getRhsSym(2) as Block)
                //#line 764 GJavaParser.g
                );
            break;
            }
            //
            // Rule 332:  Primary ::= PrimaryNoNewArray
            //
            case 332:
                break;
            //
            // Rule 333:  Primary ::= ArrayCreationExpression
            //
            case 333:
                break;
            //
            // Rule 334:  PrimaryNoNewArray ::= Literal
            //
            case 334:
                break;
            //
            // Rule 335:  PrimaryNoNewArray ::= Type . class
            //
            case 335: {
               //#line 780 "GJavaParser.g"
                setResult(
                    //#line 780 GJavaParser.g
                    PrimaryNoNewArray0(getLeftIToken(), getRightIToken(),
                                       //#line 780 GJavaParser.g
                                       getRhsSym(1) as Ast,
                                       //#line 780 GJavaParser.g
                                       AstToken(getRhsIToken(2)),
                                       //#line 780 GJavaParser.g
                                       AstToken(getRhsIToken(3)))
                //#line 780 GJavaParser.g
                );
            break;
            }
            //
            // Rule 336:  PrimaryNoNewArray ::= void . class
            //
            case 336: {
               //#line 781 "GJavaParser.g"
                setResult(
                    //#line 781 GJavaParser.g
                    PrimaryNoNewArray1(getLeftIToken(), getRightIToken(),
                                       //#line 781 GJavaParser.g
                                       AstToken(getRhsIToken(1)),
                                       //#line 781 GJavaParser.g
                                       AstToken(getRhsIToken(2)),
                                       //#line 781 GJavaParser.g
                                       AstToken(getRhsIToken(3)))
                //#line 781 GJavaParser.g
                );
            break;
            }
            //
            // Rule 337:  PrimaryNoNewArray ::= this
            //
            case 337: {
               //#line 782 "GJavaParser.g"
                setResult(
                    //#line 782 GJavaParser.g
                    PrimaryNoNewArray2(getRhsIToken(1))
                //#line 782 GJavaParser.g
                );
            break;
            }
            //
            // Rule 338:  PrimaryNoNewArray ::= ClassName . this
            //
            case 338: {
               //#line 783 "GJavaParser.g"
                setResult(
                    //#line 783 GJavaParser.g
                    PrimaryNoNewArray3(getLeftIToken(), getRightIToken(),
                                       //#line 783 GJavaParser.g
                                       getRhsSym(1) as Ast,
                                       //#line 783 GJavaParser.g
                                       AstToken(getRhsIToken(2)),
                                       //#line 783 GJavaParser.g
                                       AstToken(getRhsIToken(3)))
                //#line 783 GJavaParser.g
                );
            break;
            }
            //
            // Rule 339:  PrimaryNoNewArray ::= ( Expression )
            //
            case 339: {
               //#line 784 "GJavaParser.g"
                setResult(
                    //#line 784 GJavaParser.g
                    PrimaryNoNewArray4(getLeftIToken(), getRightIToken(),
                                       //#line 784 GJavaParser.g
                                       AstToken(getRhsIToken(1)),
                                       //#line 784 GJavaParser.g
                                       getRhsSym(2) as Ast,
                                       //#line 784 GJavaParser.g
                                       AstToken(getRhsIToken(3)))
                //#line 784 GJavaParser.g
                );
            break;
            }
            //
            // Rule 340:  PrimaryNoNewArray ::= ClassInstanceCreationExpression
            //
            case 340:
                break;
            //
            // Rule 341:  PrimaryNoNewArray ::= FieldAccess
            //
            case 341:
                break;
            //
            // Rule 342:  PrimaryNoNewArray ::= MethodInvocation
            //
            case 342:
                break;
            //
            // Rule 343:  PrimaryNoNewArray ::= ArrayAccess
            //
            case 343:
                break;
            //
            // Rule 344:  Literal ::= IntegerLiteral
            //
            case 344: {
               //#line 790 "GJavaParser.g"
                setResult(
                    //#line 790 GJavaParser.g
                    Literal0(getRhsIToken(1))
                //#line 790 GJavaParser.g
                );
            break;
            }
            //
            // Rule 345:  Literal ::= LongLiteral
            //
            case 345: {
               //#line 791 "GJavaParser.g"
                setResult(
                    //#line 791 GJavaParser.g
                    Literal1(getRhsIToken(1))
                //#line 791 GJavaParser.g
                );
            break;
            }
            //
            // Rule 346:  Literal ::= FloatingPointLiteral
            //
            case 346: {
               //#line 792 "GJavaParser.g"
                setResult(
                    //#line 792 GJavaParser.g
                    Literal2(getRhsIToken(1))
                //#line 792 GJavaParser.g
                );
            break;
            }
            //
            // Rule 347:  Literal ::= DoubleLiteral
            //
            case 347: {
               //#line 793 "GJavaParser.g"
                setResult(
                    //#line 793 GJavaParser.g
                    Literal3(getRhsIToken(1))
                //#line 793 GJavaParser.g
                );
            break;
            }
            //
            // Rule 348:  Literal ::= BooleanLiteral
            //
            case 348:
                break;
            //
            // Rule 349:  Literal ::= CharacterLiteral
            //
            case 349: {
               //#line 795 "GJavaParser.g"
                setResult(
                    //#line 795 GJavaParser.g
                    Literal4(getRhsIToken(1))
                //#line 795 GJavaParser.g
                );
            break;
            }
            //
            // Rule 350:  Literal ::= StringLiteral
            //
            case 350: {
               //#line 796 "GJavaParser.g"
                setResult(
                    //#line 796 GJavaParser.g
                    Literal5(getRhsIToken(1))
                //#line 796 GJavaParser.g
                );
            break;
            }
            //
            // Rule 351:  Literal ::= null
            //
            case 351: {
               //#line 797 "GJavaParser.g"
                setResult(
                    //#line 797 GJavaParser.g
                    Literal6(getRhsIToken(1))
                //#line 797 GJavaParser.g
                );
            break;
            }
            //
            // Rule 352:  BooleanLiteral ::= true
            //
            case 352: {
               //#line 799 "GJavaParser.g"
                setResult(
                    //#line 799 GJavaParser.g
                    BooleanLiteral0(getRhsIToken(1))
                //#line 799 GJavaParser.g
                );
            break;
            }
            //
            // Rule 353:  BooleanLiteral ::= false
            //
            case 353: {
               //#line 800 "GJavaParser.g"
                setResult(
                    //#line 800 GJavaParser.g
                    BooleanLiteral1(getRhsIToken(1))
                //#line 800 GJavaParser.g
                );
            break;
            }
            //
            // Rule 354:  ClassInstanceCreationExpression ::= new TypeArgumentsopt ClassOrInterfaceType TypeArgumentsopt ( ArgumentListopt ) ClassBodyopt
            //
            case 354: {
               //#line 807 "GJavaParser.g"
                setResult(
                    //#line 807 GJavaParser.g
                    ClassInstanceCreationExpression0(getLeftIToken(), getRightIToken(),
                                                     //#line 807 GJavaParser.g
                                                     AstToken(getRhsIToken(1)),
                                                     //#line 807 GJavaParser.g
                                                     getRhsSym(2) as TypeArguments?,
                                                     //#line 807 GJavaParser.g
                                                     getRhsSym(3) as ClassType,
                                                     //#line 807 GJavaParser.g
                                                     getRhsSym(4) as TypeArguments?,
                                                     //#line 807 GJavaParser.g
                                                     AstToken(getRhsIToken(5)),
                                                     //#line 807 GJavaParser.g
                                                     getRhsSym(6) as Ast?,
                                                     //#line 807 GJavaParser.g
                                                     AstToken(getRhsIToken(7)),
                                                     //#line 807 GJavaParser.g
                                                     getRhsSym(8) as ClassBody?)
                //#line 807 GJavaParser.g
                );
            break;
            }
            //
            // Rule 355:  ClassInstanceCreationExpression ::= Primary . new TypeArgumentsopt identifier TypeArgumentsopt ( ArgumentListopt ) ClassBodyopt
            //
            case 355: {
               //#line 808 "GJavaParser.g"
                setResult(
                    //#line 808 GJavaParser.g
                    ClassInstanceCreationExpression1(getLeftIToken(), getRightIToken(),
                                                     //#line 808 GJavaParser.g
                                                     getRhsSym(1) as Ast,
                                                     //#line 808 GJavaParser.g
                                                     AstToken(getRhsIToken(2)),
                                                     //#line 808 GJavaParser.g
                                                     AstToken(getRhsIToken(3)),
                                                     //#line 808 GJavaParser.g
                                                     getRhsSym(4) as TypeArguments?,
                                                     //#line 808 GJavaParser.g
                                                     getRhsSym(5) as identifier,
                                                     //#line 808 GJavaParser.g
                                                     getRhsSym(6) as TypeArguments?,
                                                     //#line 808 GJavaParser.g
                                                     AstToken(getRhsIToken(7)),
                                                     //#line 808 GJavaParser.g
                                                     getRhsSym(8) as Ast?,
                                                     //#line 808 GJavaParser.g
                                                     AstToken(getRhsIToken(9)),
                                                     //#line 808 GJavaParser.g
                                                     getRhsSym(10) as ClassBody?)
                //#line 808 GJavaParser.g
                );
            break;
            }
            //
            // Rule 356:  ArgumentList ::= Expression
            //
            case 356:
                break;
            //
            // Rule 357:  ArgumentList ::= ArgumentList , Expression
            //
            case 357: {
               //#line 812 "GJavaParser.g"
                setResult(
                    //#line 812 GJavaParser.g
                    ArgumentList(getLeftIToken(), getRightIToken(),
                                 //#line 812 GJavaParser.g
                                 getRhsSym(1) as Ast,
                                 //#line 812 GJavaParser.g
                                 AstToken(getRhsIToken(2)),
                                 //#line 812 GJavaParser.g
                                 getRhsSym(3) as Ast)
                //#line 812 GJavaParser.g
                );
            break;
            }
            //
            // Rule 358:  ArrayCreationExpression ::= new PrimitiveType DimExprs Dimsopt
            //
            case 358: {
               //#line 822 "GJavaParser.g"
                setResult(
                    //#line 822 GJavaParser.g
                    ArrayCreationExpression0(getLeftIToken(), getRightIToken(),
                                             //#line 822 GJavaParser.g
                                             AstToken(getRhsIToken(1)),
                                             //#line 822 GJavaParser.g
                                             getRhsSym(2) as Ast,
                                             //#line 822 GJavaParser.g
                                             getRhsSym(3) as Ast,
                                             //#line 822 GJavaParser.g
                                             getRhsSym(4) as Ast?)
                //#line 822 GJavaParser.g
                );
            break;
            }
            //
            // Rule 359:  ArrayCreationExpression ::= new ClassOrInterfaceType DimExprs Dimsopt
            //
            case 359: {
               //#line 823 "GJavaParser.g"
                setResult(
                    //#line 823 GJavaParser.g
                    ArrayCreationExpression1(getLeftIToken(), getRightIToken(),
                                             //#line 823 GJavaParser.g
                                             AstToken(getRhsIToken(1)),
                                             //#line 823 GJavaParser.g
                                             getRhsSym(2) as ClassType,
                                             //#line 823 GJavaParser.g
                                             getRhsSym(3) as Ast,
                                             //#line 823 GJavaParser.g
                                             getRhsSym(4) as Ast?)
                //#line 823 GJavaParser.g
                );
            break;
            }
            //
            // Rule 360:  ArrayCreationExpression ::= new PrimitiveType Dims ArrayInitializer
            //
            case 360: {
               //#line 824 "GJavaParser.g"
                setResult(
                    //#line 824 GJavaParser.g
                    ArrayCreationExpression2(getLeftIToken(), getRightIToken(),
                                             //#line 824 GJavaParser.g
                                             AstToken(getRhsIToken(1)),
                                             //#line 824 GJavaParser.g
                                             getRhsSym(2) as Ast,
                                             //#line 824 GJavaParser.g
                                             getRhsSym(3) as Ast,
                                             //#line 824 GJavaParser.g
                                             getRhsSym(4) as ArrayInitializer)
                //#line 824 GJavaParser.g
                );
            break;
            }
            //
            // Rule 361:  ArrayCreationExpression ::= new ClassOrInterfaceType Dims ArrayInitializer
            //
            case 361: {
               //#line 825 "GJavaParser.g"
                setResult(
                    //#line 825 GJavaParser.g
                    ArrayCreationExpression3(getLeftIToken(), getRightIToken(),
                                             //#line 825 GJavaParser.g
                                             AstToken(getRhsIToken(1)),
                                             //#line 825 GJavaParser.g
                                             getRhsSym(2) as ClassType,
                                             //#line 825 GJavaParser.g
                                             getRhsSym(3) as Ast,
                                             //#line 825 GJavaParser.g
                                             getRhsSym(4) as ArrayInitializer)
                //#line 825 GJavaParser.g
                );
            break;
            }
            //
            // Rule 362:  DimExprs ::= DimExpr
            //
            case 362:
                break;
            //
            // Rule 363:  DimExprs ::= DimExprs DimExpr
            //
            case 363: {
               //#line 828 "GJavaParser.g"
                setResult(
                    //#line 828 GJavaParser.g
                    DimExprs(getLeftIToken(), getRightIToken(),
                             //#line 828 GJavaParser.g
                             getRhsSym(1) as Ast,
                             //#line 828 GJavaParser.g
                             getRhsSym(2) as DimExpr)
                //#line 828 GJavaParser.g
                );
            break;
            }
            //
            // Rule 364:  DimExpr ::= [ Expression ]
            //
            case 364: {
               //#line 830 "GJavaParser.g"
                setResult(
                    //#line 830 GJavaParser.g
                    DimExpr(getLeftIToken(), getRightIToken(),
                            //#line 830 GJavaParser.g
                            AstToken(getRhsIToken(1)),
                            //#line 830 GJavaParser.g
                            getRhsSym(2) as Ast,
                            //#line 830 GJavaParser.g
                            AstToken(getRhsIToken(3)))
                //#line 830 GJavaParser.g
                );
            break;
            }
            //
            // Rule 365:  Dims ::= [ ]
            //
            case 365: {
               //#line 832 "GJavaParser.g"
                setResult(
                    //#line 832 GJavaParser.g
                    Dims0(getLeftIToken(), getRightIToken(),
                          //#line 832 GJavaParser.g
                          AstToken(getRhsIToken(1)),
                          //#line 832 GJavaParser.g
                          AstToken(getRhsIToken(2)))
                //#line 832 GJavaParser.g
                );
            break;
            }
            //
            // Rule 366:  Dims ::= Dims [ ]
            //
            case 366: {
               //#line 833 "GJavaParser.g"
                setResult(
                    //#line 833 GJavaParser.g
                    Dims1(getLeftIToken(), getRightIToken(),
                          //#line 833 GJavaParser.g
                          getRhsSym(1) as Ast,
                          //#line 833 GJavaParser.g
                          AstToken(getRhsIToken(2)),
                          //#line 833 GJavaParser.g
                          AstToken(getRhsIToken(3)))
                //#line 833 GJavaParser.g
                );
            break;
            }
            //
            // Rule 367:  FieldAccess ::= Primary . identifier
            //
            case 367: {
               //#line 835 "GJavaParser.g"
                setResult(
                    //#line 835 GJavaParser.g
                    FieldAccess0(getLeftIToken(), getRightIToken(),
                                 //#line 835 GJavaParser.g
                                 getRhsSym(1) as Ast,
                                 //#line 835 GJavaParser.g
                                 AstToken(getRhsIToken(2)),
                                 //#line 835 GJavaParser.g
                                 getRhsSym(3) as identifier)
                //#line 835 GJavaParser.g
                );
            break;
            }
            //
            // Rule 368:  FieldAccess ::= super . identifier
            //
            case 368: {
               //#line 836 "GJavaParser.g"
                setResult(
                    //#line 836 GJavaParser.g
                    FieldAccess1(getLeftIToken(), getRightIToken(),
                                 //#line 836 GJavaParser.g
                                 AstToken(getRhsIToken(1)),
                                 //#line 836 GJavaParser.g
                                 AstToken(getRhsIToken(2)),
                                 //#line 836 GJavaParser.g
                                 getRhsSym(3) as identifier)
                //#line 836 GJavaParser.g
                );
            break;
            }
            //
            // Rule 369:  FieldAccess ::= ClassName . super . identifier
            //
            case 369: {
               //#line 837 "GJavaParser.g"
                setResult(
                    //#line 837 GJavaParser.g
                    FieldAccess2(getLeftIToken(), getRightIToken(),
                                 //#line 837 GJavaParser.g
                                 getRhsSym(1) as Ast,
                                 //#line 837 GJavaParser.g
                                 AstToken(getRhsIToken(2)),
                                 //#line 837 GJavaParser.g
                                 AstToken(getRhsIToken(3)),
                                 //#line 837 GJavaParser.g
                                 AstToken(getRhsIToken(4)),
                                 //#line 837 GJavaParser.g
                                 getRhsSym(5) as identifier)
                //#line 837 GJavaParser.g
                );
            break;
            }
            //
            // Rule 370:  MethodInvocation ::= MethodName ( ArgumentListopt )
            //
            case 370: {
               //#line 839 "GJavaParser.g"
                setResult(
                    //#line 839 GJavaParser.g
                    MethodInvocation0(getLeftIToken(), getRightIToken(),
                                      //#line 839 GJavaParser.g
                                      getRhsSym(1) as Ast,
                                      //#line 839 GJavaParser.g
                                      AstToken(getRhsIToken(2)),
                                      //#line 839 GJavaParser.g
                                      getRhsSym(3) as Ast?,
                                      //#line 839 GJavaParser.g
                                      AstToken(getRhsIToken(4)))
                //#line 839 GJavaParser.g
                );
            break;
            }
            //
            // Rule 371:  MethodInvocation ::= Primary . TypeArgumentsopt identifier ( ArgumentListopt )
            //
            case 371: {
               //#line 840 "GJavaParser.g"
                setResult(
                    //#line 840 GJavaParser.g
                    MethodInvocation1(getLeftIToken(), getRightIToken(),
                                      //#line 840 GJavaParser.g
                                      getRhsSym(1) as Ast,
                                      //#line 840 GJavaParser.g
                                      AstToken(getRhsIToken(2)),
                                      //#line 840 GJavaParser.g
                                      getRhsSym(3) as TypeArguments?,
                                      //#line 840 GJavaParser.g
                                      getRhsSym(4) as identifier,
                                      //#line 840 GJavaParser.g
                                      AstToken(getRhsIToken(5)),
                                      //#line 840 GJavaParser.g
                                      getRhsSym(6) as Ast?,
                                      //#line 840 GJavaParser.g
                                      AstToken(getRhsIToken(7)))
                //#line 840 GJavaParser.g
                );
            break;
            }
            //
            // Rule 372:  MethodInvocation ::= super . TypeArgumentsopt identifier ( ArgumentListopt )
            //
            case 372: {
               //#line 841 "GJavaParser.g"
                setResult(
                    //#line 841 GJavaParser.g
                    MethodInvocation2(getLeftIToken(), getRightIToken(),
                                      //#line 841 GJavaParser.g
                                      AstToken(getRhsIToken(1)),
                                      //#line 841 GJavaParser.g
                                      AstToken(getRhsIToken(2)),
                                      //#line 841 GJavaParser.g
                                      getRhsSym(3) as TypeArguments?,
                                      //#line 841 GJavaParser.g
                                      getRhsSym(4) as identifier,
                                      //#line 841 GJavaParser.g
                                      AstToken(getRhsIToken(5)),
                                      //#line 841 GJavaParser.g
                                      getRhsSym(6) as Ast?,
                                      //#line 841 GJavaParser.g
                                      AstToken(getRhsIToken(7)))
                //#line 841 GJavaParser.g
                );
            break;
            }
            //
            // Rule 373:  MethodInvocation ::= ClassName . super . TypeArgumentsopt identifier ( ArgumentListopt )
            //
            case 373: {
               //#line 842 "GJavaParser.g"
                setResult(
                    //#line 842 GJavaParser.g
                    MethodInvocation3(getLeftIToken(), getRightIToken(),
                                      //#line 842 GJavaParser.g
                                      getRhsSym(1) as Ast,
                                      //#line 842 GJavaParser.g
                                      AstToken(getRhsIToken(2)),
                                      //#line 842 GJavaParser.g
                                      AstToken(getRhsIToken(3)),
                                      //#line 842 GJavaParser.g
                                      AstToken(getRhsIToken(4)),
                                      //#line 842 GJavaParser.g
                                      getRhsSym(5) as TypeArguments?,
                                      //#line 842 GJavaParser.g
                                      getRhsSym(6) as identifier,
                                      //#line 842 GJavaParser.g
                                      AstToken(getRhsIToken(7)),
                                      //#line 842 GJavaParser.g
                                      getRhsSym(8) as Ast?,
                                      //#line 842 GJavaParser.g
                                      AstToken(getRhsIToken(9)))
                //#line 842 GJavaParser.g
                );
            break;
            }
            //
            // Rule 374:  MethodInvocation ::= TypeName . TypeArguments identifier ( ArgumentListopt )
            //
            case 374: {
               //#line 843 "GJavaParser.g"
                setResult(
                    //#line 843 GJavaParser.g
                    MethodInvocation4(getLeftIToken(), getRightIToken(),
                                      //#line 843 GJavaParser.g
                                      getRhsSym(1) as Ast,
                                      //#line 843 GJavaParser.g
                                      AstToken(getRhsIToken(2)),
                                      //#line 843 GJavaParser.g
                                      getRhsSym(3) as TypeArguments,
                                      //#line 843 GJavaParser.g
                                      getRhsSym(4) as identifier,
                                      //#line 843 GJavaParser.g
                                      AstToken(getRhsIToken(5)),
                                      //#line 843 GJavaParser.g
                                      getRhsSym(6) as Ast?,
                                      //#line 843 GJavaParser.g
                                      AstToken(getRhsIToken(7)))
                //#line 843 GJavaParser.g
                );
            break;
            }
            //
            // Rule 375:  ArrayAccess ::= ExpressionName [ Expression ]
            //
            case 375: {
               //#line 851 "GJavaParser.g"
                setResult(
                    //#line 851 GJavaParser.g
                    ArrayAccess0(getLeftIToken(), getRightIToken(),
                                 //#line 851 GJavaParser.g
                                 getRhsSym(1) as Ast,
                                 //#line 851 GJavaParser.g
                                 AstToken(getRhsIToken(2)),
                                 //#line 851 GJavaParser.g
                                 getRhsSym(3) as Ast,
                                 //#line 851 GJavaParser.g
                                 AstToken(getRhsIToken(4)))
                //#line 851 GJavaParser.g
                );
            break;
            }
            //
            // Rule 376:  ArrayAccess ::= PrimaryNoNewArray [ Expression ]
            //
            case 376: {
               //#line 852 "GJavaParser.g"
                setResult(
                    //#line 852 GJavaParser.g
                    ArrayAccess1(getLeftIToken(), getRightIToken(),
                                 //#line 852 GJavaParser.g
                                 getRhsSym(1) as Ast,
                                 //#line 852 GJavaParser.g
                                 AstToken(getRhsIToken(2)),
                                 //#line 852 GJavaParser.g
                                 getRhsSym(3) as Ast,
                                 //#line 852 GJavaParser.g
                                 AstToken(getRhsIToken(4)))
                //#line 852 GJavaParser.g
                );
            break;
            }
            //
            // Rule 377:  PostfixExpression ::= Primary
            //
            case 377:
                break;
            //
            // Rule 378:  PostfixExpression ::= ExpressionName
            //
            case 378:
                break;
            //
            // Rule 379:  PostfixExpression ::= PostIncrementExpression
            //
            case 379:
                break;
            //
            // Rule 380:  PostfixExpression ::= PostDecrementExpression
            //
            case 380:
                break;
            //
            // Rule 381:  PostIncrementExpression ::= PostfixExpression ++
            //
            case 381: {
               //#line 859 "GJavaParser.g"
                setResult(
                    //#line 859 GJavaParser.g
                    PostIncrementExpression(getLeftIToken(), getRightIToken(),
                                            //#line 859 GJavaParser.g
                                            getRhsSym(1) as Ast,
                                            //#line 859 GJavaParser.g
                                            AstToken(getRhsIToken(2)))
                //#line 859 GJavaParser.g
                );
            break;
            }
            //
            // Rule 382:  PostDecrementExpression ::= PostfixExpression --
            //
            case 382: {
               //#line 861 "GJavaParser.g"
                setResult(
                    //#line 861 GJavaParser.g
                    PostDecrementExpression(getLeftIToken(), getRightIToken(),
                                            //#line 861 GJavaParser.g
                                            getRhsSym(1) as Ast,
                                            //#line 861 GJavaParser.g
                                            AstToken(getRhsIToken(2)))
                //#line 861 GJavaParser.g
                );
            break;
            }
            //
            // Rule 383:  UnaryExpression ::= PreIncrementExpression
            //
            case 383:
                break;
            //
            // Rule 384:  UnaryExpression ::= PreDecrementExpression
            //
            case 384:
                break;
            //
            // Rule 385:  UnaryExpression ::= + UnaryExpression
            //
            case 385: {
               //#line 865 "GJavaParser.g"
                setResult(
                    //#line 865 GJavaParser.g
                    UnaryExpression0(getLeftIToken(), getRightIToken(),
                                     //#line 865 GJavaParser.g
                                     AstToken(getRhsIToken(1)),
                                     //#line 865 GJavaParser.g
                                     getRhsSym(2) as Ast)
                //#line 865 GJavaParser.g
                );
            break;
            }
            //
            // Rule 386:  UnaryExpression ::= - UnaryExpression
            //
            case 386: {
               //#line 866 "GJavaParser.g"
                setResult(
                    //#line 866 GJavaParser.g
                    UnaryExpression1(getLeftIToken(), getRightIToken(),
                                     //#line 866 GJavaParser.g
                                     AstToken(getRhsIToken(1)),
                                     //#line 866 GJavaParser.g
                                     getRhsSym(2) as Ast)
                //#line 866 GJavaParser.g
                );
            break;
            }
            //
            // Rule 387:  UnaryExpression ::= UnaryExpressionNotPlusMinus
            //
            case 387:
                break;
            //
            // Rule 388:  PreIncrementExpression ::= ++ UnaryExpression
            //
            case 388: {
               //#line 869 "GJavaParser.g"
                setResult(
                    //#line 869 GJavaParser.g
                    PreIncrementExpression(getLeftIToken(), getRightIToken(),
                                           //#line 869 GJavaParser.g
                                           AstToken(getRhsIToken(1)),
                                           //#line 869 GJavaParser.g
                                           getRhsSym(2) as Ast)
                //#line 869 GJavaParser.g
                );
            break;
            }
            //
            // Rule 389:  PreDecrementExpression ::= -- UnaryExpression
            //
            case 389: {
               //#line 871 "GJavaParser.g"
                setResult(
                    //#line 871 GJavaParser.g
                    PreDecrementExpression(getLeftIToken(), getRightIToken(),
                                           //#line 871 GJavaParser.g
                                           AstToken(getRhsIToken(1)),
                                           //#line 871 GJavaParser.g
                                           getRhsSym(2) as Ast)
                //#line 871 GJavaParser.g
                );
            break;
            }
            //
            // Rule 390:  UnaryExpressionNotPlusMinus ::= PostfixExpression
            //
            case 390:
                break;
            //
            // Rule 391:  UnaryExpressionNotPlusMinus ::= ~ UnaryExpression
            //
            case 391: {
               //#line 874 "GJavaParser.g"
                setResult(
                    //#line 874 GJavaParser.g
                    UnaryExpressionNotPlusMinus0(getLeftIToken(), getRightIToken(),
                                                 //#line 874 GJavaParser.g
                                                 AstToken(getRhsIToken(1)),
                                                 //#line 874 GJavaParser.g
                                                 getRhsSym(2) as Ast)
                //#line 874 GJavaParser.g
                );
            break;
            }
            //
            // Rule 392:  UnaryExpressionNotPlusMinus ::= ! UnaryExpression
            //
            case 392: {
               //#line 875 "GJavaParser.g"
                setResult(
                    //#line 875 GJavaParser.g
                    UnaryExpressionNotPlusMinus1(getLeftIToken(), getRightIToken(),
                                                 //#line 875 GJavaParser.g
                                                 AstToken(getRhsIToken(1)),
                                                 //#line 875 GJavaParser.g
                                                 getRhsSym(2) as Ast)
                //#line 875 GJavaParser.g
                );
            break;
            }
            //
            // Rule 393:  UnaryExpressionNotPlusMinus ::= CastExpression
            //
            case 393:
                break;
            //
            // Rule 394:  CastExpression ::= ( PrimitiveType Dimsopt ) UnaryExpression
            //
            case 394: {
               //#line 878 "GJavaParser.g"
                setResult(
                    //#line 878 GJavaParser.g
                    CastExpression0(getLeftIToken(), getRightIToken(),
                                    //#line 878 GJavaParser.g
                                    AstToken(getRhsIToken(1)),
                                    //#line 878 GJavaParser.g
                                    getRhsSym(2) as Ast,
                                    //#line 878 GJavaParser.g
                                    getRhsSym(3) as Ast?,
                                    //#line 878 GJavaParser.g
                                    AstToken(getRhsIToken(4)),
                                    //#line 878 GJavaParser.g
                                    getRhsSym(5) as Ast)
                //#line 878 GJavaParser.g
                );
            break;
            }
            //
            // Rule 395:  CastExpression ::= ( ReferenceType ) UnaryExpressionNotPlusMinus
            //
            case 395: {
               //#line 879 "GJavaParser.g"
                setResult(
                    //#line 879 GJavaParser.g
                    CastExpression1(getLeftIToken(), getRightIToken(),
                                    //#line 879 GJavaParser.g
                                    AstToken(getRhsIToken(1)),
                                    //#line 879 GJavaParser.g
                                    getRhsSym(2) as Ast,
                                    //#line 879 GJavaParser.g
                                    AstToken(getRhsIToken(3)),
                                    //#line 879 GJavaParser.g
                                    getRhsSym(4) as Ast)
                //#line 879 GJavaParser.g
                );
            break;
            }
            //
            // Rule 396:  MultiplicativeExpression ::= UnaryExpression
            //
            case 396:
                break;
            //
            // Rule 397:  MultiplicativeExpression ::= MultiplicativeExpression * UnaryExpression
            //
            case 397: {
               //#line 882 "GJavaParser.g"
                setResult(
                    //#line 882 GJavaParser.g
                    MultiplicativeExpression0(getLeftIToken(), getRightIToken(),
                                              //#line 882 GJavaParser.g
                                              getRhsSym(1) as Ast,
                                              //#line 882 GJavaParser.g
                                              AstToken(getRhsIToken(2)),
                                              //#line 882 GJavaParser.g
                                              getRhsSym(3) as Ast)
                //#line 882 GJavaParser.g
                );
            break;
            }
            //
            // Rule 398:  MultiplicativeExpression ::= MultiplicativeExpression / UnaryExpression
            //
            case 398: {
               //#line 883 "GJavaParser.g"
                setResult(
                    //#line 883 GJavaParser.g
                    MultiplicativeExpression1(getLeftIToken(), getRightIToken(),
                                              //#line 883 GJavaParser.g
                                              getRhsSym(1) as Ast,
                                              //#line 883 GJavaParser.g
                                              AstToken(getRhsIToken(2)),
                                              //#line 883 GJavaParser.g
                                              getRhsSym(3) as Ast)
                //#line 883 GJavaParser.g
                );
            break;
            }
            //
            // Rule 399:  MultiplicativeExpression ::= MultiplicativeExpression % UnaryExpression
            //
            case 399: {
               //#line 884 "GJavaParser.g"
                setResult(
                    //#line 884 GJavaParser.g
                    MultiplicativeExpression2(getLeftIToken(), getRightIToken(),
                                              //#line 884 GJavaParser.g
                                              getRhsSym(1) as Ast,
                                              //#line 884 GJavaParser.g
                                              AstToken(getRhsIToken(2)),
                                              //#line 884 GJavaParser.g
                                              getRhsSym(3) as Ast)
                //#line 884 GJavaParser.g
                );
            break;
            }
            //
            // Rule 400:  AdditiveExpression ::= MultiplicativeExpression
            //
            case 400:
                break;
            //
            // Rule 401:  AdditiveExpression ::= AdditiveExpression + MultiplicativeExpression
            //
            case 401: {
               //#line 887 "GJavaParser.g"
                setResult(
                    //#line 887 GJavaParser.g
                    AdditiveExpression0(getLeftIToken(), getRightIToken(),
                                        //#line 887 GJavaParser.g
                                        getRhsSym(1) as Ast,
                                        //#line 887 GJavaParser.g
                                        AstToken(getRhsIToken(2)),
                                        //#line 887 GJavaParser.g
                                        getRhsSym(3) as Ast)
                //#line 887 GJavaParser.g
                );
            break;
            }
            //
            // Rule 402:  AdditiveExpression ::= AdditiveExpression - MultiplicativeExpression
            //
            case 402: {
               //#line 888 "GJavaParser.g"
                setResult(
                    //#line 888 GJavaParser.g
                    AdditiveExpression1(getLeftIToken(), getRightIToken(),
                                        //#line 888 GJavaParser.g
                                        getRhsSym(1) as Ast,
                                        //#line 888 GJavaParser.g
                                        AstToken(getRhsIToken(2)),
                                        //#line 888 GJavaParser.g
                                        getRhsSym(3) as Ast)
                //#line 888 GJavaParser.g
                );
            break;
            }
            //
            // Rule 403:  ShiftExpression ::= AdditiveExpression
            //
            case 403:
                break;
            //
            // Rule 404:  ShiftExpression ::= ShiftExpression << AdditiveExpression
            //
            case 404: {
               //#line 891 "GJavaParser.g"
                setResult(
                    //#line 891 GJavaParser.g
                    ShiftExpression0(getLeftIToken(), getRightIToken(),
                                     //#line 891 GJavaParser.g
                                     getRhsSym(1) as Ast,
                                     //#line 891 GJavaParser.g
                                     AstToken(getRhsIToken(2)),
                                     //#line 891 GJavaParser.g
                                     getRhsSym(3) as Ast)
                //#line 891 GJavaParser.g
                );
            break;
            }
            //
            // Rule 405:  ShiftExpression ::= ShiftExpression > > AdditiveExpression
            //
            case 405: {
               //#line 892 "GJavaParser.g"
                setResult(
                    //#line 892 GJavaParser.g
                    ShiftExpression1(getLeftIToken(), getRightIToken(),
                                     //#line 892 GJavaParser.g
                                     getRhsSym(1) as Ast,
                                     //#line 892 GJavaParser.g
                                     AstToken(getRhsIToken(2)),
                                     //#line 892 GJavaParser.g
                                     AstToken(getRhsIToken(3)),
                                     //#line 892 GJavaParser.g
                                     getRhsSym(4) as Ast)
                //#line 892 GJavaParser.g
                );
            break;
            }
            //
            // Rule 406:  ShiftExpression ::= ShiftExpression > > > AdditiveExpression
            //
            case 406: {
               //#line 893 "GJavaParser.g"
                setResult(
                    //#line 893 GJavaParser.g
                    ShiftExpression2(getLeftIToken(), getRightIToken(),
                                     //#line 893 GJavaParser.g
                                     getRhsSym(1) as Ast,
                                     //#line 893 GJavaParser.g
                                     AstToken(getRhsIToken(2)),
                                     //#line 893 GJavaParser.g
                                     AstToken(getRhsIToken(3)),
                                     //#line 893 GJavaParser.g
                                     AstToken(getRhsIToken(4)),
                                     //#line 893 GJavaParser.g
                                     getRhsSym(5) as Ast)
                //#line 893 GJavaParser.g
                );
            break;
            }
            //
            // Rule 407:  RelationalExpression ::= ShiftExpression
            //
            case 407:
                break;
            //
            // Rule 408:  RelationalExpression ::= RelationalExpression < ShiftExpression
            //
            case 408: {
               //#line 896 "GJavaParser.g"
                setResult(
                    //#line 896 GJavaParser.g
                    RelationalExpression0(getLeftIToken(), getRightIToken(),
                                          //#line 896 GJavaParser.g
                                          getRhsSym(1) as Ast,
                                          //#line 896 GJavaParser.g
                                          AstToken(getRhsIToken(2)),
                                          //#line 896 GJavaParser.g
                                          getRhsSym(3) as Ast)
                //#line 896 GJavaParser.g
                );
            break;
            }
            //
            // Rule 409:  RelationalExpression ::= RelationalExpression > ShiftExpression
            //
            case 409: {
               //#line 897 "GJavaParser.g"
                setResult(
                    //#line 897 GJavaParser.g
                    RelationalExpression1(getLeftIToken(), getRightIToken(),
                                          //#line 897 GJavaParser.g
                                          getRhsSym(1) as Ast,
                                          //#line 897 GJavaParser.g
                                          AstToken(getRhsIToken(2)),
                                          //#line 897 GJavaParser.g
                                          getRhsSym(3) as Ast)
                //#line 897 GJavaParser.g
                );
            break;
            }
            //
            // Rule 410:  RelationalExpression ::= RelationalExpression <= ShiftExpression
            //
            case 410: {
               //#line 898 "GJavaParser.g"
                setResult(
                    //#line 898 GJavaParser.g
                    RelationalExpression2(getLeftIToken(), getRightIToken(),
                                          //#line 898 GJavaParser.g
                                          getRhsSym(1) as Ast,
                                          //#line 898 GJavaParser.g
                                          AstToken(getRhsIToken(2)),
                                          //#line 898 GJavaParser.g
                                          getRhsSym(3) as Ast)
                //#line 898 GJavaParser.g
                );
            break;
            }
            //
            // Rule 411:  RelationalExpression ::= RelationalExpression > = ShiftExpression
            //
            case 411: {
               //#line 899 "GJavaParser.g"
                setResult(
                    //#line 899 GJavaParser.g
                    RelationalExpression3(getLeftIToken(), getRightIToken(),
                                          //#line 899 GJavaParser.g
                                          getRhsSym(1) as Ast,
                                          //#line 899 GJavaParser.g
                                          AstToken(getRhsIToken(2)),
                                          //#line 899 GJavaParser.g
                                          AstToken(getRhsIToken(3)),
                                          //#line 899 GJavaParser.g
                                          getRhsSym(4) as Ast)
                //#line 899 GJavaParser.g
                );
            break;
            }
            //
            // Rule 412:  RelationalExpression ::= RelationalExpression instanceof ReferenceType
            //
            case 412: {
               //#line 900 "GJavaParser.g"
                setResult(
                    //#line 900 GJavaParser.g
                    RelationalExpression4(getLeftIToken(), getRightIToken(),
                                          //#line 900 GJavaParser.g
                                          getRhsSym(1) as Ast,
                                          //#line 900 GJavaParser.g
                                          AstToken(getRhsIToken(2)),
                                          //#line 900 GJavaParser.g
                                          getRhsSym(3) as Ast)
                //#line 900 GJavaParser.g
                );
            break;
            }
            //
            // Rule 413:  EqualityExpression ::= RelationalExpression
            //
            case 413:
                break;
            //
            // Rule 414:  EqualityExpression ::= EqualityExpression == RelationalExpression
            //
            case 414: {
               //#line 903 "GJavaParser.g"
                setResult(
                    //#line 903 GJavaParser.g
                    EqualityExpression0(getLeftIToken(), getRightIToken(),
                                        //#line 903 GJavaParser.g
                                        getRhsSym(1) as Ast,
                                        //#line 903 GJavaParser.g
                                        AstToken(getRhsIToken(2)),
                                        //#line 903 GJavaParser.g
                                        getRhsSym(3) as Ast)
                //#line 903 GJavaParser.g
                );
            break;
            }
            //
            // Rule 415:  EqualityExpression ::= EqualityExpression != RelationalExpression
            //
            case 415: {
               //#line 904 "GJavaParser.g"
                setResult(
                    //#line 904 GJavaParser.g
                    EqualityExpression1(getLeftIToken(), getRightIToken(),
                                        //#line 904 GJavaParser.g
                                        getRhsSym(1) as Ast,
                                        //#line 904 GJavaParser.g
                                        AstToken(getRhsIToken(2)),
                                        //#line 904 GJavaParser.g
                                        getRhsSym(3) as Ast)
                //#line 904 GJavaParser.g
                );
            break;
            }
            //
            // Rule 416:  AndExpression ::= EqualityExpression
            //
            case 416:
                break;
            //
            // Rule 417:  AndExpression ::= AndExpression & EqualityExpression
            //
            case 417: {
               //#line 907 "GJavaParser.g"
                setResult(
                    //#line 907 GJavaParser.g
                    AndExpression(getLeftIToken(), getRightIToken(),
                                  //#line 907 GJavaParser.g
                                  getRhsSym(1) as Ast,
                                  //#line 907 GJavaParser.g
                                  AstToken(getRhsIToken(2)),
                                  //#line 907 GJavaParser.g
                                  getRhsSym(3) as Ast)
                //#line 907 GJavaParser.g
                );
            break;
            }
            //
            // Rule 418:  ExclusiveOrExpression ::= AndExpression
            //
            case 418:
                break;
            //
            // Rule 419:  ExclusiveOrExpression ::= ExclusiveOrExpression ^ AndExpression
            //
            case 419: {
               //#line 910 "GJavaParser.g"
                setResult(
                    //#line 910 GJavaParser.g
                    ExclusiveOrExpression(getLeftIToken(), getRightIToken(),
                                          //#line 910 GJavaParser.g
                                          getRhsSym(1) as Ast,
                                          //#line 910 GJavaParser.g
                                          AstToken(getRhsIToken(2)),
                                          //#line 910 GJavaParser.g
                                          getRhsSym(3) as Ast)
                //#line 910 GJavaParser.g
                );
            break;
            }
            //
            // Rule 420:  InclusiveOrExpression ::= ExclusiveOrExpression
            //
            case 420:
                break;
            //
            // Rule 421:  InclusiveOrExpression ::= InclusiveOrExpression | ExclusiveOrExpression
            //
            case 421: {
               //#line 913 "GJavaParser.g"
                setResult(
                    //#line 913 GJavaParser.g
                    InclusiveOrExpression(getLeftIToken(), getRightIToken(),
                                          //#line 913 GJavaParser.g
                                          getRhsSym(1) as Ast,
                                          //#line 913 GJavaParser.g
                                          AstToken(getRhsIToken(2)),
                                          //#line 913 GJavaParser.g
                                          getRhsSym(3) as Ast)
                //#line 913 GJavaParser.g
                );
            break;
            }
            //
            // Rule 422:  ConditionalAndExpression ::= InclusiveOrExpression
            //
            case 422:
                break;
            //
            // Rule 423:  ConditionalAndExpression ::= ConditionalAndExpression && InclusiveOrExpression
            //
            case 423: {
               //#line 916 "GJavaParser.g"
                setResult(
                    //#line 916 GJavaParser.g
                    ConditionalAndExpression(getLeftIToken(), getRightIToken(),
                                             //#line 916 GJavaParser.g
                                             getRhsSym(1) as Ast,
                                             //#line 916 GJavaParser.g
                                             AstToken(getRhsIToken(2)),
                                             //#line 916 GJavaParser.g
                                             getRhsSym(3) as Ast)
                //#line 916 GJavaParser.g
                );
            break;
            }
            //
            // Rule 424:  ConditionalOrExpression ::= ConditionalAndExpression
            //
            case 424:
                break;
            //
            // Rule 425:  ConditionalOrExpression ::= ConditionalOrExpression || ConditionalAndExpression
            //
            case 425: {
               //#line 919 "GJavaParser.g"
                setResult(
                    //#line 919 GJavaParser.g
                    ConditionalOrExpression(getLeftIToken(), getRightIToken(),
                                            //#line 919 GJavaParser.g
                                            getRhsSym(1) as Ast,
                                            //#line 919 GJavaParser.g
                                            AstToken(getRhsIToken(2)),
                                            //#line 919 GJavaParser.g
                                            getRhsSym(3) as Ast)
                //#line 919 GJavaParser.g
                );
            break;
            }
            //
            // Rule 426:  ConditionalExpression ::= ConditionalOrExpression
            //
            case 426:
                break;
            //
            // Rule 427:  ConditionalExpression ::= ConditionalOrExpression ? Expression : ConditionalExpression
            //
            case 427: {
               //#line 922 "GJavaParser.g"
                setResult(
                    //#line 922 GJavaParser.g
                    ConditionalExpression(getLeftIToken(), getRightIToken(),
                                          //#line 922 GJavaParser.g
                                          getRhsSym(1) as Ast,
                                          //#line 922 GJavaParser.g
                                          AstToken(getRhsIToken(2)),
                                          //#line 922 GJavaParser.g
                                          getRhsSym(3) as Ast,
                                          //#line 922 GJavaParser.g
                                          AstToken(getRhsIToken(4)),
                                          //#line 922 GJavaParser.g
                                          getRhsSym(5) as Ast)
                //#line 922 GJavaParser.g
                );
            break;
            }
            //
            // Rule 428:  AssignmentExpression ::= ConditionalExpression
            //
            case 428:
                break;
            //
            // Rule 429:  AssignmentExpression ::= Assignment
            //
            case 429:
                break;
            //
            // Rule 430:  Assignment ::= LeftHandSide AssignmentOperator AssignmentExpression
            //
            case 430: {
               //#line 927 "GJavaParser.g"
                setResult(
                    //#line 927 GJavaParser.g
                    Assignment(getLeftIToken(), getRightIToken(),
                               //#line 927 GJavaParser.g
                               getRhsSym(1) as Ast,
                               //#line 927 GJavaParser.g
                               getRhsSym(2) as Ast,
                               //#line 927 GJavaParser.g
                               getRhsSym(3) as Ast)
                //#line 927 GJavaParser.g
                );
            break;
            }
            //
            // Rule 431:  LeftHandSide ::= ExpressionName
            //
            case 431:
                break;
            //
            // Rule 432:  LeftHandSide ::= FieldAccess
            //
            case 432:
                break;
            //
            // Rule 433:  LeftHandSide ::= ArrayAccess
            //
            case 433:
                break;
            //
            // Rule 434:  AssignmentOperator ::= =
            //
            case 434: {
               //#line 933 "GJavaParser.g"
                setResult(
                    //#line 933 GJavaParser.g
                    AssignmentOperator0(getRhsIToken(1))
                //#line 933 GJavaParser.g
                );
            break;
            }
            //
            // Rule 435:  AssignmentOperator ::= *=
            //
            case 435: {
               //#line 934 "GJavaParser.g"
                setResult(
                    //#line 934 GJavaParser.g
                    AssignmentOperator1(getRhsIToken(1))
                //#line 934 GJavaParser.g
                );
            break;
            }
            //
            // Rule 436:  AssignmentOperator ::= /=
            //
            case 436: {
               //#line 935 "GJavaParser.g"
                setResult(
                    //#line 935 GJavaParser.g
                    AssignmentOperator2(getRhsIToken(1))
                //#line 935 GJavaParser.g
                );
            break;
            }
            //
            // Rule 437:  AssignmentOperator ::= %=
            //
            case 437: {
               //#line 936 "GJavaParser.g"
                setResult(
                    //#line 936 GJavaParser.g
                    AssignmentOperator3(getRhsIToken(1))
                //#line 936 GJavaParser.g
                );
            break;
            }
            //
            // Rule 438:  AssignmentOperator ::= +=
            //
            case 438: {
               //#line 937 "GJavaParser.g"
                setResult(
                    //#line 937 GJavaParser.g
                    AssignmentOperator4(getRhsIToken(1))
                //#line 937 GJavaParser.g
                );
            break;
            }
            //
            // Rule 439:  AssignmentOperator ::= -=
            //
            case 439: {
               //#line 938 "GJavaParser.g"
                setResult(
                    //#line 938 GJavaParser.g
                    AssignmentOperator5(getRhsIToken(1))
                //#line 938 GJavaParser.g
                );
            break;
            }
            //
            // Rule 440:  AssignmentOperator ::= <<=
            //
            case 440: {
               //#line 939 "GJavaParser.g"
                setResult(
                    //#line 939 GJavaParser.g
                    AssignmentOperator6(getRhsIToken(1))
                //#line 939 GJavaParser.g
                );
            break;
            }
            //
            // Rule 441:  AssignmentOperator ::= > > =
            //
            case 441: {
               //#line 940 "GJavaParser.g"
                setResult(
                    //#line 940 GJavaParser.g
                    AssignmentOperator7(getLeftIToken(), getRightIToken(),
                                        //#line 940 GJavaParser.g
                                        AstToken(getRhsIToken(1)),
                                        //#line 940 GJavaParser.g
                                        AstToken(getRhsIToken(2)),
                                        //#line 940 GJavaParser.g
                                        AstToken(getRhsIToken(3)))
                //#line 940 GJavaParser.g
                );
            break;
            }
            //
            // Rule 442:  AssignmentOperator ::= > > > =
            //
            case 442: {
               //#line 941 "GJavaParser.g"
                setResult(
                    //#line 941 GJavaParser.g
                    AssignmentOperator8(getLeftIToken(), getRightIToken(),
                                        //#line 941 GJavaParser.g
                                        AstToken(getRhsIToken(1)),
                                        //#line 941 GJavaParser.g
                                        AstToken(getRhsIToken(2)),
                                        //#line 941 GJavaParser.g
                                        AstToken(getRhsIToken(3)),
                                        //#line 941 GJavaParser.g
                                        AstToken(getRhsIToken(4)))
                //#line 941 GJavaParser.g
                );
            break;
            }
            //
            // Rule 443:  AssignmentOperator ::= &=
            //
            case 443: {
               //#line 942 "GJavaParser.g"
                setResult(
                    //#line 942 GJavaParser.g
                    AssignmentOperator9(getRhsIToken(1))
                //#line 942 GJavaParser.g
                );
            break;
            }
            //
            // Rule 444:  AssignmentOperator ::= ^=
            //
            case 444: {
               //#line 943 "GJavaParser.g"
                setResult(
                    //#line 943 GJavaParser.g
                    AssignmentOperator10(getRhsIToken(1))
                //#line 943 GJavaParser.g
                );
            break;
            }
            //
            // Rule 445:  AssignmentOperator ::= |=
            //
            case 445: {
               //#line 944 "GJavaParser.g"
                setResult(
                    //#line 944 GJavaParser.g
                    AssignmentOperator11(getRhsIToken(1))
                //#line 944 GJavaParser.g
                );
            break;
            }
            //
            // Rule 446:  Expression ::= AssignmentExpression
            //
            case 446:
                break;
            //
            // Rule 447:  ConstantExpression ::= Expression
            //
            case 447:
                break;
            //
            // Rule 448:  Dimsopt ::= %Empty
            //
            case 448: {
               //#line 953 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 449:  Dimsopt ::= Dims
            //
            case 449:
                break;
            //
            // Rule 450:  Catchesopt ::= %Empty
            //
            case 450: {
               //#line 956 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 451:  Catchesopt ::= Catches
            //
            case 451:
                break;
            //
            // Rule 452:  identifieropt ::= %Empty
            //
            case 452: {
               //#line 959 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 453:  identifieropt ::= identifier
            //
            case 453:
                break;
            //
            // Rule 454:  ForUpdateopt ::= %Empty
            //
            case 454: {
               //#line 962 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 455:  ForUpdateopt ::= ForUpdate
            //
            case 455:
                break;
            //
            // Rule 456:  Expressionopt ::= %Empty
            //
            case 456: {
               //#line 965 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 457:  Expressionopt ::= Expression
            //
            case 457:
                break;
            //
            // Rule 458:  ForInitopt ::= %Empty
            //
            case 458: {
               //#line 968 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 459:  ForInitopt ::= ForInit
            //
            case 459:
                break;
            //
            // Rule 460:  SwitchLabelsopt ::= %Empty
            //
            case 460: {
               //#line 971 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 461:  SwitchLabelsopt ::= SwitchLabels
            //
            case 461:
                break;
            //
            // Rule 462:  SwitchBlockStatementGroupsopt ::= %Empty
            //
            case 462: {
               //#line 974 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 463:  SwitchBlockStatementGroupsopt ::= SwitchBlockStatementGroups
            //
            case 463:
                break;
            //
            // Rule 464:  VariableModifiersopt ::= %Empty
            //
            case 464: {
               //#line 977 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 465:  VariableModifiersopt ::= VariableModifiers
            //
            case 465:
                break;
            //
            // Rule 466:  VariableInitializersopt ::= %Empty
            //
            case 466: {
               //#line 980 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 467:  VariableInitializersopt ::= VariableInitializers
            //
            case 467:
                break;
            //
            // Rule 468:  ElementValuesopt ::= %Empty
            //
            case 468: {
               //#line 983 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 469:  ElementValuesopt ::= ElementValues
            //
            case 469:
                break;
            //
            // Rule 470:  ElementValuePairsopt ::= %Empty
            //
            case 470: {
               //#line 986 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 471:  ElementValuePairsopt ::= ElementValuePairs
            //
            case 471:
                break;
            //
            // Rule 472:  DefaultValueopt ::= %Empty
            //
            case 472: {
               //#line 989 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 473:  DefaultValueopt ::= DefaultValue
            //
            case 473:
                break;
            //
            // Rule 474:  AnnotationTypeElementDeclarationsopt ::= %Empty
            //
            case 474: {
               //#line 992 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 475:  AnnotationTypeElementDeclarationsopt ::= AnnotationTypeElementDeclarations
            //
            case 475:
                break;
            //
            // Rule 476:  AbstractMethodModifiersopt ::= %Empty
            //
            case 476: {
               //#line 995 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 477:  AbstractMethodModifiersopt ::= AbstractMethodModifiers
            //
            case 477:
                break;
            //
            // Rule 478:  ConstantModifiersopt ::= %Empty
            //
            case 478: {
               //#line 998 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 479:  ConstantModifiersopt ::= ConstantModifiers
            //
            case 479:
                break;
            //
            // Rule 480:  InterfaceMemberDeclarationsopt ::= %Empty
            //
            case 480: {
               //#line 1001 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 481:  InterfaceMemberDeclarationsopt ::= InterfaceMemberDeclarations
            //
            case 481:
                break;
            //
            // Rule 482:  ExtendsInterfacesopt ::= %Empty
            //
            case 482: {
               //#line 1004 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 483:  ExtendsInterfacesopt ::= ExtendsInterfaces
            //
            case 483:
                break;
            //
            // Rule 484:  InterfaceModifiersopt ::= %Empty
            //
            case 484: {
               //#line 1007 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 485:  InterfaceModifiersopt ::= InterfaceModifiers
            //
            case 485:
                break;
            //
            // Rule 486:  ClassBodyopt ::= %Empty
            //
            case 486: {
               //#line 1010 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 487:  ClassBodyopt ::= ClassBody
            //
            case 487:
                break;
            //
            // Rule 488:  Argumentsopt ::= %Empty
            //
            case 488: {
               //#line 1013 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 489:  Argumentsopt ::= Arguments
            //
            case 489:
                break;
            //
            // Rule 490:  EnumBodyDeclarationsopt ::= %Empty
            //
            case 490: {
               //#line 1016 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 491:  EnumBodyDeclarationsopt ::= EnumBodyDeclarations
            //
            case 491:
                break;
            //
            // Rule 492:  ,opt ::= %Empty
            //
            case 492: {
               //#line 1019 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 493:  ,opt ::= ,
            //
            case 493: {
               //#line 1020 "GJavaParser.g"
                setResult(
                    //#line 1020 GJavaParser.g
                    Commaopt(getRhsIToken(1))
                //#line 1020 GJavaParser.g
                );
            break;
            }
            //
            // Rule 494:  EnumConstantsopt ::= %Empty
            //
            case 494: {
               //#line 1022 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 495:  EnumConstantsopt ::= EnumConstants
            //
            case 495:
                break;
            //
            // Rule 496:  ArgumentListopt ::= %Empty
            //
            case 496: {
               //#line 1025 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 497:  ArgumentListopt ::= ArgumentList
            //
            case 497:
                break;
            //
            // Rule 498:  BlockStatementsopt ::= %Empty
            //
            case 498: {
               //#line 1028 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 499:  BlockStatementsopt ::= BlockStatements
            //
            case 499:
                break;
            //
            // Rule 500:  ExplicitConstructorInvocationopt ::= %Empty
            //
            case 500: {
               //#line 1031 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 501:  ExplicitConstructorInvocationopt ::= ExplicitConstructorInvocation
            //
            case 501:
                break;
            //
            // Rule 502:  ConstructorModifiersopt ::= %Empty
            //
            case 502: {
               //#line 1034 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 503:  ConstructorModifiersopt ::= ConstructorModifiers
            //
            case 503:
                break;
            //
            // Rule 504:  ...opt ::= %Empty
            //
            case 504: {
               //#line 1037 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 505:  ...opt ::= ...
            //
            case 505: {
               //#line 1038 "GJavaParser.g"
                setResult(
                    //#line 1038 GJavaParser.g
                    Ellipsisopt(getRhsIToken(1))
                //#line 1038 GJavaParser.g
                );
            break;
            }
            //
            // Rule 506:  FormalParameterListopt ::= %Empty
            //
            case 506: {
               //#line 1040 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 507:  FormalParameterListopt ::= FormalParameterList
            //
            case 507:
                break;
            //
            // Rule 508:  Throwsopt ::= %Empty
            //
            case 508: {
               //#line 1043 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 509:  Throwsopt ::= Throws
            //
            case 509:
                break;
            //
            // Rule 510:  MethodModifiersopt ::= %Empty
            //
            case 510: {
               //#line 1046 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 511:  MethodModifiersopt ::= MethodModifiers
            //
            case 511:
                break;
            //
            // Rule 512:  FieldModifiersopt ::= %Empty
            //
            case 512: {
               //#line 1049 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 513:  FieldModifiersopt ::= FieldModifiers
            //
            case 513:
                break;
            //
            // Rule 514:  ClassBodyDeclarationsopt ::= %Empty
            //
            case 514: {
               //#line 1052 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 515:  ClassBodyDeclarationsopt ::= ClassBodyDeclarations
            //
            case 515:
                break;
            //
            // Rule 516:  Interfacesopt ::= %Empty
            //
            case 516: {
               //#line 1055 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 517:  Interfacesopt ::= Interfaces
            //
            case 517:
                break;
            //
            // Rule 518:  Superopt ::= %Empty
            //
            case 518: {
               //#line 1058 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 519:  Superopt ::= Super
            //
            case 519:
                break;
            //
            // Rule 520:  TypeParametersopt ::= %Empty
            //
            case 520: {
               //#line 1061 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 521:  TypeParametersopt ::= TypeParameters
            //
            case 521:
                break;
            //
            // Rule 522:  ClassModifiersopt ::= %Empty
            //
            case 522: {
               //#line 1064 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 523:  ClassModifiersopt ::= ClassModifiers
            //
            case 523:
                break;
            //
            // Rule 524:  Annotationsopt ::= %Empty
            //
            case 524: {
               //#line 1067 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 525:  Annotationsopt ::= Annotations
            //
            case 525:
                break;
            //
            // Rule 526:  TypeDeclarationsopt ::= %Empty
            //
            case 526: {
               //#line 1070 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 527:  TypeDeclarationsopt ::= TypeDeclarations
            //
            case 527:
                break;
            //
            // Rule 528:  ImportDeclarationsopt ::= %Empty
            //
            case 528: {
               //#line 1073 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 529:  ImportDeclarationsopt ::= ImportDeclarations
            //
            case 529:
                break;
            //
            // Rule 530:  PackageDeclarationopt ::= %Empty
            //
            case 530: {
               //#line 1076 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 531:  PackageDeclarationopt ::= PackageDeclaration
            //
            case 531:
                break;
            //
            // Rule 532:  WildcardBoundsOpt ::= %Empty
            //
            case 532: {
               //#line 1079 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 533:  WildcardBoundsOpt ::= WildcardBounds
            //
            case 533:
                break;
            //
            // Rule 534:  AdditionalBoundListopt ::= %Empty
            //
            case 534: {
               //#line 1082 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 535:  AdditionalBoundListopt ::= AdditionalBoundList
            //
            case 535:
                break;
            //
            // Rule 536:  TypeBoundopt ::= %Empty
            //
            case 536: {
               //#line 1085 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 537:  TypeBoundopt ::= TypeBound
            //
            case 537:
                break;
            //
            // Rule 538:  TypeArgumentsopt ::= %Empty
            //
            case 538: {
               //#line 1088 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 539:  TypeArgumentsopt ::= TypeArguments
            //
            case 539:
                break;
    //#line 289 "btParserTemplateS.gi

    
            default:
                break;
        }
        return;
    }
}
abstract class IRootForJavaParser
    {
         IToken getLeftIToken() ;
        IToken  getRightIToken() ;

         void acceptWithVisitor(Visitor v);
         void acceptWithArg(ArgumentVisitor v, Object o);
        Object acceptWithResult(ResultVisitor v);
        Object acceptWithResultArgument(ResultArgumentVisitor v, Object o);
    }

    /***
     ** is always implemented by <b>AstToken</b>. It is also implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>PrimitiveType
     **<li>ClassType
     **<li>ArrayType
     **<li>TypeDeclaration
     **<li>NormalClassDeclaration
     **<li>ClassMemberDeclaration
     **<li>FieldDeclaration
     **<li>MethodDeclaration
     **<li>ResultType
     **<li>VariableModifier
     **<li>MethodBody
     **<li>EnumDeclaration
     **<li>NormalInterfaceDeclaration
     **<li>InterfaceMemberDeclaration
     **<li>ConstantDeclaration
     **<li>AbstractMethodDeclaration
     **<li>AnnotationTypeDeclaration
     **<li>Annotations
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>Block
     **<li>BlockStatements
     **<li>LocalVariableDeclarationStatement
     **<li>IfThenStatement
     **<li>IfThenElseStatement
     **<li>EmptyStatement
     **<li>LabeledStatement
     **<li>ExpressionStatement
     **<li>SwitchStatement
     **<li>WhileStatement
     **<li>DoStatement
     **<li>BasicForStatement
     **<li>EnhancedForStatement
     **<li>BreakStatement
     **<li>ContinueStatement
     **<li>ReturnStatement
     **<li>ThrowStatement
     **<li>SynchronizedStatement
     **<li>Commaopt
     **<li>Ellipsisopt
     **<li>LPGUserAction0
     **<li>LPGUserAction1
     **<li>LPGUserAction2
     **<li>LPGUserAction3
     **<li>LPGUserAction4
     **<li>IntegralType0
     **<li>IntegralType1
     **<li>IntegralType2
     **<li>IntegralType3
     **<li>IntegralType4
     **<li>FloatingPointType0
     **<li>FloatingPointType1
     **<li>ClassModifier0
     **<li>ClassModifier1
     **<li>ClassModifier2
     **<li>ClassModifier3
     **<li>ClassModifier4
     **<li>ClassModifier5
     **<li>ClassModifier6
     **<li>FieldModifier0
     **<li>FieldModifier1
     **<li>FieldModifier2
     **<li>FieldModifier3
     **<li>FieldModifier4
     **<li>FieldModifier5
     **<li>FieldModifier6
     **<li>MethodModifier0
     **<li>MethodModifier1
     **<li>MethodModifier2
     **<li>MethodModifier3
     **<li>MethodModifier4
     **<li>MethodModifier5
     **<li>MethodModifier6
     **<li>MethodModifier7
     **<li>MethodModifier8
     **<li>ConstructorModifier0
     **<li>ConstructorModifier1
     **<li>ConstructorModifier2
     **<li>InterfaceModifier0
     **<li>InterfaceModifier1
     **<li>InterfaceModifier2
     **<li>InterfaceModifier3
     **<li>InterfaceModifier4
     **<li>InterfaceModifier5
     **<li>ConstantModifier0
     **<li>ConstantModifier1
     **<li>ConstantModifier2
     **<li>AbstractMethodModifier0
     **<li>AbstractMethodModifier1
     **<li>AnnotationTypeElementDeclaration0
     **<li>AnnotationTypeElementDeclaration1
     **<li>AssertStatement0
     **<li>AssertStatement1
     **<li>TryStatement0
     **<li>TryStatement1
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>AssignmentOperator0
     **<li>AssignmentOperator1
     **<li>AssignmentOperator2
     **<li>AssignmentOperator3
     **<li>AssignmentOperator4
     **<li>AssignmentOperator5
     **<li>AssignmentOperator6
     **<li>AssignmentOperator7
     **<li>AssignmentOperator8
     **<li>AssignmentOperator9
     **<li>AssignmentOperator10
     **<li>AssignmentOperator11
     **</ul>
     **</b>
     **/
abstract class IAstToken implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>CompilationUnit</b>
     **/
abstract class ICompilationUnit implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalClassDeclaration
     **<li>ClassBodyDeclarations
     **<li>ClassMemberDeclaration
     **<li>FieldDeclaration
     **<li>MethodDeclaration
     **<li>StaticInitializer
     **<li>ConstructorDeclaration
     **<li>EnumDeclaration
     **<li>NormalInterfaceDeclaration
     **<li>AnnotationTypeDeclaration
     **<li>Block
     **</ul>
     **</b>
     **/
abstract class IClassBodyDeclarationsopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>TypeArguments</b>
     **/
abstract class ITypeArgumentsopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>TypeName
     **</ul>
     **</b>
     **/
abstract class IClassName implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>TypeBound</b>
     **/
abstract class ITypeBoundopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>AdditionalBoundList
     **<li>AdditionalBound
     **</ul>
     **</b>
     **/
abstract class IAdditionalBoundListopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ClassType
     **<li>ArrayType
     **<li>ActualTypeArgumentList
     **<li>Wildcard
     **</ul>
     **</b>
     **/
abstract class IActualTypeArgumentList implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>WildcardBounds0
     **<li>WildcardBounds1
     **</ul>
     **</b>
     **/
abstract class IWildcardBoundsOpt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>PackageName
     **</ul>
     **</b>
     **/
abstract class IPackageName implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>AmbiguousName
     **</ul>
     **</b>
     **/
abstract class IAmbiguousName implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>MethodName
     **</ul>
     **</b>
     **/
abstract class IMethodName implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>PackageOrTypeName
     **</ul>
     **</b>
     **/
abstract class IPackageOrTypeName implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>PackageDeclaration</b>
     **/
abstract class IPackageDeclarationopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>ImportDeclarations
     **<li>SingleTypeImportDeclaration
     **<li>TypeImportOnDemandDeclaration
     **<li>SingleStaticImportDeclaration
     **<li>StaticImportOnDemandDeclaration
     **</ul>
     **</b>
     **/
abstract class IImportDeclarationsopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>TypeDeclarations
     **<li>TypeDeclaration
     **<li>NormalClassDeclaration
     **<li>EnumDeclaration
     **<li>NormalInterfaceDeclaration
     **<li>AnnotationTypeDeclaration
     **</ul>
     **</b>
     **/
abstract class ITypeDeclarationsopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>Annotations
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **</ul>
     **</b>
     **/
abstract class IAnnotationsopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>ClassModifiers
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>ClassModifier0
     **<li>ClassModifier1
     **<li>ClassModifier2
     **<li>ClassModifier3
     **<li>ClassModifier4
     **<li>ClassModifier5
     **<li>ClassModifier6
     **</ul>
     **</b>
     **/
abstract class IClassModifiersopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>TypeParameters</b>
     **/
abstract class ITypeParametersopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>Super</b>
     **/
abstract class ISuperopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>Interfaces</b>
     **/
abstract class IInterfacesopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>TypeParameter
     **<li>TypeParameterList
     **</ul>
     **</b>
     **/
abstract class ITypeParameterList implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>InterfaceType
     **<li>InterfaceTypeList
     **</ul>
     **</b>
     **/
abstract class IInterfaceTypeList implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>FieldModifiers
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>FieldModifier0
     **<li>FieldModifier1
     **<li>FieldModifier2
     **<li>FieldModifier3
     **<li>FieldModifier4
     **<li>FieldModifier5
     **<li>FieldModifier6
     **</ul>
     **</b>
     **/
abstract class IFieldModifiersopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>VariableDeclarators
     **<li>VariableDeclarator
     **<li>VariableDeclaratorId
     **</ul>
     **</b>
     **/
abstract class IVariableDeclarators implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>MethodHeader</b>
     **/
abstract class IMethodHeader implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>MethodModifiers
     **<li>Annotations
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>MethodModifier0
     **<li>MethodModifier1
     **<li>MethodModifier2
     **<li>MethodModifier3
     **<li>MethodModifier4
     **<li>MethodModifier5
     **<li>MethodModifier6
     **<li>MethodModifier7
     **<li>MethodModifier8
     **</ul>
     **</b>
     **/
abstract class IMethodModifiersopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>MethodDeclarator0
     **<li>MethodDeclarator1
     **</ul>
     **</b>
     **/
abstract class IMethodDeclarator implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>Throws</b>
     **/
abstract class IThrowsopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>FormalParameterList
     **<li>LastFormalParameter
     **</ul>
     **</b>
     **/
abstract class IFormalParameterListopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>FormalParameters
     **<li>FormalParameter
     **</ul>
     **</b>
     **/
abstract class IFormalParameters implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>VariableModifiers
     **<li>VariableModifier
     **<li>Annotations
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **</ul>
     **</b>
     **/
abstract class IVariableModifiersopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ClassType
     **<li>ExceptionTypeList
     **</ul>
     **</b>
     **/
abstract class IExceptionTypeList implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>ConstructorModifiers
     **<li>Annotations
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>ConstructorModifier0
     **<li>ConstructorModifier1
     **<li>ConstructorModifier2
     **</ul>
     **</b>
     **/
abstract class IConstructorModifiersopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>ConstructorDeclarator</b>
     **/
abstract class IConstructorDeclarator implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>ConstructorBody</b>
     **/
abstract class IConstructorBody implements IRootForJavaParser    {
    }

    /***
     ** is always implemented by <b>AstToken</b>. It is also implemented by <b>identifier</b>
     **/
abstract class ISimpleTypeName implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>ExplicitConstructorInvocation0
     **<li>ExplicitConstructorInvocation1
     **<li>ExplicitConstructorInvocation2
     **</ul>
     **</b>
     **/
abstract class IExplicitConstructorInvocationopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>ArgumentList
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>AndExpression
     **<li>ExclusiveOrExpression
     **<li>InclusiveOrExpression
     **<li>ConditionalAndExpression
     **<li>ConditionalOrExpression
     **<li>ConditionalExpression
     **<li>Assignment
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **<li>EqualityExpression0
     **<li>EqualityExpression1
     **</ul>
     **</b>
     **/
abstract class IArgumentListopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>EnumBody</b>
     **/
abstract class IEnumBody implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>EnumConstants
     **<li>EnumConstant
     **</ul>
     **</b>
     **/
abstract class IEnumConstantsopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>EnumBodyDeclarations</b>
     **/
abstract class IEnumBodyDeclarationsopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>Arguments</b>
     **/
abstract class IArgumentsopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>ClassBody</b>
     **/
abstract class IClassBodyopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>InterfaceModifiers
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>InterfaceModifier0
     **<li>InterfaceModifier1
     **<li>InterfaceModifier2
     **<li>InterfaceModifier3
     **<li>InterfaceModifier4
     **<li>InterfaceModifier5
     **</ul>
     **</b>
     **/
abstract class IInterfaceModifiersopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>ExtendsInterfaces0
     **<li>ExtendsInterfaces1
     **</ul>
     **</b>
     **/
abstract class IExtendsInterfacesopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>InterfaceBody</b>
     **/
abstract class IInterfaceBody implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalClassDeclaration
     **<li>EnumDeclaration
     **<li>NormalInterfaceDeclaration
     **<li>InterfaceMemberDeclarations
     **<li>InterfaceMemberDeclaration
     **<li>ConstantDeclaration
     **<li>AbstractMethodDeclaration
     **<li>AnnotationTypeDeclaration
     **</ul>
     **</b>
     **/
abstract class IInterfaceMemberDeclarationsopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>ConstantModifiers
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>ConstantModifier0
     **<li>ConstantModifier1
     **<li>ConstantModifier2
     **</ul>
     **</b>
     **/
abstract class IConstantModifiersopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>AbstractMethodModifiers
     **<li>Annotations
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>AbstractMethodModifier0
     **<li>AbstractMethodModifier1
     **</ul>
     **</b>
     **/
abstract class IAbstractMethodModifiersopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>AnnotationTypeBody</b>
     **/
abstract class IAnnotationTypeBody implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalClassDeclaration
     **<li>EnumDeclaration
     **<li>NormalInterfaceDeclaration
     **<li>ConstantDeclaration
     **<li>AnnotationTypeDeclaration
     **<li>AnnotationTypeElementDeclarations
     **<li>AnnotationTypeElementDeclaration0
     **<li>AnnotationTypeElementDeclaration1
     **</ul>
     **</b>
     **/
abstract class IAnnotationTypeElementDeclarationsopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>DefaultValue</b>
     **/
abstract class IDefaultValueopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>ElementValuePairs
     **<li>ElementValuePair
     **</ul>
     **</b>
     **/
abstract class IElementValuePairsopt implements IRootForJavaParser    {
    }

    /***
     ** is always implemented by <b>AstToken</b>. It is also implemented by <b>identifier</b>
     **/
abstract class ISimpleName implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>NormalAnnotation
     **<li>ElementValueArrayInitializer
     **<li>ElementValues
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>AndExpression
     **<li>ExclusiveOrExpression
     **<li>InclusiveOrExpression
     **<li>ConditionalAndExpression
     **<li>ConditionalOrExpression
     **<li>ConditionalExpression
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **<li>EqualityExpression0
     **<li>EqualityExpression1
     **</ul>
     **</b>
     **/
abstract class IElementValuesopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>ArrayInitializer
     **<li>VariableInitializers
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>AndExpression
     **<li>ExclusiveOrExpression
     **<li>InclusiveOrExpression
     **<li>ConditionalAndExpression
     **<li>ConditionalOrExpression
     **<li>ConditionalExpression
     **<li>Assignment
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **<li>EqualityExpression0
     **<li>EqualityExpression1
     **</ul>
     **</b>
     **/
abstract class IVariableInitializersopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>Block
     **<li>IfThenElseStatementNoShortIf
     **<li>EmptyStatement
     **<li>LabeledStatementNoShortIf
     **<li>ExpressionStatement
     **<li>SwitchStatement
     **<li>WhileStatementNoShortIf
     **<li>DoStatement
     **<li>ForStatementNoShortIf
     **<li>BreakStatement
     **<li>ContinueStatement
     **<li>ReturnStatement
     **<li>ThrowStatement
     **<li>SynchronizedStatement
     **<li>AssertStatement0
     **<li>AssertStatement1
     **<li>TryStatement0
     **<li>TryStatement1
     **</ul>
     **</b>
     **/
abstract class IStatementNoShortIf implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>SwitchBlock</b>
     **/
abstract class ISwitchBlock implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>SwitchBlockStatementGroups
     **<li>SwitchBlockStatementGroup
     **</ul>
     **</b>
     **/
abstract class ISwitchBlockStatementGroupsopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>SwitchLabels
     **<li>SwitchLabel0
     **<li>SwitchLabel1
     **<li>SwitchLabel2
     **</ul>
     **</b>
     **/
abstract class ISwitchLabelsopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>AndExpression
     **<li>ExclusiveOrExpression
     **<li>InclusiveOrExpression
     **<li>ConditionalAndExpression
     **<li>ConditionalOrExpression
     **<li>ConditionalExpression
     **<li>Assignment
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **<li>EqualityExpression0
     **<li>EqualityExpression1
     **</ul>
     **</b>
     **/
abstract class IConstantExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>LocalVariableDeclaration
     **<li>StatementExpressionList
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>Assignment
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **</ul>
     **</b>
     **/
abstract class IForInitopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>AndExpression
     **<li>ExclusiveOrExpression
     **<li>InclusiveOrExpression
     **<li>ConditionalAndExpression
     **<li>ConditionalOrExpression
     **<li>ConditionalExpression
     **<li>Assignment
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **<li>EqualityExpression0
     **<li>EqualityExpression1
     **</ul>
     **</b>
     **/
abstract class IExpressionopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>StatementExpressionList
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>Assignment
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **</ul>
     **</b>
     **/
abstract class IForUpdateopt implements IRootForJavaParser    {
    }

    /***
     ** is always implemented by <b>AstToken</b>. It is also implemented by <b>identifier</b>
     **/
abstract class Iidentifieropt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>Catches
     **<li>CatchClause
     **</ul>
     **</b>
     **/
abstract class ICatchesopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>Finally</b>
     **/
abstract class IFinally implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>DimExprs
     **<li>DimExpr
     **</ul>
     **</b>
     **/
abstract class IDimExprs implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>Dims0
     **<li>Dims1
     **</ul>
     **</b>
     **/
abstract class IDimsopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **</ul>
     **</b>
     **/
abstract class ILeftHandSide implements IRootForJavaParser    {
    }

    /***
     ** is always implemented by <b>AstToken</b>. It is also implemented by <b>Commaopt</b>
     **/
abstract class ICommaopt implements IRootForJavaParser    {
    }

    /***
     ** is always implemented by <b>AstToken</b>. It is also implemented by <b>Ellipsisopt</b>
     **/
abstract class IEllipsisopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalClassDeclaration
     **<li>EnumDeclaration
     **<li>Block
     **<li>BlockStatements
     **<li>LocalVariableDeclarationStatement
     **<li>IfThenStatement
     **<li>IfThenElseStatement
     **<li>EmptyStatement
     **<li>LabeledStatement
     **<li>ExpressionStatement
     **<li>SwitchStatement
     **<li>WhileStatement
     **<li>DoStatement
     **<li>BasicForStatement
     **<li>EnhancedForStatement
     **<li>BreakStatement
     **<li>ContinueStatement
     **<li>ReturnStatement
     **<li>ThrowStatement
     **<li>SynchronizedStatement
     **<li>LPGUserAction0
     **<li>LPGUserAction1
     **<li>LPGUserAction2
     **<li>LPGUserAction3
     **<li>LPGUserAction4
     **<li>AssertStatement0
     **<li>AssertStatement1
     **<li>TryStatement0
     **<li>TryStatement1
     **</ul>
     **</b>
     **/
abstract class ILPGUserAction implements IRootForJavaParser    {
    }

    /***
     ** is always implemented by <b>AstToken</b>. It is also implemented by <b>identifier</b>
     **/
abstract class Iidentifier implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalClassDeclaration
     **<li>EnumDeclaration
     **<li>Block
     **<li>BlockStatements
     **<li>LocalVariableDeclarationStatement
     **<li>IfThenStatement
     **<li>IfThenElseStatement
     **<li>EmptyStatement
     **<li>LabeledStatement
     **<li>ExpressionStatement
     **<li>SwitchStatement
     **<li>WhileStatement
     **<li>DoStatement
     **<li>BasicForStatement
     **<li>EnhancedForStatement
     **<li>BreakStatement
     **<li>ContinueStatement
     **<li>ReturnStatement
     **<li>ThrowStatement
     **<li>SynchronizedStatement
     **<li>AssertStatement0
     **<li>AssertStatement1
     **<li>TryStatement0
     **<li>TryStatement1
     **</ul>
     **</b>
     **/
abstract class IBlockStatementsopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>PrimitiveType
     **<li>ClassType
     **<li>ArrayType
     **<li>IntegralType0
     **<li>IntegralType1
     **<li>IntegralType2
     **<li>IntegralType3
     **<li>IntegralType4
     **<li>FloatingPointType0
     **<li>FloatingPointType1
     **</ul>
     **</b>
     **/
abstract class IType implements IRootForJavaParser    {
    }

    /***
     ** is always implemented by <b>AstToken</b>. It is also implemented by:
     **<b>
     **<ul>
     **<li>PrimitiveType
     **<li>IntegralType0
     **<li>IntegralType1
     **<li>IntegralType2
     **<li>IntegralType3
     **<li>IntegralType4
     **<li>FloatingPointType0
     **<li>FloatingPointType1
     **</ul>
     **</b>
     **/
abstract class IPrimitiveType implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ClassType
     **<li>ArrayType
     **</ul>
     **</b>
     **/
abstract class IReferenceType implements IRootForJavaParser    {
    }

    /***
     ** is always implemented by <b>AstToken</b>. It is also implemented by:
     **<b>
     **<ul>
     **<li>IntegralType0
     **<li>IntegralType1
     **<li>IntegralType2
     **<li>IntegralType3
     **<li>IntegralType4
     **<li>FloatingPointType0
     **<li>FloatingPointType1
     **</ul>
     **</b>
     **/
abstract class INumericType implements IRootForJavaParser    {
    }

    /***
     ** is always implemented by <b>AstToken</b>. It is also implemented by:
     **<b>
     **<ul>
     **<li>IntegralType0
     **<li>IntegralType1
     **<li>IntegralType2
     **<li>IntegralType3
     **<li>IntegralType4
     **</ul>
     **</b>
     **/
abstract class IIntegralType implements IRootForJavaParser    {
    }

    /***
     ** is always implemented by <b>AstToken</b>. It is also implemented by:
     **<b>
     **<ul>
     **<li>FloatingPointType0
     **<li>FloatingPointType1
     **</ul>
     **</b>
     **/
abstract class IFloatingPointType implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>ClassType</b>
     **/
abstract class IClassOrInterfaceType implements IRootForJavaParser    {
    }

    /***
     ** is always implemented by <b>AstToken</b>. It is also implemented by <b>identifier</b>
     **/
abstract class ITypeVariable implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>ArrayType</b>
     **/
abstract class IArrayType implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>ClassType</b>
     **/
abstract class IClassType implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>TypeName
     **</ul>
     **</b>
     **/
abstract class ITypeName implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>InterfaceType</b>
     **/
abstract class IInterfaceType implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>TypeParameter</b>
     **/
abstract class ITypeParameter implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>TypeBound</b>
     **/
abstract class ITypeBound implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>AdditionalBoundList
     **<li>AdditionalBound
     **</ul>
     **</b>
     **/
abstract class IAdditionalBoundList implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>AdditionalBound</b>
     **/
abstract class IAdditionalBound implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>TypeArguments</b>
     **/
abstract class ITypeArguments implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ClassType
     **<li>ArrayType
     **<li>Wildcard
     **</ul>
     **</b>
     **/
abstract class IActualTypeArgument implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>Wildcard</b>
     **/
abstract class IWildcard implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>WildcardBounds0
     **<li>WildcardBounds1
     **</ul>
     **</b>
     **/
abstract class IWildcardBounds implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **</ul>
     **</b>
     **/
abstract class IExpressionName implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>ImportDeclarations
     **<li>SingleTypeImportDeclaration
     **<li>TypeImportOnDemandDeclaration
     **<li>SingleStaticImportDeclaration
     **<li>StaticImportOnDemandDeclaration
     **</ul>
     **</b>
     **/
abstract class IImportDeclarations implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>SingleTypeImportDeclaration
     **<li>TypeImportOnDemandDeclaration
     **<li>SingleStaticImportDeclaration
     **<li>StaticImportOnDemandDeclaration
     **</ul>
     **</b>
     **/
abstract class IImportDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>TypeDeclarations
     **<li>TypeDeclaration
     **<li>NormalClassDeclaration
     **<li>EnumDeclaration
     **<li>NormalInterfaceDeclaration
     **<li>AnnotationTypeDeclaration
     **</ul>
     **</b>
     **/
abstract class ITypeDeclarations implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>TypeDeclaration
     **<li>NormalClassDeclaration
     **<li>EnumDeclaration
     **<li>NormalInterfaceDeclaration
     **<li>AnnotationTypeDeclaration
     **</ul>
     **</b>
     **/
abstract class ITypeDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>PackageDeclaration</b>
     **/
abstract class IPackageDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>SingleTypeImportDeclaration</b>
     **/
abstract class ISingleTypeImportDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>TypeImportOnDemandDeclaration</b>
     **/
abstract class ITypeImportOnDemandDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>SingleStaticImportDeclaration</b>
     **/
abstract class ISingleStaticImportDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>StaticImportOnDemandDeclaration</b>
     **/
abstract class IStaticImportOnDemandDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalClassDeclaration
     **<li>EnumDeclaration
     **</ul>
     **</b>
     **/
abstract class IClassDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalInterfaceDeclaration
     **<li>AnnotationTypeDeclaration
     **</ul>
     **</b>
     **/
abstract class IInterfaceDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>NormalClassDeclaration</b>
     **/
abstract class INormalClassDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>EnumDeclaration</b>
     **/
abstract class IEnumDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>ClassBody</b>
     **/
abstract class IClassBody implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>ClassModifiers
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>ClassModifier0
     **<li>ClassModifier1
     **<li>ClassModifier2
     **<li>ClassModifier3
     **<li>ClassModifier4
     **<li>ClassModifier5
     **<li>ClassModifier6
     **</ul>
     **</b>
     **/
abstract class IClassModifiers implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>ClassModifier0
     **<li>ClassModifier1
     **<li>ClassModifier2
     **<li>ClassModifier3
     **<li>ClassModifier4
     **<li>ClassModifier5
     **<li>ClassModifier6
     **</ul>
     **</b>
     **/
abstract class IClassModifier implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **</ul>
     **</b>
     **/
abstract class IAnnotation implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>TypeParameters</b>
     **/
abstract class ITypeParameters implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>Super</b>
     **/
abstract class ISuper implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>Interfaces</b>
     **/
abstract class IInterfaces implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalClassDeclaration
     **<li>ClassBodyDeclarations
     **<li>ClassMemberDeclaration
     **<li>FieldDeclaration
     **<li>MethodDeclaration
     **<li>StaticInitializer
     **<li>ConstructorDeclaration
     **<li>EnumDeclaration
     **<li>NormalInterfaceDeclaration
     **<li>AnnotationTypeDeclaration
     **<li>Block
     **</ul>
     **</b>
     **/
abstract class IClassBodyDeclarations implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalClassDeclaration
     **<li>ClassMemberDeclaration
     **<li>FieldDeclaration
     **<li>MethodDeclaration
     **<li>StaticInitializer
     **<li>ConstructorDeclaration
     **<li>EnumDeclaration
     **<li>NormalInterfaceDeclaration
     **<li>AnnotationTypeDeclaration
     **<li>Block
     **</ul>
     **</b>
     **/
abstract class IClassBodyDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalClassDeclaration
     **<li>ClassMemberDeclaration
     **<li>FieldDeclaration
     **<li>MethodDeclaration
     **<li>EnumDeclaration
     **<li>NormalInterfaceDeclaration
     **<li>AnnotationTypeDeclaration
     **</ul>
     **</b>
     **/
abstract class IClassMemberDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>Block</b>
     **/
abstract class IInstanceInitializer implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>StaticInitializer</b>
     **/
abstract class IStaticInitializer implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>ConstructorDeclaration</b>
     **/
abstract class IConstructorDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>FieldDeclaration</b>
     **/
abstract class IFieldDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>MethodDeclaration</b>
     **/
abstract class IMethodDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>VariableDeclarator
     **<li>VariableDeclaratorId
     **</ul>
     **</b>
     **/
abstract class IVariableDeclarator implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>VariableDeclaratorId
     **</ul>
     **</b>
     **/
abstract class IVariableDeclaratorId implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>ArrayInitializer
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>AndExpression
     **<li>ExclusiveOrExpression
     **<li>InclusiveOrExpression
     **<li>ConditionalAndExpression
     **<li>ConditionalOrExpression
     **<li>ConditionalExpression
     **<li>Assignment
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **<li>EqualityExpression0
     **<li>EqualityExpression1
     **</ul>
     **</b>
     **/
abstract class IVariableInitializer implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>AndExpression
     **<li>ExclusiveOrExpression
     **<li>InclusiveOrExpression
     **<li>ConditionalAndExpression
     **<li>ConditionalOrExpression
     **<li>ConditionalExpression
     **<li>Assignment
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **<li>EqualityExpression0
     **<li>EqualityExpression1
     **</ul>
     **</b>
     **/
abstract class IExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>ArrayInitializer</b>
     **/
abstract class IArrayInitializer implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>FieldModifiers
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>FieldModifier0
     **<li>FieldModifier1
     **<li>FieldModifier2
     **<li>FieldModifier3
     **<li>FieldModifier4
     **<li>FieldModifier5
     **<li>FieldModifier6
     **</ul>
     **</b>
     **/
abstract class IFieldModifiers implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>FieldModifier0
     **<li>FieldModifier1
     **<li>FieldModifier2
     **<li>FieldModifier3
     **<li>FieldModifier4
     **<li>FieldModifier5
     **<li>FieldModifier6
     **</ul>
     **</b>
     **/
abstract class IFieldModifier implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>MethodBody
     **<li>Block
     **</ul>
     **</b>
     **/
abstract class IMethodBody implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>PrimitiveType
     **<li>ClassType
     **<li>ArrayType
     **<li>ResultType
     **<li>IntegralType0
     **<li>IntegralType1
     **<li>IntegralType2
     **<li>IntegralType3
     **<li>IntegralType4
     **<li>FloatingPointType0
     **<li>FloatingPointType1
     **</ul>
     **</b>
     **/
abstract class IResultType implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>FormalParameterList
     **<li>LastFormalParameter
     **</ul>
     **</b>
     **/
abstract class IFormalParameterList implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>LastFormalParameter</b>
     **/
abstract class ILastFormalParameter implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>FormalParameter</b>
     **/
abstract class IFormalParameter implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>VariableModifiers
     **<li>VariableModifier
     **<li>Annotations
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **</ul>
     **</b>
     **/
abstract class IVariableModifiers implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>VariableModifier
     **<li>Annotations
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **</ul>
     **</b>
     **/
abstract class IVariableModifier implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>Annotations
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **</ul>
     **</b>
     **/
abstract class IAnnotations implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>MethodModifiers
     **<li>Annotations
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>MethodModifier0
     **<li>MethodModifier1
     **<li>MethodModifier2
     **<li>MethodModifier3
     **<li>MethodModifier4
     **<li>MethodModifier5
     **<li>MethodModifier6
     **<li>MethodModifier7
     **<li>MethodModifier8
     **</ul>
     **</b>
     **/
abstract class IMethodModifiers implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>Annotations
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>MethodModifier0
     **<li>MethodModifier1
     **<li>MethodModifier2
     **<li>MethodModifier3
     **<li>MethodModifier4
     **<li>MethodModifier5
     **<li>MethodModifier6
     **<li>MethodModifier7
     **<li>MethodModifier8
     **</ul>
     **</b>
     **/
abstract class IMethodModifier implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>Throws</b>
     **/
abstract class IThrows implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ClassType
     **</ul>
     **</b>
     **/
abstract class IExceptionType implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>Block</b>
     **/
abstract class IBlock implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>ConstructorModifiers
     **<li>Annotations
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>ConstructorModifier0
     **<li>ConstructorModifier1
     **<li>ConstructorModifier2
     **</ul>
     **</b>
     **/
abstract class IConstructorModifiers implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>Annotations
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>ConstructorModifier0
     **<li>ConstructorModifier1
     **<li>ConstructorModifier2
     **</ul>
     **</b>
     **/
abstract class IConstructorModifier implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>ExplicitConstructorInvocation0
     **<li>ExplicitConstructorInvocation1
     **<li>ExplicitConstructorInvocation2
     **</ul>
     **</b>
     **/
abstract class IExplicitConstructorInvocation implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **</ul>
     **</b>
     **/
abstract class IPrimary implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>EnumConstants
     **<li>EnumConstant
     **</ul>
     **</b>
     **/
abstract class IEnumConstants implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>EnumConstant
     **</ul>
     **</b>
     **/
abstract class IEnumConstant implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>Arguments</b>
     **/
abstract class IArguments implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>EnumBodyDeclarations</b>
     **/
abstract class IEnumBodyDeclarations implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>NormalInterfaceDeclaration</b>
     **/
abstract class INormalInterfaceDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>AnnotationTypeDeclaration</b>
     **/
abstract class IAnnotationTypeDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>InterfaceModifiers
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>InterfaceModifier0
     **<li>InterfaceModifier1
     **<li>InterfaceModifier2
     **<li>InterfaceModifier3
     **<li>InterfaceModifier4
     **<li>InterfaceModifier5
     **</ul>
     **</b>
     **/
abstract class IInterfaceModifiers implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>InterfaceModifier0
     **<li>InterfaceModifier1
     **<li>InterfaceModifier2
     **<li>InterfaceModifier3
     **<li>InterfaceModifier4
     **<li>InterfaceModifier5
     **</ul>
     **</b>
     **/
abstract class IInterfaceModifier implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>ExtendsInterfaces0
     **<li>ExtendsInterfaces1
     **</ul>
     **</b>
     **/
abstract class IExtendsInterfaces implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalClassDeclaration
     **<li>EnumDeclaration
     **<li>NormalInterfaceDeclaration
     **<li>InterfaceMemberDeclarations
     **<li>InterfaceMemberDeclaration
     **<li>ConstantDeclaration
     **<li>AbstractMethodDeclaration
     **<li>AnnotationTypeDeclaration
     **</ul>
     **</b>
     **/
abstract class IInterfaceMemberDeclarations implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalClassDeclaration
     **<li>EnumDeclaration
     **<li>NormalInterfaceDeclaration
     **<li>InterfaceMemberDeclaration
     **<li>ConstantDeclaration
     **<li>AbstractMethodDeclaration
     **<li>AnnotationTypeDeclaration
     **</ul>
     **</b>
     **/
abstract class IInterfaceMemberDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>ConstantDeclaration</b>
     **/
abstract class IConstantDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>AbstractMethodDeclaration</b>
     **/
abstract class IAbstractMethodDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>ConstantModifiers
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>ConstantModifier0
     **<li>ConstantModifier1
     **<li>ConstantModifier2
     **</ul>
     **</b>
     **/
abstract class IConstantModifiers implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>ConstantModifier0
     **<li>ConstantModifier1
     **<li>ConstantModifier2
     **</ul>
     **</b>
     **/
abstract class IConstantModifier implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>AbstractMethodModifiers
     **<li>Annotations
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>AbstractMethodModifier0
     **<li>AbstractMethodModifier1
     **</ul>
     **</b>
     **/
abstract class IAbstractMethodModifiers implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>Annotations
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>AbstractMethodModifier0
     **<li>AbstractMethodModifier1
     **</ul>
     **</b>
     **/
abstract class IAbstractMethodModifier implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalClassDeclaration
     **<li>EnumDeclaration
     **<li>NormalInterfaceDeclaration
     **<li>ConstantDeclaration
     **<li>AnnotationTypeDeclaration
     **<li>AnnotationTypeElementDeclarations
     **<li>AnnotationTypeElementDeclaration0
     **<li>AnnotationTypeElementDeclaration1
     **</ul>
     **</b>
     **/
abstract class IAnnotationTypeElementDeclarations implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalClassDeclaration
     **<li>EnumDeclaration
     **<li>NormalInterfaceDeclaration
     **<li>ConstantDeclaration
     **<li>AnnotationTypeDeclaration
     **<li>AnnotationTypeElementDeclaration0
     **<li>AnnotationTypeElementDeclaration1
     **</ul>
     **</b>
     **/
abstract class IAnnotationTypeElementDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>DefaultValue</b>
     **/
abstract class IDefaultValue implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>NormalAnnotation
     **<li>ElementValueArrayInitializer
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>AndExpression
     **<li>ExclusiveOrExpression
     **<li>InclusiveOrExpression
     **<li>ConditionalAndExpression
     **<li>ConditionalOrExpression
     **<li>ConditionalExpression
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **<li>EqualityExpression0
     **<li>EqualityExpression1
     **</ul>
     **</b>
     **/
abstract class IElementValue implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>NormalAnnotation</b>
     **/
abstract class INormalAnnotation implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>MarkerAnnotation</b>
     **/
abstract class IMarkerAnnotation implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>SingleElementAnnotation</b>
     **/
abstract class ISingleElementAnnotation implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>ElementValuePairs
     **<li>ElementValuePair
     **</ul>
     **</b>
     **/
abstract class IElementValuePairs implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>ElementValuePair</b>
     **/
abstract class IElementValuePair implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>AndExpression
     **<li>ExclusiveOrExpression
     **<li>InclusiveOrExpression
     **<li>ConditionalAndExpression
     **<li>ConditionalOrExpression
     **<li>ConditionalExpression
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **<li>EqualityExpression0
     **<li>EqualityExpression1
     **</ul>
     **</b>
     **/
abstract class IConditionalExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>ElementValueArrayInitializer</b>
     **/
abstract class IElementValueArrayInitializer implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>NormalAnnotation
     **<li>ElementValueArrayInitializer
     **<li>ElementValues
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>AndExpression
     **<li>ExclusiveOrExpression
     **<li>InclusiveOrExpression
     **<li>ConditionalAndExpression
     **<li>ConditionalOrExpression
     **<li>ConditionalExpression
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **<li>EqualityExpression0
     **<li>EqualityExpression1
     **</ul>
     **</b>
     **/
abstract class IElementValues implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>ArrayInitializer
     **<li>VariableInitializers
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>AndExpression
     **<li>ExclusiveOrExpression
     **<li>InclusiveOrExpression
     **<li>ConditionalAndExpression
     **<li>ConditionalOrExpression
     **<li>ConditionalExpression
     **<li>Assignment
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **<li>EqualityExpression0
     **<li>EqualityExpression1
     **</ul>
     **</b>
     **/
abstract class IVariableInitializers implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalClassDeclaration
     **<li>EnumDeclaration
     **<li>Block
     **<li>BlockStatements
     **<li>LocalVariableDeclarationStatement
     **<li>IfThenStatement
     **<li>IfThenElseStatement
     **<li>EmptyStatement
     **<li>LabeledStatement
     **<li>ExpressionStatement
     **<li>SwitchStatement
     **<li>WhileStatement
     **<li>DoStatement
     **<li>BasicForStatement
     **<li>EnhancedForStatement
     **<li>BreakStatement
     **<li>ContinueStatement
     **<li>ReturnStatement
     **<li>ThrowStatement
     **<li>SynchronizedStatement
     **<li>AssertStatement0
     **<li>AssertStatement1
     **<li>TryStatement0
     **<li>TryStatement1
     **</ul>
     **</b>
     **/
abstract class IBlockStatements implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalClassDeclaration
     **<li>EnumDeclaration
     **<li>Block
     **<li>LocalVariableDeclarationStatement
     **<li>IfThenStatement
     **<li>IfThenElseStatement
     **<li>EmptyStatement
     **<li>LabeledStatement
     **<li>ExpressionStatement
     **<li>SwitchStatement
     **<li>WhileStatement
     **<li>DoStatement
     **<li>BasicForStatement
     **<li>EnhancedForStatement
     **<li>BreakStatement
     **<li>ContinueStatement
     **<li>ReturnStatement
     **<li>ThrowStatement
     **<li>SynchronizedStatement
     **<li>AssertStatement0
     **<li>AssertStatement1
     **<li>TryStatement0
     **<li>TryStatement1
     **</ul>
     **</b>
     **/
abstract class IBlockStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>LocalVariableDeclarationStatement</b>
     **/
abstract class ILocalVariableDeclarationStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>Block
     **<li>IfThenStatement
     **<li>IfThenElseStatement
     **<li>EmptyStatement
     **<li>LabeledStatement
     **<li>ExpressionStatement
     **<li>SwitchStatement
     **<li>WhileStatement
     **<li>DoStatement
     **<li>BasicForStatement
     **<li>EnhancedForStatement
     **<li>BreakStatement
     **<li>ContinueStatement
     **<li>ReturnStatement
     **<li>ThrowStatement
     **<li>SynchronizedStatement
     **<li>AssertStatement0
     **<li>AssertStatement1
     **<li>TryStatement0
     **<li>TryStatement1
     **</ul>
     **</b>
     **/
abstract class IStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>LocalVariableDeclaration</b>
     **/
abstract class ILocalVariableDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>Block
     **<li>EmptyStatement
     **<li>ExpressionStatement
     **<li>SwitchStatement
     **<li>DoStatement
     **<li>BreakStatement
     **<li>ContinueStatement
     **<li>ReturnStatement
     **<li>ThrowStatement
     **<li>SynchronizedStatement
     **<li>AssertStatement0
     **<li>AssertStatement1
     **<li>TryStatement0
     **<li>TryStatement1
     **</ul>
     **</b>
     **/
abstract class IStatementWithoutTrailingSubstatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>LabeledStatement</b>
     **/
abstract class ILabeledStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>IfThenStatement</b>
     **/
abstract class IIfThenStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>IfThenElseStatement</b>
     **/
abstract class IIfThenElseStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>WhileStatement</b>
     **/
abstract class IWhileStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>BasicForStatement
     **<li>EnhancedForStatement
     **</ul>
     **</b>
     **/
abstract class IForStatement implements IRootForJavaParser    {
    }

    /***
     ** is always implemented by <b>AstToken</b>. It is also implemented by <b>EmptyStatement</b>
     **/
abstract class IEmptyStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>ExpressionStatement</b>
     **/
abstract class IExpressionStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>AssertStatement0
     **<li>AssertStatement1
     **</ul>
     **</b>
     **/
abstract class IAssertStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>SwitchStatement</b>
     **/
abstract class ISwitchStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>DoStatement</b>
     **/
abstract class IDoStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>BreakStatement</b>
     **/
abstract class IBreakStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>ContinueStatement</b>
     **/
abstract class IContinueStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>ReturnStatement</b>
     **/
abstract class IReturnStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>SynchronizedStatement</b>
     **/
abstract class ISynchronizedStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>ThrowStatement</b>
     **/
abstract class IThrowStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>TryStatement0
     **<li>TryStatement1
     **</ul>
     **</b>
     **/
abstract class ITryStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>LabeledStatementNoShortIf</b>
     **/
abstract class ILabeledStatementNoShortIf implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>IfThenElseStatementNoShortIf</b>
     **/
abstract class IIfThenElseStatementNoShortIf implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>WhileStatementNoShortIf</b>
     **/
abstract class IWhileStatementNoShortIf implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>ForStatementNoShortIf</b>
     **/
abstract class IForStatementNoShortIf implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>Assignment
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **</ul>
     **</b>
     **/
abstract class IStatementExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>Assignment</b>
     **/
abstract class IAssignment implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>PreIncrementExpression</b>
     **/
abstract class IPreIncrementExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>PreDecrementExpression</b>
     **/
abstract class IPreDecrementExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>PostIncrementExpression</b>
     **/
abstract class IPostIncrementExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>PostDecrementExpression</b>
     **/
abstract class IPostDecrementExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **</ul>
     **</b>
     **/
abstract class IMethodInvocation implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **</ul>
     **</b>
     **/
abstract class IClassInstanceCreationExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>SwitchBlockStatementGroups
     **<li>SwitchBlockStatementGroup
     **</ul>
     **</b>
     **/
abstract class ISwitchBlockStatementGroups implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>SwitchBlockStatementGroup</b>
     **/
abstract class ISwitchBlockStatementGroup implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>SwitchLabels
     **<li>SwitchLabel0
     **<li>SwitchLabel1
     **<li>SwitchLabel2
     **</ul>
     **</b>
     **/
abstract class ISwitchLabels implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>SwitchLabel0
     **<li>SwitchLabel1
     **<li>SwitchLabel2
     **</ul>
     **</b>
     **/
abstract class ISwitchLabel implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>BasicForStatement</b>
     **/
abstract class IBasicForStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>EnhancedForStatement</b>
     **/
abstract class IEnhancedForStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>LocalVariableDeclaration
     **<li>StatementExpressionList
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>Assignment
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **</ul>
     **</b>
     **/
abstract class IForInit implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>StatementExpressionList
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>Assignment
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **</ul>
     **</b>
     **/
abstract class IStatementExpressionList implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>StatementExpressionList
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>Assignment
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **</ul>
     **</b>
     **/
abstract class IForUpdate implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>Catches
     **<li>CatchClause
     **</ul>
     **</b>
     **/
abstract class ICatches implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>CatchClause</b>
     **/
abstract class ICatchClause implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **</ul>
     **</b>
     **/
abstract class IPrimaryNoNewArray implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **</ul>
     **</b>
     **/
abstract class IArrayCreationExpression implements IRootForJavaParser    {
    }

    /***
     ** is always implemented by <b>AstToken</b>. It is also implemented by:
     **<b>
     **<ul>
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **</ul>
     **</b>
     **/
abstract class ILiteral implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **</ul>
     **</b>
     **/
abstract class IFieldAccess implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **</ul>
     **</b>
     **/
abstract class IArrayAccess implements IRootForJavaParser    {
    }

    /***
     ** is always implemented by <b>AstToken</b>. It is also implemented by:
     **<b>
     **<ul>
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **</ul>
     **</b>
     **/
abstract class IBooleanLiteral implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>ArgumentList
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>AndExpression
     **<li>ExclusiveOrExpression
     **<li>InclusiveOrExpression
     **<li>ConditionalAndExpression
     **<li>ConditionalOrExpression
     **<li>ConditionalExpression
     **<li>Assignment
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **<li>EqualityExpression0
     **<li>EqualityExpression1
     **</ul>
     **</b>
     **/
abstract class IArgumentList implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>Dims0
     **<li>Dims1
     **</ul>
     **</b>
     **/
abstract class IDims implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>DimExpr</b>
     **/
abstract class IDimExpr implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **</ul>
     **</b>
     **/
abstract class IPostfixExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **</ul>
     **</b>
     **/
abstract class IUnaryExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **</ul>
     **</b>
     **/
abstract class IUnaryExpressionNotPlusMinus implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>CastExpression0
     **<li>CastExpression1
     **</ul>
     **</b>
     **/
abstract class ICastExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **</ul>
     **</b>
     **/
abstract class IMultiplicativeExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **</ul>
     **</b>
     **/
abstract class IAdditiveExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **</ul>
     **</b>
     **/
abstract class IShiftExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **</ul>
     **</b>
     **/
abstract class IRelationalExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **<li>EqualityExpression0
     **<li>EqualityExpression1
     **</ul>
     **</b>
     **/
abstract class IEqualityExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>AndExpression
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **<li>EqualityExpression0
     **<li>EqualityExpression1
     **</ul>
     **</b>
     **/
abstract class IAndExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>AndExpression
     **<li>ExclusiveOrExpression
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **<li>EqualityExpression0
     **<li>EqualityExpression1
     **</ul>
     **</b>
     **/
abstract class IExclusiveOrExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>AndExpression
     **<li>ExclusiveOrExpression
     **<li>InclusiveOrExpression
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **<li>EqualityExpression0
     **<li>EqualityExpression1
     **</ul>
     **</b>
     **/
abstract class IInclusiveOrExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>AndExpression
     **<li>ExclusiveOrExpression
     **<li>InclusiveOrExpression
     **<li>ConditionalAndExpression
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **<li>EqualityExpression0
     **<li>EqualityExpression1
     **</ul>
     **</b>
     **/
abstract class IConditionalAndExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>AndExpression
     **<li>ExclusiveOrExpression
     **<li>InclusiveOrExpression
     **<li>ConditionalAndExpression
     **<li>ConditionalOrExpression
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **<li>EqualityExpression0
     **<li>EqualityExpression1
     **</ul>
     **</b>
     **/
abstract class IConditionalOrExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>AndExpression
     **<li>ExclusiveOrExpression
     **<li>InclusiveOrExpression
     **<li>ConditionalAndExpression
     **<li>ConditionalOrExpression
     **<li>ConditionalExpression
     **<li>Assignment
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **<li>EqualityExpression0
     **<li>EqualityExpression1
     **</ul>
     **</b>
     **/
abstract class IAssignmentExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>AssignmentOperator0
     **<li>AssignmentOperator1
     **<li>AssignmentOperator2
     **<li>AssignmentOperator3
     **<li>AssignmentOperator4
     **<li>AssignmentOperator5
     **<li>AssignmentOperator6
     **<li>AssignmentOperator7
     **<li>AssignmentOperator8
     **<li>AssignmentOperator9
     **<li>AssignmentOperator10
     **<li>AssignmentOperator11
     **</ul>
     **</b>
     **/
abstract class IAssignmentOperator implements IRootForJavaParser    {
    }

abstract class Ast implements IAst
    {
        IAst? getNextAst(){ return null; }
         late IToken leftIToken ;
         late IToken rightIToken ;
         IAst? parent;
         void setParent(IAst p){ parent = p; }
         IAst? getParent(){ return parent; }

         IToken getLeftIToken()  { return leftIToken; }
         IToken getRightIToken()  { return rightIToken; }
          List<IToken> getPrecedingAdjuncts() { return leftIToken.getPrecedingAdjuncts(); }
          List<IToken> getFollowingAdjuncts() { return rightIToken.getFollowingAdjuncts(); }

        String  toString()  
        {
          var  lex = leftIToken.getILexStream();
          if( lex != null)
            return lex.toStringWithOffset(leftIToken.getStartOffset(), rightIToken.getEndOffset());
          return  '';
        }

    Ast(IToken leftIToken ,[ IToken? rightIToken ])
        {
            this.leftIToken = leftIToken;
            if(rightIToken != null) this.rightIToken = rightIToken;
            else            this.rightIToken = leftIToken;
        }

        void initialize(){}

        /**
         * A list of all children of this node, excluding the null ones.
         */
          ArrayList getChildren() 
        {
             var list = getAllChildren() ;
            var k = -1;
            for (var i = 0; i < list.size(); i++)
            {
                var element = list.get(i);
                if (null==element)
                {
                    if (++k != i)
                        list.set(k, element);
                }
            }
            for (var i = list.size() - 1; i > k; i--) // remove extraneous elements
                list.remove(i);
            return list;
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
         ArrayList getAllChildren() ;

          void acceptWithVisitor(Visitor v);
          void acceptWithArg(ArgumentVisitor v, Object o);
         Object acceptWithResult(ResultVisitor v);
         Object acceptWithResultArgument(ResultArgumentVisitor v, Object o);
         void accept(IAstVisitor v){}
    }

abstract class AbstractAstList extends Ast implements IAbstractArrayList<Ast>
    {
         late bool leftRecursive  ;
          var list  =  ArrayList();
         int size()   { return list.size(); }
         ArrayList getList(){ return list; }
         Ast getElementAt(int i) { return list.get(leftRecursive ? i : list.size() - 1 - i); }
         ArrayList getArrayList()
        {
            if (! leftRecursive) // reverse the list 
            {
                for (var i = 0, n = list.size() - 1; i < n; i++, n--)
                {
                    var ith = list.get(i),
                           nth = list.get(n);
                    list.set(i, nth);
                    list.set(n, ith);
                }
                leftRecursive = true;
            }
            return list;
        }
        /**
         * @deprecated replaced by {@link #addElement()}
         *
         */
         bool add(Ast element)
        {
            addElement(element);
            return true;
        }

         void addElement(Ast element)
        {
            list.add(element);
            if (leftRecursive)
                 rightIToken = element.getRightIToken();
            else leftIToken = element.getLeftIToken();
        }

          AbstractAstList(IToken leftToken, IToken rightToken , bool leftRecursive  ):super(leftToken, rightToken){
              this.leftRecursive = leftRecursive;
        }

        /**
         * Make a copy of the list and return it. Note that we obtain the local list by
         * invoking getArrayList so as to make sure that the list we return is in proper order.
         */
            ArrayList getAllChildren() 
        {
            return getArrayList().clone();
        }

    }

class AstToken extends Ast implements IAstToken
    {
        AstToken(IToken token   ):super(token){  }
         IToken getIToken()  { return leftIToken; }
         String toString(){ return leftIToken.toString(); }

        /**
         * A token class has no children. So, we return the empty list.
         */
            ArrayList getAllChildren()  { return  ArrayList(); }


          void acceptWithVisitor(Visitor v){ v.visitAstToken(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitAstToken(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitAstToken(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitAstToken(this, o); }
    }

/**
 *<b>
*<li>Rule 3:  identifier ::= IDENTIFIER
 *</b>
 */
class identifier extends AstToken implements Iidentifier
    {
         late JavaParser environment;
         JavaParser getEnvironment() { return environment; }

         IToken getIDENTIFIER(){ return leftIToken; }

    identifier(JavaParser environment, IToken token):super(token)        {
            this.environment = environment;
            initialize();
        }

          void acceptWithVisitor(Visitor v){ v.visitidentifier(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitidentifier(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitidentifier(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitidentifier(this, o); }
    }

/**
 *<em>
*<li>Rule 12:  PrimitiveType ::= NumericType
 *</em>
 *<p>
 *<b>
*<li>Rule 13:  PrimitiveType ::= boolean
 *</b>
 */
class PrimitiveType extends AstToken implements IPrimitiveType
    {
         IToken getboolean(){ return leftIToken; }

    PrimitiveType(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitPrimitiveType(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitPrimitiveType(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitPrimitiveType(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitPrimitiveType(this, o); }
    }

/**
 *<b>
*<li>Rule 27:  ClassType ::= TypeName TypeArgumentsopt
 *</b>
 */
class ClassType extends Ast implements IClassType
    {
         late Ast _TypeName;
         late TypeArguments? _TypeArgumentsopt;

         Ast getTypeName(){ return _TypeName; }
         void setTypeName(Ast _TypeName){ this._TypeName = _TypeName; }
        /**
         * The value returned by <b>getTypeArgumentsopt</b> may be <b>null</b>
         */
         TypeArguments ?  getTypeArgumentsopt(){ return _TypeArgumentsopt; }
         void setTypeArgumentsopt(TypeArguments _TypeArgumentsopt){ this._TypeArgumentsopt = _TypeArgumentsopt; }

        ClassType(IToken leftIToken, IToken rightIToken,
                  Ast _TypeName,
                  TypeArguments? _TypeArgumentsopt)
            :super(leftIToken, rightIToken)

        {
            this._TypeName = _TypeName;
            (_TypeName as Ast).setParent(this);
            this._TypeArgumentsopt = _TypeArgumentsopt;
            if (null != _TypeArgumentsopt) (_TypeArgumentsopt as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _TypeName)  list.add(_TypeName);
            if(null != _TypeArgumentsopt)  list.add(_TypeArgumentsopt);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitClassType(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitClassType(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitClassType(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitClassType(this, o); }
    }

/**
 *<b>
*<li>Rule 28:  InterfaceType ::= TypeName TypeArgumentsopt
 *</b>
 */
class InterfaceType extends Ast implements IInterfaceType
    {
         late Ast _TypeName;
         late TypeArguments? _TypeArgumentsopt;

         Ast getTypeName(){ return _TypeName; }
         void setTypeName(Ast _TypeName){ this._TypeName = _TypeName; }
        /**
         * The value returned by <b>getTypeArgumentsopt</b> may be <b>null</b>
         */
         TypeArguments ?  getTypeArgumentsopt(){ return _TypeArgumentsopt; }
         void setTypeArgumentsopt(TypeArguments _TypeArgumentsopt){ this._TypeArgumentsopt = _TypeArgumentsopt; }

        InterfaceType(IToken leftIToken, IToken rightIToken,
                      Ast _TypeName,
                      TypeArguments? _TypeArgumentsopt)
            :super(leftIToken, rightIToken)

        {
            this._TypeName = _TypeName;
            (_TypeName as Ast).setParent(this);
            this._TypeArgumentsopt = _TypeArgumentsopt;
            if (null != _TypeArgumentsopt) (_TypeArgumentsopt as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _TypeName)  list.add(_TypeName);
            if(null != _TypeArgumentsopt)  list.add(_TypeArgumentsopt);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitInterfaceType(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitInterfaceType(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitInterfaceType(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitInterfaceType(this, o); }
    }

/**
 *<em>
*<li>Rule 29:  TypeName ::= identifier
 *</em>
 *<p>
 *<b>
*<li>Rule 30:  TypeName ::= TypeName . identifier
 *</b>
 */
class TypeName extends Ast implements ITypeName
    {
         late Ast _TypeName;
         late AstToken _DOT;
         late identifier _identifier;

         Ast getTypeName(){ return _TypeName; }
         void setTypeName(Ast _TypeName){ this._TypeName = _TypeName; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }

        TypeName(IToken leftIToken, IToken rightIToken,
                 Ast _TypeName,
                 AstToken _DOT,
                 identifier _identifier)
            :super(leftIToken, rightIToken)

        {
            this._TypeName = _TypeName;
            (_TypeName as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _TypeName)  list.add(_TypeName);
            if(null != _DOT)  list.add(_DOT);
            if(null != _identifier)  list.add(_identifier);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitTypeName(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitTypeName(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitTypeName(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitTypeName(this, o); }
    }

/**
 *<b>
*<li>Rule 33:  ArrayType ::= Type [ ]
 *</b>
 */
class ArrayType extends Ast implements IArrayType
    {
         late Ast _Type;
         late AstToken _LBRACKET;
         late AstToken _RBRACKET;

         Ast getType(){ return _Type; }
         void setType(Ast _Type){ this._Type = _Type; }
         AstToken getLBRACKET(){ return _LBRACKET; }
         void setLBRACKET(AstToken _LBRACKET){ this._LBRACKET = _LBRACKET; }
         AstToken getRBRACKET(){ return _RBRACKET; }
         void setRBRACKET(AstToken _RBRACKET){ this._RBRACKET = _RBRACKET; }

        ArrayType(IToken leftIToken, IToken rightIToken,
                  Ast _Type,
                  AstToken _LBRACKET,
                  AstToken _RBRACKET)
            :super(leftIToken, rightIToken)

        {
            this._Type = _Type;
            (_Type as Ast).setParent(this);
            this._LBRACKET = _LBRACKET;
            (_LBRACKET as Ast).setParent(this);
            this._RBRACKET = _RBRACKET;
            (_RBRACKET as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _Type)  list.add(_Type);
            if(null != _LBRACKET)  list.add(_LBRACKET);
            if(null != _RBRACKET)  list.add(_RBRACKET);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitArrayType(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitArrayType(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitArrayType(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitArrayType(this, o); }
    }

/**
 *<b>
*<li>Rule 34:  TypeParameter ::= TypeVariable TypeBoundopt
 *</b>
 */
class TypeParameter extends Ast implements ITypeParameter
    {
         late identifier _TypeVariable;
         late TypeBound? _TypeBoundopt;

         identifier getTypeVariable(){ return _TypeVariable; }
         void setTypeVariable(identifier _TypeVariable){ this._TypeVariable = _TypeVariable; }
        /**
         * The value returned by <b>getTypeBoundopt</b> may be <b>null</b>
         */
         TypeBound ?  getTypeBoundopt(){ return _TypeBoundopt; }
         void setTypeBoundopt(TypeBound _TypeBoundopt){ this._TypeBoundopt = _TypeBoundopt; }

        TypeParameter(IToken leftIToken, IToken rightIToken,
                      identifier _TypeVariable,
                      TypeBound? _TypeBoundopt)
            :super(leftIToken, rightIToken)

        {
            this._TypeVariable = _TypeVariable;
            (_TypeVariable as Ast).setParent(this);
            this._TypeBoundopt = _TypeBoundopt;
            if (null != _TypeBoundopt) (_TypeBoundopt as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _TypeVariable)  list.add(_TypeVariable);
            if(null != _TypeBoundopt)  list.add(_TypeBoundopt);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitTypeParameter(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitTypeParameter(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitTypeParameter(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitTypeParameter(this, o); }
    }

/**
 *<b>
*<li>Rule 35:  TypeBound ::= extends ClassOrInterfaceType AdditionalBoundListopt
 *</b>
 */
class TypeBound extends Ast implements ITypeBound
    {
         late AstToken _extends;
         late ClassType _ClassOrInterfaceType;
         late Ast? _AdditionalBoundListopt;

         AstToken getextends(){ return _extends; }
         void setextends(AstToken _extends){ this._extends = _extends; }
         ClassType getClassOrInterfaceType(){ return _ClassOrInterfaceType; }
         void setClassOrInterfaceType(ClassType _ClassOrInterfaceType){ this._ClassOrInterfaceType = _ClassOrInterfaceType; }
        /**
         * The value returned by <b>getAdditionalBoundListopt</b> may be <b>null</b>
         */
         Ast ?  getAdditionalBoundListopt(){ return _AdditionalBoundListopt; }
         void setAdditionalBoundListopt(Ast _AdditionalBoundListopt){ this._AdditionalBoundListopt = _AdditionalBoundListopt; }

        TypeBound(IToken leftIToken, IToken rightIToken,
                  AstToken _extends,
                  ClassType _ClassOrInterfaceType,
                  Ast? _AdditionalBoundListopt)
            :super(leftIToken, rightIToken)

        {
            this._extends = _extends;
            (_extends as Ast).setParent(this);
            this._ClassOrInterfaceType = _ClassOrInterfaceType;
            (_ClassOrInterfaceType as Ast).setParent(this);
            this._AdditionalBoundListopt = _AdditionalBoundListopt;
            if (null != _AdditionalBoundListopt) (_AdditionalBoundListopt as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _extends)  list.add(_extends);
            if(null != _ClassOrInterfaceType)  list.add(_ClassOrInterfaceType);
            if(null != _AdditionalBoundListopt)  list.add(_AdditionalBoundListopt);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitTypeBound(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitTypeBound(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitTypeBound(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitTypeBound(this, o); }
    }

/**
 *<em>
*<li>Rule 36:  AdditionalBoundList ::= AdditionalBound
 *</em>
 *<p>
 *<b>
*<li>Rule 37:  AdditionalBoundList ::= AdditionalBoundList AdditionalBound
 *</b>
 */
class AdditionalBoundList extends Ast implements IAdditionalBoundList
    {
         late Ast _AdditionalBoundList;
         late AdditionalBound _AdditionalBound;

         Ast getAdditionalBoundList(){ return _AdditionalBoundList; }
         void setAdditionalBoundList(Ast _AdditionalBoundList){ this._AdditionalBoundList = _AdditionalBoundList; }
         AdditionalBound getAdditionalBound(){ return _AdditionalBound; }
         void setAdditionalBound(AdditionalBound _AdditionalBound){ this._AdditionalBound = _AdditionalBound; }

        AdditionalBoundList(IToken leftIToken, IToken rightIToken,
                            Ast _AdditionalBoundList,
                            AdditionalBound _AdditionalBound)
            :super(leftIToken, rightIToken)

        {
            this._AdditionalBoundList = _AdditionalBoundList;
            (_AdditionalBoundList as Ast).setParent(this);
            this._AdditionalBound = _AdditionalBound;
            (_AdditionalBound as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _AdditionalBoundList)  list.add(_AdditionalBoundList);
            if(null != _AdditionalBound)  list.add(_AdditionalBound);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitAdditionalBoundList(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitAdditionalBoundList(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitAdditionalBoundList(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitAdditionalBoundList(this, o); }
    }

/**
 *<b>
*<li>Rule 38:  AdditionalBound ::= & InterfaceType
 *</b>
 */
class AdditionalBound extends Ast implements IAdditionalBound
    {
         late AstToken _AND;
         late InterfaceType _InterfaceType;

         AstToken getAND(){ return _AND; }
         void setAND(AstToken _AND){ this._AND = _AND; }
         InterfaceType getInterfaceType(){ return _InterfaceType; }
         void setInterfaceType(InterfaceType _InterfaceType){ this._InterfaceType = _InterfaceType; }

        AdditionalBound(IToken leftIToken, IToken rightIToken,
                        AstToken _AND,
                        InterfaceType _InterfaceType)
            :super(leftIToken, rightIToken)

        {
            this._AND = _AND;
            (_AND as Ast).setParent(this);
            this._InterfaceType = _InterfaceType;
            (_InterfaceType as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _AND)  list.add(_AND);
            if(null != _InterfaceType)  list.add(_InterfaceType);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitAdditionalBound(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitAdditionalBound(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitAdditionalBound(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitAdditionalBound(this, o); }
    }

/**
 *<b>
*<li>Rule 39:  TypeArguments ::= < ActualTypeArgumentList >
 *</b>
 */
class TypeArguments extends Ast implements ITypeArguments
    {
         late AstToken _LESS;
         late Ast _ActualTypeArgumentList;
         late AstToken _GREATER;

         AstToken getLESS(){ return _LESS; }
         void setLESS(AstToken _LESS){ this._LESS = _LESS; }
         Ast getActualTypeArgumentList(){ return _ActualTypeArgumentList; }
         void setActualTypeArgumentList(Ast _ActualTypeArgumentList){ this._ActualTypeArgumentList = _ActualTypeArgumentList; }
         AstToken getGREATER(){ return _GREATER; }
         void setGREATER(AstToken _GREATER){ this._GREATER = _GREATER; }

        TypeArguments(IToken leftIToken, IToken rightIToken,
                      AstToken _LESS,
                      Ast _ActualTypeArgumentList,
                      AstToken _GREATER)
            :super(leftIToken, rightIToken)

        {
            this._LESS = _LESS;
            (_LESS as Ast).setParent(this);
            this._ActualTypeArgumentList = _ActualTypeArgumentList;
            (_ActualTypeArgumentList as Ast).setParent(this);
            this._GREATER = _GREATER;
            (_GREATER as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _LESS)  list.add(_LESS);
            if(null != _ActualTypeArgumentList)  list.add(_ActualTypeArgumentList);
            if(null != _GREATER)  list.add(_GREATER);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitTypeArguments(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitTypeArguments(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitTypeArguments(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitTypeArguments(this, o); }
    }

/**
 *<em>
*<li>Rule 40:  ActualTypeArgumentList ::= ActualTypeArgument
 *</em>
 *<p>
 *<b>
*<li>Rule 41:  ActualTypeArgumentList ::= ActualTypeArgumentList , ActualTypeArgument
 *</b>
 */
class ActualTypeArgumentList extends Ast implements IActualTypeArgumentList
    {
         late Ast _ActualTypeArgumentList;
         late AstToken _COMMA;
         late Ast _ActualTypeArgument;

         Ast getActualTypeArgumentList(){ return _ActualTypeArgumentList; }
         void setActualTypeArgumentList(Ast _ActualTypeArgumentList){ this._ActualTypeArgumentList = _ActualTypeArgumentList; }
         AstToken getCOMMA(){ return _COMMA; }
         void setCOMMA(AstToken _COMMA){ this._COMMA = _COMMA; }
         Ast getActualTypeArgument(){ return _ActualTypeArgument; }
         void setActualTypeArgument(Ast _ActualTypeArgument){ this._ActualTypeArgument = _ActualTypeArgument; }

        ActualTypeArgumentList(IToken leftIToken, IToken rightIToken,
                               Ast _ActualTypeArgumentList,
                               AstToken _COMMA,
                               Ast _ActualTypeArgument)
            :super(leftIToken, rightIToken)

        {
            this._ActualTypeArgumentList = _ActualTypeArgumentList;
            (_ActualTypeArgumentList as Ast).setParent(this);
            this._COMMA = _COMMA;
            (_COMMA as Ast).setParent(this);
            this._ActualTypeArgument = _ActualTypeArgument;
            (_ActualTypeArgument as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ActualTypeArgumentList)  list.add(_ActualTypeArgumentList);
            if(null != _COMMA)  list.add(_COMMA);
            if(null != _ActualTypeArgument)  list.add(_ActualTypeArgument);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitActualTypeArgumentList(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitActualTypeArgumentList(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitActualTypeArgumentList(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitActualTypeArgumentList(this, o); }
    }

/**
 *<b>
*<li>Rule 44:  Wildcard ::= ? WildcardBoundsOpt
 *</b>
 */
class Wildcard extends Ast implements IWildcard
    {
         late AstToken _QUESTION;
         late Ast? _WildcardBoundsOpt;

         AstToken getQUESTION(){ return _QUESTION; }
         void setQUESTION(AstToken _QUESTION){ this._QUESTION = _QUESTION; }
        /**
         * The value returned by <b>getWildcardBoundsOpt</b> may be <b>null</b>
         */
         Ast ?  getWildcardBoundsOpt(){ return _WildcardBoundsOpt; }
         void setWildcardBoundsOpt(Ast _WildcardBoundsOpt){ this._WildcardBoundsOpt = _WildcardBoundsOpt; }

        Wildcard(IToken leftIToken, IToken rightIToken,
                 AstToken _QUESTION,
                 Ast? _WildcardBoundsOpt)
            :super(leftIToken, rightIToken)

        {
            this._QUESTION = _QUESTION;
            (_QUESTION as Ast).setParent(this);
            this._WildcardBoundsOpt = _WildcardBoundsOpt;
            if (null != _WildcardBoundsOpt) (_WildcardBoundsOpt as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _QUESTION)  list.add(_QUESTION);
            if(null != _WildcardBoundsOpt)  list.add(_WildcardBoundsOpt);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitWildcard(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitWildcard(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitWildcard(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitWildcard(this, o); }
    }

/**
 *<em>
*<li>Rule 47:  PackageName ::= identifier
 *</em>
 *<p>
 *<b>
*<li>Rule 48:  PackageName ::= PackageName . identifier
 *</b>
 */
class PackageName extends Ast implements IPackageName
    {
         late Ast _PackageName;
         late AstToken _DOT;
         late identifier _identifier;

         Ast getPackageName(){ return _PackageName; }
         void setPackageName(Ast _PackageName){ this._PackageName = _PackageName; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }

        PackageName(IToken leftIToken, IToken rightIToken,
                    Ast _PackageName,
                    AstToken _DOT,
                    identifier _identifier)
            :super(leftIToken, rightIToken)

        {
            this._PackageName = _PackageName;
            (_PackageName as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _PackageName)  list.add(_PackageName);
            if(null != _DOT)  list.add(_DOT);
            if(null != _identifier)  list.add(_identifier);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitPackageName(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitPackageName(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitPackageName(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitPackageName(this, o); }
    }

/**
 *<em>
*<li>Rule 49:  ExpressionName ::= identifier
 *</em>
 *<p>
 *<b>
*<li>Rule 50:  ExpressionName ::= AmbiguousName . identifier
 *</b>
 */
class ExpressionName extends Ast implements IExpressionName
    {
         late Ast _AmbiguousName;
         late AstToken _DOT;
         late identifier _identifier;

         Ast getAmbiguousName(){ return _AmbiguousName; }
         void setAmbiguousName(Ast _AmbiguousName){ this._AmbiguousName = _AmbiguousName; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }

        ExpressionName(IToken leftIToken, IToken rightIToken,
                       Ast _AmbiguousName,
                       AstToken _DOT,
                       identifier _identifier)
            :super(leftIToken, rightIToken)

        {
            this._AmbiguousName = _AmbiguousName;
            (_AmbiguousName as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _AmbiguousName)  list.add(_AmbiguousName);
            if(null != _DOT)  list.add(_DOT);
            if(null != _identifier)  list.add(_identifier);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitExpressionName(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitExpressionName(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitExpressionName(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitExpressionName(this, o); }
    }

/**
 *<em>
*<li>Rule 51:  MethodName ::= identifier
 *</em>
 *<p>
 *<b>
*<li>Rule 52:  MethodName ::= AmbiguousName . identifier
 *</b>
 */
class MethodName extends Ast implements IMethodName
    {
         late Ast _AmbiguousName;
         late AstToken _DOT;
         late identifier _identifier;

         Ast getAmbiguousName(){ return _AmbiguousName; }
         void setAmbiguousName(Ast _AmbiguousName){ this._AmbiguousName = _AmbiguousName; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }

        MethodName(IToken leftIToken, IToken rightIToken,
                   Ast _AmbiguousName,
                   AstToken _DOT,
                   identifier _identifier)
            :super(leftIToken, rightIToken)

        {
            this._AmbiguousName = _AmbiguousName;
            (_AmbiguousName as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _AmbiguousName)  list.add(_AmbiguousName);
            if(null != _DOT)  list.add(_DOT);
            if(null != _identifier)  list.add(_identifier);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitMethodName(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitMethodName(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitMethodName(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitMethodName(this, o); }
    }

/**
 *<em>
*<li>Rule 53:  PackageOrTypeName ::= identifier
 *</em>
 *<p>
 *<b>
*<li>Rule 54:  PackageOrTypeName ::= PackageOrTypeName . identifier
 *</b>
 */
class PackageOrTypeName extends Ast implements IPackageOrTypeName
    {
         late Ast _PackageOrTypeName;
         late AstToken _DOT;
         late identifier _identifier;

         Ast getPackageOrTypeName(){ return _PackageOrTypeName; }
         void setPackageOrTypeName(Ast _PackageOrTypeName){ this._PackageOrTypeName = _PackageOrTypeName; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }

        PackageOrTypeName(IToken leftIToken, IToken rightIToken,
                          Ast _PackageOrTypeName,
                          AstToken _DOT,
                          identifier _identifier)
            :super(leftIToken, rightIToken)

        {
            this._PackageOrTypeName = _PackageOrTypeName;
            (_PackageOrTypeName as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _PackageOrTypeName)  list.add(_PackageOrTypeName);
            if(null != _DOT)  list.add(_DOT);
            if(null != _identifier)  list.add(_identifier);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitPackageOrTypeName(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitPackageOrTypeName(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitPackageOrTypeName(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitPackageOrTypeName(this, o); }
    }

/**
 *<em>
*<li>Rule 55:  AmbiguousName ::= identifier
 *</em>
 *<p>
 *<b>
*<li>Rule 56:  AmbiguousName ::= AmbiguousName . identifier
 *</b>
 */
class AmbiguousName extends Ast implements IAmbiguousName
    {
         late Ast _AmbiguousName;
         late AstToken _DOT;
         late identifier _identifier;

         Ast getAmbiguousName(){ return _AmbiguousName; }
         void setAmbiguousName(Ast _AmbiguousName){ this._AmbiguousName = _AmbiguousName; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }

        AmbiguousName(IToken leftIToken, IToken rightIToken,
                      Ast _AmbiguousName,
                      AstToken _DOT,
                      identifier _identifier)
            :super(leftIToken, rightIToken)

        {
            this._AmbiguousName = _AmbiguousName;
            (_AmbiguousName as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _AmbiguousName)  list.add(_AmbiguousName);
            if(null != _DOT)  list.add(_DOT);
            if(null != _identifier)  list.add(_identifier);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitAmbiguousName(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitAmbiguousName(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitAmbiguousName(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitAmbiguousName(this, o); }
    }

/**
 *<b>
*<li>Rule 57:  CompilationUnit ::= PackageDeclarationopt ImportDeclarationsopt TypeDeclarationsopt
 *</b>
 */
class CompilationUnit extends Ast implements ICompilationUnit
    {
         late PackageDeclaration? _PackageDeclarationopt;
         late Ast? _ImportDeclarationsopt;
         late Ast? _TypeDeclarationsopt;

        /**
         * The value returned by <b>getPackageDeclarationopt</b> may be <b>null</b>
         */
         PackageDeclaration ?  getPackageDeclarationopt(){ return _PackageDeclarationopt; }
         void setPackageDeclarationopt(PackageDeclaration _PackageDeclarationopt){ this._PackageDeclarationopt = _PackageDeclarationopt; }
        /**
         * The value returned by <b>getImportDeclarationsopt</b> may be <b>null</b>
         */
         Ast ?  getImportDeclarationsopt(){ return _ImportDeclarationsopt; }
         void setImportDeclarationsopt(Ast _ImportDeclarationsopt){ this._ImportDeclarationsopt = _ImportDeclarationsopt; }
        /**
         * The value returned by <b>getTypeDeclarationsopt</b> may be <b>null</b>
         */
         Ast ?  getTypeDeclarationsopt(){ return _TypeDeclarationsopt; }
         void setTypeDeclarationsopt(Ast _TypeDeclarationsopt){ this._TypeDeclarationsopt = _TypeDeclarationsopt; }

        CompilationUnit(IToken leftIToken, IToken rightIToken,
                        PackageDeclaration? _PackageDeclarationopt,
                        Ast? _ImportDeclarationsopt,
                        Ast? _TypeDeclarationsopt)
            :super(leftIToken, rightIToken)

        {
            this._PackageDeclarationopt = _PackageDeclarationopt;
            if (null != _PackageDeclarationopt) (_PackageDeclarationopt as Ast).setParent(this);
            this._ImportDeclarationsopt = _ImportDeclarationsopt;
            if (null != _ImportDeclarationsopt) (_ImportDeclarationsopt as Ast).setParent(this);
            this._TypeDeclarationsopt = _TypeDeclarationsopt;
            if (null != _TypeDeclarationsopt) (_TypeDeclarationsopt as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _PackageDeclarationopt)  list.add(_PackageDeclarationopt);
            if(null != _ImportDeclarationsopt)  list.add(_ImportDeclarationsopt);
            if(null != _TypeDeclarationsopt)  list.add(_TypeDeclarationsopt);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitCompilationUnit(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitCompilationUnit(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitCompilationUnit(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitCompilationUnit(this, o); }
    }

/**
 *<em>
*<li>Rule 58:  ImportDeclarations ::= ImportDeclaration
 *</em>
 *<p>
 *<b>
*<li>Rule 59:  ImportDeclarations ::= ImportDeclarations ImportDeclaration
 *</b>
 */
class ImportDeclarations extends Ast implements IImportDeclarations
    {
         late Ast _ImportDeclarations;
         late Ast _ImportDeclaration;

         Ast getImportDeclarations(){ return _ImportDeclarations; }
         void setImportDeclarations(Ast _ImportDeclarations){ this._ImportDeclarations = _ImportDeclarations; }
         Ast getImportDeclaration(){ return _ImportDeclaration; }
         void setImportDeclaration(Ast _ImportDeclaration){ this._ImportDeclaration = _ImportDeclaration; }

        ImportDeclarations(IToken leftIToken, IToken rightIToken,
                           Ast _ImportDeclarations,
                           Ast _ImportDeclaration)
            :super(leftIToken, rightIToken)

        {
            this._ImportDeclarations = _ImportDeclarations;
            (_ImportDeclarations as Ast).setParent(this);
            this._ImportDeclaration = _ImportDeclaration;
            (_ImportDeclaration as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ImportDeclarations)  list.add(_ImportDeclarations);
            if(null != _ImportDeclaration)  list.add(_ImportDeclaration);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitImportDeclarations(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitImportDeclarations(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitImportDeclarations(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitImportDeclarations(this, o); }
    }

/**
 *<em>
*<li>Rule 60:  TypeDeclarations ::= TypeDeclaration
 *</em>
 *<p>
 *<b>
*<li>Rule 61:  TypeDeclarations ::= TypeDeclarations TypeDeclaration
 *</b>
 */
class TypeDeclarations extends Ast implements ITypeDeclarations
    {
         late Ast _TypeDeclarations;
         late Ast _TypeDeclaration;

         Ast getTypeDeclarations(){ return _TypeDeclarations; }
         void setTypeDeclarations(Ast _TypeDeclarations){ this._TypeDeclarations = _TypeDeclarations; }
         Ast getTypeDeclaration(){ return _TypeDeclaration; }
         void setTypeDeclaration(Ast _TypeDeclaration){ this._TypeDeclaration = _TypeDeclaration; }

        TypeDeclarations(IToken leftIToken, IToken rightIToken,
                         Ast _TypeDeclarations,
                         Ast _TypeDeclaration)
            :super(leftIToken, rightIToken)

        {
            this._TypeDeclarations = _TypeDeclarations;
            (_TypeDeclarations as Ast).setParent(this);
            this._TypeDeclaration = _TypeDeclaration;
            (_TypeDeclaration as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _TypeDeclarations)  list.add(_TypeDeclarations);
            if(null != _TypeDeclaration)  list.add(_TypeDeclaration);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitTypeDeclarations(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitTypeDeclarations(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitTypeDeclarations(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitTypeDeclarations(this, o); }
    }

/**
 *<b>
*<li>Rule 62:  PackageDeclaration ::= Annotationsopt package PackageName ;
 *</b>
 */
class PackageDeclaration extends Ast implements IPackageDeclaration
    {
         late Ast? _Annotationsopt;
         late AstToken _package;
         late Ast _PackageName;
         late AstToken _SEMICOLON;

        /**
         * The value returned by <b>getAnnotationsopt</b> may be <b>null</b>
         */
         Ast ?  getAnnotationsopt(){ return _Annotationsopt; }
         void setAnnotationsopt(Ast _Annotationsopt){ this._Annotationsopt = _Annotationsopt; }
         AstToken getpackage(){ return _package; }
         void setpackage(AstToken _package){ this._package = _package; }
         Ast getPackageName(){ return _PackageName; }
         void setPackageName(Ast _PackageName){ this._PackageName = _PackageName; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        PackageDeclaration(IToken leftIToken, IToken rightIToken,
                           Ast? _Annotationsopt,
                           AstToken _package,
                           Ast _PackageName,
                           AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._Annotationsopt = _Annotationsopt;
            if (null != _Annotationsopt) (_Annotationsopt as Ast).setParent(this);
            this._package = _package;
            (_package as Ast).setParent(this);
            this._PackageName = _PackageName;
            (_PackageName as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _Annotationsopt)  list.add(_Annotationsopt);
            if(null != _package)  list.add(_package);
            if(null != _PackageName)  list.add(_PackageName);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitPackageDeclaration(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitPackageDeclaration(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitPackageDeclaration(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitPackageDeclaration(this, o); }
    }

/**
 *<b>
*<li>Rule 67:  SingleTypeImportDeclaration ::= import TypeName ;
 *</b>
 */
class SingleTypeImportDeclaration extends Ast implements ISingleTypeImportDeclaration
    {
         late AstToken _import;
         late Ast _TypeName;
         late AstToken _SEMICOLON;

         AstToken getimport(){ return _import; }
         void setimport(AstToken _import){ this._import = _import; }
         Ast getTypeName(){ return _TypeName; }
         void setTypeName(Ast _TypeName){ this._TypeName = _TypeName; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        SingleTypeImportDeclaration(IToken leftIToken, IToken rightIToken,
                                    AstToken _import,
                                    Ast _TypeName,
                                    AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._import = _import;
            (_import as Ast).setParent(this);
            this._TypeName = _TypeName;
            (_TypeName as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _import)  list.add(_import);
            if(null != _TypeName)  list.add(_TypeName);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitSingleTypeImportDeclaration(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitSingleTypeImportDeclaration(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitSingleTypeImportDeclaration(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitSingleTypeImportDeclaration(this, o); }
    }

/**
 *<b>
*<li>Rule 68:  TypeImportOnDemandDeclaration ::= import PackageOrTypeName . * ;
 *</b>
 */
class TypeImportOnDemandDeclaration extends Ast implements ITypeImportOnDemandDeclaration
    {
         late AstToken _import;
         late Ast _PackageOrTypeName;
         late AstToken _DOT;
         late AstToken _MULTIPLY;
         late AstToken _SEMICOLON;

         AstToken getimport(){ return _import; }
         void setimport(AstToken _import){ this._import = _import; }
         Ast getPackageOrTypeName(){ return _PackageOrTypeName; }
         void setPackageOrTypeName(Ast _PackageOrTypeName){ this._PackageOrTypeName = _PackageOrTypeName; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
         AstToken getMULTIPLY(){ return _MULTIPLY; }
         void setMULTIPLY(AstToken _MULTIPLY){ this._MULTIPLY = _MULTIPLY; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        TypeImportOnDemandDeclaration(IToken leftIToken, IToken rightIToken,
                                      AstToken _import,
                                      Ast _PackageOrTypeName,
                                      AstToken _DOT,
                                      AstToken _MULTIPLY,
                                      AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._import = _import;
            (_import as Ast).setParent(this);
            this._PackageOrTypeName = _PackageOrTypeName;
            (_PackageOrTypeName as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._MULTIPLY = _MULTIPLY;
            (_MULTIPLY as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _import)  list.add(_import);
            if(null != _PackageOrTypeName)  list.add(_PackageOrTypeName);
            if(null != _DOT)  list.add(_DOT);
            if(null != _MULTIPLY)  list.add(_MULTIPLY);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitTypeImportOnDemandDeclaration(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitTypeImportOnDemandDeclaration(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitTypeImportOnDemandDeclaration(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitTypeImportOnDemandDeclaration(this, o); }
    }

/**
 *<b>
*<li>Rule 69:  SingleStaticImportDeclaration ::= import static TypeName . identifier ;
 *</b>
 */
class SingleStaticImportDeclaration extends Ast implements ISingleStaticImportDeclaration
    {
         late AstToken _import;
         late AstToken _static;
         late Ast _TypeName;
         late AstToken _DOT;
         late identifier _identifier;
         late AstToken _SEMICOLON;

         AstToken getimport(){ return _import; }
         void setimport(AstToken _import){ this._import = _import; }
         AstToken getstatic(){ return _static; }
         void setstatic(AstToken _static){ this._static = _static; }
         Ast getTypeName(){ return _TypeName; }
         void setTypeName(Ast _TypeName){ this._TypeName = _TypeName; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        SingleStaticImportDeclaration(IToken leftIToken, IToken rightIToken,
                                      AstToken _import,
                                      AstToken _static,
                                      Ast _TypeName,
                                      AstToken _DOT,
                                      identifier _identifier,
                                      AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._import = _import;
            (_import as Ast).setParent(this);
            this._static = _static;
            (_static as Ast).setParent(this);
            this._TypeName = _TypeName;
            (_TypeName as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _import)  list.add(_import);
            if(null != _static)  list.add(_static);
            if(null != _TypeName)  list.add(_TypeName);
            if(null != _DOT)  list.add(_DOT);
            if(null != _identifier)  list.add(_identifier);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitSingleStaticImportDeclaration(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitSingleStaticImportDeclaration(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitSingleStaticImportDeclaration(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitSingleStaticImportDeclaration(this, o); }
    }

/**
 *<b>
*<li>Rule 70:  StaticImportOnDemandDeclaration ::= import static TypeName . * ;
 *</b>
 */
class StaticImportOnDemandDeclaration extends Ast implements IStaticImportOnDemandDeclaration
    {
         late AstToken _import;
         late AstToken _static;
         late Ast _TypeName;
         late AstToken _DOT;
         late AstToken _MULTIPLY;
         late AstToken _SEMICOLON;

         AstToken getimport(){ return _import; }
         void setimport(AstToken _import){ this._import = _import; }
         AstToken getstatic(){ return _static; }
         void setstatic(AstToken _static){ this._static = _static; }
         Ast getTypeName(){ return _TypeName; }
         void setTypeName(Ast _TypeName){ this._TypeName = _TypeName; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
         AstToken getMULTIPLY(){ return _MULTIPLY; }
         void setMULTIPLY(AstToken _MULTIPLY){ this._MULTIPLY = _MULTIPLY; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        StaticImportOnDemandDeclaration(IToken leftIToken, IToken rightIToken,
                                        AstToken _import,
                                        AstToken _static,
                                        Ast _TypeName,
                                        AstToken _DOT,
                                        AstToken _MULTIPLY,
                                        AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._import = _import;
            (_import as Ast).setParent(this);
            this._static = _static;
            (_static as Ast).setParent(this);
            this._TypeName = _TypeName;
            (_TypeName as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._MULTIPLY = _MULTIPLY;
            (_MULTIPLY as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _import)  list.add(_import);
            if(null != _static)  list.add(_static);
            if(null != _TypeName)  list.add(_TypeName);
            if(null != _DOT)  list.add(_DOT);
            if(null != _MULTIPLY)  list.add(_MULTIPLY);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitStaticImportOnDemandDeclaration(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitStaticImportOnDemandDeclaration(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitStaticImportOnDemandDeclaration(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitStaticImportOnDemandDeclaration(this, o); }
    }

/**
 *<em>
*<li>Rule 71:  TypeDeclaration ::= ClassDeclaration
*<li>Rule 72:  TypeDeclaration ::= InterfaceDeclaration
 *</em>
 *<p>
 *<b>
*<li>Rule 73:  TypeDeclaration ::= ;
 *</b>
 */
class TypeDeclaration extends AstToken implements ITypeDeclaration
    {
         IToken getSEMICOLON(){ return leftIToken; }

    TypeDeclaration(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitTypeDeclaration(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitTypeDeclaration(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitTypeDeclaration(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitTypeDeclaration(this, o); }
    }

/**
 *<b>
*<li>Rule 76:  NormalClassDeclaration ::= ClassModifiersopt class identifier TypeParametersopt Superopt Interfacesopt ClassBody
 *</b>
 */
class NormalClassDeclaration extends Ast implements INormalClassDeclaration
    {
         late Ast? _ClassModifiersopt;
         late AstToken _class;
         late identifier _identifier;
         late TypeParameters? _TypeParametersopt;
         late Super? _Superopt;
         late Interfaces? _Interfacesopt;
         late ClassBody _ClassBody;

        /**
         * The value returned by <b>getClassModifiersopt</b> may be <b>null</b>
         */
         Ast ?  getClassModifiersopt(){ return _ClassModifiersopt; }
         void setClassModifiersopt(Ast _ClassModifiersopt){ this._ClassModifiersopt = _ClassModifiersopt; }
         AstToken getclass(){ return _class; }
         void setclass(AstToken _class){ this._class = _class; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }
        /**
         * The value returned by <b>getTypeParametersopt</b> may be <b>null</b>
         */
         TypeParameters ?  getTypeParametersopt(){ return _TypeParametersopt; }
         void setTypeParametersopt(TypeParameters _TypeParametersopt){ this._TypeParametersopt = _TypeParametersopt; }
        /**
         * The value returned by <b>getSuperopt</b> may be <b>null</b>
         */
         Super ?  getSuperopt(){ return _Superopt; }
         void setSuperopt(Super _Superopt){ this._Superopt = _Superopt; }
        /**
         * The value returned by <b>getInterfacesopt</b> may be <b>null</b>
         */
         Interfaces ?  getInterfacesopt(){ return _Interfacesopt; }
         void setInterfacesopt(Interfaces _Interfacesopt){ this._Interfacesopt = _Interfacesopt; }
         ClassBody getClassBody(){ return _ClassBody; }
         void setClassBody(ClassBody _ClassBody){ this._ClassBody = _ClassBody; }

        NormalClassDeclaration(IToken leftIToken, IToken rightIToken,
                               Ast? _ClassModifiersopt,
                               AstToken _class,
                               identifier _identifier,
                               TypeParameters? _TypeParametersopt,
                               Super? _Superopt,
                               Interfaces? _Interfacesopt,
                               ClassBody _ClassBody)
            :super(leftIToken, rightIToken)

        {
            this._ClassModifiersopt = _ClassModifiersopt;
            if (null != _ClassModifiersopt) (_ClassModifiersopt as Ast).setParent(this);
            this._class = _class;
            (_class as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            this._TypeParametersopt = _TypeParametersopt;
            if (null != _TypeParametersopt) (_TypeParametersopt as Ast).setParent(this);
            this._Superopt = _Superopt;
            if (null != _Superopt) (_Superopt as Ast).setParent(this);
            this._Interfacesopt = _Interfacesopt;
            if (null != _Interfacesopt) (_Interfacesopt as Ast).setParent(this);
            this._ClassBody = _ClassBody;
            (_ClassBody as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ClassModifiersopt)  list.add(_ClassModifiersopt);
            if(null != _class)  list.add(_class);
            if(null != _identifier)  list.add(_identifier);
            if(null != _TypeParametersopt)  list.add(_TypeParametersopt);
            if(null != _Superopt)  list.add(_Superopt);
            if(null != _Interfacesopt)  list.add(_Interfacesopt);
            if(null != _ClassBody)  list.add(_ClassBody);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitNormalClassDeclaration(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitNormalClassDeclaration(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitNormalClassDeclaration(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitNormalClassDeclaration(this, o); }
    }

/**
 *<em>
*<li>Rule 77:  ClassModifiers ::= ClassModifier
 *</em>
 *<p>
 *<b>
*<li>Rule 78:  ClassModifiers ::= ClassModifiers ClassModifier
 *</b>
 */
class ClassModifiers extends Ast implements IClassModifiers
    {
         late Ast _ClassModifiers;
         late Ast _ClassModifier;

         Ast getClassModifiers(){ return _ClassModifiers; }
         void setClassModifiers(Ast _ClassModifiers){ this._ClassModifiers = _ClassModifiers; }
         Ast getClassModifier(){ return _ClassModifier; }
         void setClassModifier(Ast _ClassModifier){ this._ClassModifier = _ClassModifier; }

        ClassModifiers(IToken leftIToken, IToken rightIToken,
                       Ast _ClassModifiers,
                       Ast _ClassModifier)
            :super(leftIToken, rightIToken)

        {
            this._ClassModifiers = _ClassModifiers;
            (_ClassModifiers as Ast).setParent(this);
            this._ClassModifier = _ClassModifier;
            (_ClassModifier as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ClassModifiers)  list.add(_ClassModifiers);
            if(null != _ClassModifier)  list.add(_ClassModifier);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitClassModifiers(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitClassModifiers(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitClassModifiers(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitClassModifiers(this, o); }
    }

/**
 *<b>
*<li>Rule 87:  TypeParameters ::= < TypeParameterList >
 *</b>
 */
class TypeParameters extends Ast implements ITypeParameters
    {
         late AstToken _LESS;
         late Ast _TypeParameterList;
         late AstToken _GREATER;

         AstToken getLESS(){ return _LESS; }
         void setLESS(AstToken _LESS){ this._LESS = _LESS; }
         Ast getTypeParameterList(){ return _TypeParameterList; }
         void setTypeParameterList(Ast _TypeParameterList){ this._TypeParameterList = _TypeParameterList; }
         AstToken getGREATER(){ return _GREATER; }
         void setGREATER(AstToken _GREATER){ this._GREATER = _GREATER; }

        TypeParameters(IToken leftIToken, IToken rightIToken,
                       AstToken _LESS,
                       Ast _TypeParameterList,
                       AstToken _GREATER)
            :super(leftIToken, rightIToken)

        {
            this._LESS = _LESS;
            (_LESS as Ast).setParent(this);
            this._TypeParameterList = _TypeParameterList;
            (_TypeParameterList as Ast).setParent(this);
            this._GREATER = _GREATER;
            (_GREATER as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _LESS)  list.add(_LESS);
            if(null != _TypeParameterList)  list.add(_TypeParameterList);
            if(null != _GREATER)  list.add(_GREATER);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitTypeParameters(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitTypeParameters(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitTypeParameters(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitTypeParameters(this, o); }
    }

/**
 *<em>
*<li>Rule 88:  TypeParameterList ::= TypeParameter
 *</em>
 *<p>
 *<b>
*<li>Rule 89:  TypeParameterList ::= TypeParameterList , TypeParameter
 *</b>
 */
class TypeParameterList extends Ast implements ITypeParameterList
    {
         late Ast _TypeParameterList;
         late AstToken _COMMA;
         late TypeParameter _TypeParameter;

         Ast getTypeParameterList(){ return _TypeParameterList; }
         void setTypeParameterList(Ast _TypeParameterList){ this._TypeParameterList = _TypeParameterList; }
         AstToken getCOMMA(){ return _COMMA; }
         void setCOMMA(AstToken _COMMA){ this._COMMA = _COMMA; }
         TypeParameter getTypeParameter(){ return _TypeParameter; }
         void setTypeParameter(TypeParameter _TypeParameter){ this._TypeParameter = _TypeParameter; }

        TypeParameterList(IToken leftIToken, IToken rightIToken,
                          Ast _TypeParameterList,
                          AstToken _COMMA,
                          TypeParameter _TypeParameter)
            :super(leftIToken, rightIToken)

        {
            this._TypeParameterList = _TypeParameterList;
            (_TypeParameterList as Ast).setParent(this);
            this._COMMA = _COMMA;
            (_COMMA as Ast).setParent(this);
            this._TypeParameter = _TypeParameter;
            (_TypeParameter as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _TypeParameterList)  list.add(_TypeParameterList);
            if(null != _COMMA)  list.add(_COMMA);
            if(null != _TypeParameter)  list.add(_TypeParameter);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitTypeParameterList(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitTypeParameterList(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitTypeParameterList(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitTypeParameterList(this, o); }
    }

/**
 *<b>
*<li>Rule 90:  Super ::= extends ClassType
 *</b>
 */
class Super extends Ast implements ISuper
    {
         late AstToken _extends;
         late ClassType _ClassType;

         AstToken getextends(){ return _extends; }
         void setextends(AstToken _extends){ this._extends = _extends; }
         ClassType getClassType(){ return _ClassType; }
         void setClassType(ClassType _ClassType){ this._ClassType = _ClassType; }

        Super(IToken leftIToken, IToken rightIToken,
              AstToken _extends,
              ClassType _ClassType)
            :super(leftIToken, rightIToken)

        {
            this._extends = _extends;
            (_extends as Ast).setParent(this);
            this._ClassType = _ClassType;
            (_ClassType as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _extends)  list.add(_extends);
            if(null != _ClassType)  list.add(_ClassType);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitSuper(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitSuper(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitSuper(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitSuper(this, o); }
    }

/**
 *<b>
*<li>Rule 91:  Interfaces ::= implements InterfaceTypeList
 *</b>
 */
class Interfaces extends Ast implements IInterfaces
    {
         late AstToken _implements;
         late Ast _InterfaceTypeList;

         AstToken getimplements(){ return _implements; }
         void setimplements(AstToken _implements){ this._implements = _implements; }
         Ast getInterfaceTypeList(){ return _InterfaceTypeList; }
         void setInterfaceTypeList(Ast _InterfaceTypeList){ this._InterfaceTypeList = _InterfaceTypeList; }

        Interfaces(IToken leftIToken, IToken rightIToken,
                   AstToken _implements,
                   Ast _InterfaceTypeList)
            :super(leftIToken, rightIToken)

        {
            this._implements = _implements;
            (_implements as Ast).setParent(this);
            this._InterfaceTypeList = _InterfaceTypeList;
            (_InterfaceTypeList as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _implements)  list.add(_implements);
            if(null != _InterfaceTypeList)  list.add(_InterfaceTypeList);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitInterfaces(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitInterfaces(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitInterfaces(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitInterfaces(this, o); }
    }

/**
 *<em>
*<li>Rule 92:  InterfaceTypeList ::= InterfaceType
 *</em>
 *<p>
 *<b>
*<li>Rule 93:  InterfaceTypeList ::= InterfaceTypeList , InterfaceType
 *</b>
 */
class InterfaceTypeList extends Ast implements IInterfaceTypeList
    {
         late Ast _InterfaceTypeList;
         late AstToken _COMMA;
         late InterfaceType _InterfaceType;

         Ast getInterfaceTypeList(){ return _InterfaceTypeList; }
         void setInterfaceTypeList(Ast _InterfaceTypeList){ this._InterfaceTypeList = _InterfaceTypeList; }
         AstToken getCOMMA(){ return _COMMA; }
         void setCOMMA(AstToken _COMMA){ this._COMMA = _COMMA; }
         InterfaceType getInterfaceType(){ return _InterfaceType; }
         void setInterfaceType(InterfaceType _InterfaceType){ this._InterfaceType = _InterfaceType; }

        InterfaceTypeList(IToken leftIToken, IToken rightIToken,
                          Ast _InterfaceTypeList,
                          AstToken _COMMA,
                          InterfaceType _InterfaceType)
            :super(leftIToken, rightIToken)

        {
            this._InterfaceTypeList = _InterfaceTypeList;
            (_InterfaceTypeList as Ast).setParent(this);
            this._COMMA = _COMMA;
            (_COMMA as Ast).setParent(this);
            this._InterfaceType = _InterfaceType;
            (_InterfaceType as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _InterfaceTypeList)  list.add(_InterfaceTypeList);
            if(null != _COMMA)  list.add(_COMMA);
            if(null != _InterfaceType)  list.add(_InterfaceType);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitInterfaceTypeList(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitInterfaceTypeList(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitInterfaceTypeList(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitInterfaceTypeList(this, o); }
    }

/**
 *<b>
*<li>Rule 94:  ClassBody ::= { ClassBodyDeclarationsopt }
 *</b>
 */
class ClassBody extends Ast implements IClassBody
    {
         late AstToken _LBRACE;
         late Ast? _ClassBodyDeclarationsopt;
         late AstToken _RBRACE;

         AstToken getLBRACE(){ return _LBRACE; }
         void setLBRACE(AstToken _LBRACE){ this._LBRACE = _LBRACE; }
        /**
         * The value returned by <b>getClassBodyDeclarationsopt</b> may be <b>null</b>
         */
         Ast ?  getClassBodyDeclarationsopt(){ return _ClassBodyDeclarationsopt; }
         void setClassBodyDeclarationsopt(Ast _ClassBodyDeclarationsopt){ this._ClassBodyDeclarationsopt = _ClassBodyDeclarationsopt; }
         AstToken getRBRACE(){ return _RBRACE; }
         void setRBRACE(AstToken _RBRACE){ this._RBRACE = _RBRACE; }

        ClassBody(IToken leftIToken, IToken rightIToken,
                  AstToken _LBRACE,
                  Ast? _ClassBodyDeclarationsopt,
                  AstToken _RBRACE)
            :super(leftIToken, rightIToken)

        {
            this._LBRACE = _LBRACE;
            (_LBRACE as Ast).setParent(this);
            this._ClassBodyDeclarationsopt = _ClassBodyDeclarationsopt;
            if (null != _ClassBodyDeclarationsopt) (_ClassBodyDeclarationsopt as Ast).setParent(this);
            this._RBRACE = _RBRACE;
            (_RBRACE as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _LBRACE)  list.add(_LBRACE);
            if(null != _ClassBodyDeclarationsopt)  list.add(_ClassBodyDeclarationsopt);
            if(null != _RBRACE)  list.add(_RBRACE);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitClassBody(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitClassBody(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitClassBody(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitClassBody(this, o); }
    }

/**
 *<em>
*<li>Rule 95:  ClassBodyDeclarations ::= ClassBodyDeclaration
 *</em>
 *<p>
 *<b>
*<li>Rule 96:  ClassBodyDeclarations ::= ClassBodyDeclarations ClassBodyDeclaration
 *</b>
 */
class ClassBodyDeclarations extends Ast implements IClassBodyDeclarations
    {
         late Ast _ClassBodyDeclarations;
         late Ast _ClassBodyDeclaration;

         Ast getClassBodyDeclarations(){ return _ClassBodyDeclarations; }
         void setClassBodyDeclarations(Ast _ClassBodyDeclarations){ this._ClassBodyDeclarations = _ClassBodyDeclarations; }
         Ast getClassBodyDeclaration(){ return _ClassBodyDeclaration; }
         void setClassBodyDeclaration(Ast _ClassBodyDeclaration){ this._ClassBodyDeclaration = _ClassBodyDeclaration; }

        ClassBodyDeclarations(IToken leftIToken, IToken rightIToken,
                              Ast _ClassBodyDeclarations,
                              Ast _ClassBodyDeclaration)
            :super(leftIToken, rightIToken)

        {
            this._ClassBodyDeclarations = _ClassBodyDeclarations;
            (_ClassBodyDeclarations as Ast).setParent(this);
            this._ClassBodyDeclaration = _ClassBodyDeclaration;
            (_ClassBodyDeclaration as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ClassBodyDeclarations)  list.add(_ClassBodyDeclarations);
            if(null != _ClassBodyDeclaration)  list.add(_ClassBodyDeclaration);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitClassBodyDeclarations(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitClassBodyDeclarations(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitClassBodyDeclarations(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitClassBodyDeclarations(this, o); }
    }

/**
 *<em>
*<li>Rule 101:  ClassMemberDeclaration ::= FieldDeclaration
*<li>Rule 102:  ClassMemberDeclaration ::= MethodDeclaration
*<li>Rule 103:  ClassMemberDeclaration ::= ClassDeclaration
*<li>Rule 104:  ClassMemberDeclaration ::= InterfaceDeclaration
 *</em>
 *<p>
 *<b>
*<li>Rule 105:  ClassMemberDeclaration ::= ;
 *</b>
 */
class ClassMemberDeclaration extends AstToken implements IClassMemberDeclaration
    {
         IToken getSEMICOLON(){ return leftIToken; }

    ClassMemberDeclaration(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitClassMemberDeclaration(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitClassMemberDeclaration(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitClassMemberDeclaration(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitClassMemberDeclaration(this, o); }
    }

/**
 *<b>
*<li>Rule 106:  FieldDeclaration ::= FieldModifiersopt Type VariableDeclarators ;
 *</b>
 */
class FieldDeclaration extends Ast implements IFieldDeclaration
    {
         late Ast? _FieldModifiersopt;
         late Ast _Type;
         late Ast _VariableDeclarators;
         late AstToken _SEMICOLON;

        /**
         * The value returned by <b>getFieldModifiersopt</b> may be <b>null</b>
         */
         Ast ?  getFieldModifiersopt(){ return _FieldModifiersopt; }
         void setFieldModifiersopt(Ast _FieldModifiersopt){ this._FieldModifiersopt = _FieldModifiersopt; }
         Ast getType(){ return _Type; }
         void setType(Ast _Type){ this._Type = _Type; }
         Ast getVariableDeclarators(){ return _VariableDeclarators; }
         void setVariableDeclarators(Ast _VariableDeclarators){ this._VariableDeclarators = _VariableDeclarators; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        FieldDeclaration(IToken leftIToken, IToken rightIToken,
                         Ast? _FieldModifiersopt,
                         Ast _Type,
                         Ast _VariableDeclarators,
                         AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._FieldModifiersopt = _FieldModifiersopt;
            if (null != _FieldModifiersopt) (_FieldModifiersopt as Ast).setParent(this);
            this._Type = _Type;
            (_Type as Ast).setParent(this);
            this._VariableDeclarators = _VariableDeclarators;
            (_VariableDeclarators as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _FieldModifiersopt)  list.add(_FieldModifiersopt);
            if(null != _Type)  list.add(_Type);
            if(null != _VariableDeclarators)  list.add(_VariableDeclarators);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitFieldDeclaration(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitFieldDeclaration(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitFieldDeclaration(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitFieldDeclaration(this, o); }
    }

/**
 *<em>
*<li>Rule 107:  VariableDeclarators ::= VariableDeclarator
 *</em>
 *<p>
 *<b>
*<li>Rule 108:  VariableDeclarators ::= VariableDeclarators , VariableDeclarator
 *</b>
 */
class VariableDeclarators extends Ast implements IVariableDeclarators
    {
         late Ast _VariableDeclarators;
         late AstToken _COMMA;
         late Ast _VariableDeclarator;

         Ast getVariableDeclarators(){ return _VariableDeclarators; }
         void setVariableDeclarators(Ast _VariableDeclarators){ this._VariableDeclarators = _VariableDeclarators; }
         AstToken getCOMMA(){ return _COMMA; }
         void setCOMMA(AstToken _COMMA){ this._COMMA = _COMMA; }
         Ast getVariableDeclarator(){ return _VariableDeclarator; }
         void setVariableDeclarator(Ast _VariableDeclarator){ this._VariableDeclarator = _VariableDeclarator; }

        VariableDeclarators(IToken leftIToken, IToken rightIToken,
                            Ast _VariableDeclarators,
                            AstToken _COMMA,
                            Ast _VariableDeclarator)
            :super(leftIToken, rightIToken)

        {
            this._VariableDeclarators = _VariableDeclarators;
            (_VariableDeclarators as Ast).setParent(this);
            this._COMMA = _COMMA;
            (_COMMA as Ast).setParent(this);
            this._VariableDeclarator = _VariableDeclarator;
            (_VariableDeclarator as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _VariableDeclarators)  list.add(_VariableDeclarators);
            if(null != _COMMA)  list.add(_COMMA);
            if(null != _VariableDeclarator)  list.add(_VariableDeclarator);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitVariableDeclarators(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitVariableDeclarators(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitVariableDeclarators(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitVariableDeclarators(this, o); }
    }

/**
 *<em>
*<li>Rule 109:  VariableDeclarator ::= VariableDeclaratorId
 *</em>
 *<p>
 *<b>
*<li>Rule 110:  VariableDeclarator ::= VariableDeclaratorId = VariableInitializer
 *</b>
 */
class VariableDeclarator extends Ast implements IVariableDeclarator
    {
         late Ast _VariableDeclaratorId;
         late AstToken _EQUAL;
         late Ast _VariableInitializer;

         Ast getVariableDeclaratorId(){ return _VariableDeclaratorId; }
         void setVariableDeclaratorId(Ast _VariableDeclaratorId){ this._VariableDeclaratorId = _VariableDeclaratorId; }
         AstToken getEQUAL(){ return _EQUAL; }
         void setEQUAL(AstToken _EQUAL){ this._EQUAL = _EQUAL; }
         Ast getVariableInitializer(){ return _VariableInitializer; }
         void setVariableInitializer(Ast _VariableInitializer){ this._VariableInitializer = _VariableInitializer; }

        VariableDeclarator(IToken leftIToken, IToken rightIToken,
                           Ast _VariableDeclaratorId,
                           AstToken _EQUAL,
                           Ast _VariableInitializer)
            :super(leftIToken, rightIToken)

        {
            this._VariableDeclaratorId = _VariableDeclaratorId;
            (_VariableDeclaratorId as Ast).setParent(this);
            this._EQUAL = _EQUAL;
            (_EQUAL as Ast).setParent(this);
            this._VariableInitializer = _VariableInitializer;
            (_VariableInitializer as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _VariableDeclaratorId)  list.add(_VariableDeclaratorId);
            if(null != _EQUAL)  list.add(_EQUAL);
            if(null != _VariableInitializer)  list.add(_VariableInitializer);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitVariableDeclarator(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitVariableDeclarator(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitVariableDeclarator(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitVariableDeclarator(this, o); }
    }

/**
 *<em>
*<li>Rule 111:  VariableDeclaratorId ::= identifier
 *</em>
 *<p>
 *<b>
*<li>Rule 112:  VariableDeclaratorId ::= VariableDeclaratorId [ ]
 *</b>
 */
class VariableDeclaratorId extends Ast implements IVariableDeclaratorId
    {
         late Ast _VariableDeclaratorId;
         late AstToken _LBRACKET;
         late AstToken _RBRACKET;

         Ast getVariableDeclaratorId(){ return _VariableDeclaratorId; }
         void setVariableDeclaratorId(Ast _VariableDeclaratorId){ this._VariableDeclaratorId = _VariableDeclaratorId; }
         AstToken getLBRACKET(){ return _LBRACKET; }
         void setLBRACKET(AstToken _LBRACKET){ this._LBRACKET = _LBRACKET; }
         AstToken getRBRACKET(){ return _RBRACKET; }
         void setRBRACKET(AstToken _RBRACKET){ this._RBRACKET = _RBRACKET; }

        VariableDeclaratorId(IToken leftIToken, IToken rightIToken,
                             Ast _VariableDeclaratorId,
                             AstToken _LBRACKET,
                             AstToken _RBRACKET)
            :super(leftIToken, rightIToken)

        {
            this._VariableDeclaratorId = _VariableDeclaratorId;
            (_VariableDeclaratorId as Ast).setParent(this);
            this._LBRACKET = _LBRACKET;
            (_LBRACKET as Ast).setParent(this);
            this._RBRACKET = _RBRACKET;
            (_RBRACKET as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _VariableDeclaratorId)  list.add(_VariableDeclaratorId);
            if(null != _LBRACKET)  list.add(_LBRACKET);
            if(null != _RBRACKET)  list.add(_RBRACKET);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitVariableDeclaratorId(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitVariableDeclaratorId(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitVariableDeclaratorId(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitVariableDeclaratorId(this, o); }
    }

/**
 *<em>
*<li>Rule 115:  FieldModifiers ::= FieldModifier
 *</em>
 *<p>
 *<b>
*<li>Rule 116:  FieldModifiers ::= FieldModifiers FieldModifier
 *</b>
 */
class FieldModifiers extends Ast implements IFieldModifiers
    {
         late Ast _FieldModifiers;
         late Ast _FieldModifier;

         Ast getFieldModifiers(){ return _FieldModifiers; }
         void setFieldModifiers(Ast _FieldModifiers){ this._FieldModifiers = _FieldModifiers; }
         Ast getFieldModifier(){ return _FieldModifier; }
         void setFieldModifier(Ast _FieldModifier){ this._FieldModifier = _FieldModifier; }

        FieldModifiers(IToken leftIToken, IToken rightIToken,
                       Ast _FieldModifiers,
                       Ast _FieldModifier)
            :super(leftIToken, rightIToken)

        {
            this._FieldModifiers = _FieldModifiers;
            (_FieldModifiers as Ast).setParent(this);
            this._FieldModifier = _FieldModifier;
            (_FieldModifier as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _FieldModifiers)  list.add(_FieldModifiers);
            if(null != _FieldModifier)  list.add(_FieldModifier);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitFieldModifiers(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitFieldModifiers(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitFieldModifiers(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitFieldModifiers(this, o); }
    }

/**
 *<b>
*<li>Rule 125:  MethodDeclaration ::= MethodHeader MethodBody
 *</b>
 */
class MethodDeclaration extends Ast implements IMethodDeclaration
    {
         late MethodHeader _MethodHeader;
         late Ast _MethodBody;

         MethodHeader getMethodHeader(){ return _MethodHeader; }
         void setMethodHeader(MethodHeader _MethodHeader){ this._MethodHeader = _MethodHeader; }
         Ast getMethodBody(){ return _MethodBody; }
         void setMethodBody(Ast _MethodBody){ this._MethodBody = _MethodBody; }

        MethodDeclaration(IToken leftIToken, IToken rightIToken,
                          MethodHeader _MethodHeader,
                          Ast _MethodBody)
            :super(leftIToken, rightIToken)

        {
            this._MethodHeader = _MethodHeader;
            (_MethodHeader as Ast).setParent(this);
            this._MethodBody = _MethodBody;
            (_MethodBody as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _MethodHeader)  list.add(_MethodHeader);
            if(null != _MethodBody)  list.add(_MethodBody);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitMethodDeclaration(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitMethodDeclaration(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitMethodDeclaration(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitMethodDeclaration(this, o); }
    }

/**
 *<b>
*<li>Rule 126:  MethodHeader ::= MethodModifiersopt TypeParametersopt ResultType MethodDeclarator Throwsopt
 *</b>
 */
class MethodHeader extends Ast implements IMethodHeader
    {
         late Ast? _MethodModifiersopt;
         late TypeParameters? _TypeParametersopt;
         late Ast _ResultType;
         late Ast _MethodDeclarator;
         late Throws? _Throwsopt;

        /**
         * The value returned by <b>getMethodModifiersopt</b> may be <b>null</b>
         */
         Ast ?  getMethodModifiersopt(){ return _MethodModifiersopt; }
         void setMethodModifiersopt(Ast _MethodModifiersopt){ this._MethodModifiersopt = _MethodModifiersopt; }
        /**
         * The value returned by <b>getTypeParametersopt</b> may be <b>null</b>
         */
         TypeParameters ?  getTypeParametersopt(){ return _TypeParametersopt; }
         void setTypeParametersopt(TypeParameters _TypeParametersopt){ this._TypeParametersopt = _TypeParametersopt; }
         Ast getResultType(){ return _ResultType; }
         void setResultType(Ast _ResultType){ this._ResultType = _ResultType; }
         Ast getMethodDeclarator(){ return _MethodDeclarator; }
         void setMethodDeclarator(Ast _MethodDeclarator){ this._MethodDeclarator = _MethodDeclarator; }
        /**
         * The value returned by <b>getThrowsopt</b> may be <b>null</b>
         */
         Throws ?  getThrowsopt(){ return _Throwsopt; }
         void setThrowsopt(Throws _Throwsopt){ this._Throwsopt = _Throwsopt; }

        MethodHeader(IToken leftIToken, IToken rightIToken,
                     Ast? _MethodModifiersopt,
                     TypeParameters? _TypeParametersopt,
                     Ast _ResultType,
                     Ast _MethodDeclarator,
                     Throws? _Throwsopt)
            :super(leftIToken, rightIToken)

        {
            this._MethodModifiersopt = _MethodModifiersopt;
            if (null != _MethodModifiersopt) (_MethodModifiersopt as Ast).setParent(this);
            this._TypeParametersopt = _TypeParametersopt;
            if (null != _TypeParametersopt) (_TypeParametersopt as Ast).setParent(this);
            this._ResultType = _ResultType;
            (_ResultType as Ast).setParent(this);
            this._MethodDeclarator = _MethodDeclarator;
            (_MethodDeclarator as Ast).setParent(this);
            this._Throwsopt = _Throwsopt;
            if (null != _Throwsopt) (_Throwsopt as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _MethodModifiersopt)  list.add(_MethodModifiersopt);
            if(null != _TypeParametersopt)  list.add(_TypeParametersopt);
            if(null != _ResultType)  list.add(_ResultType);
            if(null != _MethodDeclarator)  list.add(_MethodDeclarator);
            if(null != _Throwsopt)  list.add(_Throwsopt);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitMethodHeader(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitMethodHeader(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitMethodHeader(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitMethodHeader(this, o); }
    }

/**
 *<em>
*<li>Rule 127:  ResultType ::= Type
 *</em>
 *<p>
 *<b>
*<li>Rule 128:  ResultType ::= void
 *</b>
 */
class ResultType extends AstToken implements IResultType
    {
         IToken getvoid(){ return leftIToken; }

    ResultType(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitResultType(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitResultType(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitResultType(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitResultType(this, o); }
    }

/**
 *<em>
*<li>Rule 131:  FormalParameterList ::= LastFormalParameter
 *</em>
 *<p>
 *<b>
*<li>Rule 132:  FormalParameterList ::= FormalParameters , LastFormalParameter
 *</b>
 */
class FormalParameterList extends Ast implements IFormalParameterList
    {
         late Ast _FormalParameters;
         late AstToken _COMMA;
         late LastFormalParameter _LastFormalParameter;

         Ast getFormalParameters(){ return _FormalParameters; }
         void setFormalParameters(Ast _FormalParameters){ this._FormalParameters = _FormalParameters; }
         AstToken getCOMMA(){ return _COMMA; }
         void setCOMMA(AstToken _COMMA){ this._COMMA = _COMMA; }
         LastFormalParameter getLastFormalParameter(){ return _LastFormalParameter; }
         void setLastFormalParameter(LastFormalParameter _LastFormalParameter){ this._LastFormalParameter = _LastFormalParameter; }

        FormalParameterList(IToken leftIToken, IToken rightIToken,
                            Ast _FormalParameters,
                            AstToken _COMMA,
                            LastFormalParameter _LastFormalParameter)
            :super(leftIToken, rightIToken)

        {
            this._FormalParameters = _FormalParameters;
            (_FormalParameters as Ast).setParent(this);
            this._COMMA = _COMMA;
            (_COMMA as Ast).setParent(this);
            this._LastFormalParameter = _LastFormalParameter;
            (_LastFormalParameter as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _FormalParameters)  list.add(_FormalParameters);
            if(null != _COMMA)  list.add(_COMMA);
            if(null != _LastFormalParameter)  list.add(_LastFormalParameter);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitFormalParameterList(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitFormalParameterList(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitFormalParameterList(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitFormalParameterList(this, o); }
    }

/**
 *<em>
*<li>Rule 133:  FormalParameters ::= FormalParameter
 *</em>
 *<p>
 *<b>
*<li>Rule 134:  FormalParameters ::= FormalParameters , FormalParameter
 *</b>
 */
class FormalParameters extends Ast implements IFormalParameters
    {
         late Ast _FormalParameters;
         late AstToken _COMMA;
         late FormalParameter _FormalParameter;

         Ast getFormalParameters(){ return _FormalParameters; }
         void setFormalParameters(Ast _FormalParameters){ this._FormalParameters = _FormalParameters; }
         AstToken getCOMMA(){ return _COMMA; }
         void setCOMMA(AstToken _COMMA){ this._COMMA = _COMMA; }
         FormalParameter getFormalParameter(){ return _FormalParameter; }
         void setFormalParameter(FormalParameter _FormalParameter){ this._FormalParameter = _FormalParameter; }

        FormalParameters(IToken leftIToken, IToken rightIToken,
                         Ast _FormalParameters,
                         AstToken _COMMA,
                         FormalParameter _FormalParameter)
            :super(leftIToken, rightIToken)

        {
            this._FormalParameters = _FormalParameters;
            (_FormalParameters as Ast).setParent(this);
            this._COMMA = _COMMA;
            (_COMMA as Ast).setParent(this);
            this._FormalParameter = _FormalParameter;
            (_FormalParameter as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _FormalParameters)  list.add(_FormalParameters);
            if(null != _COMMA)  list.add(_COMMA);
            if(null != _FormalParameter)  list.add(_FormalParameter);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitFormalParameters(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitFormalParameters(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitFormalParameters(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitFormalParameters(this, o); }
    }

/**
 *<b>
*<li>Rule 135:  FormalParameter ::= VariableModifiersopt Type VariableDeclaratorId
 *</b>
 */
class FormalParameter extends Ast implements IFormalParameter
    {
         late Ast? _VariableModifiersopt;
         late Ast _Type;
         late Ast _VariableDeclaratorId;

        /**
         * The value returned by <b>getVariableModifiersopt</b> may be <b>null</b>
         */
         Ast ?  getVariableModifiersopt(){ return _VariableModifiersopt; }
         void setVariableModifiersopt(Ast _VariableModifiersopt){ this._VariableModifiersopt = _VariableModifiersopt; }
         Ast getType(){ return _Type; }
         void setType(Ast _Type){ this._Type = _Type; }
         Ast getVariableDeclaratorId(){ return _VariableDeclaratorId; }
         void setVariableDeclaratorId(Ast _VariableDeclaratorId){ this._VariableDeclaratorId = _VariableDeclaratorId; }

        FormalParameter(IToken leftIToken, IToken rightIToken,
                        Ast? _VariableModifiersopt,
                        Ast _Type,
                        Ast _VariableDeclaratorId)
            :super(leftIToken, rightIToken)

        {
            this._VariableModifiersopt = _VariableModifiersopt;
            if (null != _VariableModifiersopt) (_VariableModifiersopt as Ast).setParent(this);
            this._Type = _Type;
            (_Type as Ast).setParent(this);
            this._VariableDeclaratorId = _VariableDeclaratorId;
            (_VariableDeclaratorId as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _VariableModifiersopt)  list.add(_VariableModifiersopt);
            if(null != _Type)  list.add(_Type);
            if(null != _VariableDeclaratorId)  list.add(_VariableDeclaratorId);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitFormalParameter(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitFormalParameter(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitFormalParameter(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitFormalParameter(this, o); }
    }

/**
 *<em>
*<li>Rule 136:  VariableModifiers ::= VariableModifier
 *</em>
 *<p>
 *<b>
*<li>Rule 137:  VariableModifiers ::= VariableModifiers VariableModifier
 *</b>
 */
class VariableModifiers extends Ast implements IVariableModifiers
    {
         late Ast _VariableModifiers;
         late Ast _VariableModifier;

         Ast getVariableModifiers(){ return _VariableModifiers; }
         void setVariableModifiers(Ast _VariableModifiers){ this._VariableModifiers = _VariableModifiers; }
         Ast getVariableModifier(){ return _VariableModifier; }
         void setVariableModifier(Ast _VariableModifier){ this._VariableModifier = _VariableModifier; }

        VariableModifiers(IToken leftIToken, IToken rightIToken,
                          Ast _VariableModifiers,
                          Ast _VariableModifier)
            :super(leftIToken, rightIToken)

        {
            this._VariableModifiers = _VariableModifiers;
            (_VariableModifiers as Ast).setParent(this);
            this._VariableModifier = _VariableModifier;
            (_VariableModifier as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _VariableModifiers)  list.add(_VariableModifiers);
            if(null != _VariableModifier)  list.add(_VariableModifier);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitVariableModifiers(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitVariableModifiers(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitVariableModifiers(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitVariableModifiers(this, o); }
    }

/**
 *<em>
*<li>Rule 139:  VariableModifier ::= Annotations
 *</em>
 *<p>
 *<b>
*<li>Rule 138:  VariableModifier ::= final
 *</b>
 */
class VariableModifier extends AstToken implements IVariableModifier
    {
         IToken getfinal(){ return leftIToken; }

    VariableModifier(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitVariableModifier(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitVariableModifier(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitVariableModifier(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitVariableModifier(this, o); }
    }

/**
 *<b>
*<li>Rule 140:  LastFormalParameter ::= VariableModifiersopt Type ...opt VariableDeclaratorId
 *</b>
 */
class LastFormalParameter extends Ast implements ILastFormalParameter
    {
         late Ast? _VariableModifiersopt;
         late Ast _Type;
         late Ellipsisopt? _Ellipsisopt;
         late Ast _VariableDeclaratorId;

        /**
         * The value returned by <b>getVariableModifiersopt</b> may be <b>null</b>
         */
         Ast ?  getVariableModifiersopt(){ return _VariableModifiersopt; }
         void setVariableModifiersopt(Ast _VariableModifiersopt){ this._VariableModifiersopt = _VariableModifiersopt; }
         Ast getType(){ return _Type; }
         void setType(Ast _Type){ this._Type = _Type; }
        /**
         * The value returned by <b>getEllipsisopt</b> may be <b>null</b>
         */
         Ellipsisopt ?  getEllipsisopt(){ return _Ellipsisopt; }
         void setEllipsisopt(Ellipsisopt _Ellipsisopt){ this._Ellipsisopt = _Ellipsisopt; }
         Ast getVariableDeclaratorId(){ return _VariableDeclaratorId; }
         void setVariableDeclaratorId(Ast _VariableDeclaratorId){ this._VariableDeclaratorId = _VariableDeclaratorId; }

        LastFormalParameter(IToken leftIToken, IToken rightIToken,
                            Ast? _VariableModifiersopt,
                            Ast _Type,
                            Ellipsisopt? _Ellipsisopt,
                            Ast _VariableDeclaratorId)
            :super(leftIToken, rightIToken)

        {
            this._VariableModifiersopt = _VariableModifiersopt;
            if (null != _VariableModifiersopt) (_VariableModifiersopt as Ast).setParent(this);
            this._Type = _Type;
            (_Type as Ast).setParent(this);
            this._Ellipsisopt = _Ellipsisopt;
            if (null != _Ellipsisopt) (_Ellipsisopt as Ast).setParent(this);
            this._VariableDeclaratorId = _VariableDeclaratorId;
            (_VariableDeclaratorId as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _VariableModifiersopt)  list.add(_VariableModifiersopt);
            if(null != _Type)  list.add(_Type);
            if(null != _Ellipsisopt)  list.add(_Ellipsisopt);
            if(null != _VariableDeclaratorId)  list.add(_VariableDeclaratorId);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitLastFormalParameter(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitLastFormalParameter(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitLastFormalParameter(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitLastFormalParameter(this, o); }
    }

/**
 *<em>
*<li>Rule 141:  MethodModifiers ::= MethodModifier
 *</em>
 *<p>
 *<b>
*<li>Rule 142:  MethodModifiers ::= MethodModifiers MethodModifier
 *</b>
 */
class MethodModifiers extends Ast implements IMethodModifiers
    {
         late Ast _MethodModifiers;
         late Ast _MethodModifier;

         Ast getMethodModifiers(){ return _MethodModifiers; }
         void setMethodModifiers(Ast _MethodModifiers){ this._MethodModifiers = _MethodModifiers; }
         Ast getMethodModifier(){ return _MethodModifier; }
         void setMethodModifier(Ast _MethodModifier){ this._MethodModifier = _MethodModifier; }

        MethodModifiers(IToken leftIToken, IToken rightIToken,
                        Ast _MethodModifiers,
                        Ast _MethodModifier)
            :super(leftIToken, rightIToken)

        {
            this._MethodModifiers = _MethodModifiers;
            (_MethodModifiers as Ast).setParent(this);
            this._MethodModifier = _MethodModifier;
            (_MethodModifier as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _MethodModifiers)  list.add(_MethodModifiers);
            if(null != _MethodModifier)  list.add(_MethodModifier);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitMethodModifiers(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitMethodModifiers(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitMethodModifiers(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitMethodModifiers(this, o); }
    }

/**
 *<b>
*<li>Rule 153:  Throws ::= throws ExceptionTypeList
 *</b>
 */
class Throws extends Ast implements IThrows
    {
         late AstToken _throws;
         late Ast _ExceptionTypeList;

         AstToken getthrows(){ return _throws; }
         void setthrows(AstToken _throws){ this._throws = _throws; }
         Ast getExceptionTypeList(){ return _ExceptionTypeList; }
         void setExceptionTypeList(Ast _ExceptionTypeList){ this._ExceptionTypeList = _ExceptionTypeList; }

        Throws(IToken leftIToken, IToken rightIToken,
               AstToken _throws,
               Ast _ExceptionTypeList)
            :super(leftIToken, rightIToken)

        {
            this._throws = _throws;
            (_throws as Ast).setParent(this);
            this._ExceptionTypeList = _ExceptionTypeList;
            (_ExceptionTypeList as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _throws)  list.add(_throws);
            if(null != _ExceptionTypeList)  list.add(_ExceptionTypeList);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitThrows(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitThrows(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitThrows(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitThrows(this, o); }
    }

/**
 *<em>
*<li>Rule 154:  ExceptionTypeList ::= ExceptionType
 *</em>
 *<p>
 *<b>
*<li>Rule 155:  ExceptionTypeList ::= ExceptionTypeList , ExceptionType
 *</b>
 */
class ExceptionTypeList extends Ast implements IExceptionTypeList
    {
         late Ast _ExceptionTypeList;
         late AstToken _COMMA;
         late Ast _ExceptionType;

         Ast getExceptionTypeList(){ return _ExceptionTypeList; }
         void setExceptionTypeList(Ast _ExceptionTypeList){ this._ExceptionTypeList = _ExceptionTypeList; }
         AstToken getCOMMA(){ return _COMMA; }
         void setCOMMA(AstToken _COMMA){ this._COMMA = _COMMA; }
         Ast getExceptionType(){ return _ExceptionType; }
         void setExceptionType(Ast _ExceptionType){ this._ExceptionType = _ExceptionType; }

        ExceptionTypeList(IToken leftIToken, IToken rightIToken,
                          Ast _ExceptionTypeList,
                          AstToken _COMMA,
                          Ast _ExceptionType)
            :super(leftIToken, rightIToken)

        {
            this._ExceptionTypeList = _ExceptionTypeList;
            (_ExceptionTypeList as Ast).setParent(this);
            this._COMMA = _COMMA;
            (_COMMA as Ast).setParent(this);
            this._ExceptionType = _ExceptionType;
            (_ExceptionType as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ExceptionTypeList)  list.add(_ExceptionTypeList);
            if(null != _COMMA)  list.add(_COMMA);
            if(null != _ExceptionType)  list.add(_ExceptionType);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitExceptionTypeList(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitExceptionTypeList(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitExceptionTypeList(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitExceptionTypeList(this, o); }
    }

/**
 *<em>
*<li>Rule 158:  MethodBody ::= Block
 *</em>
 *<p>
 *<b>
*<li>Rule 159:  MethodBody ::= ;
 *</b>
 */
class MethodBody extends AstToken implements IMethodBody
    {
         IToken getSEMICOLON(){ return leftIToken; }

    MethodBody(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitMethodBody(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitMethodBody(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitMethodBody(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitMethodBody(this, o); }
    }

/**
 *<b>
*<li>Rule 161:  StaticInitializer ::= static Block
 *</b>
 */
class StaticInitializer extends Ast implements IStaticInitializer
    {
         late AstToken _static;
         late Block _Block;

         AstToken getstatic(){ return _static; }
         void setstatic(AstToken _static){ this._static = _static; }
         Block getBlock(){ return _Block; }
         void setBlock(Block _Block){ this._Block = _Block; }

        StaticInitializer(IToken leftIToken, IToken rightIToken,
                          AstToken _static,
                          Block _Block)
            :super(leftIToken, rightIToken)

        {
            this._static = _static;
            (_static as Ast).setParent(this);
            this._Block = _Block;
            (_Block as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _static)  list.add(_static);
            if(null != _Block)  list.add(_Block);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitStaticInitializer(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitStaticInitializer(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitStaticInitializer(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitStaticInitializer(this, o); }
    }

/**
 *<b>
*<li>Rule 162:  ConstructorDeclaration ::= ConstructorModifiersopt ConstructorDeclarator Throwsopt ConstructorBody
 *</b>
 */
class ConstructorDeclaration extends Ast implements IConstructorDeclaration
    {
         late Ast? _ConstructorModifiersopt;
         late ConstructorDeclarator _ConstructorDeclarator;
         late Throws? _Throwsopt;
         late ConstructorBody _ConstructorBody;

        /**
         * The value returned by <b>getConstructorModifiersopt</b> may be <b>null</b>
         */
         Ast ?  getConstructorModifiersopt(){ return _ConstructorModifiersopt; }
         void setConstructorModifiersopt(Ast _ConstructorModifiersopt){ this._ConstructorModifiersopt = _ConstructorModifiersopt; }
         ConstructorDeclarator getConstructorDeclarator(){ return _ConstructorDeclarator; }
         void setConstructorDeclarator(ConstructorDeclarator _ConstructorDeclarator){ this._ConstructorDeclarator = _ConstructorDeclarator; }
        /**
         * The value returned by <b>getThrowsopt</b> may be <b>null</b>
         */
         Throws ?  getThrowsopt(){ return _Throwsopt; }
         void setThrowsopt(Throws _Throwsopt){ this._Throwsopt = _Throwsopt; }
         ConstructorBody getConstructorBody(){ return _ConstructorBody; }
         void setConstructorBody(ConstructorBody _ConstructorBody){ this._ConstructorBody = _ConstructorBody; }

        ConstructorDeclaration(IToken leftIToken, IToken rightIToken,
                               Ast? _ConstructorModifiersopt,
                               ConstructorDeclarator _ConstructorDeclarator,
                               Throws? _Throwsopt,
                               ConstructorBody _ConstructorBody)
            :super(leftIToken, rightIToken)

        {
            this._ConstructorModifiersopt = _ConstructorModifiersopt;
            if (null != _ConstructorModifiersopt) (_ConstructorModifiersopt as Ast).setParent(this);
            this._ConstructorDeclarator = _ConstructorDeclarator;
            (_ConstructorDeclarator as Ast).setParent(this);
            this._Throwsopt = _Throwsopt;
            if (null != _Throwsopt) (_Throwsopt as Ast).setParent(this);
            this._ConstructorBody = _ConstructorBody;
            (_ConstructorBody as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ConstructorModifiersopt)  list.add(_ConstructorModifiersopt);
            if(null != _ConstructorDeclarator)  list.add(_ConstructorDeclarator);
            if(null != _Throwsopt)  list.add(_Throwsopt);
            if(null != _ConstructorBody)  list.add(_ConstructorBody);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitConstructorDeclaration(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitConstructorDeclaration(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitConstructorDeclaration(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitConstructorDeclaration(this, o); }
    }

/**
 *<b>
*<li>Rule 163:  ConstructorDeclarator ::= TypeParametersopt SimpleTypeName ( FormalParameterListopt )
 *</b>
 */
class ConstructorDeclarator extends Ast implements IConstructorDeclarator
    {
         late TypeParameters? _TypeParametersopt;
         late identifier _SimpleTypeName;
         late AstToken _LPAREN;
         late Ast? _FormalParameterListopt;
         late AstToken _RPAREN;

        /**
         * The value returned by <b>getTypeParametersopt</b> may be <b>null</b>
         */
         TypeParameters ?  getTypeParametersopt(){ return _TypeParametersopt; }
         void setTypeParametersopt(TypeParameters _TypeParametersopt){ this._TypeParametersopt = _TypeParametersopt; }
         identifier getSimpleTypeName(){ return _SimpleTypeName; }
         void setSimpleTypeName(identifier _SimpleTypeName){ this._SimpleTypeName = _SimpleTypeName; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
        /**
         * The value returned by <b>getFormalParameterListopt</b> may be <b>null</b>
         */
         Ast ?  getFormalParameterListopt(){ return _FormalParameterListopt; }
         void setFormalParameterListopt(Ast _FormalParameterListopt){ this._FormalParameterListopt = _FormalParameterListopt; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }

        ConstructorDeclarator(IToken leftIToken, IToken rightIToken,
                              TypeParameters? _TypeParametersopt,
                              identifier _SimpleTypeName,
                              AstToken _LPAREN,
                              Ast? _FormalParameterListopt,
                              AstToken _RPAREN)
            :super(leftIToken, rightIToken)

        {
            this._TypeParametersopt = _TypeParametersopt;
            if (null != _TypeParametersopt) (_TypeParametersopt as Ast).setParent(this);
            this._SimpleTypeName = _SimpleTypeName;
            (_SimpleTypeName as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._FormalParameterListopt = _FormalParameterListopt;
            if (null != _FormalParameterListopt) (_FormalParameterListopt as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _TypeParametersopt)  list.add(_TypeParametersopt);
            if(null != _SimpleTypeName)  list.add(_SimpleTypeName);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _FormalParameterListopt)  list.add(_FormalParameterListopt);
            if(null != _RPAREN)  list.add(_RPAREN);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitConstructorDeclarator(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitConstructorDeclarator(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitConstructorDeclarator(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitConstructorDeclarator(this, o); }
    }

/**
 *<em>
*<li>Rule 165:  ConstructorModifiers ::= ConstructorModifier
 *</em>
 *<p>
 *<b>
*<li>Rule 166:  ConstructorModifiers ::= ConstructorModifiers ConstructorModifier
 *</b>
 */
class ConstructorModifiers extends Ast implements IConstructorModifiers
    {
         late Ast _ConstructorModifiers;
         late Ast _ConstructorModifier;

         Ast getConstructorModifiers(){ return _ConstructorModifiers; }
         void setConstructorModifiers(Ast _ConstructorModifiers){ this._ConstructorModifiers = _ConstructorModifiers; }
         Ast getConstructorModifier(){ return _ConstructorModifier; }
         void setConstructorModifier(Ast _ConstructorModifier){ this._ConstructorModifier = _ConstructorModifier; }

        ConstructorModifiers(IToken leftIToken, IToken rightIToken,
                             Ast _ConstructorModifiers,
                             Ast _ConstructorModifier)
            :super(leftIToken, rightIToken)

        {
            this._ConstructorModifiers = _ConstructorModifiers;
            (_ConstructorModifiers as Ast).setParent(this);
            this._ConstructorModifier = _ConstructorModifier;
            (_ConstructorModifier as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ConstructorModifiers)  list.add(_ConstructorModifiers);
            if(null != _ConstructorModifier)  list.add(_ConstructorModifier);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitConstructorModifiers(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitConstructorModifiers(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitConstructorModifiers(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitConstructorModifiers(this, o); }
    }

/**
 *<b>
*<li>Rule 171:  ConstructorBody ::= { ExplicitConstructorInvocationopt BlockStatementsopt }
 *</b>
 */
class ConstructorBody extends Ast implements IConstructorBody
    {
         late AstToken _LBRACE;
         late Ast? _ExplicitConstructorInvocationopt;
         late Ast? _BlockStatementsopt;
         late AstToken _RBRACE;

         AstToken getLBRACE(){ return _LBRACE; }
         void setLBRACE(AstToken _LBRACE){ this._LBRACE = _LBRACE; }
        /**
         * The value returned by <b>getExplicitConstructorInvocationopt</b> may be <b>null</b>
         */
         Ast ?  getExplicitConstructorInvocationopt(){ return _ExplicitConstructorInvocationopt; }
         void setExplicitConstructorInvocationopt(Ast _ExplicitConstructorInvocationopt){ this._ExplicitConstructorInvocationopt = _ExplicitConstructorInvocationopt; }
        /**
         * The value returned by <b>getBlockStatementsopt</b> may be <b>null</b>
         */
         Ast ?  getBlockStatementsopt(){ return _BlockStatementsopt; }
         void setBlockStatementsopt(Ast _BlockStatementsopt){ this._BlockStatementsopt = _BlockStatementsopt; }
         AstToken getRBRACE(){ return _RBRACE; }
         void setRBRACE(AstToken _RBRACE){ this._RBRACE = _RBRACE; }

        ConstructorBody(IToken leftIToken, IToken rightIToken,
                        AstToken _LBRACE,
                        Ast? _ExplicitConstructorInvocationopt,
                        Ast? _BlockStatementsopt,
                        AstToken _RBRACE)
            :super(leftIToken, rightIToken)

        {
            this._LBRACE = _LBRACE;
            (_LBRACE as Ast).setParent(this);
            this._ExplicitConstructorInvocationopt = _ExplicitConstructorInvocationopt;
            if (null != _ExplicitConstructorInvocationopt) (_ExplicitConstructorInvocationopt as Ast).setParent(this);
            this._BlockStatementsopt = _BlockStatementsopt;
            if (null != _BlockStatementsopt) (_BlockStatementsopt as Ast).setParent(this);
            this._RBRACE = _RBRACE;
            (_RBRACE as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _LBRACE)  list.add(_LBRACE);
            if(null != _ExplicitConstructorInvocationopt)  list.add(_ExplicitConstructorInvocationopt);
            if(null != _BlockStatementsopt)  list.add(_BlockStatementsopt);
            if(null != _RBRACE)  list.add(_RBRACE);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitConstructorBody(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitConstructorBody(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitConstructorBody(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitConstructorBody(this, o); }
    }

/**
 *<b>
*<li>Rule 175:  EnumDeclaration ::= ClassModifiersopt enum identifier Interfacesopt EnumBody
 *</b>
 */
class EnumDeclaration extends Ast implements IEnumDeclaration
    {
         late Ast? _ClassModifiersopt;
         late AstToken _enum;
         late identifier _identifier;
         late Interfaces? _Interfacesopt;
         late EnumBody _EnumBody;

        /**
         * The value returned by <b>getClassModifiersopt</b> may be <b>null</b>
         */
         Ast ?  getClassModifiersopt(){ return _ClassModifiersopt; }
         void setClassModifiersopt(Ast _ClassModifiersopt){ this._ClassModifiersopt = _ClassModifiersopt; }
         AstToken getenum(){ return _enum; }
         void setenum(AstToken _enum){ this._enum = _enum; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }
        /**
         * The value returned by <b>getInterfacesopt</b> may be <b>null</b>
         */
         Interfaces ?  getInterfacesopt(){ return _Interfacesopt; }
         void setInterfacesopt(Interfaces _Interfacesopt){ this._Interfacesopt = _Interfacesopt; }
         EnumBody getEnumBody(){ return _EnumBody; }
         void setEnumBody(EnumBody _EnumBody){ this._EnumBody = _EnumBody; }

        EnumDeclaration(IToken leftIToken, IToken rightIToken,
                        Ast? _ClassModifiersopt,
                        AstToken _enum,
                        identifier _identifier,
                        Interfaces? _Interfacesopt,
                        EnumBody _EnumBody)
            :super(leftIToken, rightIToken)

        {
            this._ClassModifiersopt = _ClassModifiersopt;
            if (null != _ClassModifiersopt) (_ClassModifiersopt as Ast).setParent(this);
            this._enum = _enum;
            (_enum as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            this._Interfacesopt = _Interfacesopt;
            if (null != _Interfacesopt) (_Interfacesopt as Ast).setParent(this);
            this._EnumBody = _EnumBody;
            (_EnumBody as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ClassModifiersopt)  list.add(_ClassModifiersopt);
            if(null != _enum)  list.add(_enum);
            if(null != _identifier)  list.add(_identifier);
            if(null != _Interfacesopt)  list.add(_Interfacesopt);
            if(null != _EnumBody)  list.add(_EnumBody);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitEnumDeclaration(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitEnumDeclaration(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitEnumDeclaration(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitEnumDeclaration(this, o); }
    }

/**
 *<b>
*<li>Rule 176:  EnumBody ::= { EnumConstantsopt ,opt EnumBodyDeclarationsopt }
 *</b>
 */
class EnumBody extends Ast implements IEnumBody
    {
         late AstToken _LBRACE;
         late Ast? _EnumConstantsopt;
         late Commaopt? _Commaopt;
         late EnumBodyDeclarations? _EnumBodyDeclarationsopt;
         late AstToken _RBRACE;

         AstToken getLBRACE(){ return _LBRACE; }
         void setLBRACE(AstToken _LBRACE){ this._LBRACE = _LBRACE; }
        /**
         * The value returned by <b>getEnumConstantsopt</b> may be <b>null</b>
         */
         Ast ?  getEnumConstantsopt(){ return _EnumConstantsopt; }
         void setEnumConstantsopt(Ast _EnumConstantsopt){ this._EnumConstantsopt = _EnumConstantsopt; }
        /**
         * The value returned by <b>getCommaopt</b> may be <b>null</b>
         */
         Commaopt ?  getCommaopt(){ return _Commaopt; }
         void setCommaopt(Commaopt _Commaopt){ this._Commaopt = _Commaopt; }
        /**
         * The value returned by <b>getEnumBodyDeclarationsopt</b> may be <b>null</b>
         */
         EnumBodyDeclarations ?  getEnumBodyDeclarationsopt(){ return _EnumBodyDeclarationsopt; }
         void setEnumBodyDeclarationsopt(EnumBodyDeclarations _EnumBodyDeclarationsopt){ this._EnumBodyDeclarationsopt = _EnumBodyDeclarationsopt; }
         AstToken getRBRACE(){ return _RBRACE; }
         void setRBRACE(AstToken _RBRACE){ this._RBRACE = _RBRACE; }

        EnumBody(IToken leftIToken, IToken rightIToken,
                 AstToken _LBRACE,
                 Ast? _EnumConstantsopt,
                 Commaopt? _Commaopt,
                 EnumBodyDeclarations? _EnumBodyDeclarationsopt,
                 AstToken _RBRACE)
            :super(leftIToken, rightIToken)

        {
            this._LBRACE = _LBRACE;
            (_LBRACE as Ast).setParent(this);
            this._EnumConstantsopt = _EnumConstantsopt;
            if (null != _EnumConstantsopt) (_EnumConstantsopt as Ast).setParent(this);
            this._Commaopt = _Commaopt;
            if (null != _Commaopt) (_Commaopt as Ast).setParent(this);
            this._EnumBodyDeclarationsopt = _EnumBodyDeclarationsopt;
            if (null != _EnumBodyDeclarationsopt) (_EnumBodyDeclarationsopt as Ast).setParent(this);
            this._RBRACE = _RBRACE;
            (_RBRACE as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _LBRACE)  list.add(_LBRACE);
            if(null != _EnumConstantsopt)  list.add(_EnumConstantsopt);
            if(null != _Commaopt)  list.add(_Commaopt);
            if(null != _EnumBodyDeclarationsopt)  list.add(_EnumBodyDeclarationsopt);
            if(null != _RBRACE)  list.add(_RBRACE);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitEnumBody(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitEnumBody(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitEnumBody(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitEnumBody(this, o); }
    }

/**
 *<em>
*<li>Rule 177:  EnumConstants ::= EnumConstant
 *</em>
 *<p>
 *<b>
*<li>Rule 178:  EnumConstants ::= EnumConstants , EnumConstant
 *</b>
 */
class EnumConstants extends Ast implements IEnumConstants
    {
         late Ast _EnumConstants;
         late AstToken _COMMA;
         late Ast _EnumConstant;

         Ast getEnumConstants(){ return _EnumConstants; }
         void setEnumConstants(Ast _EnumConstants){ this._EnumConstants = _EnumConstants; }
         AstToken getCOMMA(){ return _COMMA; }
         void setCOMMA(AstToken _COMMA){ this._COMMA = _COMMA; }
         Ast getEnumConstant(){ return _EnumConstant; }
         void setEnumConstant(Ast _EnumConstant){ this._EnumConstant = _EnumConstant; }

        EnumConstants(IToken leftIToken, IToken rightIToken,
                      Ast _EnumConstants,
                      AstToken _COMMA,
                      Ast _EnumConstant)
            :super(leftIToken, rightIToken)

        {
            this._EnumConstants = _EnumConstants;
            (_EnumConstants as Ast).setParent(this);
            this._COMMA = _COMMA;
            (_COMMA as Ast).setParent(this);
            this._EnumConstant = _EnumConstant;
            (_EnumConstant as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _EnumConstants)  list.add(_EnumConstants);
            if(null != _COMMA)  list.add(_COMMA);
            if(null != _EnumConstant)  list.add(_EnumConstant);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitEnumConstants(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitEnumConstants(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitEnumConstants(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitEnumConstants(this, o); }
    }

/**
 *<em>
*<li>Rule 307:  EnumConstant ::= identifier
 *</em>
 *<p>
 *<b>
*<li>Rule 179:  EnumConstant ::= Annotationsopt identifier Argumentsopt ClassBodyopt
 *</b>
 */
class EnumConstant extends Ast implements IEnumConstant
    {
         late Ast? _Annotationsopt;
         late identifier _identifier;
         late Arguments? _Argumentsopt;
         late ClassBody? _ClassBodyopt;

        /**
         * The value returned by <b>getAnnotationsopt</b> may be <b>null</b>
         */
         Ast ?  getAnnotationsopt(){ return _Annotationsopt; }
         void setAnnotationsopt(Ast _Annotationsopt){ this._Annotationsopt = _Annotationsopt; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }
        /**
         * The value returned by <b>getArgumentsopt</b> may be <b>null</b>
         */
         Arguments ?  getArgumentsopt(){ return _Argumentsopt; }
         void setArgumentsopt(Arguments _Argumentsopt){ this._Argumentsopt = _Argumentsopt; }
        /**
         * The value returned by <b>getClassBodyopt</b> may be <b>null</b>
         */
         ClassBody ?  getClassBodyopt(){ return _ClassBodyopt; }
         void setClassBodyopt(ClassBody _ClassBodyopt){ this._ClassBodyopt = _ClassBodyopt; }

        EnumConstant(IToken leftIToken, IToken rightIToken,
                     Ast? _Annotationsopt,
                     identifier _identifier,
                     Arguments? _Argumentsopt,
                     ClassBody? _ClassBodyopt)
            :super(leftIToken, rightIToken)

        {
            this._Annotationsopt = _Annotationsopt;
            if (null != _Annotationsopt) (_Annotationsopt as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            this._Argumentsopt = _Argumentsopt;
            if (null != _Argumentsopt) (_Argumentsopt as Ast).setParent(this);
            this._ClassBodyopt = _ClassBodyopt;
            if (null != _ClassBodyopt) (_ClassBodyopt as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _Annotationsopt)  list.add(_Annotationsopt);
            if(null != _identifier)  list.add(_identifier);
            if(null != _Argumentsopt)  list.add(_Argumentsopt);
            if(null != _ClassBodyopt)  list.add(_ClassBodyopt);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitEnumConstant(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitEnumConstant(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitEnumConstant(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitEnumConstant(this, o); }
    }

/**
 *<b>
*<li>Rule 180:  Arguments ::= ( ArgumentListopt )
 *</b>
 */
class Arguments extends Ast implements IArguments
    {
         late AstToken _LPAREN;
         late Ast? _ArgumentListopt;
         late AstToken _RPAREN;

         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
        /**
         * The value returned by <b>getArgumentListopt</b> may be <b>null</b>
         */
         Ast ?  getArgumentListopt(){ return _ArgumentListopt; }
         void setArgumentListopt(Ast _ArgumentListopt){ this._ArgumentListopt = _ArgumentListopt; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }

        Arguments(IToken leftIToken, IToken rightIToken,
                  AstToken _LPAREN,
                  Ast? _ArgumentListopt,
                  AstToken _RPAREN)
            :super(leftIToken, rightIToken)

        {
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._ArgumentListopt = _ArgumentListopt;
            if (null != _ArgumentListopt) (_ArgumentListopt as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _ArgumentListopt)  list.add(_ArgumentListopt);
            if(null != _RPAREN)  list.add(_RPAREN);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitArguments(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitArguments(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitArguments(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitArguments(this, o); }
    }

/**
 *<b>
*<li>Rule 181:  EnumBodyDeclarations ::= ; ClassBodyDeclarationsopt
 *</b>
 */
class EnumBodyDeclarations extends Ast implements IEnumBodyDeclarations
    {
         late AstToken _SEMICOLON;
         late Ast? _ClassBodyDeclarationsopt;

         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }
        /**
         * The value returned by <b>getClassBodyDeclarationsopt</b> may be <b>null</b>
         */
         Ast ?  getClassBodyDeclarationsopt(){ return _ClassBodyDeclarationsopt; }
         void setClassBodyDeclarationsopt(Ast _ClassBodyDeclarationsopt){ this._ClassBodyDeclarationsopt = _ClassBodyDeclarationsopt; }

        EnumBodyDeclarations(IToken leftIToken, IToken rightIToken,
                             AstToken _SEMICOLON,
                             Ast? _ClassBodyDeclarationsopt)
            :super(leftIToken, rightIToken)

        {
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            this._ClassBodyDeclarationsopt = _ClassBodyDeclarationsopt;
            if (null != _ClassBodyDeclarationsopt) (_ClassBodyDeclarationsopt as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            if(null != _ClassBodyDeclarationsopt)  list.add(_ClassBodyDeclarationsopt);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitEnumBodyDeclarations(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitEnumBodyDeclarations(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitEnumBodyDeclarations(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitEnumBodyDeclarations(this, o); }
    }

/**
 *<b>
*<li>Rule 184:  NormalInterfaceDeclaration ::= InterfaceModifiersopt interface identifier TypeParametersopt ExtendsInterfacesopt InterfaceBody
 *</b>
 */
class NormalInterfaceDeclaration extends Ast implements INormalInterfaceDeclaration
    {
         late Ast? _InterfaceModifiersopt;
         late AstToken _interface;
         late identifier _identifier;
         late TypeParameters? _TypeParametersopt;
         late Ast? _ExtendsInterfacesopt;
         late InterfaceBody _InterfaceBody;

        /**
         * The value returned by <b>getInterfaceModifiersopt</b> may be <b>null</b>
         */
         Ast ?  getInterfaceModifiersopt(){ return _InterfaceModifiersopt; }
         void setInterfaceModifiersopt(Ast _InterfaceModifiersopt){ this._InterfaceModifiersopt = _InterfaceModifiersopt; }
         AstToken getinterface(){ return _interface; }
         void setinterface(AstToken _interface){ this._interface = _interface; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }
        /**
         * The value returned by <b>getTypeParametersopt</b> may be <b>null</b>
         */
         TypeParameters ?  getTypeParametersopt(){ return _TypeParametersopt; }
         void setTypeParametersopt(TypeParameters _TypeParametersopt){ this._TypeParametersopt = _TypeParametersopt; }
        /**
         * The value returned by <b>getExtendsInterfacesopt</b> may be <b>null</b>
         */
         Ast ?  getExtendsInterfacesopt(){ return _ExtendsInterfacesopt; }
         void setExtendsInterfacesopt(Ast _ExtendsInterfacesopt){ this._ExtendsInterfacesopt = _ExtendsInterfacesopt; }
         InterfaceBody getInterfaceBody(){ return _InterfaceBody; }
         void setInterfaceBody(InterfaceBody _InterfaceBody){ this._InterfaceBody = _InterfaceBody; }

        NormalInterfaceDeclaration(IToken leftIToken, IToken rightIToken,
                                   Ast? _InterfaceModifiersopt,
                                   AstToken _interface,
                                   identifier _identifier,
                                   TypeParameters? _TypeParametersopt,
                                   Ast? _ExtendsInterfacesopt,
                                   InterfaceBody _InterfaceBody)
            :super(leftIToken, rightIToken)

        {
            this._InterfaceModifiersopt = _InterfaceModifiersopt;
            if (null != _InterfaceModifiersopt) (_InterfaceModifiersopt as Ast).setParent(this);
            this._interface = _interface;
            (_interface as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            this._TypeParametersopt = _TypeParametersopt;
            if (null != _TypeParametersopt) (_TypeParametersopt as Ast).setParent(this);
            this._ExtendsInterfacesopt = _ExtendsInterfacesopt;
            if (null != _ExtendsInterfacesopt) (_ExtendsInterfacesopt as Ast).setParent(this);
            this._InterfaceBody = _InterfaceBody;
            (_InterfaceBody as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _InterfaceModifiersopt)  list.add(_InterfaceModifiersopt);
            if(null != _interface)  list.add(_interface);
            if(null != _identifier)  list.add(_identifier);
            if(null != _TypeParametersopt)  list.add(_TypeParametersopt);
            if(null != _ExtendsInterfacesopt)  list.add(_ExtendsInterfacesopt);
            if(null != _InterfaceBody)  list.add(_InterfaceBody);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitNormalInterfaceDeclaration(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitNormalInterfaceDeclaration(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitNormalInterfaceDeclaration(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitNormalInterfaceDeclaration(this, o); }
    }

/**
 *<em>
*<li>Rule 185:  InterfaceModifiers ::= InterfaceModifier
 *</em>
 *<p>
 *<b>
*<li>Rule 186:  InterfaceModifiers ::= InterfaceModifiers InterfaceModifier
 *</b>
 */
class InterfaceModifiers extends Ast implements IInterfaceModifiers
    {
         late Ast _InterfaceModifiers;
         late Ast _InterfaceModifier;

         Ast getInterfaceModifiers(){ return _InterfaceModifiers; }
         void setInterfaceModifiers(Ast _InterfaceModifiers){ this._InterfaceModifiers = _InterfaceModifiers; }
         Ast getInterfaceModifier(){ return _InterfaceModifier; }
         void setInterfaceModifier(Ast _InterfaceModifier){ this._InterfaceModifier = _InterfaceModifier; }

        InterfaceModifiers(IToken leftIToken, IToken rightIToken,
                           Ast _InterfaceModifiers,
                           Ast _InterfaceModifier)
            :super(leftIToken, rightIToken)

        {
            this._InterfaceModifiers = _InterfaceModifiers;
            (_InterfaceModifiers as Ast).setParent(this);
            this._InterfaceModifier = _InterfaceModifier;
            (_InterfaceModifier as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _InterfaceModifiers)  list.add(_InterfaceModifiers);
            if(null != _InterfaceModifier)  list.add(_InterfaceModifier);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitInterfaceModifiers(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitInterfaceModifiers(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitInterfaceModifiers(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitInterfaceModifiers(this, o); }
    }

/**
 *<b>
*<li>Rule 196:  InterfaceBody ::= { InterfaceMemberDeclarationsopt }
 *</b>
 */
class InterfaceBody extends Ast implements IInterfaceBody
    {
         late AstToken _LBRACE;
         late Ast? _InterfaceMemberDeclarationsopt;
         late AstToken _RBRACE;

         AstToken getLBRACE(){ return _LBRACE; }
         void setLBRACE(AstToken _LBRACE){ this._LBRACE = _LBRACE; }
        /**
         * The value returned by <b>getInterfaceMemberDeclarationsopt</b> may be <b>null</b>
         */
         Ast ?  getInterfaceMemberDeclarationsopt(){ return _InterfaceMemberDeclarationsopt; }
         void setInterfaceMemberDeclarationsopt(Ast _InterfaceMemberDeclarationsopt){ this._InterfaceMemberDeclarationsopt = _InterfaceMemberDeclarationsopt; }
         AstToken getRBRACE(){ return _RBRACE; }
         void setRBRACE(AstToken _RBRACE){ this._RBRACE = _RBRACE; }

        InterfaceBody(IToken leftIToken, IToken rightIToken,
                      AstToken _LBRACE,
                      Ast? _InterfaceMemberDeclarationsopt,
                      AstToken _RBRACE)
            :super(leftIToken, rightIToken)

        {
            this._LBRACE = _LBRACE;
            (_LBRACE as Ast).setParent(this);
            this._InterfaceMemberDeclarationsopt = _InterfaceMemberDeclarationsopt;
            if (null != _InterfaceMemberDeclarationsopt) (_InterfaceMemberDeclarationsopt as Ast).setParent(this);
            this._RBRACE = _RBRACE;
            (_RBRACE as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _LBRACE)  list.add(_LBRACE);
            if(null != _InterfaceMemberDeclarationsopt)  list.add(_InterfaceMemberDeclarationsopt);
            if(null != _RBRACE)  list.add(_RBRACE);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitInterfaceBody(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitInterfaceBody(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitInterfaceBody(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitInterfaceBody(this, o); }
    }

/**
 *<em>
*<li>Rule 197:  InterfaceMemberDeclarations ::= InterfaceMemberDeclaration
 *</em>
 *<p>
 *<b>
*<li>Rule 198:  InterfaceMemberDeclarations ::= InterfaceMemberDeclarations InterfaceMemberDeclaration
 *</b>
 */
class InterfaceMemberDeclarations extends Ast implements IInterfaceMemberDeclarations
    {
         late Ast _InterfaceMemberDeclarations;
         late Ast _InterfaceMemberDeclaration;

         Ast getInterfaceMemberDeclarations(){ return _InterfaceMemberDeclarations; }
         void setInterfaceMemberDeclarations(Ast _InterfaceMemberDeclarations){ this._InterfaceMemberDeclarations = _InterfaceMemberDeclarations; }
         Ast getInterfaceMemberDeclaration(){ return _InterfaceMemberDeclaration; }
         void setInterfaceMemberDeclaration(Ast _InterfaceMemberDeclaration){ this._InterfaceMemberDeclaration = _InterfaceMemberDeclaration; }

        InterfaceMemberDeclarations(IToken leftIToken, IToken rightIToken,
                                    Ast _InterfaceMemberDeclarations,
                                    Ast _InterfaceMemberDeclaration)
            :super(leftIToken, rightIToken)

        {
            this._InterfaceMemberDeclarations = _InterfaceMemberDeclarations;
            (_InterfaceMemberDeclarations as Ast).setParent(this);
            this._InterfaceMemberDeclaration = _InterfaceMemberDeclaration;
            (_InterfaceMemberDeclaration as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _InterfaceMemberDeclarations)  list.add(_InterfaceMemberDeclarations);
            if(null != _InterfaceMemberDeclaration)  list.add(_InterfaceMemberDeclaration);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitInterfaceMemberDeclarations(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitInterfaceMemberDeclarations(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitInterfaceMemberDeclarations(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitInterfaceMemberDeclarations(this, o); }
    }

/**
 *<em>
*<li>Rule 199:  InterfaceMemberDeclaration ::= ConstantDeclaration
*<li>Rule 200:  InterfaceMemberDeclaration ::= AbstractMethodDeclaration
*<li>Rule 201:  InterfaceMemberDeclaration ::= ClassDeclaration
*<li>Rule 202:  InterfaceMemberDeclaration ::= InterfaceDeclaration
 *</em>
 *<p>
 *<b>
*<li>Rule 203:  InterfaceMemberDeclaration ::= ;
 *</b>
 */
class InterfaceMemberDeclaration extends AstToken implements IInterfaceMemberDeclaration
    {
         IToken getSEMICOLON(){ return leftIToken; }

    InterfaceMemberDeclaration(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitInterfaceMemberDeclaration(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitInterfaceMemberDeclaration(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitInterfaceMemberDeclaration(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitInterfaceMemberDeclaration(this, o); }
    }

/**
 *<b>
*<li>Rule 204:  ConstantDeclaration ::= ConstantModifiersopt Type VariableDeclarators
 *</b>
 */
class ConstantDeclaration extends Ast implements IConstantDeclaration
    {
         late Ast? _ConstantModifiersopt;
         late Ast _Type;
         late Ast _VariableDeclarators;

        /**
         * The value returned by <b>getConstantModifiersopt</b> may be <b>null</b>
         */
         Ast ?  getConstantModifiersopt(){ return _ConstantModifiersopt; }
         void setConstantModifiersopt(Ast _ConstantModifiersopt){ this._ConstantModifiersopt = _ConstantModifiersopt; }
         Ast getType(){ return _Type; }
         void setType(Ast _Type){ this._Type = _Type; }
         Ast getVariableDeclarators(){ return _VariableDeclarators; }
         void setVariableDeclarators(Ast _VariableDeclarators){ this._VariableDeclarators = _VariableDeclarators; }

        ConstantDeclaration(IToken leftIToken, IToken rightIToken,
                            Ast? _ConstantModifiersopt,
                            Ast _Type,
                            Ast _VariableDeclarators)
            :super(leftIToken, rightIToken)

        {
            this._ConstantModifiersopt = _ConstantModifiersopt;
            if (null != _ConstantModifiersopt) (_ConstantModifiersopt as Ast).setParent(this);
            this._Type = _Type;
            (_Type as Ast).setParent(this);
            this._VariableDeclarators = _VariableDeclarators;
            (_VariableDeclarators as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ConstantModifiersopt)  list.add(_ConstantModifiersopt);
            if(null != _Type)  list.add(_Type);
            if(null != _VariableDeclarators)  list.add(_VariableDeclarators);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitConstantDeclaration(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitConstantDeclaration(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitConstantDeclaration(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitConstantDeclaration(this, o); }
    }

/**
 *<em>
*<li>Rule 205:  ConstantModifiers ::= ConstantModifier
 *</em>
 *<p>
 *<b>
*<li>Rule 206:  ConstantModifiers ::= ConstantModifiers ConstantModifier
 *</b>
 */
class ConstantModifiers extends Ast implements IConstantModifiers
    {
         late Ast _ConstantModifiers;
         late Ast _ConstantModifier;

         Ast getConstantModifiers(){ return _ConstantModifiers; }
         void setConstantModifiers(Ast _ConstantModifiers){ this._ConstantModifiers = _ConstantModifiers; }
         Ast getConstantModifier(){ return _ConstantModifier; }
         void setConstantModifier(Ast _ConstantModifier){ this._ConstantModifier = _ConstantModifier; }

        ConstantModifiers(IToken leftIToken, IToken rightIToken,
                          Ast _ConstantModifiers,
                          Ast _ConstantModifier)
            :super(leftIToken, rightIToken)

        {
            this._ConstantModifiers = _ConstantModifiers;
            (_ConstantModifiers as Ast).setParent(this);
            this._ConstantModifier = _ConstantModifier;
            (_ConstantModifier as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ConstantModifiers)  list.add(_ConstantModifiers);
            if(null != _ConstantModifier)  list.add(_ConstantModifier);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitConstantModifiers(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitConstantModifiers(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitConstantModifiers(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitConstantModifiers(this, o); }
    }

/**
 *<b>
*<li>Rule 211:  AbstractMethodDeclaration ::= AbstractMethodModifiersopt TypeParametersopt ResultType MethodDeclarator Throwsopt ;
 *</b>
 */
class AbstractMethodDeclaration extends Ast implements IAbstractMethodDeclaration
    {
         late Ast? _AbstractMethodModifiersopt;
         late TypeParameters? _TypeParametersopt;
         late Ast _ResultType;
         late Ast _MethodDeclarator;
         late Throws? _Throwsopt;
         late AstToken _SEMICOLON;

        /**
         * The value returned by <b>getAbstractMethodModifiersopt</b> may be <b>null</b>
         */
         Ast ?  getAbstractMethodModifiersopt(){ return _AbstractMethodModifiersopt; }
         void setAbstractMethodModifiersopt(Ast _AbstractMethodModifiersopt){ this._AbstractMethodModifiersopt = _AbstractMethodModifiersopt; }
        /**
         * The value returned by <b>getTypeParametersopt</b> may be <b>null</b>
         */
         TypeParameters ?  getTypeParametersopt(){ return _TypeParametersopt; }
         void setTypeParametersopt(TypeParameters _TypeParametersopt){ this._TypeParametersopt = _TypeParametersopt; }
         Ast getResultType(){ return _ResultType; }
         void setResultType(Ast _ResultType){ this._ResultType = _ResultType; }
         Ast getMethodDeclarator(){ return _MethodDeclarator; }
         void setMethodDeclarator(Ast _MethodDeclarator){ this._MethodDeclarator = _MethodDeclarator; }
        /**
         * The value returned by <b>getThrowsopt</b> may be <b>null</b>
         */
         Throws ?  getThrowsopt(){ return _Throwsopt; }
         void setThrowsopt(Throws _Throwsopt){ this._Throwsopt = _Throwsopt; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        AbstractMethodDeclaration(IToken leftIToken, IToken rightIToken,
                                  Ast? _AbstractMethodModifiersopt,
                                  TypeParameters? _TypeParametersopt,
                                  Ast _ResultType,
                                  Ast _MethodDeclarator,
                                  Throws? _Throwsopt,
                                  AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._AbstractMethodModifiersopt = _AbstractMethodModifiersopt;
            if (null != _AbstractMethodModifiersopt) (_AbstractMethodModifiersopt as Ast).setParent(this);
            this._TypeParametersopt = _TypeParametersopt;
            if (null != _TypeParametersopt) (_TypeParametersopt as Ast).setParent(this);
            this._ResultType = _ResultType;
            (_ResultType as Ast).setParent(this);
            this._MethodDeclarator = _MethodDeclarator;
            (_MethodDeclarator as Ast).setParent(this);
            this._Throwsopt = _Throwsopt;
            if (null != _Throwsopt) (_Throwsopt as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _AbstractMethodModifiersopt)  list.add(_AbstractMethodModifiersopt);
            if(null != _TypeParametersopt)  list.add(_TypeParametersopt);
            if(null != _ResultType)  list.add(_ResultType);
            if(null != _MethodDeclarator)  list.add(_MethodDeclarator);
            if(null != _Throwsopt)  list.add(_Throwsopt);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitAbstractMethodDeclaration(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitAbstractMethodDeclaration(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitAbstractMethodDeclaration(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitAbstractMethodDeclaration(this, o); }
    }

/**
 *<em>
*<li>Rule 212:  AbstractMethodModifiers ::= AbstractMethodModifier
 *</em>
 *<p>
 *<b>
*<li>Rule 213:  AbstractMethodModifiers ::= AbstractMethodModifiers AbstractMethodModifier
 *</b>
 */
class AbstractMethodModifiers extends Ast implements IAbstractMethodModifiers
    {
         late Ast _AbstractMethodModifiers;
         late Ast _AbstractMethodModifier;

         Ast getAbstractMethodModifiers(){ return _AbstractMethodModifiers; }
         void setAbstractMethodModifiers(Ast _AbstractMethodModifiers){ this._AbstractMethodModifiers = _AbstractMethodModifiers; }
         Ast getAbstractMethodModifier(){ return _AbstractMethodModifier; }
         void setAbstractMethodModifier(Ast _AbstractMethodModifier){ this._AbstractMethodModifier = _AbstractMethodModifier; }

        AbstractMethodModifiers(IToken leftIToken, IToken rightIToken,
                                Ast _AbstractMethodModifiers,
                                Ast _AbstractMethodModifier)
            :super(leftIToken, rightIToken)

        {
            this._AbstractMethodModifiers = _AbstractMethodModifiers;
            (_AbstractMethodModifiers as Ast).setParent(this);
            this._AbstractMethodModifier = _AbstractMethodModifier;
            (_AbstractMethodModifier as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _AbstractMethodModifiers)  list.add(_AbstractMethodModifiers);
            if(null != _AbstractMethodModifier)  list.add(_AbstractMethodModifier);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitAbstractMethodModifiers(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitAbstractMethodModifiers(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitAbstractMethodModifiers(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitAbstractMethodModifiers(this, o); }
    }

/**
 *<b>
*<li>Rule 217:  AnnotationTypeDeclaration ::= InterfaceModifiersopt @ interface identifier AnnotationTypeBody
 *</b>
 */
class AnnotationTypeDeclaration extends Ast implements IAnnotationTypeDeclaration
    {
         late Ast? _InterfaceModifiersopt;
         late AstToken _AT;
         late AstToken _interface;
         late identifier _identifier;
         late AnnotationTypeBody _AnnotationTypeBody;

        /**
         * The value returned by <b>getInterfaceModifiersopt</b> may be <b>null</b>
         */
         Ast ?  getInterfaceModifiersopt(){ return _InterfaceModifiersopt; }
         void setInterfaceModifiersopt(Ast _InterfaceModifiersopt){ this._InterfaceModifiersopt = _InterfaceModifiersopt; }
         AstToken getAT(){ return _AT; }
         void setAT(AstToken _AT){ this._AT = _AT; }
         AstToken getinterface(){ return _interface; }
         void setinterface(AstToken _interface){ this._interface = _interface; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }
         AnnotationTypeBody getAnnotationTypeBody(){ return _AnnotationTypeBody; }
         void setAnnotationTypeBody(AnnotationTypeBody _AnnotationTypeBody){ this._AnnotationTypeBody = _AnnotationTypeBody; }

        AnnotationTypeDeclaration(IToken leftIToken, IToken rightIToken,
                                  Ast? _InterfaceModifiersopt,
                                  AstToken _AT,
                                  AstToken _interface,
                                  identifier _identifier,
                                  AnnotationTypeBody _AnnotationTypeBody)
            :super(leftIToken, rightIToken)

        {
            this._InterfaceModifiersopt = _InterfaceModifiersopt;
            if (null != _InterfaceModifiersopt) (_InterfaceModifiersopt as Ast).setParent(this);
            this._AT = _AT;
            (_AT as Ast).setParent(this);
            this._interface = _interface;
            (_interface as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            this._AnnotationTypeBody = _AnnotationTypeBody;
            (_AnnotationTypeBody as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _InterfaceModifiersopt)  list.add(_InterfaceModifiersopt);
            if(null != _AT)  list.add(_AT);
            if(null != _interface)  list.add(_interface);
            if(null != _identifier)  list.add(_identifier);
            if(null != _AnnotationTypeBody)  list.add(_AnnotationTypeBody);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitAnnotationTypeDeclaration(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitAnnotationTypeDeclaration(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitAnnotationTypeDeclaration(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitAnnotationTypeDeclaration(this, o); }
    }

/**
 *<b>
*<li>Rule 218:  AnnotationTypeBody ::= { AnnotationTypeElementDeclarationsopt }
 *</b>
 */
class AnnotationTypeBody extends Ast implements IAnnotationTypeBody
    {
         late AstToken _LBRACE;
         late Ast? _AnnotationTypeElementDeclarationsopt;
         late AstToken _RBRACE;

         AstToken getLBRACE(){ return _LBRACE; }
         void setLBRACE(AstToken _LBRACE){ this._LBRACE = _LBRACE; }
        /**
         * The value returned by <b>getAnnotationTypeElementDeclarationsopt</b> may be <b>null</b>
         */
         Ast ?  getAnnotationTypeElementDeclarationsopt(){ return _AnnotationTypeElementDeclarationsopt; }
         void setAnnotationTypeElementDeclarationsopt(Ast _AnnotationTypeElementDeclarationsopt){ this._AnnotationTypeElementDeclarationsopt = _AnnotationTypeElementDeclarationsopt; }
         AstToken getRBRACE(){ return _RBRACE; }
         void setRBRACE(AstToken _RBRACE){ this._RBRACE = _RBRACE; }

        AnnotationTypeBody(IToken leftIToken, IToken rightIToken,
                           AstToken _LBRACE,
                           Ast? _AnnotationTypeElementDeclarationsopt,
                           AstToken _RBRACE)
            :super(leftIToken, rightIToken)

        {
            this._LBRACE = _LBRACE;
            (_LBRACE as Ast).setParent(this);
            this._AnnotationTypeElementDeclarationsopt = _AnnotationTypeElementDeclarationsopt;
            if (null != _AnnotationTypeElementDeclarationsopt) (_AnnotationTypeElementDeclarationsopt as Ast).setParent(this);
            this._RBRACE = _RBRACE;
            (_RBRACE as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _LBRACE)  list.add(_LBRACE);
            if(null != _AnnotationTypeElementDeclarationsopt)  list.add(_AnnotationTypeElementDeclarationsopt);
            if(null != _RBRACE)  list.add(_RBRACE);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitAnnotationTypeBody(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitAnnotationTypeBody(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitAnnotationTypeBody(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitAnnotationTypeBody(this, o); }
    }

/**
 *<em>
*<li>Rule 219:  AnnotationTypeElementDeclarations ::= AnnotationTypeElementDeclaration
 *</em>
 *<p>
 *<b>
*<li>Rule 220:  AnnotationTypeElementDeclarations ::= AnnotationTypeElementDeclarations AnnotationTypeElementDeclaration
 *</b>
 */
class AnnotationTypeElementDeclarations extends Ast implements IAnnotationTypeElementDeclarations
    {
         late Ast _AnnotationTypeElementDeclarations;
         late Ast _AnnotationTypeElementDeclaration;

         Ast getAnnotationTypeElementDeclarations(){ return _AnnotationTypeElementDeclarations; }
         void setAnnotationTypeElementDeclarations(Ast _AnnotationTypeElementDeclarations){ this._AnnotationTypeElementDeclarations = _AnnotationTypeElementDeclarations; }
         Ast getAnnotationTypeElementDeclaration(){ return _AnnotationTypeElementDeclaration; }
         void setAnnotationTypeElementDeclaration(Ast _AnnotationTypeElementDeclaration){ this._AnnotationTypeElementDeclaration = _AnnotationTypeElementDeclaration; }

        AnnotationTypeElementDeclarations(IToken leftIToken, IToken rightIToken,
                                          Ast _AnnotationTypeElementDeclarations,
                                          Ast _AnnotationTypeElementDeclaration)
            :super(leftIToken, rightIToken)

        {
            this._AnnotationTypeElementDeclarations = _AnnotationTypeElementDeclarations;
            (_AnnotationTypeElementDeclarations as Ast).setParent(this);
            this._AnnotationTypeElementDeclaration = _AnnotationTypeElementDeclaration;
            (_AnnotationTypeElementDeclaration as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _AnnotationTypeElementDeclarations)  list.add(_AnnotationTypeElementDeclarations);
            if(null != _AnnotationTypeElementDeclaration)  list.add(_AnnotationTypeElementDeclaration);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitAnnotationTypeElementDeclarations(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitAnnotationTypeElementDeclarations(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitAnnotationTypeElementDeclarations(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitAnnotationTypeElementDeclarations(this, o); }
    }

/**
 *<b>
*<li>Rule 228:  DefaultValue ::= default ElementValue
 *</b>
 */
class DefaultValue extends Ast implements IDefaultValue
    {
         late AstToken _default;
         late Ast _ElementValue;

         AstToken getdefault(){ return _default; }
         void setdefault(AstToken _default){ this._default = _default; }
         Ast getElementValue(){ return _ElementValue; }
         void setElementValue(Ast _ElementValue){ this._ElementValue = _ElementValue; }

        DefaultValue(IToken leftIToken, IToken rightIToken,
                     AstToken _default,
                     Ast _ElementValue)
            :super(leftIToken, rightIToken)

        {
            this._default = _default;
            (_default as Ast).setParent(this);
            this._ElementValue = _ElementValue;
            (_ElementValue as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _default)  list.add(_default);
            if(null != _ElementValue)  list.add(_ElementValue);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitDefaultValue(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitDefaultValue(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitDefaultValue(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitDefaultValue(this, o); }
    }

/**
 *<em>
*<li>Rule 229:  Annotations ::= Annotation
 *</em>
 *<p>
 *<b>
*<li>Rule 230:  Annotations ::= Annotations Annotation
 *</b>
 */
class Annotations extends Ast implements IAnnotations
    {
         late Ast _Annotations;
         late Ast _Annotation;

         Ast getAnnotations(){ return _Annotations; }
         void setAnnotations(Ast _Annotations){ this._Annotations = _Annotations; }
         Ast getAnnotation(){ return _Annotation; }
         void setAnnotation(Ast _Annotation){ this._Annotation = _Annotation; }

        Annotations(IToken leftIToken, IToken rightIToken,
                    Ast _Annotations,
                    Ast _Annotation)
            :super(leftIToken, rightIToken)

        {
            this._Annotations = _Annotations;
            (_Annotations as Ast).setParent(this);
            this._Annotation = _Annotation;
            (_Annotation as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _Annotations)  list.add(_Annotations);
            if(null != _Annotation)  list.add(_Annotation);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitAnnotations(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitAnnotations(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitAnnotations(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitAnnotations(this, o); }
    }

/**
 *<b>
*<li>Rule 234:  NormalAnnotation ::= @ TypeName ( ElementValuePairsopt )
 *</b>
 */
class NormalAnnotation extends Ast implements INormalAnnotation
    {
         late AstToken _AT;
         late Ast _TypeName;
         late AstToken _LPAREN;
         late Ast? _ElementValuePairsopt;
         late AstToken _RPAREN;

         AstToken getAT(){ return _AT; }
         void setAT(AstToken _AT){ this._AT = _AT; }
         Ast getTypeName(){ return _TypeName; }
         void setTypeName(Ast _TypeName){ this._TypeName = _TypeName; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
        /**
         * The value returned by <b>getElementValuePairsopt</b> may be <b>null</b>
         */
         Ast ?  getElementValuePairsopt(){ return _ElementValuePairsopt; }
         void setElementValuePairsopt(Ast _ElementValuePairsopt){ this._ElementValuePairsopt = _ElementValuePairsopt; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }

        NormalAnnotation(IToken leftIToken, IToken rightIToken,
                         AstToken _AT,
                         Ast _TypeName,
                         AstToken _LPAREN,
                         Ast? _ElementValuePairsopt,
                         AstToken _RPAREN)
            :super(leftIToken, rightIToken)

        {
            this._AT = _AT;
            (_AT as Ast).setParent(this);
            this._TypeName = _TypeName;
            (_TypeName as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._ElementValuePairsopt = _ElementValuePairsopt;
            if (null != _ElementValuePairsopt) (_ElementValuePairsopt as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _AT)  list.add(_AT);
            if(null != _TypeName)  list.add(_TypeName);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _ElementValuePairsopt)  list.add(_ElementValuePairsopt);
            if(null != _RPAREN)  list.add(_RPAREN);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitNormalAnnotation(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitNormalAnnotation(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitNormalAnnotation(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitNormalAnnotation(this, o); }
    }

/**
 *<em>
*<li>Rule 235:  ElementValuePairs ::= ElementValuePair
 *</em>
 *<p>
 *<b>
*<li>Rule 236:  ElementValuePairs ::= ElementValuePairs , ElementValuePair
 *</b>
 */
class ElementValuePairs extends Ast implements IElementValuePairs
    {
         late Ast _ElementValuePairs;
         late AstToken _COMMA;
         late ElementValuePair _ElementValuePair;

         Ast getElementValuePairs(){ return _ElementValuePairs; }
         void setElementValuePairs(Ast _ElementValuePairs){ this._ElementValuePairs = _ElementValuePairs; }
         AstToken getCOMMA(){ return _COMMA; }
         void setCOMMA(AstToken _COMMA){ this._COMMA = _COMMA; }
         ElementValuePair getElementValuePair(){ return _ElementValuePair; }
         void setElementValuePair(ElementValuePair _ElementValuePair){ this._ElementValuePair = _ElementValuePair; }

        ElementValuePairs(IToken leftIToken, IToken rightIToken,
                          Ast _ElementValuePairs,
                          AstToken _COMMA,
                          ElementValuePair _ElementValuePair)
            :super(leftIToken, rightIToken)

        {
            this._ElementValuePairs = _ElementValuePairs;
            (_ElementValuePairs as Ast).setParent(this);
            this._COMMA = _COMMA;
            (_COMMA as Ast).setParent(this);
            this._ElementValuePair = _ElementValuePair;
            (_ElementValuePair as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ElementValuePairs)  list.add(_ElementValuePairs);
            if(null != _COMMA)  list.add(_COMMA);
            if(null != _ElementValuePair)  list.add(_ElementValuePair);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitElementValuePairs(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitElementValuePairs(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitElementValuePairs(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitElementValuePairs(this, o); }
    }

/**
 *<b>
*<li>Rule 237:  ElementValuePair ::= SimpleName = ElementValue
 *</b>
 */
class ElementValuePair extends Ast implements IElementValuePair
    {
         late identifier _SimpleName;
         late AstToken _EQUAL;
         late Ast _ElementValue;

         identifier getSimpleName(){ return _SimpleName; }
         void setSimpleName(identifier _SimpleName){ this._SimpleName = _SimpleName; }
         AstToken getEQUAL(){ return _EQUAL; }
         void setEQUAL(AstToken _EQUAL){ this._EQUAL = _EQUAL; }
         Ast getElementValue(){ return _ElementValue; }
         void setElementValue(Ast _ElementValue){ this._ElementValue = _ElementValue; }

        ElementValuePair(IToken leftIToken, IToken rightIToken,
                         identifier _SimpleName,
                         AstToken _EQUAL,
                         Ast _ElementValue)
            :super(leftIToken, rightIToken)

        {
            this._SimpleName = _SimpleName;
            (_SimpleName as Ast).setParent(this);
            this._EQUAL = _EQUAL;
            (_EQUAL as Ast).setParent(this);
            this._ElementValue = _ElementValue;
            (_ElementValue as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _SimpleName)  list.add(_SimpleName);
            if(null != _EQUAL)  list.add(_EQUAL);
            if(null != _ElementValue)  list.add(_ElementValue);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitElementValuePair(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitElementValuePair(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitElementValuePair(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitElementValuePair(this, o); }
    }

/**
 *<b>
*<li>Rule 242:  ElementValueArrayInitializer ::= { ElementValuesopt ,opt }
 *</b>
 */
class ElementValueArrayInitializer extends Ast implements IElementValueArrayInitializer
    {
         late AstToken _LBRACE;
         late Ast? _ElementValuesopt;
         late Commaopt? _Commaopt;
         late AstToken _RBRACE;

         AstToken getLBRACE(){ return _LBRACE; }
         void setLBRACE(AstToken _LBRACE){ this._LBRACE = _LBRACE; }
        /**
         * The value returned by <b>getElementValuesopt</b> may be <b>null</b>
         */
         Ast ?  getElementValuesopt(){ return _ElementValuesopt; }
         void setElementValuesopt(Ast _ElementValuesopt){ this._ElementValuesopt = _ElementValuesopt; }
        /**
         * The value returned by <b>getCommaopt</b> may be <b>null</b>
         */
         Commaopt ?  getCommaopt(){ return _Commaopt; }
         void setCommaopt(Commaopt _Commaopt){ this._Commaopt = _Commaopt; }
         AstToken getRBRACE(){ return _RBRACE; }
         void setRBRACE(AstToken _RBRACE){ this._RBRACE = _RBRACE; }

        ElementValueArrayInitializer(IToken leftIToken, IToken rightIToken,
                                     AstToken _LBRACE,
                                     Ast? _ElementValuesopt,
                                     Commaopt? _Commaopt,
                                     AstToken _RBRACE)
            :super(leftIToken, rightIToken)

        {
            this._LBRACE = _LBRACE;
            (_LBRACE as Ast).setParent(this);
            this._ElementValuesopt = _ElementValuesopt;
            if (null != _ElementValuesopt) (_ElementValuesopt as Ast).setParent(this);
            this._Commaopt = _Commaopt;
            if (null != _Commaopt) (_Commaopt as Ast).setParent(this);
            this._RBRACE = _RBRACE;
            (_RBRACE as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _LBRACE)  list.add(_LBRACE);
            if(null != _ElementValuesopt)  list.add(_ElementValuesopt);
            if(null != _Commaopt)  list.add(_Commaopt);
            if(null != _RBRACE)  list.add(_RBRACE);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitElementValueArrayInitializer(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitElementValueArrayInitializer(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitElementValueArrayInitializer(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitElementValueArrayInitializer(this, o); }
    }

/**
 *<em>
*<li>Rule 243:  ElementValues ::= ElementValue
 *</em>
 *<p>
 *<b>
*<li>Rule 244:  ElementValues ::= ElementValues , ElementValue
 *</b>
 */
class ElementValues extends Ast implements IElementValues
    {
         late Ast _ElementValues;
         late AstToken _COMMA;
         late Ast _ElementValue;

         Ast getElementValues(){ return _ElementValues; }
         void setElementValues(Ast _ElementValues){ this._ElementValues = _ElementValues; }
         AstToken getCOMMA(){ return _COMMA; }
         void setCOMMA(AstToken _COMMA){ this._COMMA = _COMMA; }
         Ast getElementValue(){ return _ElementValue; }
         void setElementValue(Ast _ElementValue){ this._ElementValue = _ElementValue; }

        ElementValues(IToken leftIToken, IToken rightIToken,
                      Ast _ElementValues,
                      AstToken _COMMA,
                      Ast _ElementValue)
            :super(leftIToken, rightIToken)

        {
            this._ElementValues = _ElementValues;
            (_ElementValues as Ast).setParent(this);
            this._COMMA = _COMMA;
            (_COMMA as Ast).setParent(this);
            this._ElementValue = _ElementValue;
            (_ElementValue as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ElementValues)  list.add(_ElementValues);
            if(null != _COMMA)  list.add(_COMMA);
            if(null != _ElementValue)  list.add(_ElementValue);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitElementValues(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitElementValues(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitElementValues(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitElementValues(this, o); }
    }

/**
 *<b>
*<li>Rule 245:  MarkerAnnotation ::= @ TypeName
 *</b>
 */
class MarkerAnnotation extends Ast implements IMarkerAnnotation
    {
         late AstToken _AT;
         late Ast _TypeName;

         AstToken getAT(){ return _AT; }
         void setAT(AstToken _AT){ this._AT = _AT; }
         Ast getTypeName(){ return _TypeName; }
         void setTypeName(Ast _TypeName){ this._TypeName = _TypeName; }

        MarkerAnnotation(IToken leftIToken, IToken rightIToken,
                         AstToken _AT,
                         Ast _TypeName)
            :super(leftIToken, rightIToken)

        {
            this._AT = _AT;
            (_AT as Ast).setParent(this);
            this._TypeName = _TypeName;
            (_TypeName as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _AT)  list.add(_AT);
            if(null != _TypeName)  list.add(_TypeName);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitMarkerAnnotation(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitMarkerAnnotation(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitMarkerAnnotation(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitMarkerAnnotation(this, o); }
    }

/**
 *<b>
*<li>Rule 246:  SingleElementAnnotation ::= @ TypeName ( ElementValue )
 *</b>
 */
class SingleElementAnnotation extends Ast implements ISingleElementAnnotation
    {
         late AstToken _AT;
         late Ast _TypeName;
         late AstToken _LPAREN;
         late Ast _ElementValue;
         late AstToken _RPAREN;

         AstToken getAT(){ return _AT; }
         void setAT(AstToken _AT){ this._AT = _AT; }
         Ast getTypeName(){ return _TypeName; }
         void setTypeName(Ast _TypeName){ this._TypeName = _TypeName; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
         Ast getElementValue(){ return _ElementValue; }
         void setElementValue(Ast _ElementValue){ this._ElementValue = _ElementValue; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }

        SingleElementAnnotation(IToken leftIToken, IToken rightIToken,
                                AstToken _AT,
                                Ast _TypeName,
                                AstToken _LPAREN,
                                Ast _ElementValue,
                                AstToken _RPAREN)
            :super(leftIToken, rightIToken)

        {
            this._AT = _AT;
            (_AT as Ast).setParent(this);
            this._TypeName = _TypeName;
            (_TypeName as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._ElementValue = _ElementValue;
            (_ElementValue as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _AT)  list.add(_AT);
            if(null != _TypeName)  list.add(_TypeName);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _ElementValue)  list.add(_ElementValue);
            if(null != _RPAREN)  list.add(_RPAREN);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitSingleElementAnnotation(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitSingleElementAnnotation(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitSingleElementAnnotation(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitSingleElementAnnotation(this, o); }
    }

/**
 *<b>
*<li>Rule 247:  ArrayInitializer ::= { VariableInitializersopt ,opt }
 *</b>
 */
class ArrayInitializer extends Ast implements IArrayInitializer
    {
         late AstToken _LBRACE;
         late Ast? _VariableInitializersopt;
         late Commaopt? _Commaopt;
         late AstToken _RBRACE;

         AstToken getLBRACE(){ return _LBRACE; }
         void setLBRACE(AstToken _LBRACE){ this._LBRACE = _LBRACE; }
        /**
         * The value returned by <b>getVariableInitializersopt</b> may be <b>null</b>
         */
         Ast ?  getVariableInitializersopt(){ return _VariableInitializersopt; }
         void setVariableInitializersopt(Ast _VariableInitializersopt){ this._VariableInitializersopt = _VariableInitializersopt; }
        /**
         * The value returned by <b>getCommaopt</b> may be <b>null</b>
         */
         Commaopt ?  getCommaopt(){ return _Commaopt; }
         void setCommaopt(Commaopt _Commaopt){ this._Commaopt = _Commaopt; }
         AstToken getRBRACE(){ return _RBRACE; }
         void setRBRACE(AstToken _RBRACE){ this._RBRACE = _RBRACE; }

        ArrayInitializer(IToken leftIToken, IToken rightIToken,
                         AstToken _LBRACE,
                         Ast? _VariableInitializersopt,
                         Commaopt? _Commaopt,
                         AstToken _RBRACE)
            :super(leftIToken, rightIToken)

        {
            this._LBRACE = _LBRACE;
            (_LBRACE as Ast).setParent(this);
            this._VariableInitializersopt = _VariableInitializersopt;
            if (null != _VariableInitializersopt) (_VariableInitializersopt as Ast).setParent(this);
            this._Commaopt = _Commaopt;
            if (null != _Commaopt) (_Commaopt as Ast).setParent(this);
            this._RBRACE = _RBRACE;
            (_RBRACE as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _LBRACE)  list.add(_LBRACE);
            if(null != _VariableInitializersopt)  list.add(_VariableInitializersopt);
            if(null != _Commaopt)  list.add(_Commaopt);
            if(null != _RBRACE)  list.add(_RBRACE);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitArrayInitializer(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitArrayInitializer(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitArrayInitializer(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitArrayInitializer(this, o); }
    }

/**
 *<em>
*<li>Rule 248:  VariableInitializers ::= VariableInitializer
 *</em>
 *<p>
 *<b>
*<li>Rule 249:  VariableInitializers ::= VariableInitializers , VariableInitializer
 *</b>
 */
class VariableInitializers extends Ast implements IVariableInitializers
    {
         late Ast _VariableInitializers;
         late AstToken _COMMA;
         late Ast _VariableInitializer;

         Ast getVariableInitializers(){ return _VariableInitializers; }
         void setVariableInitializers(Ast _VariableInitializers){ this._VariableInitializers = _VariableInitializers; }
         AstToken getCOMMA(){ return _COMMA; }
         void setCOMMA(AstToken _COMMA){ this._COMMA = _COMMA; }
         Ast getVariableInitializer(){ return _VariableInitializer; }
         void setVariableInitializer(Ast _VariableInitializer){ this._VariableInitializer = _VariableInitializer; }

        VariableInitializers(IToken leftIToken, IToken rightIToken,
                             Ast _VariableInitializers,
                             AstToken _COMMA,
                             Ast _VariableInitializer)
            :super(leftIToken, rightIToken)

        {
            this._VariableInitializers = _VariableInitializers;
            (_VariableInitializers as Ast).setParent(this);
            this._COMMA = _COMMA;
            (_COMMA as Ast).setParent(this);
            this._VariableInitializer = _VariableInitializer;
            (_VariableInitializer as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _VariableInitializers)  list.add(_VariableInitializers);
            if(null != _COMMA)  list.add(_COMMA);
            if(null != _VariableInitializer)  list.add(_VariableInitializer);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitVariableInitializers(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitVariableInitializers(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitVariableInitializers(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitVariableInitializers(this, o); }
    }

/**
 *<b>
*<li>Rule 250:  Block ::= { BlockStatementsopt }
 *</b>
 */
class Block extends Ast implements IBlock
    {
         late AstToken _LBRACE;
         late Ast? _BlockStatementsopt;
         late AstToken _RBRACE;

         AstToken getLBRACE(){ return _LBRACE; }
         void setLBRACE(AstToken _LBRACE){ this._LBRACE = _LBRACE; }
        /**
         * The value returned by <b>getBlockStatementsopt</b> may be <b>null</b>
         */
         Ast ?  getBlockStatementsopt(){ return _BlockStatementsopt; }
         void setBlockStatementsopt(Ast _BlockStatementsopt){ this._BlockStatementsopt = _BlockStatementsopt; }
         AstToken getRBRACE(){ return _RBRACE; }
         void setRBRACE(AstToken _RBRACE){ this._RBRACE = _RBRACE; }

        Block(IToken leftIToken, IToken rightIToken,
              AstToken _LBRACE,
              Ast? _BlockStatementsopt,
              AstToken _RBRACE)
            :super(leftIToken, rightIToken)

        {
            this._LBRACE = _LBRACE;
            (_LBRACE as Ast).setParent(this);
            this._BlockStatementsopt = _BlockStatementsopt;
            if (null != _BlockStatementsopt) (_BlockStatementsopt as Ast).setParent(this);
            this._RBRACE = _RBRACE;
            (_RBRACE as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _LBRACE)  list.add(_LBRACE);
            if(null != _BlockStatementsopt)  list.add(_BlockStatementsopt);
            if(null != _RBRACE)  list.add(_RBRACE);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitBlock(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitBlock(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitBlock(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitBlock(this, o); }
    }

/**
 *<em>
*<li>Rule 251:  BlockStatements ::= BlockStatement
 *</em>
 *<p>
 *<b>
*<li>Rule 252:  BlockStatements ::= BlockStatements BlockStatement
 *</b>
 */
class BlockStatements extends Ast implements IBlockStatements
    {
         late Ast _BlockStatements;
         late Ast _BlockStatement;

         Ast getBlockStatements(){ return _BlockStatements; }
         void setBlockStatements(Ast _BlockStatements){ this._BlockStatements = _BlockStatements; }
         Ast getBlockStatement(){ return _BlockStatement; }
         void setBlockStatement(Ast _BlockStatement){ this._BlockStatement = _BlockStatement; }

        BlockStatements(IToken leftIToken, IToken rightIToken,
                        Ast _BlockStatements,
                        Ast _BlockStatement)
            :super(leftIToken, rightIToken)

        {
            this._BlockStatements = _BlockStatements;
            (_BlockStatements as Ast).setParent(this);
            this._BlockStatement = _BlockStatement;
            (_BlockStatement as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _BlockStatements)  list.add(_BlockStatements);
            if(null != _BlockStatement)  list.add(_BlockStatement);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitBlockStatements(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitBlockStatements(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitBlockStatements(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitBlockStatements(this, o); }
    }

/**
 *<b>
*<li>Rule 256:  LocalVariableDeclarationStatement ::= LocalVariableDeclaration ;
 *</b>
 */
class LocalVariableDeclarationStatement extends Ast implements ILocalVariableDeclarationStatement
    {
         late LocalVariableDeclaration _LocalVariableDeclaration;
         late AstToken _SEMICOLON;

         LocalVariableDeclaration getLocalVariableDeclaration(){ return _LocalVariableDeclaration; }
         void setLocalVariableDeclaration(LocalVariableDeclaration _LocalVariableDeclaration){ this._LocalVariableDeclaration = _LocalVariableDeclaration; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        LocalVariableDeclarationStatement(IToken leftIToken, IToken rightIToken,
                                          LocalVariableDeclaration _LocalVariableDeclaration,
                                          AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._LocalVariableDeclaration = _LocalVariableDeclaration;
            (_LocalVariableDeclaration as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _LocalVariableDeclaration)  list.add(_LocalVariableDeclaration);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitLocalVariableDeclarationStatement(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitLocalVariableDeclarationStatement(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitLocalVariableDeclarationStatement(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitLocalVariableDeclarationStatement(this, o); }
    }

/**
 *<b>
*<li>Rule 257:  LocalVariableDeclaration ::= VariableModifiersopt Type VariableDeclarators
 *</b>
 */
class LocalVariableDeclaration extends Ast implements ILocalVariableDeclaration
    {
         late Ast? _VariableModifiersopt;
         late Ast _Type;
         late Ast _VariableDeclarators;

        /**
         * The value returned by <b>getVariableModifiersopt</b> may be <b>null</b>
         */
         Ast ?  getVariableModifiersopt(){ return _VariableModifiersopt; }
         void setVariableModifiersopt(Ast _VariableModifiersopt){ this._VariableModifiersopt = _VariableModifiersopt; }
         Ast getType(){ return _Type; }
         void setType(Ast _Type){ this._Type = _Type; }
         Ast getVariableDeclarators(){ return _VariableDeclarators; }
         void setVariableDeclarators(Ast _VariableDeclarators){ this._VariableDeclarators = _VariableDeclarators; }

        LocalVariableDeclaration(IToken leftIToken, IToken rightIToken,
                                 Ast? _VariableModifiersopt,
                                 Ast _Type,
                                 Ast _VariableDeclarators)
            :super(leftIToken, rightIToken)

        {
            this._VariableModifiersopt = _VariableModifiersopt;
            if (null != _VariableModifiersopt) (_VariableModifiersopt as Ast).setParent(this);
            this._Type = _Type;
            (_Type as Ast).setParent(this);
            this._VariableDeclarators = _VariableDeclarators;
            (_VariableDeclarators as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _VariableModifiersopt)  list.add(_VariableModifiersopt);
            if(null != _Type)  list.add(_Type);
            if(null != _VariableDeclarators)  list.add(_VariableDeclarators);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitLocalVariableDeclaration(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitLocalVariableDeclaration(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitLocalVariableDeclaration(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitLocalVariableDeclaration(this, o); }
    }

/**
 *<b>
*<li>Rule 281:  IfThenStatement ::= if ( Expression ) Statement
 *</b>
 */
class IfThenStatement extends Ast implements IIfThenStatement
    {
         late AstToken _if;
         late AstToken _LPAREN;
         late Ast _Expression;
         late AstToken _RPAREN;
         late Ast _Statement;

         AstToken getif(){ return _if; }
         void setif(AstToken _if){ this._if = _if; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
         Ast getExpression(){ return _Expression; }
         void setExpression(Ast _Expression){ this._Expression = _Expression; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
         Ast getStatement(){ return _Statement; }
         void setStatement(Ast _Statement){ this._Statement = _Statement; }

        IfThenStatement(IToken leftIToken, IToken rightIToken,
                        AstToken _if,
                        AstToken _LPAREN,
                        Ast _Expression,
                        AstToken _RPAREN,
                        Ast _Statement)
            :super(leftIToken, rightIToken)

        {
            this._if = _if;
            (_if as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._Expression = _Expression;
            (_Expression as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._Statement = _Statement;
            (_Statement as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _if)  list.add(_if);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _Expression)  list.add(_Expression);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _Statement)  list.add(_Statement);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitIfThenStatement(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitIfThenStatement(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitIfThenStatement(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitIfThenStatement(this, o); }
    }

/**
 *<b>
*<li>Rule 282:  IfThenElseStatement ::= if ( Expression ) StatementNoShortIf else Statement
 *</b>
 */
class IfThenElseStatement extends Ast implements IIfThenElseStatement
    {
         late AstToken _if;
         late AstToken _LPAREN;
         late Ast _Expression;
         late AstToken _RPAREN;
         late Ast _StatementNoShortIf;
         late AstToken _else;
         late Ast _Statement;

         AstToken getif(){ return _if; }
         void setif(AstToken _if){ this._if = _if; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
         Ast getExpression(){ return _Expression; }
         void setExpression(Ast _Expression){ this._Expression = _Expression; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
         Ast getStatementNoShortIf(){ return _StatementNoShortIf; }
         void setStatementNoShortIf(Ast _StatementNoShortIf){ this._StatementNoShortIf = _StatementNoShortIf; }
         AstToken getelse(){ return _else; }
         void setelse(AstToken _else){ this._else = _else; }
         Ast getStatement(){ return _Statement; }
         void setStatement(Ast _Statement){ this._Statement = _Statement; }

        IfThenElseStatement(IToken leftIToken, IToken rightIToken,
                            AstToken _if,
                            AstToken _LPAREN,
                            Ast _Expression,
                            AstToken _RPAREN,
                            Ast _StatementNoShortIf,
                            AstToken _else,
                            Ast _Statement)
            :super(leftIToken, rightIToken)

        {
            this._if = _if;
            (_if as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._Expression = _Expression;
            (_Expression as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._StatementNoShortIf = _StatementNoShortIf;
            (_StatementNoShortIf as Ast).setParent(this);
            this._else = _else;
            (_else as Ast).setParent(this);
            this._Statement = _Statement;
            (_Statement as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _if)  list.add(_if);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _Expression)  list.add(_Expression);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _StatementNoShortIf)  list.add(_StatementNoShortIf);
            if(null != _else)  list.add(_else);
            if(null != _Statement)  list.add(_Statement);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitIfThenElseStatement(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitIfThenElseStatement(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitIfThenElseStatement(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitIfThenElseStatement(this, o); }
    }

/**
 *<b>
*<li>Rule 283:  IfThenElseStatementNoShortIf ::= if ( Expression ) StatementNoShortIf else StatementNoShortIf
 *</b>
 */
class IfThenElseStatementNoShortIf extends Ast implements IIfThenElseStatementNoShortIf
    {
         late AstToken _if;
         late AstToken _LPAREN;
         late Ast _Expression;
         late AstToken _RPAREN;
         late Ast _StatementNoShortIf;
         late AstToken _else;
         late Ast _StatementNoShortIf7;

         AstToken getif(){ return _if; }
         void setif(AstToken _if){ this._if = _if; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
         Ast getExpression(){ return _Expression; }
         void setExpression(Ast _Expression){ this._Expression = _Expression; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
         Ast getStatementNoShortIf(){ return _StatementNoShortIf; }
         void setStatementNoShortIf(Ast _StatementNoShortIf){ this._StatementNoShortIf = _StatementNoShortIf; }
         AstToken getelse(){ return _else; }
         void setelse(AstToken _else){ this._else = _else; }
         Ast getStatementNoShortIf7(){ return _StatementNoShortIf7; }
         void setStatementNoShortIf7(Ast _StatementNoShortIf7){ this._StatementNoShortIf7 = _StatementNoShortIf7; }

        IfThenElseStatementNoShortIf(IToken leftIToken, IToken rightIToken,
                                     AstToken _if,
                                     AstToken _LPAREN,
                                     Ast _Expression,
                                     AstToken _RPAREN,
                                     Ast _StatementNoShortIf,
                                     AstToken _else,
                                     Ast _StatementNoShortIf7)
            :super(leftIToken, rightIToken)

        {
            this._if = _if;
            (_if as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._Expression = _Expression;
            (_Expression as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._StatementNoShortIf = _StatementNoShortIf;
            (_StatementNoShortIf as Ast).setParent(this);
            this._else = _else;
            (_else as Ast).setParent(this);
            this._StatementNoShortIf7 = _StatementNoShortIf7;
            (_StatementNoShortIf7 as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _if)  list.add(_if);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _Expression)  list.add(_Expression);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _StatementNoShortIf)  list.add(_StatementNoShortIf);
            if(null != _else)  list.add(_else);
            if(null != _StatementNoShortIf7)  list.add(_StatementNoShortIf7);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitIfThenElseStatementNoShortIf(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitIfThenElseStatementNoShortIf(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitIfThenElseStatementNoShortIf(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitIfThenElseStatementNoShortIf(this, o); }
    }

/**
 *<b>
*<li>Rule 284:  EmptyStatement ::= ;
 *</b>
 */
class EmptyStatement extends AstToken implements IEmptyStatement
    {
         IToken getSEMICOLON(){ return leftIToken; }

    EmptyStatement(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitEmptyStatement(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitEmptyStatement(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitEmptyStatement(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitEmptyStatement(this, o); }
    }

/**
 *<b>
*<li>Rule 285:  LabeledStatement ::= identifier : Statement
 *</b>
 */
class LabeledStatement extends Ast implements ILabeledStatement
    {
         late identifier _identifier;
         late AstToken _COLON;
         late Ast _Statement;

         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }
         AstToken getCOLON(){ return _COLON; }
         void setCOLON(AstToken _COLON){ this._COLON = _COLON; }
         Ast getStatement(){ return _Statement; }
         void setStatement(Ast _Statement){ this._Statement = _Statement; }

        LabeledStatement(IToken leftIToken, IToken rightIToken,
                         identifier _identifier,
                         AstToken _COLON,
                         Ast _Statement)
            :super(leftIToken, rightIToken)

        {
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            this._COLON = _COLON;
            (_COLON as Ast).setParent(this);
            this._Statement = _Statement;
            (_Statement as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _identifier)  list.add(_identifier);
            if(null != _COLON)  list.add(_COLON);
            if(null != _Statement)  list.add(_Statement);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitLabeledStatement(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitLabeledStatement(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitLabeledStatement(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitLabeledStatement(this, o); }
    }

/**
 *<b>
*<li>Rule 286:  LabeledStatementNoShortIf ::= identifier : StatementNoShortIf
 *</b>
 */
class LabeledStatementNoShortIf extends Ast implements ILabeledStatementNoShortIf
    {
         late identifier _identifier;
         late AstToken _COLON;
         late Ast _StatementNoShortIf;

         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }
         AstToken getCOLON(){ return _COLON; }
         void setCOLON(AstToken _COLON){ this._COLON = _COLON; }
         Ast getStatementNoShortIf(){ return _StatementNoShortIf; }
         void setStatementNoShortIf(Ast _StatementNoShortIf){ this._StatementNoShortIf = _StatementNoShortIf; }

        LabeledStatementNoShortIf(IToken leftIToken, IToken rightIToken,
                                  identifier _identifier,
                                  AstToken _COLON,
                                  Ast _StatementNoShortIf)
            :super(leftIToken, rightIToken)

        {
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            this._COLON = _COLON;
            (_COLON as Ast).setParent(this);
            this._StatementNoShortIf = _StatementNoShortIf;
            (_StatementNoShortIf as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _identifier)  list.add(_identifier);
            if(null != _COLON)  list.add(_COLON);
            if(null != _StatementNoShortIf)  list.add(_StatementNoShortIf);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitLabeledStatementNoShortIf(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitLabeledStatementNoShortIf(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitLabeledStatementNoShortIf(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitLabeledStatementNoShortIf(this, o); }
    }

/**
 *<b>
*<li>Rule 287:  ExpressionStatement ::= StatementExpression ;
 *</b>
 */
class ExpressionStatement extends Ast implements IExpressionStatement
    {
         late Ast _StatementExpression;
         late AstToken _SEMICOLON;

         Ast getStatementExpression(){ return _StatementExpression; }
         void setStatementExpression(Ast _StatementExpression){ this._StatementExpression = _StatementExpression; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        ExpressionStatement(IToken leftIToken, IToken rightIToken,
                            Ast _StatementExpression,
                            AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._StatementExpression = _StatementExpression;
            (_StatementExpression as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _StatementExpression)  list.add(_StatementExpression);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitExpressionStatement(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitExpressionStatement(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitExpressionStatement(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitExpressionStatement(this, o); }
    }

/**
 *<b>
*<li>Rule 297:  SwitchStatement ::= switch ( Expression ) SwitchBlock
 *</b>
 */
class SwitchStatement extends Ast implements ISwitchStatement
    {
         late AstToken _switch;
         late AstToken _LPAREN;
         late Ast _Expression;
         late AstToken _RPAREN;
         late SwitchBlock _SwitchBlock;

         AstToken getswitch(){ return _switch; }
         void setswitch(AstToken _switch){ this._switch = _switch; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
         Ast getExpression(){ return _Expression; }
         void setExpression(Ast _Expression){ this._Expression = _Expression; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
         SwitchBlock getSwitchBlock(){ return _SwitchBlock; }
         void setSwitchBlock(SwitchBlock _SwitchBlock){ this._SwitchBlock = _SwitchBlock; }

        SwitchStatement(IToken leftIToken, IToken rightIToken,
                        AstToken _switch,
                        AstToken _LPAREN,
                        Ast _Expression,
                        AstToken _RPAREN,
                        SwitchBlock _SwitchBlock)
            :super(leftIToken, rightIToken)

        {
            this._switch = _switch;
            (_switch as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._Expression = _Expression;
            (_Expression as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._SwitchBlock = _SwitchBlock;
            (_SwitchBlock as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _switch)  list.add(_switch);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _Expression)  list.add(_Expression);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _SwitchBlock)  list.add(_SwitchBlock);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitSwitchStatement(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitSwitchStatement(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitSwitchStatement(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitSwitchStatement(this, o); }
    }

/**
 *<b>
*<li>Rule 298:  SwitchBlock ::= { SwitchBlockStatementGroupsopt SwitchLabelsopt }
 *</b>
 */
class SwitchBlock extends Ast implements ISwitchBlock
    {
         late AstToken _LBRACE;
         late Ast? _SwitchBlockStatementGroupsopt;
         late Ast? _SwitchLabelsopt;
         late AstToken _RBRACE;

         AstToken getLBRACE(){ return _LBRACE; }
         void setLBRACE(AstToken _LBRACE){ this._LBRACE = _LBRACE; }
        /**
         * The value returned by <b>getSwitchBlockStatementGroupsopt</b> may be <b>null</b>
         */
         Ast ?  getSwitchBlockStatementGroupsopt(){ return _SwitchBlockStatementGroupsopt; }
         void setSwitchBlockStatementGroupsopt(Ast _SwitchBlockStatementGroupsopt){ this._SwitchBlockStatementGroupsopt = _SwitchBlockStatementGroupsopt; }
        /**
         * The value returned by <b>getSwitchLabelsopt</b> may be <b>null</b>
         */
         Ast ?  getSwitchLabelsopt(){ return _SwitchLabelsopt; }
         void setSwitchLabelsopt(Ast _SwitchLabelsopt){ this._SwitchLabelsopt = _SwitchLabelsopt; }
         AstToken getRBRACE(){ return _RBRACE; }
         void setRBRACE(AstToken _RBRACE){ this._RBRACE = _RBRACE; }

        SwitchBlock(IToken leftIToken, IToken rightIToken,
                    AstToken _LBRACE,
                    Ast? _SwitchBlockStatementGroupsopt,
                    Ast? _SwitchLabelsopt,
                    AstToken _RBRACE)
            :super(leftIToken, rightIToken)

        {
            this._LBRACE = _LBRACE;
            (_LBRACE as Ast).setParent(this);
            this._SwitchBlockStatementGroupsopt = _SwitchBlockStatementGroupsopt;
            if (null != _SwitchBlockStatementGroupsopt) (_SwitchBlockStatementGroupsopt as Ast).setParent(this);
            this._SwitchLabelsopt = _SwitchLabelsopt;
            if (null != _SwitchLabelsopt) (_SwitchLabelsopt as Ast).setParent(this);
            this._RBRACE = _RBRACE;
            (_RBRACE as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _LBRACE)  list.add(_LBRACE);
            if(null != _SwitchBlockStatementGroupsopt)  list.add(_SwitchBlockStatementGroupsopt);
            if(null != _SwitchLabelsopt)  list.add(_SwitchLabelsopt);
            if(null != _RBRACE)  list.add(_RBRACE);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitSwitchBlock(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitSwitchBlock(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitSwitchBlock(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitSwitchBlock(this, o); }
    }

/**
 *<em>
*<li>Rule 299:  SwitchBlockStatementGroups ::= SwitchBlockStatementGroup
 *</em>
 *<p>
 *<b>
*<li>Rule 300:  SwitchBlockStatementGroups ::= SwitchBlockStatementGroups SwitchBlockStatementGroup
 *</b>
 */
class SwitchBlockStatementGroups extends Ast implements ISwitchBlockStatementGroups
    {
         late Ast _SwitchBlockStatementGroups;
         late SwitchBlockStatementGroup _SwitchBlockStatementGroup;

         Ast getSwitchBlockStatementGroups(){ return _SwitchBlockStatementGroups; }
         void setSwitchBlockStatementGroups(Ast _SwitchBlockStatementGroups){ this._SwitchBlockStatementGroups = _SwitchBlockStatementGroups; }
         SwitchBlockStatementGroup getSwitchBlockStatementGroup(){ return _SwitchBlockStatementGroup; }
         void setSwitchBlockStatementGroup(SwitchBlockStatementGroup _SwitchBlockStatementGroup){ this._SwitchBlockStatementGroup = _SwitchBlockStatementGroup; }

        SwitchBlockStatementGroups(IToken leftIToken, IToken rightIToken,
                                   Ast _SwitchBlockStatementGroups,
                                   SwitchBlockStatementGroup _SwitchBlockStatementGroup)
            :super(leftIToken, rightIToken)

        {
            this._SwitchBlockStatementGroups = _SwitchBlockStatementGroups;
            (_SwitchBlockStatementGroups as Ast).setParent(this);
            this._SwitchBlockStatementGroup = _SwitchBlockStatementGroup;
            (_SwitchBlockStatementGroup as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _SwitchBlockStatementGroups)  list.add(_SwitchBlockStatementGroups);
            if(null != _SwitchBlockStatementGroup)  list.add(_SwitchBlockStatementGroup);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitSwitchBlockStatementGroups(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitSwitchBlockStatementGroups(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitSwitchBlockStatementGroups(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitSwitchBlockStatementGroups(this, o); }
    }

/**
 *<b>
*<li>Rule 301:  SwitchBlockStatementGroup ::= SwitchLabels BlockStatements
 *</b>
 */
class SwitchBlockStatementGroup extends Ast implements ISwitchBlockStatementGroup
    {
         late Ast _SwitchLabels;
         late Ast _BlockStatements;

         Ast getSwitchLabels(){ return _SwitchLabels; }
         void setSwitchLabels(Ast _SwitchLabels){ this._SwitchLabels = _SwitchLabels; }
         Ast getBlockStatements(){ return _BlockStatements; }
         void setBlockStatements(Ast _BlockStatements){ this._BlockStatements = _BlockStatements; }

        SwitchBlockStatementGroup(IToken leftIToken, IToken rightIToken,
                                  Ast _SwitchLabels,
                                  Ast _BlockStatements)
            :super(leftIToken, rightIToken)

        {
            this._SwitchLabels = _SwitchLabels;
            (_SwitchLabels as Ast).setParent(this);
            this._BlockStatements = _BlockStatements;
            (_BlockStatements as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _SwitchLabels)  list.add(_SwitchLabels);
            if(null != _BlockStatements)  list.add(_BlockStatements);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitSwitchBlockStatementGroup(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitSwitchBlockStatementGroup(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitSwitchBlockStatementGroup(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitSwitchBlockStatementGroup(this, o); }
    }

/**
 *<em>
*<li>Rule 302:  SwitchLabels ::= SwitchLabel
 *</em>
 *<p>
 *<b>
*<li>Rule 303:  SwitchLabels ::= SwitchLabels SwitchLabel
 *</b>
 */
class SwitchLabels extends Ast implements ISwitchLabels
    {
         late Ast _SwitchLabels;
         late Ast _SwitchLabel;

         Ast getSwitchLabels(){ return _SwitchLabels; }
         void setSwitchLabels(Ast _SwitchLabels){ this._SwitchLabels = _SwitchLabels; }
         Ast getSwitchLabel(){ return _SwitchLabel; }
         void setSwitchLabel(Ast _SwitchLabel){ this._SwitchLabel = _SwitchLabel; }

        SwitchLabels(IToken leftIToken, IToken rightIToken,
                     Ast _SwitchLabels,
                     Ast _SwitchLabel)
            :super(leftIToken, rightIToken)

        {
            this._SwitchLabels = _SwitchLabels;
            (_SwitchLabels as Ast).setParent(this);
            this._SwitchLabel = _SwitchLabel;
            (_SwitchLabel as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _SwitchLabels)  list.add(_SwitchLabels);
            if(null != _SwitchLabel)  list.add(_SwitchLabel);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitSwitchLabels(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitSwitchLabels(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitSwitchLabels(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitSwitchLabels(this, o); }
    }

/**
 *<b>
*<li>Rule 308:  WhileStatement ::= while ( Expression ) Statement
 *</b>
 */
class WhileStatement extends Ast implements IWhileStatement
    {
         late AstToken _while;
         late AstToken _LPAREN;
         late Ast _Expression;
         late AstToken _RPAREN;
         late Ast _Statement;

         AstToken getwhile(){ return _while; }
         void setwhile(AstToken _while){ this._while = _while; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
         Ast getExpression(){ return _Expression; }
         void setExpression(Ast _Expression){ this._Expression = _Expression; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
         Ast getStatement(){ return _Statement; }
         void setStatement(Ast _Statement){ this._Statement = _Statement; }

        WhileStatement(IToken leftIToken, IToken rightIToken,
                       AstToken _while,
                       AstToken _LPAREN,
                       Ast _Expression,
                       AstToken _RPAREN,
                       Ast _Statement)
            :super(leftIToken, rightIToken)

        {
            this._while = _while;
            (_while as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._Expression = _Expression;
            (_Expression as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._Statement = _Statement;
            (_Statement as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _while)  list.add(_while);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _Expression)  list.add(_Expression);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _Statement)  list.add(_Statement);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitWhileStatement(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitWhileStatement(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitWhileStatement(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitWhileStatement(this, o); }
    }

/**
 *<b>
*<li>Rule 309:  WhileStatementNoShortIf ::= while ( Expression ) StatementNoShortIf
 *</b>
 */
class WhileStatementNoShortIf extends Ast implements IWhileStatementNoShortIf
    {
         late AstToken _while;
         late AstToken _LPAREN;
         late Ast _Expression;
         late AstToken _RPAREN;
         late Ast _StatementNoShortIf;

         AstToken getwhile(){ return _while; }
         void setwhile(AstToken _while){ this._while = _while; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
         Ast getExpression(){ return _Expression; }
         void setExpression(Ast _Expression){ this._Expression = _Expression; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
         Ast getStatementNoShortIf(){ return _StatementNoShortIf; }
         void setStatementNoShortIf(Ast _StatementNoShortIf){ this._StatementNoShortIf = _StatementNoShortIf; }

        WhileStatementNoShortIf(IToken leftIToken, IToken rightIToken,
                                AstToken _while,
                                AstToken _LPAREN,
                                Ast _Expression,
                                AstToken _RPAREN,
                                Ast _StatementNoShortIf)
            :super(leftIToken, rightIToken)

        {
            this._while = _while;
            (_while as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._Expression = _Expression;
            (_Expression as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._StatementNoShortIf = _StatementNoShortIf;
            (_StatementNoShortIf as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _while)  list.add(_while);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _Expression)  list.add(_Expression);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _StatementNoShortIf)  list.add(_StatementNoShortIf);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitWhileStatementNoShortIf(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitWhileStatementNoShortIf(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitWhileStatementNoShortIf(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitWhileStatementNoShortIf(this, o); }
    }

/**
 *<b>
*<li>Rule 310:  DoStatement ::= do Statement while ( Expression ) ;
 *</b>
 */
class DoStatement extends Ast implements IDoStatement
    {
         late AstToken _do;
         late Ast _Statement;
         late AstToken _while;
         late AstToken _LPAREN;
         late Ast _Expression;
         late AstToken _RPAREN;
         late AstToken _SEMICOLON;

         AstToken getdo(){ return _do; }
         void setdo(AstToken _do){ this._do = _do; }
         Ast getStatement(){ return _Statement; }
         void setStatement(Ast _Statement){ this._Statement = _Statement; }
         AstToken getwhile(){ return _while; }
         void setwhile(AstToken _while){ this._while = _while; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
         Ast getExpression(){ return _Expression; }
         void setExpression(Ast _Expression){ this._Expression = _Expression; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        DoStatement(IToken leftIToken, IToken rightIToken,
                    AstToken _do,
                    Ast _Statement,
                    AstToken _while,
                    AstToken _LPAREN,
                    Ast _Expression,
                    AstToken _RPAREN,
                    AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._do = _do;
            (_do as Ast).setParent(this);
            this._Statement = _Statement;
            (_Statement as Ast).setParent(this);
            this._while = _while;
            (_while as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._Expression = _Expression;
            (_Expression as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _do)  list.add(_do);
            if(null != _Statement)  list.add(_Statement);
            if(null != _while)  list.add(_while);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _Expression)  list.add(_Expression);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitDoStatement(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitDoStatement(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitDoStatement(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitDoStatement(this, o); }
    }

/**
 *<b>
*<li>Rule 313:  BasicForStatement ::= for ( ForInitopt ; Expressionopt ; ForUpdateopt ) Statement
 *</b>
 */
class BasicForStatement extends Ast implements IBasicForStatement
    {
         late AstToken _for;
         late AstToken _LPAREN;
         late Ast? _ForInitopt;
         late AstToken _SEMICOLON;
         late Ast? _Expressionopt;
         late AstToken _SEMICOLON6;
         late Ast? _ForUpdateopt;
         late AstToken _RPAREN;
         late Ast _Statement;

         AstToken getfor(){ return _for; }
         void setfor(AstToken _for){ this._for = _for; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
        /**
         * The value returned by <b>getForInitopt</b> may be <b>null</b>
         */
         Ast ?  getForInitopt(){ return _ForInitopt; }
         void setForInitopt(Ast _ForInitopt){ this._ForInitopt = _ForInitopt; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }
        /**
         * The value returned by <b>getExpressionopt</b> may be <b>null</b>
         */
         Ast ?  getExpressionopt(){ return _Expressionopt; }
         void setExpressionopt(Ast _Expressionopt){ this._Expressionopt = _Expressionopt; }
         AstToken getSEMICOLON6(){ return _SEMICOLON6; }
         void setSEMICOLON6(AstToken _SEMICOLON6){ this._SEMICOLON6 = _SEMICOLON6; }
        /**
         * The value returned by <b>getForUpdateopt</b> may be <b>null</b>
         */
         Ast ?  getForUpdateopt(){ return _ForUpdateopt; }
         void setForUpdateopt(Ast _ForUpdateopt){ this._ForUpdateopt = _ForUpdateopt; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
         Ast getStatement(){ return _Statement; }
         void setStatement(Ast _Statement){ this._Statement = _Statement; }

        BasicForStatement(IToken leftIToken, IToken rightIToken,
                          AstToken _for,
                          AstToken _LPAREN,
                          Ast? _ForInitopt,
                          AstToken _SEMICOLON,
                          Ast? _Expressionopt,
                          AstToken _SEMICOLON6,
                          Ast? _ForUpdateopt,
                          AstToken _RPAREN,
                          Ast _Statement)
            :super(leftIToken, rightIToken)

        {
            this._for = _for;
            (_for as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._ForInitopt = _ForInitopt;
            if (null != _ForInitopt) (_ForInitopt as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            this._Expressionopt = _Expressionopt;
            if (null != _Expressionopt) (_Expressionopt as Ast).setParent(this);
            this._SEMICOLON6 = _SEMICOLON6;
            (_SEMICOLON6 as Ast).setParent(this);
            this._ForUpdateopt = _ForUpdateopt;
            if (null != _ForUpdateopt) (_ForUpdateopt as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._Statement = _Statement;
            (_Statement as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _for)  list.add(_for);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _ForInitopt)  list.add(_ForInitopt);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            if(null != _Expressionopt)  list.add(_Expressionopt);
            if(null != _SEMICOLON6)  list.add(_SEMICOLON6);
            if(null != _ForUpdateopt)  list.add(_ForUpdateopt);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _Statement)  list.add(_Statement);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitBasicForStatement(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitBasicForStatement(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitBasicForStatement(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitBasicForStatement(this, o); }
    }

/**
 *<b>
*<li>Rule 314:  ForStatementNoShortIf ::= for ( ForInitopt ; Expressionopt ; ForUpdateopt ) StatementNoShortIf
 *</b>
 */
class ForStatementNoShortIf extends Ast implements IForStatementNoShortIf
    {
         late AstToken _for;
         late AstToken _LPAREN;
         late Ast? _ForInitopt;
         late AstToken _SEMICOLON;
         late Ast? _Expressionopt;
         late AstToken _SEMICOLON6;
         late Ast? _ForUpdateopt;
         late AstToken _RPAREN;
         late Ast _StatementNoShortIf;

         AstToken getfor(){ return _for; }
         void setfor(AstToken _for){ this._for = _for; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
        /**
         * The value returned by <b>getForInitopt</b> may be <b>null</b>
         */
         Ast ?  getForInitopt(){ return _ForInitopt; }
         void setForInitopt(Ast _ForInitopt){ this._ForInitopt = _ForInitopt; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }
        /**
         * The value returned by <b>getExpressionopt</b> may be <b>null</b>
         */
         Ast ?  getExpressionopt(){ return _Expressionopt; }
         void setExpressionopt(Ast _Expressionopt){ this._Expressionopt = _Expressionopt; }
         AstToken getSEMICOLON6(){ return _SEMICOLON6; }
         void setSEMICOLON6(AstToken _SEMICOLON6){ this._SEMICOLON6 = _SEMICOLON6; }
        /**
         * The value returned by <b>getForUpdateopt</b> may be <b>null</b>
         */
         Ast ?  getForUpdateopt(){ return _ForUpdateopt; }
         void setForUpdateopt(Ast _ForUpdateopt){ this._ForUpdateopt = _ForUpdateopt; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
         Ast getStatementNoShortIf(){ return _StatementNoShortIf; }
         void setStatementNoShortIf(Ast _StatementNoShortIf){ this._StatementNoShortIf = _StatementNoShortIf; }

        ForStatementNoShortIf(IToken leftIToken, IToken rightIToken,
                              AstToken _for,
                              AstToken _LPAREN,
                              Ast? _ForInitopt,
                              AstToken _SEMICOLON,
                              Ast? _Expressionopt,
                              AstToken _SEMICOLON6,
                              Ast? _ForUpdateopt,
                              AstToken _RPAREN,
                              Ast _StatementNoShortIf)
            :super(leftIToken, rightIToken)

        {
            this._for = _for;
            (_for as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._ForInitopt = _ForInitopt;
            if (null != _ForInitopt) (_ForInitopt as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            this._Expressionopt = _Expressionopt;
            if (null != _Expressionopt) (_Expressionopt as Ast).setParent(this);
            this._SEMICOLON6 = _SEMICOLON6;
            (_SEMICOLON6 as Ast).setParent(this);
            this._ForUpdateopt = _ForUpdateopt;
            if (null != _ForUpdateopt) (_ForUpdateopt as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._StatementNoShortIf = _StatementNoShortIf;
            (_StatementNoShortIf as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _for)  list.add(_for);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _ForInitopt)  list.add(_ForInitopt);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            if(null != _Expressionopt)  list.add(_Expressionopt);
            if(null != _SEMICOLON6)  list.add(_SEMICOLON6);
            if(null != _ForUpdateopt)  list.add(_ForUpdateopt);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _StatementNoShortIf)  list.add(_StatementNoShortIf);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitForStatementNoShortIf(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitForStatementNoShortIf(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitForStatementNoShortIf(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitForStatementNoShortIf(this, o); }
    }

/**
 *<em>
*<li>Rule 318:  StatementExpressionList ::= StatementExpression
 *</em>
 *<p>
 *<b>
*<li>Rule 319:  StatementExpressionList ::= StatementExpressionList , StatementExpression
 *</b>
 */
class StatementExpressionList extends Ast implements IStatementExpressionList
    {
         late Ast _StatementExpressionList;
         late AstToken _COMMA;
         late Ast _StatementExpression;

         Ast getStatementExpressionList(){ return _StatementExpressionList; }
         void setStatementExpressionList(Ast _StatementExpressionList){ this._StatementExpressionList = _StatementExpressionList; }
         AstToken getCOMMA(){ return _COMMA; }
         void setCOMMA(AstToken _COMMA){ this._COMMA = _COMMA; }
         Ast getStatementExpression(){ return _StatementExpression; }
         void setStatementExpression(Ast _StatementExpression){ this._StatementExpression = _StatementExpression; }

        StatementExpressionList(IToken leftIToken, IToken rightIToken,
                                Ast _StatementExpressionList,
                                AstToken _COMMA,
                                Ast _StatementExpression)
            :super(leftIToken, rightIToken)

        {
            this._StatementExpressionList = _StatementExpressionList;
            (_StatementExpressionList as Ast).setParent(this);
            this._COMMA = _COMMA;
            (_COMMA as Ast).setParent(this);
            this._StatementExpression = _StatementExpression;
            (_StatementExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _StatementExpressionList)  list.add(_StatementExpressionList);
            if(null != _COMMA)  list.add(_COMMA);
            if(null != _StatementExpression)  list.add(_StatementExpression);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitStatementExpressionList(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitStatementExpressionList(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitStatementExpressionList(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitStatementExpressionList(this, o); }
    }

/**
 *<b>
*<li>Rule 320:  EnhancedForStatement ::= for ( FormalParameter : Expression ) Statement
 *</b>
 */
class EnhancedForStatement extends Ast implements IEnhancedForStatement
    {
         late AstToken _for;
         late AstToken _LPAREN;
         late FormalParameter _FormalParameter;
         late AstToken _COLON;
         late Ast _Expression;
         late AstToken _RPAREN;
         late Ast _Statement;

         AstToken getfor(){ return _for; }
         void setfor(AstToken _for){ this._for = _for; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
         FormalParameter getFormalParameter(){ return _FormalParameter; }
         void setFormalParameter(FormalParameter _FormalParameter){ this._FormalParameter = _FormalParameter; }
         AstToken getCOLON(){ return _COLON; }
         void setCOLON(AstToken _COLON){ this._COLON = _COLON; }
         Ast getExpression(){ return _Expression; }
         void setExpression(Ast _Expression){ this._Expression = _Expression; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
         Ast getStatement(){ return _Statement; }
         void setStatement(Ast _Statement){ this._Statement = _Statement; }

        EnhancedForStatement(IToken leftIToken, IToken rightIToken,
                             AstToken _for,
                             AstToken _LPAREN,
                             FormalParameter _FormalParameter,
                             AstToken _COLON,
                             Ast _Expression,
                             AstToken _RPAREN,
                             Ast _Statement)
            :super(leftIToken, rightIToken)

        {
            this._for = _for;
            (_for as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._FormalParameter = _FormalParameter;
            (_FormalParameter as Ast).setParent(this);
            this._COLON = _COLON;
            (_COLON as Ast).setParent(this);
            this._Expression = _Expression;
            (_Expression as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._Statement = _Statement;
            (_Statement as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _for)  list.add(_for);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _FormalParameter)  list.add(_FormalParameter);
            if(null != _COLON)  list.add(_COLON);
            if(null != _Expression)  list.add(_Expression);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _Statement)  list.add(_Statement);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitEnhancedForStatement(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitEnhancedForStatement(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitEnhancedForStatement(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitEnhancedForStatement(this, o); }
    }

/**
 *<b>
*<li>Rule 321:  BreakStatement ::= break identifieropt ;
 *</b>
 */
class BreakStatement extends Ast implements IBreakStatement
    {
         late AstToken _break;
         late identifier? _identifieropt;
         late AstToken _SEMICOLON;

         AstToken getbreak(){ return _break; }
         void setbreak(AstToken _break){ this._break = _break; }
        /**
         * The value returned by <b>getidentifieropt</b> may be <b>null</b>
         */
         identifier ?  getidentifieropt(){ return _identifieropt; }
         void setidentifieropt(identifier _identifieropt){ this._identifieropt = _identifieropt; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        BreakStatement(IToken leftIToken, IToken rightIToken,
                       AstToken _break,
                       identifier? _identifieropt,
                       AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._break = _break;
            (_break as Ast).setParent(this);
            this._identifieropt = _identifieropt;
            if (null != _identifieropt) (_identifieropt as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _break)  list.add(_break);
            if(null != _identifieropt)  list.add(_identifieropt);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitBreakStatement(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitBreakStatement(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitBreakStatement(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitBreakStatement(this, o); }
    }

/**
 *<b>
*<li>Rule 322:  ContinueStatement ::= continue identifieropt ;
 *</b>
 */
class ContinueStatement extends Ast implements IContinueStatement
    {
         late AstToken _continue;
         late identifier? _identifieropt;
         late AstToken _SEMICOLON;

         AstToken getcontinue(){ return _continue; }
         void setcontinue(AstToken _continue){ this._continue = _continue; }
        /**
         * The value returned by <b>getidentifieropt</b> may be <b>null</b>
         */
         identifier ?  getidentifieropt(){ return _identifieropt; }
         void setidentifieropt(identifier _identifieropt){ this._identifieropt = _identifieropt; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        ContinueStatement(IToken leftIToken, IToken rightIToken,
                          AstToken _continue,
                          identifier? _identifieropt,
                          AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._continue = _continue;
            (_continue as Ast).setParent(this);
            this._identifieropt = _identifieropt;
            if (null != _identifieropt) (_identifieropt as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _continue)  list.add(_continue);
            if(null != _identifieropt)  list.add(_identifieropt);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitContinueStatement(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitContinueStatement(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitContinueStatement(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitContinueStatement(this, o); }
    }

/**
 *<b>
*<li>Rule 323:  ReturnStatement ::= return Expressionopt ;
 *</b>
 */
class ReturnStatement extends Ast implements IReturnStatement
    {
         late AstToken _return;
         late Ast? _Expressionopt;
         late AstToken _SEMICOLON;

         AstToken getreturn(){ return _return; }
         void setreturn(AstToken _return){ this._return = _return; }
        /**
         * The value returned by <b>getExpressionopt</b> may be <b>null</b>
         */
         Ast ?  getExpressionopt(){ return _Expressionopt; }
         void setExpressionopt(Ast _Expressionopt){ this._Expressionopt = _Expressionopt; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        ReturnStatement(IToken leftIToken, IToken rightIToken,
                        AstToken _return,
                        Ast? _Expressionopt,
                        AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._return = _return;
            (_return as Ast).setParent(this);
            this._Expressionopt = _Expressionopt;
            if (null != _Expressionopt) (_Expressionopt as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _return)  list.add(_return);
            if(null != _Expressionopt)  list.add(_Expressionopt);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitReturnStatement(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitReturnStatement(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitReturnStatement(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitReturnStatement(this, o); }
    }

/**
 *<b>
*<li>Rule 324:  ThrowStatement ::= throw Expression ;
 *</b>
 */
class ThrowStatement extends Ast implements IThrowStatement
    {
         late AstToken _throw;
         late Ast _Expression;
         late AstToken _SEMICOLON;

         AstToken getthrow(){ return _throw; }
         void setthrow(AstToken _throw){ this._throw = _throw; }
         Ast getExpression(){ return _Expression; }
         void setExpression(Ast _Expression){ this._Expression = _Expression; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        ThrowStatement(IToken leftIToken, IToken rightIToken,
                       AstToken _throw,
                       Ast _Expression,
                       AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._throw = _throw;
            (_throw as Ast).setParent(this);
            this._Expression = _Expression;
            (_Expression as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _throw)  list.add(_throw);
            if(null != _Expression)  list.add(_Expression);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitThrowStatement(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitThrowStatement(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitThrowStatement(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitThrowStatement(this, o); }
    }

/**
 *<b>
*<li>Rule 325:  SynchronizedStatement ::= synchronized ( Expression ) Block
 *</b>
 */
class SynchronizedStatement extends Ast implements ISynchronizedStatement
    {
         late AstToken _synchronized;
         late AstToken _LPAREN;
         late Ast _Expression;
         late AstToken _RPAREN;
         late Block _Block;

         AstToken getsynchronized(){ return _synchronized; }
         void setsynchronized(AstToken _synchronized){ this._synchronized = _synchronized; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
         Ast getExpression(){ return _Expression; }
         void setExpression(Ast _Expression){ this._Expression = _Expression; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
         Block getBlock(){ return _Block; }
         void setBlock(Block _Block){ this._Block = _Block; }

        SynchronizedStatement(IToken leftIToken, IToken rightIToken,
                              AstToken _synchronized,
                              AstToken _LPAREN,
                              Ast _Expression,
                              AstToken _RPAREN,
                              Block _Block)
            :super(leftIToken, rightIToken)

        {
            this._synchronized = _synchronized;
            (_synchronized as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._Expression = _Expression;
            (_Expression as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._Block = _Block;
            (_Block as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _synchronized)  list.add(_synchronized);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _Expression)  list.add(_Expression);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _Block)  list.add(_Block);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitSynchronizedStatement(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitSynchronizedStatement(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitSynchronizedStatement(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitSynchronizedStatement(this, o); }
    }

/**
 *<em>
*<li>Rule 328:  Catches ::= CatchClause
 *</em>
 *<p>
 *<b>
*<li>Rule 329:  Catches ::= Catches CatchClause
 *</b>
 */
class Catches extends Ast implements ICatches
    {
         late Ast _Catches;
         late CatchClause _CatchClause;

         Ast getCatches(){ return _Catches; }
         void setCatches(Ast _Catches){ this._Catches = _Catches; }
         CatchClause getCatchClause(){ return _CatchClause; }
         void setCatchClause(CatchClause _CatchClause){ this._CatchClause = _CatchClause; }

        Catches(IToken leftIToken, IToken rightIToken,
                Ast _Catches,
                CatchClause _CatchClause)
            :super(leftIToken, rightIToken)

        {
            this._Catches = _Catches;
            (_Catches as Ast).setParent(this);
            this._CatchClause = _CatchClause;
            (_CatchClause as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _Catches)  list.add(_Catches);
            if(null != _CatchClause)  list.add(_CatchClause);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitCatches(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitCatches(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitCatches(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitCatches(this, o); }
    }

/**
 *<b>
*<li>Rule 330:  CatchClause ::= catch ( FormalParameter ) Block
 *</b>
 */
class CatchClause extends Ast implements ICatchClause
    {
         late AstToken _catch;
         late AstToken _LPAREN;
         late FormalParameter _FormalParameter;
         late AstToken _RPAREN;
         late Block _Block;

         AstToken getcatch(){ return _catch; }
         void setcatch(AstToken _catch){ this._catch = _catch; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
         FormalParameter getFormalParameter(){ return _FormalParameter; }
         void setFormalParameter(FormalParameter _FormalParameter){ this._FormalParameter = _FormalParameter; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
         Block getBlock(){ return _Block; }
         void setBlock(Block _Block){ this._Block = _Block; }

        CatchClause(IToken leftIToken, IToken rightIToken,
                    AstToken _catch,
                    AstToken _LPAREN,
                    FormalParameter _FormalParameter,
                    AstToken _RPAREN,
                    Block _Block)
            :super(leftIToken, rightIToken)

        {
            this._catch = _catch;
            (_catch as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._FormalParameter = _FormalParameter;
            (_FormalParameter as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._Block = _Block;
            (_Block as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _catch)  list.add(_catch);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _FormalParameter)  list.add(_FormalParameter);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _Block)  list.add(_Block);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitCatchClause(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitCatchClause(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitCatchClause(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitCatchClause(this, o); }
    }

/**
 *<b>
*<li>Rule 331:  Finally ::= finally Block
 *</b>
 */
class Finally extends Ast implements IFinally
    {
         late AstToken _finally;
         late Block _Block;

         AstToken getfinally(){ return _finally; }
         void setfinally(AstToken _finally){ this._finally = _finally; }
         Block getBlock(){ return _Block; }
         void setBlock(Block _Block){ this._Block = _Block; }

        Finally(IToken leftIToken, IToken rightIToken,
                AstToken _finally,
                Block _Block)
            :super(leftIToken, rightIToken)

        {
            this._finally = _finally;
            (_finally as Ast).setParent(this);
            this._Block = _Block;
            (_Block as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _finally)  list.add(_finally);
            if(null != _Block)  list.add(_Block);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitFinally(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitFinally(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitFinally(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitFinally(this, o); }
    }

/**
 *<em>
*<li>Rule 356:  ArgumentList ::= Expression
 *</em>
 *<p>
 *<b>
*<li>Rule 357:  ArgumentList ::= ArgumentList , Expression
 *</b>
 */
class ArgumentList extends Ast implements IArgumentList
    {
         late Ast _ArgumentList;
         late AstToken _COMMA;
         late Ast _Expression;

         Ast getArgumentList(){ return _ArgumentList; }
         void setArgumentList(Ast _ArgumentList){ this._ArgumentList = _ArgumentList; }
         AstToken getCOMMA(){ return _COMMA; }
         void setCOMMA(AstToken _COMMA){ this._COMMA = _COMMA; }
         Ast getExpression(){ return _Expression; }
         void setExpression(Ast _Expression){ this._Expression = _Expression; }

        ArgumentList(IToken leftIToken, IToken rightIToken,
                     Ast _ArgumentList,
                     AstToken _COMMA,
                     Ast _Expression)
            :super(leftIToken, rightIToken)

        {
            this._ArgumentList = _ArgumentList;
            (_ArgumentList as Ast).setParent(this);
            this._COMMA = _COMMA;
            (_COMMA as Ast).setParent(this);
            this._Expression = _Expression;
            (_Expression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ArgumentList)  list.add(_ArgumentList);
            if(null != _COMMA)  list.add(_COMMA);
            if(null != _Expression)  list.add(_Expression);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitArgumentList(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitArgumentList(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitArgumentList(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitArgumentList(this, o); }
    }

/**
 *<em>
*<li>Rule 362:  DimExprs ::= DimExpr
 *</em>
 *<p>
 *<b>
*<li>Rule 363:  DimExprs ::= DimExprs DimExpr
 *</b>
 */
class DimExprs extends Ast implements IDimExprs
    {
         late Ast _DimExprs;
         late DimExpr _DimExpr;

         Ast getDimExprs(){ return _DimExprs; }
         void setDimExprs(Ast _DimExprs){ this._DimExprs = _DimExprs; }
         DimExpr getDimExpr(){ return _DimExpr; }
         void setDimExpr(DimExpr _DimExpr){ this._DimExpr = _DimExpr; }

        DimExprs(IToken leftIToken, IToken rightIToken,
                 Ast _DimExprs,
                 DimExpr _DimExpr)
            :super(leftIToken, rightIToken)

        {
            this._DimExprs = _DimExprs;
            (_DimExprs as Ast).setParent(this);
            this._DimExpr = _DimExpr;
            (_DimExpr as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _DimExprs)  list.add(_DimExprs);
            if(null != _DimExpr)  list.add(_DimExpr);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitDimExprs(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitDimExprs(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitDimExprs(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitDimExprs(this, o); }
    }

/**
 *<b>
*<li>Rule 364:  DimExpr ::= [ Expression ]
 *</b>
 */
class DimExpr extends Ast implements IDimExpr
    {
         late AstToken _LBRACKET;
         late Ast _Expression;
         late AstToken _RBRACKET;

         AstToken getLBRACKET(){ return _LBRACKET; }
         void setLBRACKET(AstToken _LBRACKET){ this._LBRACKET = _LBRACKET; }
         Ast getExpression(){ return _Expression; }
         void setExpression(Ast _Expression){ this._Expression = _Expression; }
         AstToken getRBRACKET(){ return _RBRACKET; }
         void setRBRACKET(AstToken _RBRACKET){ this._RBRACKET = _RBRACKET; }

        DimExpr(IToken leftIToken, IToken rightIToken,
                AstToken _LBRACKET,
                Ast _Expression,
                AstToken _RBRACKET)
            :super(leftIToken, rightIToken)

        {
            this._LBRACKET = _LBRACKET;
            (_LBRACKET as Ast).setParent(this);
            this._Expression = _Expression;
            (_Expression as Ast).setParent(this);
            this._RBRACKET = _RBRACKET;
            (_RBRACKET as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _LBRACKET)  list.add(_LBRACKET);
            if(null != _Expression)  list.add(_Expression);
            if(null != _RBRACKET)  list.add(_RBRACKET);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitDimExpr(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitDimExpr(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitDimExpr(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitDimExpr(this, o); }
    }

/**
 *<b>
*<li>Rule 381:  PostIncrementExpression ::= PostfixExpression ++
 *</b>
 */
class PostIncrementExpression extends Ast implements IPostIncrementExpression
    {
         late Ast _PostfixExpression;
         late AstToken _PLUS_PLUS;

         Ast getPostfixExpression(){ return _PostfixExpression; }
         void setPostfixExpression(Ast _PostfixExpression){ this._PostfixExpression = _PostfixExpression; }
         AstToken getPLUS_PLUS(){ return _PLUS_PLUS; }
         void setPLUS_PLUS(AstToken _PLUS_PLUS){ this._PLUS_PLUS = _PLUS_PLUS; }

        PostIncrementExpression(IToken leftIToken, IToken rightIToken,
                                Ast _PostfixExpression,
                                AstToken _PLUS_PLUS)
            :super(leftIToken, rightIToken)

        {
            this._PostfixExpression = _PostfixExpression;
            (_PostfixExpression as Ast).setParent(this);
            this._PLUS_PLUS = _PLUS_PLUS;
            (_PLUS_PLUS as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _PostfixExpression)  list.add(_PostfixExpression);
            if(null != _PLUS_PLUS)  list.add(_PLUS_PLUS);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitPostIncrementExpression(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitPostIncrementExpression(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitPostIncrementExpression(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitPostIncrementExpression(this, o); }
    }

/**
 *<b>
*<li>Rule 382:  PostDecrementExpression ::= PostfixExpression --
 *</b>
 */
class PostDecrementExpression extends Ast implements IPostDecrementExpression
    {
         late Ast _PostfixExpression;
         late AstToken _MINUS_MINUS;

         Ast getPostfixExpression(){ return _PostfixExpression; }
         void setPostfixExpression(Ast _PostfixExpression){ this._PostfixExpression = _PostfixExpression; }
         AstToken getMINUS_MINUS(){ return _MINUS_MINUS; }
         void setMINUS_MINUS(AstToken _MINUS_MINUS){ this._MINUS_MINUS = _MINUS_MINUS; }

        PostDecrementExpression(IToken leftIToken, IToken rightIToken,
                                Ast _PostfixExpression,
                                AstToken _MINUS_MINUS)
            :super(leftIToken, rightIToken)

        {
            this._PostfixExpression = _PostfixExpression;
            (_PostfixExpression as Ast).setParent(this);
            this._MINUS_MINUS = _MINUS_MINUS;
            (_MINUS_MINUS as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _PostfixExpression)  list.add(_PostfixExpression);
            if(null != _MINUS_MINUS)  list.add(_MINUS_MINUS);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitPostDecrementExpression(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitPostDecrementExpression(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitPostDecrementExpression(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitPostDecrementExpression(this, o); }
    }

/**
 *<b>
*<li>Rule 388:  PreIncrementExpression ::= ++ UnaryExpression
 *</b>
 */
class PreIncrementExpression extends Ast implements IPreIncrementExpression
    {
         late AstToken _PLUS_PLUS;
         late Ast _UnaryExpression;

         AstToken getPLUS_PLUS(){ return _PLUS_PLUS; }
         void setPLUS_PLUS(AstToken _PLUS_PLUS){ this._PLUS_PLUS = _PLUS_PLUS; }
         Ast getUnaryExpression(){ return _UnaryExpression; }
         void setUnaryExpression(Ast _UnaryExpression){ this._UnaryExpression = _UnaryExpression; }

        PreIncrementExpression(IToken leftIToken, IToken rightIToken,
                               AstToken _PLUS_PLUS,
                               Ast _UnaryExpression)
            :super(leftIToken, rightIToken)

        {
            this._PLUS_PLUS = _PLUS_PLUS;
            (_PLUS_PLUS as Ast).setParent(this);
            this._UnaryExpression = _UnaryExpression;
            (_UnaryExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _PLUS_PLUS)  list.add(_PLUS_PLUS);
            if(null != _UnaryExpression)  list.add(_UnaryExpression);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitPreIncrementExpression(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitPreIncrementExpression(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitPreIncrementExpression(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitPreIncrementExpression(this, o); }
    }

/**
 *<b>
*<li>Rule 389:  PreDecrementExpression ::= -- UnaryExpression
 *</b>
 */
class PreDecrementExpression extends Ast implements IPreDecrementExpression
    {
         late AstToken _MINUS_MINUS;
         late Ast _UnaryExpression;

         AstToken getMINUS_MINUS(){ return _MINUS_MINUS; }
         void setMINUS_MINUS(AstToken _MINUS_MINUS){ this._MINUS_MINUS = _MINUS_MINUS; }
         Ast getUnaryExpression(){ return _UnaryExpression; }
         void setUnaryExpression(Ast _UnaryExpression){ this._UnaryExpression = _UnaryExpression; }

        PreDecrementExpression(IToken leftIToken, IToken rightIToken,
                               AstToken _MINUS_MINUS,
                               Ast _UnaryExpression)
            :super(leftIToken, rightIToken)

        {
            this._MINUS_MINUS = _MINUS_MINUS;
            (_MINUS_MINUS as Ast).setParent(this);
            this._UnaryExpression = _UnaryExpression;
            (_UnaryExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _MINUS_MINUS)  list.add(_MINUS_MINUS);
            if(null != _UnaryExpression)  list.add(_UnaryExpression);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitPreDecrementExpression(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitPreDecrementExpression(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitPreDecrementExpression(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitPreDecrementExpression(this, o); }
    }

/**
 *<em>
*<li>Rule 416:  AndExpression ::= EqualityExpression
 *</em>
 *<p>
 *<b>
*<li>Rule 417:  AndExpression ::= AndExpression & EqualityExpression
 *</b>
 */
class AndExpression extends Ast implements IAndExpression
    {
         late Ast _AndExpression;
         late AstToken _AND;
         late Ast _EqualityExpression;

         Ast getAndExpression(){ return _AndExpression; }
         void setAndExpression(Ast _AndExpression){ this._AndExpression = _AndExpression; }
         AstToken getAND(){ return _AND; }
         void setAND(AstToken _AND){ this._AND = _AND; }
         Ast getEqualityExpression(){ return _EqualityExpression; }
         void setEqualityExpression(Ast _EqualityExpression){ this._EqualityExpression = _EqualityExpression; }

        AndExpression(IToken leftIToken, IToken rightIToken,
                      Ast _AndExpression,
                      AstToken _AND,
                      Ast _EqualityExpression)
            :super(leftIToken, rightIToken)

        {
            this._AndExpression = _AndExpression;
            (_AndExpression as Ast).setParent(this);
            this._AND = _AND;
            (_AND as Ast).setParent(this);
            this._EqualityExpression = _EqualityExpression;
            (_EqualityExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _AndExpression)  list.add(_AndExpression);
            if(null != _AND)  list.add(_AND);
            if(null != _EqualityExpression)  list.add(_EqualityExpression);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitAndExpression(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitAndExpression(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitAndExpression(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitAndExpression(this, o); }
    }

/**
 *<em>
*<li>Rule 418:  ExclusiveOrExpression ::= AndExpression
 *</em>
 *<p>
 *<b>
*<li>Rule 419:  ExclusiveOrExpression ::= ExclusiveOrExpression ^ AndExpression
 *</b>
 */
class ExclusiveOrExpression extends Ast implements IExclusiveOrExpression
    {
         late Ast _ExclusiveOrExpression;
         late AstToken _XOR;
         late Ast _AndExpression;

         Ast getExclusiveOrExpression(){ return _ExclusiveOrExpression; }
         void setExclusiveOrExpression(Ast _ExclusiveOrExpression){ this._ExclusiveOrExpression = _ExclusiveOrExpression; }
         AstToken getXOR(){ return _XOR; }
         void setXOR(AstToken _XOR){ this._XOR = _XOR; }
         Ast getAndExpression(){ return _AndExpression; }
         void setAndExpression(Ast _AndExpression){ this._AndExpression = _AndExpression; }

        ExclusiveOrExpression(IToken leftIToken, IToken rightIToken,
                              Ast _ExclusiveOrExpression,
                              AstToken _XOR,
                              Ast _AndExpression)
            :super(leftIToken, rightIToken)

        {
            this._ExclusiveOrExpression = _ExclusiveOrExpression;
            (_ExclusiveOrExpression as Ast).setParent(this);
            this._XOR = _XOR;
            (_XOR as Ast).setParent(this);
            this._AndExpression = _AndExpression;
            (_AndExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ExclusiveOrExpression)  list.add(_ExclusiveOrExpression);
            if(null != _XOR)  list.add(_XOR);
            if(null != _AndExpression)  list.add(_AndExpression);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitExclusiveOrExpression(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitExclusiveOrExpression(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitExclusiveOrExpression(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitExclusiveOrExpression(this, o); }
    }

/**
 *<em>
*<li>Rule 420:  InclusiveOrExpression ::= ExclusiveOrExpression
 *</em>
 *<p>
 *<b>
*<li>Rule 421:  InclusiveOrExpression ::= InclusiveOrExpression | ExclusiveOrExpression
 *</b>
 */
class InclusiveOrExpression extends Ast implements IInclusiveOrExpression
    {
         late Ast _InclusiveOrExpression;
         late AstToken _OR;
         late Ast _ExclusiveOrExpression;

         Ast getInclusiveOrExpression(){ return _InclusiveOrExpression; }
         void setInclusiveOrExpression(Ast _InclusiveOrExpression){ this._InclusiveOrExpression = _InclusiveOrExpression; }
         AstToken getOR(){ return _OR; }
         void setOR(AstToken _OR){ this._OR = _OR; }
         Ast getExclusiveOrExpression(){ return _ExclusiveOrExpression; }
         void setExclusiveOrExpression(Ast _ExclusiveOrExpression){ this._ExclusiveOrExpression = _ExclusiveOrExpression; }

        InclusiveOrExpression(IToken leftIToken, IToken rightIToken,
                              Ast _InclusiveOrExpression,
                              AstToken _OR,
                              Ast _ExclusiveOrExpression)
            :super(leftIToken, rightIToken)

        {
            this._InclusiveOrExpression = _InclusiveOrExpression;
            (_InclusiveOrExpression as Ast).setParent(this);
            this._OR = _OR;
            (_OR as Ast).setParent(this);
            this._ExclusiveOrExpression = _ExclusiveOrExpression;
            (_ExclusiveOrExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _InclusiveOrExpression)  list.add(_InclusiveOrExpression);
            if(null != _OR)  list.add(_OR);
            if(null != _ExclusiveOrExpression)  list.add(_ExclusiveOrExpression);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitInclusiveOrExpression(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitInclusiveOrExpression(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitInclusiveOrExpression(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitInclusiveOrExpression(this, o); }
    }

/**
 *<em>
*<li>Rule 422:  ConditionalAndExpression ::= InclusiveOrExpression
 *</em>
 *<p>
 *<b>
*<li>Rule 423:  ConditionalAndExpression ::= ConditionalAndExpression && InclusiveOrExpression
 *</b>
 */
class ConditionalAndExpression extends Ast implements IConditionalAndExpression
    {
         late Ast _ConditionalAndExpression;
         late AstToken _AND_AND;
         late Ast _InclusiveOrExpression;

         Ast getConditionalAndExpression(){ return _ConditionalAndExpression; }
         void setConditionalAndExpression(Ast _ConditionalAndExpression){ this._ConditionalAndExpression = _ConditionalAndExpression; }
         AstToken getAND_AND(){ return _AND_AND; }
         void setAND_AND(AstToken _AND_AND){ this._AND_AND = _AND_AND; }
         Ast getInclusiveOrExpression(){ return _InclusiveOrExpression; }
         void setInclusiveOrExpression(Ast _InclusiveOrExpression){ this._InclusiveOrExpression = _InclusiveOrExpression; }

        ConditionalAndExpression(IToken leftIToken, IToken rightIToken,
                                 Ast _ConditionalAndExpression,
                                 AstToken _AND_AND,
                                 Ast _InclusiveOrExpression)
            :super(leftIToken, rightIToken)

        {
            this._ConditionalAndExpression = _ConditionalAndExpression;
            (_ConditionalAndExpression as Ast).setParent(this);
            this._AND_AND = _AND_AND;
            (_AND_AND as Ast).setParent(this);
            this._InclusiveOrExpression = _InclusiveOrExpression;
            (_InclusiveOrExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ConditionalAndExpression)  list.add(_ConditionalAndExpression);
            if(null != _AND_AND)  list.add(_AND_AND);
            if(null != _InclusiveOrExpression)  list.add(_InclusiveOrExpression);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitConditionalAndExpression(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitConditionalAndExpression(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitConditionalAndExpression(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitConditionalAndExpression(this, o); }
    }

/**
 *<em>
*<li>Rule 424:  ConditionalOrExpression ::= ConditionalAndExpression
 *</em>
 *<p>
 *<b>
*<li>Rule 425:  ConditionalOrExpression ::= ConditionalOrExpression || ConditionalAndExpression
 *</b>
 */
class ConditionalOrExpression extends Ast implements IConditionalOrExpression
    {
         late Ast _ConditionalOrExpression;
         late AstToken _OR_OR;
         late Ast _ConditionalAndExpression;

         Ast getConditionalOrExpression(){ return _ConditionalOrExpression; }
         void setConditionalOrExpression(Ast _ConditionalOrExpression){ this._ConditionalOrExpression = _ConditionalOrExpression; }
         AstToken getOR_OR(){ return _OR_OR; }
         void setOR_OR(AstToken _OR_OR){ this._OR_OR = _OR_OR; }
         Ast getConditionalAndExpression(){ return _ConditionalAndExpression; }
         void setConditionalAndExpression(Ast _ConditionalAndExpression){ this._ConditionalAndExpression = _ConditionalAndExpression; }

        ConditionalOrExpression(IToken leftIToken, IToken rightIToken,
                                Ast _ConditionalOrExpression,
                                AstToken _OR_OR,
                                Ast _ConditionalAndExpression)
            :super(leftIToken, rightIToken)

        {
            this._ConditionalOrExpression = _ConditionalOrExpression;
            (_ConditionalOrExpression as Ast).setParent(this);
            this._OR_OR = _OR_OR;
            (_OR_OR as Ast).setParent(this);
            this._ConditionalAndExpression = _ConditionalAndExpression;
            (_ConditionalAndExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ConditionalOrExpression)  list.add(_ConditionalOrExpression);
            if(null != _OR_OR)  list.add(_OR_OR);
            if(null != _ConditionalAndExpression)  list.add(_ConditionalAndExpression);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitConditionalOrExpression(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitConditionalOrExpression(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitConditionalOrExpression(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitConditionalOrExpression(this, o); }
    }

/**
 *<em>
*<li>Rule 426:  ConditionalExpression ::= ConditionalOrExpression
 *</em>
 *<p>
 *<b>
*<li>Rule 427:  ConditionalExpression ::= ConditionalOrExpression ? Expression : ConditionalExpression
 *</b>
 */
class ConditionalExpression extends Ast implements IConditionalExpression
    {
         late Ast _ConditionalOrExpression;
         late AstToken _QUESTION;
         late Ast _Expression;
         late AstToken _COLON;
         late Ast _ConditionalExpression;

         Ast getConditionalOrExpression(){ return _ConditionalOrExpression; }
         void setConditionalOrExpression(Ast _ConditionalOrExpression){ this._ConditionalOrExpression = _ConditionalOrExpression; }
         AstToken getQUESTION(){ return _QUESTION; }
         void setQUESTION(AstToken _QUESTION){ this._QUESTION = _QUESTION; }
         Ast getExpression(){ return _Expression; }
         void setExpression(Ast _Expression){ this._Expression = _Expression; }
         AstToken getCOLON(){ return _COLON; }
         void setCOLON(AstToken _COLON){ this._COLON = _COLON; }
         Ast getConditionalExpression(){ return _ConditionalExpression; }
         void setConditionalExpression(Ast _ConditionalExpression){ this._ConditionalExpression = _ConditionalExpression; }

        ConditionalExpression(IToken leftIToken, IToken rightIToken,
                              Ast _ConditionalOrExpression,
                              AstToken _QUESTION,
                              Ast _Expression,
                              AstToken _COLON,
                              Ast _ConditionalExpression)
            :super(leftIToken, rightIToken)

        {
            this._ConditionalOrExpression = _ConditionalOrExpression;
            (_ConditionalOrExpression as Ast).setParent(this);
            this._QUESTION = _QUESTION;
            (_QUESTION as Ast).setParent(this);
            this._Expression = _Expression;
            (_Expression as Ast).setParent(this);
            this._COLON = _COLON;
            (_COLON as Ast).setParent(this);
            this._ConditionalExpression = _ConditionalExpression;
            (_ConditionalExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ConditionalOrExpression)  list.add(_ConditionalOrExpression);
            if(null != _QUESTION)  list.add(_QUESTION);
            if(null != _Expression)  list.add(_Expression);
            if(null != _COLON)  list.add(_COLON);
            if(null != _ConditionalExpression)  list.add(_ConditionalExpression);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitConditionalExpression(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitConditionalExpression(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitConditionalExpression(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitConditionalExpression(this, o); }
    }

/**
 *<b>
*<li>Rule 430:  Assignment ::= LeftHandSide AssignmentOperator AssignmentExpression
 *</b>
 */
class Assignment extends Ast implements IAssignment
    {
         late Ast _LeftHandSide;
         late Ast _AssignmentOperator;
         late Ast _AssignmentExpression;

         Ast getLeftHandSide(){ return _LeftHandSide; }
         void setLeftHandSide(Ast _LeftHandSide){ this._LeftHandSide = _LeftHandSide; }
         Ast getAssignmentOperator(){ return _AssignmentOperator; }
         void setAssignmentOperator(Ast _AssignmentOperator){ this._AssignmentOperator = _AssignmentOperator; }
         Ast getAssignmentExpression(){ return _AssignmentExpression; }
         void setAssignmentExpression(Ast _AssignmentExpression){ this._AssignmentExpression = _AssignmentExpression; }

        Assignment(IToken leftIToken, IToken rightIToken,
                   Ast _LeftHandSide,
                   Ast _AssignmentOperator,
                   Ast _AssignmentExpression)
            :super(leftIToken, rightIToken)

        {
            this._LeftHandSide = _LeftHandSide;
            (_LeftHandSide as Ast).setParent(this);
            this._AssignmentOperator = _AssignmentOperator;
            (_AssignmentOperator as Ast).setParent(this);
            this._AssignmentExpression = _AssignmentExpression;
            (_AssignmentExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _LeftHandSide)  list.add(_LeftHandSide);
            if(null != _AssignmentOperator)  list.add(_AssignmentOperator);
            if(null != _AssignmentExpression)  list.add(_AssignmentExpression);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitAssignment(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitAssignment(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitAssignment(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitAssignment(this, o); }
    }

/**
 *<em>
*<li>Rule 492:  ,opt ::= %Empty
 *</em>
 *<p>
 *<b>
*<li>Rule 493:  ,opt ::= ,
 *</b>
 */
class Commaopt extends AstToken implements ICommaopt
    {
         IToken getCOMMA(){ return leftIToken; }

    Commaopt(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitCommaopt(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitCommaopt(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitCommaopt(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitCommaopt(this, o); }
    }

/**
 *<em>
*<li>Rule 504:  ...opt ::= %Empty
 *</em>
 *<p>
 *<b>
*<li>Rule 505:  ...opt ::= ...
 *</b>
 */
class Ellipsisopt extends AstToken implements IEllipsisopt
    {
         IToken getELLIPSIS(){ return leftIToken; }

    Ellipsisopt(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitEllipsisopt(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitEllipsisopt(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitEllipsisopt(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitEllipsisopt(this, o); }
    }

/**
 *<b>
*<li>Rule 5:  LPGUserAction ::= %BeginAction BlockStatementsopt %EndAction
 *</b>
 */
class LPGUserAction0 extends Ast implements ILPGUserAction
    {
         late AstToken _BeginAction;
         late Ast? _BlockStatementsopt;
         late AstToken _EndAction;

         AstToken getBeginAction(){ return _BeginAction; }
         void setBeginAction(AstToken _BeginAction){ this._BeginAction = _BeginAction; }
        /**
         * The value returned by <b>getBlockStatementsopt</b> may be <b>null</b>
         */
         Ast ?  getBlockStatementsopt(){ return _BlockStatementsopt; }
         void setBlockStatementsopt(Ast _BlockStatementsopt){ this._BlockStatementsopt = _BlockStatementsopt; }
         AstToken getEndAction(){ return _EndAction; }
         void setEndAction(AstToken _EndAction){ this._EndAction = _EndAction; }

        LPGUserAction0(IToken leftIToken, IToken rightIToken,
                       AstToken _BeginAction,
                       Ast? _BlockStatementsopt,
                       AstToken _EndAction)
            :super(leftIToken, rightIToken)

        {
            this._BeginAction = _BeginAction;
            (_BeginAction as Ast).setParent(this);
            this._BlockStatementsopt = _BlockStatementsopt;
            if (null != _BlockStatementsopt) (_BlockStatementsopt as Ast).setParent(this);
            this._EndAction = _EndAction;
            (_EndAction as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _BeginAction)  list.add(_BeginAction);
            if(null != _BlockStatementsopt)  list.add(_BlockStatementsopt);
            if(null != _EndAction)  list.add(_EndAction);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitLPGUserAction0(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitLPGUserAction0(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitLPGUserAction0(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitLPGUserAction0(this, o); }
    }

/**
 *<b>
*<li>Rule 6:  LPGUserAction ::= $BeginJava BlockStatementsopt $EndJava
 *</b>
 */
class LPGUserAction1 extends Ast implements ILPGUserAction
    {
         late AstToken _BeginJava;
         late Ast? _BlockStatementsopt;
         late AstToken _EndJava;

         AstToken getBeginJava(){ return _BeginJava; }
         void setBeginJava(AstToken _BeginJava){ this._BeginJava = _BeginJava; }
        /**
         * The value returned by <b>getBlockStatementsopt</b> may be <b>null</b>
         */
         Ast ?  getBlockStatementsopt(){ return _BlockStatementsopt; }
         void setBlockStatementsopt(Ast _BlockStatementsopt){ this._BlockStatementsopt = _BlockStatementsopt; }
         AstToken getEndJava(){ return _EndJava; }
         void setEndJava(AstToken _EndJava){ this._EndJava = _EndJava; }

        LPGUserAction1(IToken leftIToken, IToken rightIToken,
                       AstToken _BeginJava,
                       Ast? _BlockStatementsopt,
                       AstToken _EndJava)
            :super(leftIToken, rightIToken)

        {
            this._BeginJava = _BeginJava;
            (_BeginJava as Ast).setParent(this);
            this._BlockStatementsopt = _BlockStatementsopt;
            if (null != _BlockStatementsopt) (_BlockStatementsopt as Ast).setParent(this);
            this._EndJava = _EndJava;
            (_EndJava as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _BeginJava)  list.add(_BeginJava);
            if(null != _BlockStatementsopt)  list.add(_BlockStatementsopt);
            if(null != _EndJava)  list.add(_EndJava);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitLPGUserAction1(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitLPGUserAction1(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitLPGUserAction1(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitLPGUserAction1(this, o); }
    }

/**
 *<b>
*<li>Rule 7:  LPGUserAction ::= $NoAction
 *</b>
 */
class LPGUserAction2 extends AstToken implements ILPGUserAction
    {
         IToken getNoAction(){ return leftIToken; }

    LPGUserAction2(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitLPGUserAction2(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitLPGUserAction2(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitLPGUserAction2(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitLPGUserAction2(this, o); }
    }

/**
 *<b>
*<li>Rule 8:  LPGUserAction ::= $NullAction
 *</b>
 */
class LPGUserAction3 extends AstToken implements ILPGUserAction
    {
         IToken getNullAction(){ return leftIToken; }

    LPGUserAction3(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitLPGUserAction3(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitLPGUserAction3(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitLPGUserAction3(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitLPGUserAction3(this, o); }
    }

/**
 *<b>
*<li>Rule 9:  LPGUserAction ::= $BadAction
 *</b>
 */
class LPGUserAction4 extends AstToken implements ILPGUserAction
    {
         IToken getBadAction(){ return leftIToken; }

    LPGUserAction4(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitLPGUserAction4(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitLPGUserAction4(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitLPGUserAction4(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitLPGUserAction4(this, o); }
    }

/**
 *<b>
*<li>Rule 16:  IntegralType ::= byte
 *</b>
 */
class IntegralType0 extends AstToken implements IIntegralType
    {
         IToken getbyte(){ return leftIToken; }

    IntegralType0(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitIntegralType0(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitIntegralType0(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitIntegralType0(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitIntegralType0(this, o); }
    }

/**
 *<b>
*<li>Rule 17:  IntegralType ::= short
 *</b>
 */
class IntegralType1 extends AstToken implements IIntegralType
    {
         IToken getshort(){ return leftIToken; }

    IntegralType1(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitIntegralType1(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitIntegralType1(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitIntegralType1(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitIntegralType1(this, o); }
    }

/**
 *<b>
*<li>Rule 18:  IntegralType ::= int
 *</b>
 */
class IntegralType2 extends AstToken implements IIntegralType
    {
         IToken getint(){ return leftIToken; }

    IntegralType2(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitIntegralType2(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitIntegralType2(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitIntegralType2(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitIntegralType2(this, o); }
    }

/**
 *<b>
*<li>Rule 19:  IntegralType ::= long
 *</b>
 */
class IntegralType3 extends AstToken implements IIntegralType
    {
         IToken getlong(){ return leftIToken; }

    IntegralType3(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitIntegralType3(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitIntegralType3(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitIntegralType3(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitIntegralType3(this, o); }
    }

/**
 *<b>
*<li>Rule 20:  IntegralType ::= char
 *</b>
 */
class IntegralType4 extends AstToken implements IIntegralType
    {
         IToken getchar(){ return leftIToken; }

    IntegralType4(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitIntegralType4(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitIntegralType4(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitIntegralType4(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitIntegralType4(this, o); }
    }

/**
 *<b>
*<li>Rule 21:  FloatingPointType ::= float
 *</b>
 */
class FloatingPointType0 extends AstToken implements IFloatingPointType
    {
         IToken getfloat(){ return leftIToken; }

    FloatingPointType0(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitFloatingPointType0(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitFloatingPointType0(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitFloatingPointType0(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitFloatingPointType0(this, o); }
    }

/**
 *<b>
*<li>Rule 22:  FloatingPointType ::= double
 *</b>
 */
class FloatingPointType1 extends AstToken implements IFloatingPointType
    {
         IToken getdouble(){ return leftIToken; }

    FloatingPointType1(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitFloatingPointType1(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitFloatingPointType1(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitFloatingPointType1(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitFloatingPointType1(this, o); }
    }

/**
 *<b>
*<li>Rule 45:  WildcardBounds ::= extends ReferenceType
 *</b>
 */
class WildcardBounds0 extends Ast implements IWildcardBounds
    {
         late AstToken _extends;
         late Ast _ReferenceType;

         AstToken getextends(){ return _extends; }
         void setextends(AstToken _extends){ this._extends = _extends; }
         Ast getReferenceType(){ return _ReferenceType; }
         void setReferenceType(Ast _ReferenceType){ this._ReferenceType = _ReferenceType; }

        WildcardBounds0(IToken leftIToken, IToken rightIToken,
                        AstToken _extends,
                        Ast _ReferenceType)
            :super(leftIToken, rightIToken)

        {
            this._extends = _extends;
            (_extends as Ast).setParent(this);
            this._ReferenceType = _ReferenceType;
            (_ReferenceType as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _extends)  list.add(_extends);
            if(null != _ReferenceType)  list.add(_ReferenceType);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitWildcardBounds0(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitWildcardBounds0(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitWildcardBounds0(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitWildcardBounds0(this, o); }
    }

/**
 *<b>
*<li>Rule 46:  WildcardBounds ::= super ReferenceType
 *</b>
 */
class WildcardBounds1 extends Ast implements IWildcardBounds
    {
         late AstToken _super;
         late Ast _ReferenceType;

         AstToken getsuper(){ return _super; }
         void setsuper(AstToken _super){ this._super = _super; }
         Ast getReferenceType(){ return _ReferenceType; }
         void setReferenceType(Ast _ReferenceType){ this._ReferenceType = _ReferenceType; }

        WildcardBounds1(IToken leftIToken, IToken rightIToken,
                        AstToken _super,
                        Ast _ReferenceType)
            :super(leftIToken, rightIToken)

        {
            this._super = _super;
            (_super as Ast).setParent(this);
            this._ReferenceType = _ReferenceType;
            (_ReferenceType as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _super)  list.add(_super);
            if(null != _ReferenceType)  list.add(_ReferenceType);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitWildcardBounds1(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitWildcardBounds1(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitWildcardBounds1(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitWildcardBounds1(this, o); }
    }

/**
 *<b>
*<li>Rule 80:  ClassModifier ::= public
 *</b>
 */
class ClassModifier0 extends AstToken implements IClassModifier
    {
         IToken getpublic(){ return leftIToken; }

    ClassModifier0(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitClassModifier0(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitClassModifier0(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitClassModifier0(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitClassModifier0(this, o); }
    }

/**
 *<b>
*<li>Rule 81:  ClassModifier ::= protected
 *</b>
 */
class ClassModifier1 extends AstToken implements IClassModifier
    {
         IToken getprotected(){ return leftIToken; }

    ClassModifier1(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitClassModifier1(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitClassModifier1(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitClassModifier1(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitClassModifier1(this, o); }
    }

/**
 *<b>
*<li>Rule 82:  ClassModifier ::= private
 *</b>
 */
class ClassModifier2 extends AstToken implements IClassModifier
    {
         IToken getprivate(){ return leftIToken; }

    ClassModifier2(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitClassModifier2(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitClassModifier2(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitClassModifier2(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitClassModifier2(this, o); }
    }

/**
 *<b>
*<li>Rule 83:  ClassModifier ::= abstract
 *</b>
 */
class ClassModifier3 extends AstToken implements IClassModifier
    {
         IToken getabstract(){ return leftIToken; }

    ClassModifier3(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitClassModifier3(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitClassModifier3(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitClassModifier3(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitClassModifier3(this, o); }
    }

/**
 *<b>
*<li>Rule 84:  ClassModifier ::= static
 *</b>
 */
class ClassModifier4 extends AstToken implements IClassModifier
    {
         IToken getstatic(){ return leftIToken; }

    ClassModifier4(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitClassModifier4(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitClassModifier4(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitClassModifier4(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitClassModifier4(this, o); }
    }

/**
 *<b>
*<li>Rule 85:  ClassModifier ::= final
 *</b>
 */
class ClassModifier5 extends AstToken implements IClassModifier
    {
         IToken getfinal(){ return leftIToken; }

    ClassModifier5(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitClassModifier5(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitClassModifier5(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitClassModifier5(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitClassModifier5(this, o); }
    }

/**
 *<b>
*<li>Rule 86:  ClassModifier ::= strictfp
 *</b>
 */
class ClassModifier6 extends AstToken implements IClassModifier
    {
         IToken getstrictfp(){ return leftIToken; }

    ClassModifier6(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitClassModifier6(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitClassModifier6(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitClassModifier6(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitClassModifier6(this, o); }
    }

/**
 *<b>
*<li>Rule 118:  FieldModifier ::= public
 *</b>
 */
class FieldModifier0 extends AstToken implements IFieldModifier
    {
         IToken getpublic(){ return leftIToken; }

    FieldModifier0(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitFieldModifier0(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitFieldModifier0(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitFieldModifier0(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitFieldModifier0(this, o); }
    }

/**
 *<b>
*<li>Rule 119:  FieldModifier ::= protected
 *</b>
 */
class FieldModifier1 extends AstToken implements IFieldModifier
    {
         IToken getprotected(){ return leftIToken; }

    FieldModifier1(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitFieldModifier1(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitFieldModifier1(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitFieldModifier1(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitFieldModifier1(this, o); }
    }

/**
 *<b>
*<li>Rule 120:  FieldModifier ::= private
 *</b>
 */
class FieldModifier2 extends AstToken implements IFieldModifier
    {
         IToken getprivate(){ return leftIToken; }

    FieldModifier2(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitFieldModifier2(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitFieldModifier2(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitFieldModifier2(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitFieldModifier2(this, o); }
    }

/**
 *<b>
*<li>Rule 121:  FieldModifier ::= static
 *</b>
 */
class FieldModifier3 extends AstToken implements IFieldModifier
    {
         IToken getstatic(){ return leftIToken; }

    FieldModifier3(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitFieldModifier3(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitFieldModifier3(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitFieldModifier3(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitFieldModifier3(this, o); }
    }

/**
 *<b>
*<li>Rule 122:  FieldModifier ::= final
 *</b>
 */
class FieldModifier4 extends AstToken implements IFieldModifier
    {
         IToken getfinal(){ return leftIToken; }

    FieldModifier4(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitFieldModifier4(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitFieldModifier4(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitFieldModifier4(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitFieldModifier4(this, o); }
    }

/**
 *<b>
*<li>Rule 123:  FieldModifier ::= transient
 *</b>
 */
class FieldModifier5 extends AstToken implements IFieldModifier
    {
         IToken gettransient(){ return leftIToken; }

    FieldModifier5(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitFieldModifier5(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitFieldModifier5(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitFieldModifier5(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitFieldModifier5(this, o); }
    }

/**
 *<b>
*<li>Rule 124:  FieldModifier ::= volatile
 *</b>
 */
class FieldModifier6 extends AstToken implements IFieldModifier
    {
         IToken getvolatile(){ return leftIToken; }

    FieldModifier6(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitFieldModifier6(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitFieldModifier6(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitFieldModifier6(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitFieldModifier6(this, o); }
    }

/**
 *<b>
*<li>Rule 129:  MethodDeclarator ::= identifier ( FormalParameterListopt )
 *</b>
 */
class MethodDeclarator0 extends Ast implements IMethodDeclarator
    {
         late identifier _identifier;
         late AstToken _LPAREN;
         late Ast? _FormalParameterListopt;
         late AstToken _RPAREN;

         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
        /**
         * The value returned by <b>getFormalParameterListopt</b> may be <b>null</b>
         */
         Ast ?  getFormalParameterListopt(){ return _FormalParameterListopt; }
         void setFormalParameterListopt(Ast _FormalParameterListopt){ this._FormalParameterListopt = _FormalParameterListopt; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }

        MethodDeclarator0(IToken leftIToken, IToken rightIToken,
                          identifier _identifier,
                          AstToken _LPAREN,
                          Ast? _FormalParameterListopt,
                          AstToken _RPAREN)
            :super(leftIToken, rightIToken)

        {
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._FormalParameterListopt = _FormalParameterListopt;
            if (null != _FormalParameterListopt) (_FormalParameterListopt as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _identifier)  list.add(_identifier);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _FormalParameterListopt)  list.add(_FormalParameterListopt);
            if(null != _RPAREN)  list.add(_RPAREN);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitMethodDeclarator0(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitMethodDeclarator0(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitMethodDeclarator0(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitMethodDeclarator0(this, o); }
    }

/**
 *<b>
*<li>Rule 130:  MethodDeclarator ::= MethodDeclarator [ ]
 *</b>
 */
class MethodDeclarator1 extends Ast implements IMethodDeclarator
    {
         late Ast _MethodDeclarator;
         late AstToken _LBRACKET;
         late AstToken _RBRACKET;

         Ast getMethodDeclarator(){ return _MethodDeclarator; }
         void setMethodDeclarator(Ast _MethodDeclarator){ this._MethodDeclarator = _MethodDeclarator; }
         AstToken getLBRACKET(){ return _LBRACKET; }
         void setLBRACKET(AstToken _LBRACKET){ this._LBRACKET = _LBRACKET; }
         AstToken getRBRACKET(){ return _RBRACKET; }
         void setRBRACKET(AstToken _RBRACKET){ this._RBRACKET = _RBRACKET; }

        MethodDeclarator1(IToken leftIToken, IToken rightIToken,
                          Ast _MethodDeclarator,
                          AstToken _LBRACKET,
                          AstToken _RBRACKET)
            :super(leftIToken, rightIToken)

        {
            this._MethodDeclarator = _MethodDeclarator;
            (_MethodDeclarator as Ast).setParent(this);
            this._LBRACKET = _LBRACKET;
            (_LBRACKET as Ast).setParent(this);
            this._RBRACKET = _RBRACKET;
            (_RBRACKET as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _MethodDeclarator)  list.add(_MethodDeclarator);
            if(null != _LBRACKET)  list.add(_LBRACKET);
            if(null != _RBRACKET)  list.add(_RBRACKET);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitMethodDeclarator1(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitMethodDeclarator1(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitMethodDeclarator1(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitMethodDeclarator1(this, o); }
    }

/**
 *<b>
*<li>Rule 144:  MethodModifier ::= public
 *</b>
 */
class MethodModifier0 extends AstToken implements IMethodModifier
    {
         IToken getpublic(){ return leftIToken; }

    MethodModifier0(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitMethodModifier0(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitMethodModifier0(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitMethodModifier0(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitMethodModifier0(this, o); }
    }

/**
 *<b>
*<li>Rule 145:  MethodModifier ::= protected
 *</b>
 */
class MethodModifier1 extends AstToken implements IMethodModifier
    {
         IToken getprotected(){ return leftIToken; }

    MethodModifier1(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitMethodModifier1(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitMethodModifier1(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitMethodModifier1(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitMethodModifier1(this, o); }
    }

/**
 *<b>
*<li>Rule 146:  MethodModifier ::= private
 *</b>
 */
class MethodModifier2 extends AstToken implements IMethodModifier
    {
         IToken getprivate(){ return leftIToken; }

    MethodModifier2(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitMethodModifier2(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitMethodModifier2(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitMethodModifier2(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitMethodModifier2(this, o); }
    }

/**
 *<b>
*<li>Rule 147:  MethodModifier ::= abstract
 *</b>
 */
class MethodModifier3 extends AstToken implements IMethodModifier
    {
         IToken getabstract(){ return leftIToken; }

    MethodModifier3(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitMethodModifier3(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitMethodModifier3(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitMethodModifier3(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitMethodModifier3(this, o); }
    }

/**
 *<b>
*<li>Rule 148:  MethodModifier ::= static
 *</b>
 */
class MethodModifier4 extends AstToken implements IMethodModifier
    {
         IToken getstatic(){ return leftIToken; }

    MethodModifier4(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitMethodModifier4(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitMethodModifier4(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitMethodModifier4(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitMethodModifier4(this, o); }
    }

/**
 *<b>
*<li>Rule 149:  MethodModifier ::= final
 *</b>
 */
class MethodModifier5 extends AstToken implements IMethodModifier
    {
         IToken getfinal(){ return leftIToken; }

    MethodModifier5(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitMethodModifier5(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitMethodModifier5(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitMethodModifier5(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitMethodModifier5(this, o); }
    }

/**
 *<b>
*<li>Rule 150:  MethodModifier ::= synchronized
 *</b>
 */
class MethodModifier6 extends AstToken implements IMethodModifier
    {
         IToken getsynchronized(){ return leftIToken; }

    MethodModifier6(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitMethodModifier6(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitMethodModifier6(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitMethodModifier6(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitMethodModifier6(this, o); }
    }

/**
 *<b>
*<li>Rule 151:  MethodModifier ::= native
 *</b>
 */
class MethodModifier7 extends AstToken implements IMethodModifier
    {
         IToken getnative(){ return leftIToken; }

    MethodModifier7(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitMethodModifier7(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitMethodModifier7(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitMethodModifier7(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitMethodModifier7(this, o); }
    }

/**
 *<b>
*<li>Rule 152:  MethodModifier ::= strictfp
 *</b>
 */
class MethodModifier8 extends AstToken implements IMethodModifier
    {
         IToken getstrictfp(){ return leftIToken; }

    MethodModifier8(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitMethodModifier8(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitMethodModifier8(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitMethodModifier8(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitMethodModifier8(this, o); }
    }

/**
 *<b>
*<li>Rule 168:  ConstructorModifier ::= public
 *</b>
 */
class ConstructorModifier0 extends AstToken implements IConstructorModifier
    {
         IToken getpublic(){ return leftIToken; }

    ConstructorModifier0(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitConstructorModifier0(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitConstructorModifier0(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitConstructorModifier0(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitConstructorModifier0(this, o); }
    }

/**
 *<b>
*<li>Rule 169:  ConstructorModifier ::= protected
 *</b>
 */
class ConstructorModifier1 extends AstToken implements IConstructorModifier
    {
         IToken getprotected(){ return leftIToken; }

    ConstructorModifier1(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitConstructorModifier1(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitConstructorModifier1(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitConstructorModifier1(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitConstructorModifier1(this, o); }
    }

/**
 *<b>
*<li>Rule 170:  ConstructorModifier ::= private
 *</b>
 */
class ConstructorModifier2 extends AstToken implements IConstructorModifier
    {
         IToken getprivate(){ return leftIToken; }

    ConstructorModifier2(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitConstructorModifier2(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitConstructorModifier2(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitConstructorModifier2(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitConstructorModifier2(this, o); }
    }

/**
 *<b>
*<li>Rule 172:  ExplicitConstructorInvocation ::= TypeArgumentsopt this ( ArgumentListopt ) ;
 *</b>
 */
class ExplicitConstructorInvocation0 extends Ast implements IExplicitConstructorInvocation
    {
         late TypeArguments? _TypeArgumentsopt;
         late AstToken _this;
         late AstToken _LPAREN;
         late Ast? _ArgumentListopt;
         late AstToken _RPAREN;
         late AstToken _SEMICOLON;

        /**
         * The value returned by <b>getTypeArgumentsopt</b> may be <b>null</b>
         */
         TypeArguments ?  getTypeArgumentsopt(){ return _TypeArgumentsopt; }
         void setTypeArgumentsopt(TypeArguments _TypeArgumentsopt){ this._TypeArgumentsopt = _TypeArgumentsopt; }
         AstToken getthis(){ return _this; }
         void setthis(AstToken _this){ this._this = _this; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
        /**
         * The value returned by <b>getArgumentListopt</b> may be <b>null</b>
         */
         Ast ?  getArgumentListopt(){ return _ArgumentListopt; }
         void setArgumentListopt(Ast _ArgumentListopt){ this._ArgumentListopt = _ArgumentListopt; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        ExplicitConstructorInvocation0(IToken leftIToken, IToken rightIToken,
                                       TypeArguments? _TypeArgumentsopt,
                                       AstToken _this,
                                       AstToken _LPAREN,
                                       Ast? _ArgumentListopt,
                                       AstToken _RPAREN,
                                       AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._TypeArgumentsopt = _TypeArgumentsopt;
            if (null != _TypeArgumentsopt) (_TypeArgumentsopt as Ast).setParent(this);
            this._this = _this;
            (_this as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._ArgumentListopt = _ArgumentListopt;
            if (null != _ArgumentListopt) (_ArgumentListopt as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _TypeArgumentsopt)  list.add(_TypeArgumentsopt);
            if(null != _this)  list.add(_this);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _ArgumentListopt)  list.add(_ArgumentListopt);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitExplicitConstructorInvocation0(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitExplicitConstructorInvocation0(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitExplicitConstructorInvocation0(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitExplicitConstructorInvocation0(this, o); }
    }

/**
 *<b>
*<li>Rule 173:  ExplicitConstructorInvocation ::= TypeArgumentsopt super ( ArgumentListopt ) ;
 *</b>
 */
class ExplicitConstructorInvocation1 extends Ast implements IExplicitConstructorInvocation
    {
         late TypeArguments? _TypeArgumentsopt;
         late AstToken _super;
         late AstToken _LPAREN;
         late Ast? _ArgumentListopt;
         late AstToken _RPAREN;
         late AstToken _SEMICOLON;

        /**
         * The value returned by <b>getTypeArgumentsopt</b> may be <b>null</b>
         */
         TypeArguments ?  getTypeArgumentsopt(){ return _TypeArgumentsopt; }
         void setTypeArgumentsopt(TypeArguments _TypeArgumentsopt){ this._TypeArgumentsopt = _TypeArgumentsopt; }
         AstToken getsuper(){ return _super; }
         void setsuper(AstToken _super){ this._super = _super; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
        /**
         * The value returned by <b>getArgumentListopt</b> may be <b>null</b>
         */
         Ast ?  getArgumentListopt(){ return _ArgumentListopt; }
         void setArgumentListopt(Ast _ArgumentListopt){ this._ArgumentListopt = _ArgumentListopt; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        ExplicitConstructorInvocation1(IToken leftIToken, IToken rightIToken,
                                       TypeArguments? _TypeArgumentsopt,
                                       AstToken _super,
                                       AstToken _LPAREN,
                                       Ast? _ArgumentListopt,
                                       AstToken _RPAREN,
                                       AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._TypeArgumentsopt = _TypeArgumentsopt;
            if (null != _TypeArgumentsopt) (_TypeArgumentsopt as Ast).setParent(this);
            this._super = _super;
            (_super as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._ArgumentListopt = _ArgumentListopt;
            if (null != _ArgumentListopt) (_ArgumentListopt as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _TypeArgumentsopt)  list.add(_TypeArgumentsopt);
            if(null != _super)  list.add(_super);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _ArgumentListopt)  list.add(_ArgumentListopt);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitExplicitConstructorInvocation1(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitExplicitConstructorInvocation1(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitExplicitConstructorInvocation1(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitExplicitConstructorInvocation1(this, o); }
    }

/**
 *<b>
*<li>Rule 174:  ExplicitConstructorInvocation ::= Primary . TypeArgumentsopt super ( ArgumentListopt ) ;
 *</b>
 */
class ExplicitConstructorInvocation2 extends Ast implements IExplicitConstructorInvocation
    {
         late Ast _Primary;
         late AstToken _DOT;
         late TypeArguments? _TypeArgumentsopt;
         late AstToken _super;
         late AstToken _LPAREN;
         late Ast? _ArgumentListopt;
         late AstToken _RPAREN;
         late AstToken _SEMICOLON;

         Ast getPrimary(){ return _Primary; }
         void setPrimary(Ast _Primary){ this._Primary = _Primary; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
        /**
         * The value returned by <b>getTypeArgumentsopt</b> may be <b>null</b>
         */
         TypeArguments ?  getTypeArgumentsopt(){ return _TypeArgumentsopt; }
         void setTypeArgumentsopt(TypeArguments _TypeArgumentsopt){ this._TypeArgumentsopt = _TypeArgumentsopt; }
         AstToken getsuper(){ return _super; }
         void setsuper(AstToken _super){ this._super = _super; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
        /**
         * The value returned by <b>getArgumentListopt</b> may be <b>null</b>
         */
         Ast ?  getArgumentListopt(){ return _ArgumentListopt; }
         void setArgumentListopt(Ast _ArgumentListopt){ this._ArgumentListopt = _ArgumentListopt; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        ExplicitConstructorInvocation2(IToken leftIToken, IToken rightIToken,
                                       Ast _Primary,
                                       AstToken _DOT,
                                       TypeArguments? _TypeArgumentsopt,
                                       AstToken _super,
                                       AstToken _LPAREN,
                                       Ast? _ArgumentListopt,
                                       AstToken _RPAREN,
                                       AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._Primary = _Primary;
            (_Primary as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._TypeArgumentsopt = _TypeArgumentsopt;
            if (null != _TypeArgumentsopt) (_TypeArgumentsopt as Ast).setParent(this);
            this._super = _super;
            (_super as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._ArgumentListopt = _ArgumentListopt;
            if (null != _ArgumentListopt) (_ArgumentListopt as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _Primary)  list.add(_Primary);
            if(null != _DOT)  list.add(_DOT);
            if(null != _TypeArgumentsopt)  list.add(_TypeArgumentsopt);
            if(null != _super)  list.add(_super);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _ArgumentListopt)  list.add(_ArgumentListopt);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitExplicitConstructorInvocation2(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitExplicitConstructorInvocation2(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitExplicitConstructorInvocation2(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitExplicitConstructorInvocation2(this, o); }
    }

/**
 *<b>
*<li>Rule 188:  InterfaceModifier ::= public
 *</b>
 */
class InterfaceModifier0 extends AstToken implements IInterfaceModifier
    {
         IToken getpublic(){ return leftIToken; }

    InterfaceModifier0(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitInterfaceModifier0(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitInterfaceModifier0(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitInterfaceModifier0(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitInterfaceModifier0(this, o); }
    }

/**
 *<b>
*<li>Rule 189:  InterfaceModifier ::= protected
 *</b>
 */
class InterfaceModifier1 extends AstToken implements IInterfaceModifier
    {
         IToken getprotected(){ return leftIToken; }

    InterfaceModifier1(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitInterfaceModifier1(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitInterfaceModifier1(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitInterfaceModifier1(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitInterfaceModifier1(this, o); }
    }

/**
 *<b>
*<li>Rule 190:  InterfaceModifier ::= private
 *</b>
 */
class InterfaceModifier2 extends AstToken implements IInterfaceModifier
    {
         IToken getprivate(){ return leftIToken; }

    InterfaceModifier2(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitInterfaceModifier2(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitInterfaceModifier2(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitInterfaceModifier2(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitInterfaceModifier2(this, o); }
    }

/**
 *<b>
*<li>Rule 191:  InterfaceModifier ::= abstract
 *</b>
 */
class InterfaceModifier3 extends AstToken implements IInterfaceModifier
    {
         IToken getabstract(){ return leftIToken; }

    InterfaceModifier3(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitInterfaceModifier3(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitInterfaceModifier3(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitInterfaceModifier3(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitInterfaceModifier3(this, o); }
    }

/**
 *<b>
*<li>Rule 192:  InterfaceModifier ::= static
 *</b>
 */
class InterfaceModifier4 extends AstToken implements IInterfaceModifier
    {
         IToken getstatic(){ return leftIToken; }

    InterfaceModifier4(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitInterfaceModifier4(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitInterfaceModifier4(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitInterfaceModifier4(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitInterfaceModifier4(this, o); }
    }

/**
 *<b>
*<li>Rule 193:  InterfaceModifier ::= strictfp
 *</b>
 */
class InterfaceModifier5 extends AstToken implements IInterfaceModifier
    {
         IToken getstrictfp(){ return leftIToken; }

    InterfaceModifier5(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitInterfaceModifier5(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitInterfaceModifier5(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitInterfaceModifier5(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitInterfaceModifier5(this, o); }
    }

/**
 *<b>
*<li>Rule 194:  ExtendsInterfaces ::= extends InterfaceType
 *</b>
 */
class ExtendsInterfaces0 extends Ast implements IExtendsInterfaces
    {
         late AstToken _extends;
         late InterfaceType _InterfaceType;

         AstToken getextends(){ return _extends; }
         void setextends(AstToken _extends){ this._extends = _extends; }
         InterfaceType getInterfaceType(){ return _InterfaceType; }
         void setInterfaceType(InterfaceType _InterfaceType){ this._InterfaceType = _InterfaceType; }

        ExtendsInterfaces0(IToken leftIToken, IToken rightIToken,
                           AstToken _extends,
                           InterfaceType _InterfaceType)
            :super(leftIToken, rightIToken)

        {
            this._extends = _extends;
            (_extends as Ast).setParent(this);
            this._InterfaceType = _InterfaceType;
            (_InterfaceType as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _extends)  list.add(_extends);
            if(null != _InterfaceType)  list.add(_InterfaceType);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitExtendsInterfaces0(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitExtendsInterfaces0(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitExtendsInterfaces0(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitExtendsInterfaces0(this, o); }
    }

/**
 *<b>
*<li>Rule 195:  ExtendsInterfaces ::= ExtendsInterfaces , InterfaceType
 *</b>
 */
class ExtendsInterfaces1 extends Ast implements IExtendsInterfaces
    {
         late Ast _ExtendsInterfaces;
         late AstToken _COMMA;
         late InterfaceType _InterfaceType;

         Ast getExtendsInterfaces(){ return _ExtendsInterfaces; }
         void setExtendsInterfaces(Ast _ExtendsInterfaces){ this._ExtendsInterfaces = _ExtendsInterfaces; }
         AstToken getCOMMA(){ return _COMMA; }
         void setCOMMA(AstToken _COMMA){ this._COMMA = _COMMA; }
         InterfaceType getInterfaceType(){ return _InterfaceType; }
         void setInterfaceType(InterfaceType _InterfaceType){ this._InterfaceType = _InterfaceType; }

        ExtendsInterfaces1(IToken leftIToken, IToken rightIToken,
                           Ast _ExtendsInterfaces,
                           AstToken _COMMA,
                           InterfaceType _InterfaceType)
            :super(leftIToken, rightIToken)

        {
            this._ExtendsInterfaces = _ExtendsInterfaces;
            (_ExtendsInterfaces as Ast).setParent(this);
            this._COMMA = _COMMA;
            (_COMMA as Ast).setParent(this);
            this._InterfaceType = _InterfaceType;
            (_InterfaceType as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ExtendsInterfaces)  list.add(_ExtendsInterfaces);
            if(null != _COMMA)  list.add(_COMMA);
            if(null != _InterfaceType)  list.add(_InterfaceType);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitExtendsInterfaces1(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitExtendsInterfaces1(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitExtendsInterfaces1(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitExtendsInterfaces1(this, o); }
    }

/**
 *<b>
*<li>Rule 208:  ConstantModifier ::= public
 *</b>
 */
class ConstantModifier0 extends AstToken implements IConstantModifier
    {
         IToken getpublic(){ return leftIToken; }

    ConstantModifier0(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitConstantModifier0(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitConstantModifier0(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitConstantModifier0(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitConstantModifier0(this, o); }
    }

/**
 *<b>
*<li>Rule 209:  ConstantModifier ::= static
 *</b>
 */
class ConstantModifier1 extends AstToken implements IConstantModifier
    {
         IToken getstatic(){ return leftIToken; }

    ConstantModifier1(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitConstantModifier1(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitConstantModifier1(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitConstantModifier1(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitConstantModifier1(this, o); }
    }

/**
 *<b>
*<li>Rule 210:  ConstantModifier ::= final
 *</b>
 */
class ConstantModifier2 extends AstToken implements IConstantModifier
    {
         IToken getfinal(){ return leftIToken; }

    ConstantModifier2(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitConstantModifier2(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitConstantModifier2(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitConstantModifier2(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitConstantModifier2(this, o); }
    }

/**
 *<b>
*<li>Rule 215:  AbstractMethodModifier ::= public
 *</b>
 */
class AbstractMethodModifier0 extends AstToken implements IAbstractMethodModifier
    {
         IToken getpublic(){ return leftIToken; }

    AbstractMethodModifier0(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitAbstractMethodModifier0(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitAbstractMethodModifier0(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitAbstractMethodModifier0(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitAbstractMethodModifier0(this, o); }
    }

/**
 *<b>
*<li>Rule 216:  AbstractMethodModifier ::= abstract
 *</b>
 */
class AbstractMethodModifier1 extends AstToken implements IAbstractMethodModifier
    {
         IToken getabstract(){ return leftIToken; }

    AbstractMethodModifier1(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitAbstractMethodModifier1(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitAbstractMethodModifier1(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitAbstractMethodModifier1(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitAbstractMethodModifier1(this, o); }
    }

/**
 *<b>
*<li>Rule 221:  AnnotationTypeElementDeclaration ::= AbstractMethodModifiersopt Type identifier ( ) DefaultValueopt ;
 *</b>
 */
class AnnotationTypeElementDeclaration0 extends Ast implements IAnnotationTypeElementDeclaration
    {
         late Ast? _AbstractMethodModifiersopt;
         late Ast _Type;
         late identifier _identifier;
         late AstToken _LPAREN;
         late AstToken _RPAREN;
         late DefaultValue? _DefaultValueopt;
         late AstToken _SEMICOLON;

        /**
         * The value returned by <b>getAbstractMethodModifiersopt</b> may be <b>null</b>
         */
         Ast ?  getAbstractMethodModifiersopt(){ return _AbstractMethodModifiersopt; }
         void setAbstractMethodModifiersopt(Ast _AbstractMethodModifiersopt){ this._AbstractMethodModifiersopt = _AbstractMethodModifiersopt; }
         Ast getType(){ return _Type; }
         void setType(Ast _Type){ this._Type = _Type; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
        /**
         * The value returned by <b>getDefaultValueopt</b> may be <b>null</b>
         */
         DefaultValue ?  getDefaultValueopt(){ return _DefaultValueopt; }
         void setDefaultValueopt(DefaultValue _DefaultValueopt){ this._DefaultValueopt = _DefaultValueopt; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        AnnotationTypeElementDeclaration0(IToken leftIToken, IToken rightIToken,
                                          Ast? _AbstractMethodModifiersopt,
                                          Ast _Type,
                                          identifier _identifier,
                                          AstToken _LPAREN,
                                          AstToken _RPAREN,
                                          DefaultValue? _DefaultValueopt,
                                          AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._AbstractMethodModifiersopt = _AbstractMethodModifiersopt;
            if (null != _AbstractMethodModifiersopt) (_AbstractMethodModifiersopt as Ast).setParent(this);
            this._Type = _Type;
            (_Type as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._DefaultValueopt = _DefaultValueopt;
            if (null != _DefaultValueopt) (_DefaultValueopt as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _AbstractMethodModifiersopt)  list.add(_AbstractMethodModifiersopt);
            if(null != _Type)  list.add(_Type);
            if(null != _identifier)  list.add(_identifier);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _DefaultValueopt)  list.add(_DefaultValueopt);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitAnnotationTypeElementDeclaration0(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitAnnotationTypeElementDeclaration0(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitAnnotationTypeElementDeclaration0(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitAnnotationTypeElementDeclaration0(this, o); }
    }

/**
 *<b>
*<li>Rule 227:  AnnotationTypeElementDeclaration ::= ;
 *</b>
 */
class AnnotationTypeElementDeclaration1 extends AstToken implements IAnnotationTypeElementDeclaration
    {
         IToken getSEMICOLON(){ return leftIToken; }

    AnnotationTypeElementDeclaration1(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitAnnotationTypeElementDeclaration1(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitAnnotationTypeElementDeclaration1(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitAnnotationTypeElementDeclaration1(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitAnnotationTypeElementDeclaration1(this, o); }
    }

/**
 *<b>
*<li>Rule 295:  AssertStatement ::= assert Expression ;
 *</b>
 */
class AssertStatement0 extends Ast implements IAssertStatement
    {
         late AstToken _assert;
         late Ast _Expression;
         late AstToken _SEMICOLON;

         AstToken getassert(){ return _assert; }
         void setassert(AstToken _assert){ this._assert = _assert; }
         Ast getExpression(){ return _Expression; }
         void setExpression(Ast _Expression){ this._Expression = _Expression; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        AssertStatement0(IToken leftIToken, IToken rightIToken,
                         AstToken _assert,
                         Ast _Expression,
                         AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._assert = _assert;
            (_assert as Ast).setParent(this);
            this._Expression = _Expression;
            (_Expression as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _assert)  list.add(_assert);
            if(null != _Expression)  list.add(_Expression);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitAssertStatement0(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitAssertStatement0(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitAssertStatement0(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitAssertStatement0(this, o); }
    }

/**
 *<b>
*<li>Rule 296:  AssertStatement ::= assert Expression : Expression ;
 *</b>
 */
class AssertStatement1 extends Ast implements IAssertStatement
    {
         late AstToken _assert;
         late Ast _Expression;
         late AstToken _COLON;
         late Ast _Expression4;
         late AstToken _SEMICOLON;

         AstToken getassert(){ return _assert; }
         void setassert(AstToken _assert){ this._assert = _assert; }
         Ast getExpression(){ return _Expression; }
         void setExpression(Ast _Expression){ this._Expression = _Expression; }
         AstToken getCOLON(){ return _COLON; }
         void setCOLON(AstToken _COLON){ this._COLON = _COLON; }
         Ast getExpression4(){ return _Expression4; }
         void setExpression4(Ast _Expression4){ this._Expression4 = _Expression4; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        AssertStatement1(IToken leftIToken, IToken rightIToken,
                         AstToken _assert,
                         Ast _Expression,
                         AstToken _COLON,
                         Ast _Expression4,
                         AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._assert = _assert;
            (_assert as Ast).setParent(this);
            this._Expression = _Expression;
            (_Expression as Ast).setParent(this);
            this._COLON = _COLON;
            (_COLON as Ast).setParent(this);
            this._Expression4 = _Expression4;
            (_Expression4 as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _assert)  list.add(_assert);
            if(null != _Expression)  list.add(_Expression);
            if(null != _COLON)  list.add(_COLON);
            if(null != _Expression4)  list.add(_Expression4);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitAssertStatement1(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitAssertStatement1(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitAssertStatement1(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitAssertStatement1(this, o); }
    }

/**
 *<b>
*<li>Rule 304:  SwitchLabel ::= case ConstantExpression :
 *</b>
 */
class SwitchLabel0 extends Ast implements ISwitchLabel
    {
         late AstToken _case;
         late Ast _ConstantExpression;
         late AstToken _COLON;

         AstToken getcase(){ return _case; }
         void setcase(AstToken _case){ this._case = _case; }
         Ast getConstantExpression(){ return _ConstantExpression; }
         void setConstantExpression(Ast _ConstantExpression){ this._ConstantExpression = _ConstantExpression; }
         AstToken getCOLON(){ return _COLON; }
         void setCOLON(AstToken _COLON){ this._COLON = _COLON; }

        SwitchLabel0(IToken leftIToken, IToken rightIToken,
                     AstToken _case,
                     Ast _ConstantExpression,
                     AstToken _COLON)
            :super(leftIToken, rightIToken)

        {
            this._case = _case;
            (_case as Ast).setParent(this);
            this._ConstantExpression = _ConstantExpression;
            (_ConstantExpression as Ast).setParent(this);
            this._COLON = _COLON;
            (_COLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _case)  list.add(_case);
            if(null != _ConstantExpression)  list.add(_ConstantExpression);
            if(null != _COLON)  list.add(_COLON);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitSwitchLabel0(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitSwitchLabel0(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitSwitchLabel0(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitSwitchLabel0(this, o); }
    }

/**
 *<b>
*<li>Rule 305:  SwitchLabel ::= case EnumConstant :
 *</b>
 */
class SwitchLabel1 extends Ast implements ISwitchLabel
    {
         late AstToken _case;
         late Ast _EnumConstant;
         late AstToken _COLON;

         AstToken getcase(){ return _case; }
         void setcase(AstToken _case){ this._case = _case; }
         Ast getEnumConstant(){ return _EnumConstant; }
         void setEnumConstant(Ast _EnumConstant){ this._EnumConstant = _EnumConstant; }
         AstToken getCOLON(){ return _COLON; }
         void setCOLON(AstToken _COLON){ this._COLON = _COLON; }

        SwitchLabel1(IToken leftIToken, IToken rightIToken,
                     AstToken _case,
                     Ast _EnumConstant,
                     AstToken _COLON)
            :super(leftIToken, rightIToken)

        {
            this._case = _case;
            (_case as Ast).setParent(this);
            this._EnumConstant = _EnumConstant;
            (_EnumConstant as Ast).setParent(this);
            this._COLON = _COLON;
            (_COLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _case)  list.add(_case);
            if(null != _EnumConstant)  list.add(_EnumConstant);
            if(null != _COLON)  list.add(_COLON);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitSwitchLabel1(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitSwitchLabel1(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitSwitchLabel1(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitSwitchLabel1(this, o); }
    }

/**
 *<b>
*<li>Rule 306:  SwitchLabel ::= default :
 *</b>
 */
class SwitchLabel2 extends Ast implements ISwitchLabel
    {
         late AstToken _default;
         late AstToken _COLON;

         AstToken getdefault(){ return _default; }
         void setdefault(AstToken _default){ this._default = _default; }
         AstToken getCOLON(){ return _COLON; }
         void setCOLON(AstToken _COLON){ this._COLON = _COLON; }

        SwitchLabel2(IToken leftIToken, IToken rightIToken,
                     AstToken _default,
                     AstToken _COLON)
            :super(leftIToken, rightIToken)

        {
            this._default = _default;
            (_default as Ast).setParent(this);
            this._COLON = _COLON;
            (_COLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _default)  list.add(_default);
            if(null != _COLON)  list.add(_COLON);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitSwitchLabel2(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitSwitchLabel2(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitSwitchLabel2(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitSwitchLabel2(this, o); }
    }

/**
 *<b>
*<li>Rule 326:  TryStatement ::= try Block Catches
 *</b>
 */
class TryStatement0 extends Ast implements ITryStatement
    {
         late AstToken _try;
         late Block _Block;
         late Ast _Catches;

         AstToken gettry(){ return _try; }
         void settry(AstToken _try){ this._try = _try; }
         Block getBlock(){ return _Block; }
         void setBlock(Block _Block){ this._Block = _Block; }
         Ast getCatches(){ return _Catches; }
         void setCatches(Ast _Catches){ this._Catches = _Catches; }

        TryStatement0(IToken leftIToken, IToken rightIToken,
                      AstToken _try,
                      Block _Block,
                      Ast _Catches)
            :super(leftIToken, rightIToken)

        {
            this._try = _try;
            (_try as Ast).setParent(this);
            this._Block = _Block;
            (_Block as Ast).setParent(this);
            this._Catches = _Catches;
            (_Catches as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _try)  list.add(_try);
            if(null != _Block)  list.add(_Block);
            if(null != _Catches)  list.add(_Catches);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitTryStatement0(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitTryStatement0(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitTryStatement0(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitTryStatement0(this, o); }
    }

/**
 *<b>
*<li>Rule 327:  TryStatement ::= try Block Catchesopt Finally
 *</b>
 */
class TryStatement1 extends Ast implements ITryStatement
    {
         late AstToken _try;
         late Block _Block;
         late Ast? _Catchesopt;
         late Finally _Finally;

         AstToken gettry(){ return _try; }
         void settry(AstToken _try){ this._try = _try; }
         Block getBlock(){ return _Block; }
         void setBlock(Block _Block){ this._Block = _Block; }
        /**
         * The value returned by <b>getCatchesopt</b> may be <b>null</b>
         */
         Ast ?  getCatchesopt(){ return _Catchesopt; }
         void setCatchesopt(Ast _Catchesopt){ this._Catchesopt = _Catchesopt; }
         Finally getFinally(){ return _Finally; }
         void setFinally(Finally _Finally){ this._Finally = _Finally; }

        TryStatement1(IToken leftIToken, IToken rightIToken,
                      AstToken _try,
                      Block _Block,
                      Ast? _Catchesopt,
                      Finally _Finally)
            :super(leftIToken, rightIToken)

        {
            this._try = _try;
            (_try as Ast).setParent(this);
            this._Block = _Block;
            (_Block as Ast).setParent(this);
            this._Catchesopt = _Catchesopt;
            if (null != _Catchesopt) (_Catchesopt as Ast).setParent(this);
            this._Finally = _Finally;
            (_Finally as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _try)  list.add(_try);
            if(null != _Block)  list.add(_Block);
            if(null != _Catchesopt)  list.add(_Catchesopt);
            if(null != _Finally)  list.add(_Finally);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitTryStatement1(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitTryStatement1(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitTryStatement1(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitTryStatement1(this, o); }
    }

/**
 *<b>
*<li>Rule 335:  PrimaryNoNewArray ::= Type . class
 *</b>
 */
class PrimaryNoNewArray0 extends Ast implements IPrimaryNoNewArray
    {
         late Ast _Type;
         late AstToken _DOT;
         late AstToken _class;

         Ast getType(){ return _Type; }
         void setType(Ast _Type){ this._Type = _Type; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
         AstToken getclass(){ return _class; }
         void setclass(AstToken _class){ this._class = _class; }

        PrimaryNoNewArray0(IToken leftIToken, IToken rightIToken,
                           Ast _Type,
                           AstToken _DOT,
                           AstToken _class)
            :super(leftIToken, rightIToken)

        {
            this._Type = _Type;
            (_Type as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._class = _class;
            (_class as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _Type)  list.add(_Type);
            if(null != _DOT)  list.add(_DOT);
            if(null != _class)  list.add(_class);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitPrimaryNoNewArray0(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitPrimaryNoNewArray0(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitPrimaryNoNewArray0(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitPrimaryNoNewArray0(this, o); }
    }

/**
 *<b>
*<li>Rule 336:  PrimaryNoNewArray ::= void . class
 *</b>
 */
class PrimaryNoNewArray1 extends Ast implements IPrimaryNoNewArray
    {
         late AstToken _void;
         late AstToken _DOT;
         late AstToken _class;

         AstToken getvoid(){ return _void; }
         void setvoid(AstToken _void){ this._void = _void; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
         AstToken getclass(){ return _class; }
         void setclass(AstToken _class){ this._class = _class; }

        PrimaryNoNewArray1(IToken leftIToken, IToken rightIToken,
                           AstToken _void,
                           AstToken _DOT,
                           AstToken _class)
            :super(leftIToken, rightIToken)

        {
            this._void = _void;
            (_void as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._class = _class;
            (_class as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _void)  list.add(_void);
            if(null != _DOT)  list.add(_DOT);
            if(null != _class)  list.add(_class);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitPrimaryNoNewArray1(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitPrimaryNoNewArray1(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitPrimaryNoNewArray1(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitPrimaryNoNewArray1(this, o); }
    }

/**
 *<b>
*<li>Rule 337:  PrimaryNoNewArray ::= this
 *</b>
 */
class PrimaryNoNewArray2 extends AstToken implements IPrimaryNoNewArray
    {
         IToken getthis(){ return leftIToken; }

    PrimaryNoNewArray2(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitPrimaryNoNewArray2(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitPrimaryNoNewArray2(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitPrimaryNoNewArray2(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitPrimaryNoNewArray2(this, o); }
    }

/**
 *<b>
*<li>Rule 338:  PrimaryNoNewArray ::= ClassName . this
 *</b>
 */
class PrimaryNoNewArray3 extends Ast implements IPrimaryNoNewArray
    {
         late Ast _ClassName;
         late AstToken _DOT;
         late AstToken _this;

         Ast getClassName(){ return _ClassName; }
         void setClassName(Ast _ClassName){ this._ClassName = _ClassName; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
         AstToken getthis(){ return _this; }
         void setthis(AstToken _this){ this._this = _this; }

        PrimaryNoNewArray3(IToken leftIToken, IToken rightIToken,
                           Ast _ClassName,
                           AstToken _DOT,
                           AstToken _this)
            :super(leftIToken, rightIToken)

        {
            this._ClassName = _ClassName;
            (_ClassName as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._this = _this;
            (_this as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ClassName)  list.add(_ClassName);
            if(null != _DOT)  list.add(_DOT);
            if(null != _this)  list.add(_this);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitPrimaryNoNewArray3(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitPrimaryNoNewArray3(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitPrimaryNoNewArray3(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitPrimaryNoNewArray3(this, o); }
    }

/**
 *<b>
*<li>Rule 339:  PrimaryNoNewArray ::= ( Expression )
 *</b>
 */
class PrimaryNoNewArray4 extends Ast implements IPrimaryNoNewArray
    {
         late AstToken _LPAREN;
         late Ast _Expression;
         late AstToken _RPAREN;

         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
         Ast getExpression(){ return _Expression; }
         void setExpression(Ast _Expression){ this._Expression = _Expression; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }

        PrimaryNoNewArray4(IToken leftIToken, IToken rightIToken,
                           AstToken _LPAREN,
                           Ast _Expression,
                           AstToken _RPAREN)
            :super(leftIToken, rightIToken)

        {
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._Expression = _Expression;
            (_Expression as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _Expression)  list.add(_Expression);
            if(null != _RPAREN)  list.add(_RPAREN);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitPrimaryNoNewArray4(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitPrimaryNoNewArray4(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitPrimaryNoNewArray4(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitPrimaryNoNewArray4(this, o); }
    }

/**
 *<b>
*<li>Rule 344:  Literal ::= IntegerLiteral
 *</b>
 */
class Literal0 extends AstToken implements ILiteral
    {
         IToken getIntegerLiteral(){ return leftIToken; }

    Literal0(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitLiteral0(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitLiteral0(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitLiteral0(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitLiteral0(this, o); }
    }

/**
 *<b>
*<li>Rule 345:  Literal ::= LongLiteral
 *</b>
 */
class Literal1 extends AstToken implements ILiteral
    {
         IToken getLongLiteral(){ return leftIToken; }

    Literal1(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitLiteral1(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitLiteral1(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitLiteral1(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitLiteral1(this, o); }
    }

/**
 *<b>
*<li>Rule 346:  Literal ::= FloatingPointLiteral
 *</b>
 */
class Literal2 extends AstToken implements ILiteral
    {
         IToken getFloatingPointLiteral(){ return leftIToken; }

    Literal2(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitLiteral2(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitLiteral2(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitLiteral2(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitLiteral2(this, o); }
    }

/**
 *<b>
*<li>Rule 347:  Literal ::= DoubleLiteral
 *</b>
 */
class Literal3 extends AstToken implements ILiteral
    {
         IToken getDoubleLiteral(){ return leftIToken; }

    Literal3(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitLiteral3(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitLiteral3(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitLiteral3(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitLiteral3(this, o); }
    }

/**
 *<b>
*<li>Rule 349:  Literal ::= CharacterLiteral
 *</b>
 */
class Literal4 extends AstToken implements ILiteral
    {
         IToken getCharacterLiteral(){ return leftIToken; }

    Literal4(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitLiteral4(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitLiteral4(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitLiteral4(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitLiteral4(this, o); }
    }

/**
 *<b>
*<li>Rule 350:  Literal ::= StringLiteral
 *</b>
 */
class Literal5 extends AstToken implements ILiteral
    {
         IToken getStringLiteral(){ return leftIToken; }

    Literal5(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitLiteral5(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitLiteral5(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitLiteral5(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitLiteral5(this, o); }
    }

/**
 *<b>
*<li>Rule 351:  Literal ::= null
 *</b>
 */
class Literal6 extends AstToken implements ILiteral
    {
         IToken getnull(){ return leftIToken; }

    Literal6(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitLiteral6(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitLiteral6(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitLiteral6(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitLiteral6(this, o); }
    }

/**
 *<b>
*<li>Rule 352:  BooleanLiteral ::= true
 *</b>
 */
class BooleanLiteral0 extends AstToken implements IBooleanLiteral
    {
         IToken gettrue(){ return leftIToken; }

    BooleanLiteral0(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitBooleanLiteral0(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitBooleanLiteral0(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitBooleanLiteral0(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitBooleanLiteral0(this, o); }
    }

/**
 *<b>
*<li>Rule 353:  BooleanLiteral ::= false
 *</b>
 */
class BooleanLiteral1 extends AstToken implements IBooleanLiteral
    {
         IToken getfalse(){ return leftIToken; }

    BooleanLiteral1(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitBooleanLiteral1(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitBooleanLiteral1(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitBooleanLiteral1(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitBooleanLiteral1(this, o); }
    }

/**
 *<b>
*<li>Rule 354:  ClassInstanceCreationExpression ::= new TypeArgumentsopt ClassOrInterfaceType TypeArgumentsopt ( ArgumentListopt ) ClassBodyopt
 *</b>
 */
class ClassInstanceCreationExpression0 extends Ast implements IClassInstanceCreationExpression
    {
         late AstToken _new;
         late TypeArguments? _TypeArgumentsopt;
         late ClassType _ClassOrInterfaceType;
         late TypeArguments? _TypeArgumentsopt4;
         late AstToken _LPAREN;
         late Ast? _ArgumentListopt;
         late AstToken _RPAREN;
         late ClassBody? _ClassBodyopt;

         AstToken getnew(){ return _new; }
         void setnew(AstToken _new){ this._new = _new; }
        /**
         * The value returned by <b>getTypeArgumentsopt</b> may be <b>null</b>
         */
         TypeArguments ?  getTypeArgumentsopt(){ return _TypeArgumentsopt; }
         void setTypeArgumentsopt(TypeArguments _TypeArgumentsopt){ this._TypeArgumentsopt = _TypeArgumentsopt; }
         ClassType getClassOrInterfaceType(){ return _ClassOrInterfaceType; }
         void setClassOrInterfaceType(ClassType _ClassOrInterfaceType){ this._ClassOrInterfaceType = _ClassOrInterfaceType; }
        /**
         * The value returned by <b>getTypeArgumentsopt4</b> may be <b>null</b>
         */
         TypeArguments ?  getTypeArgumentsopt4(){ return _TypeArgumentsopt4; }
         void setTypeArgumentsopt4(TypeArguments _TypeArgumentsopt4){ this._TypeArgumentsopt4 = _TypeArgumentsopt4; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
        /**
         * The value returned by <b>getArgumentListopt</b> may be <b>null</b>
         */
         Ast ?  getArgumentListopt(){ return _ArgumentListopt; }
         void setArgumentListopt(Ast _ArgumentListopt){ this._ArgumentListopt = _ArgumentListopt; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
        /**
         * The value returned by <b>getClassBodyopt</b> may be <b>null</b>
         */
         ClassBody ?  getClassBodyopt(){ return _ClassBodyopt; }
         void setClassBodyopt(ClassBody _ClassBodyopt){ this._ClassBodyopt = _ClassBodyopt; }

        ClassInstanceCreationExpression0(IToken leftIToken, IToken rightIToken,
                                         AstToken _new,
                                         TypeArguments? _TypeArgumentsopt,
                                         ClassType _ClassOrInterfaceType,
                                         TypeArguments? _TypeArgumentsopt4,
                                         AstToken _LPAREN,
                                         Ast? _ArgumentListopt,
                                         AstToken _RPAREN,
                                         ClassBody? _ClassBodyopt)
            :super(leftIToken, rightIToken)

        {
            this._new = _new;
            (_new as Ast).setParent(this);
            this._TypeArgumentsopt = _TypeArgumentsopt;
            if (null != _TypeArgumentsopt) (_TypeArgumentsopt as Ast).setParent(this);
            this._ClassOrInterfaceType = _ClassOrInterfaceType;
            (_ClassOrInterfaceType as Ast).setParent(this);
            this._TypeArgumentsopt4 = _TypeArgumentsopt4;
            if (null != _TypeArgumentsopt4) (_TypeArgumentsopt4 as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._ArgumentListopt = _ArgumentListopt;
            if (null != _ArgumentListopt) (_ArgumentListopt as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._ClassBodyopt = _ClassBodyopt;
            if (null != _ClassBodyopt) (_ClassBodyopt as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _new)  list.add(_new);
            if(null != _TypeArgumentsopt)  list.add(_TypeArgumentsopt);
            if(null != _ClassOrInterfaceType)  list.add(_ClassOrInterfaceType);
            if(null != _TypeArgumentsopt4)  list.add(_TypeArgumentsopt4);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _ArgumentListopt)  list.add(_ArgumentListopt);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _ClassBodyopt)  list.add(_ClassBodyopt);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitClassInstanceCreationExpression0(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitClassInstanceCreationExpression0(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitClassInstanceCreationExpression0(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitClassInstanceCreationExpression0(this, o); }
    }

/**
 *<b>
*<li>Rule 355:  ClassInstanceCreationExpression ::= Primary . new TypeArgumentsopt identifier TypeArgumentsopt ( ArgumentListopt ) ClassBodyopt
 *</b>
 */
class ClassInstanceCreationExpression1 extends Ast implements IClassInstanceCreationExpression
    {
         late Ast _Primary;
         late AstToken _DOT;
         late AstToken _new;
         late TypeArguments? _TypeArgumentsopt;
         late identifier _identifier;
         late TypeArguments? _TypeArgumentsopt6;
         late AstToken _LPAREN;
         late Ast? _ArgumentListopt;
         late AstToken _RPAREN;
         late ClassBody? _ClassBodyopt;

         Ast getPrimary(){ return _Primary; }
         void setPrimary(Ast _Primary){ this._Primary = _Primary; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
         AstToken getnew(){ return _new; }
         void setnew(AstToken _new){ this._new = _new; }
        /**
         * The value returned by <b>getTypeArgumentsopt</b> may be <b>null</b>
         */
         TypeArguments ?  getTypeArgumentsopt(){ return _TypeArgumentsopt; }
         void setTypeArgumentsopt(TypeArguments _TypeArgumentsopt){ this._TypeArgumentsopt = _TypeArgumentsopt; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }
        /**
         * The value returned by <b>getTypeArgumentsopt6</b> may be <b>null</b>
         */
         TypeArguments ?  getTypeArgumentsopt6(){ return _TypeArgumentsopt6; }
         void setTypeArgumentsopt6(TypeArguments _TypeArgumentsopt6){ this._TypeArgumentsopt6 = _TypeArgumentsopt6; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
        /**
         * The value returned by <b>getArgumentListopt</b> may be <b>null</b>
         */
         Ast ?  getArgumentListopt(){ return _ArgumentListopt; }
         void setArgumentListopt(Ast _ArgumentListopt){ this._ArgumentListopt = _ArgumentListopt; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
        /**
         * The value returned by <b>getClassBodyopt</b> may be <b>null</b>
         */
         ClassBody ?  getClassBodyopt(){ return _ClassBodyopt; }
         void setClassBodyopt(ClassBody _ClassBodyopt){ this._ClassBodyopt = _ClassBodyopt; }

        ClassInstanceCreationExpression1(IToken leftIToken, IToken rightIToken,
                                         Ast _Primary,
                                         AstToken _DOT,
                                         AstToken _new,
                                         TypeArguments? _TypeArgumentsopt,
                                         identifier _identifier,
                                         TypeArguments? _TypeArgumentsopt6,
                                         AstToken _LPAREN,
                                         Ast? _ArgumentListopt,
                                         AstToken _RPAREN,
                                         ClassBody? _ClassBodyopt)
            :super(leftIToken, rightIToken)

        {
            this._Primary = _Primary;
            (_Primary as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._new = _new;
            (_new as Ast).setParent(this);
            this._TypeArgumentsopt = _TypeArgumentsopt;
            if (null != _TypeArgumentsopt) (_TypeArgumentsopt as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            this._TypeArgumentsopt6 = _TypeArgumentsopt6;
            if (null != _TypeArgumentsopt6) (_TypeArgumentsopt6 as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._ArgumentListopt = _ArgumentListopt;
            if (null != _ArgumentListopt) (_ArgumentListopt as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._ClassBodyopt = _ClassBodyopt;
            if (null != _ClassBodyopt) (_ClassBodyopt as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _Primary)  list.add(_Primary);
            if(null != _DOT)  list.add(_DOT);
            if(null != _new)  list.add(_new);
            if(null != _TypeArgumentsopt)  list.add(_TypeArgumentsopt);
            if(null != _identifier)  list.add(_identifier);
            if(null != _TypeArgumentsopt6)  list.add(_TypeArgumentsopt6);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _ArgumentListopt)  list.add(_ArgumentListopt);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _ClassBodyopt)  list.add(_ClassBodyopt);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitClassInstanceCreationExpression1(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitClassInstanceCreationExpression1(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitClassInstanceCreationExpression1(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitClassInstanceCreationExpression1(this, o); }
    }

/**
 *<b>
*<li>Rule 358:  ArrayCreationExpression ::= new PrimitiveType DimExprs Dimsopt
 *</b>
 */
class ArrayCreationExpression0 extends Ast implements IArrayCreationExpression
    {
         late AstToken _new;
         late Ast _PrimitiveType;
         late Ast _DimExprs;
         late Ast? _Dimsopt;

         AstToken getnew(){ return _new; }
         void setnew(AstToken _new){ this._new = _new; }
         Ast getPrimitiveType(){ return _PrimitiveType; }
         void setPrimitiveType(Ast _PrimitiveType){ this._PrimitiveType = _PrimitiveType; }
         Ast getDimExprs(){ return _DimExprs; }
         void setDimExprs(Ast _DimExprs){ this._DimExprs = _DimExprs; }
        /**
         * The value returned by <b>getDimsopt</b> may be <b>null</b>
         */
         Ast ?  getDimsopt(){ return _Dimsopt; }
         void setDimsopt(Ast _Dimsopt){ this._Dimsopt = _Dimsopt; }

        ArrayCreationExpression0(IToken leftIToken, IToken rightIToken,
                                 AstToken _new,
                                 Ast _PrimitiveType,
                                 Ast _DimExprs,
                                 Ast? _Dimsopt)
            :super(leftIToken, rightIToken)

        {
            this._new = _new;
            (_new as Ast).setParent(this);
            this._PrimitiveType = _PrimitiveType;
            (_PrimitiveType as Ast).setParent(this);
            this._DimExprs = _DimExprs;
            (_DimExprs as Ast).setParent(this);
            this._Dimsopt = _Dimsopt;
            if (null != _Dimsopt) (_Dimsopt as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _new)  list.add(_new);
            if(null != _PrimitiveType)  list.add(_PrimitiveType);
            if(null != _DimExprs)  list.add(_DimExprs);
            if(null != _Dimsopt)  list.add(_Dimsopt);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitArrayCreationExpression0(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitArrayCreationExpression0(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitArrayCreationExpression0(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitArrayCreationExpression0(this, o); }
    }

/**
 *<b>
*<li>Rule 359:  ArrayCreationExpression ::= new ClassOrInterfaceType DimExprs Dimsopt
 *</b>
 */
class ArrayCreationExpression1 extends Ast implements IArrayCreationExpression
    {
         late AstToken _new;
         late ClassType _ClassOrInterfaceType;
         late Ast _DimExprs;
         late Ast? _Dimsopt;

         AstToken getnew(){ return _new; }
         void setnew(AstToken _new){ this._new = _new; }
         ClassType getClassOrInterfaceType(){ return _ClassOrInterfaceType; }
         void setClassOrInterfaceType(ClassType _ClassOrInterfaceType){ this._ClassOrInterfaceType = _ClassOrInterfaceType; }
         Ast getDimExprs(){ return _DimExprs; }
         void setDimExprs(Ast _DimExprs){ this._DimExprs = _DimExprs; }
        /**
         * The value returned by <b>getDimsopt</b> may be <b>null</b>
         */
         Ast ?  getDimsopt(){ return _Dimsopt; }
         void setDimsopt(Ast _Dimsopt){ this._Dimsopt = _Dimsopt; }

        ArrayCreationExpression1(IToken leftIToken, IToken rightIToken,
                                 AstToken _new,
                                 ClassType _ClassOrInterfaceType,
                                 Ast _DimExprs,
                                 Ast? _Dimsopt)
            :super(leftIToken, rightIToken)

        {
            this._new = _new;
            (_new as Ast).setParent(this);
            this._ClassOrInterfaceType = _ClassOrInterfaceType;
            (_ClassOrInterfaceType as Ast).setParent(this);
            this._DimExprs = _DimExprs;
            (_DimExprs as Ast).setParent(this);
            this._Dimsopt = _Dimsopt;
            if (null != _Dimsopt) (_Dimsopt as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _new)  list.add(_new);
            if(null != _ClassOrInterfaceType)  list.add(_ClassOrInterfaceType);
            if(null != _DimExprs)  list.add(_DimExprs);
            if(null != _Dimsopt)  list.add(_Dimsopt);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitArrayCreationExpression1(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitArrayCreationExpression1(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitArrayCreationExpression1(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitArrayCreationExpression1(this, o); }
    }

/**
 *<b>
*<li>Rule 360:  ArrayCreationExpression ::= new PrimitiveType Dims ArrayInitializer
 *</b>
 */
class ArrayCreationExpression2 extends Ast implements IArrayCreationExpression
    {
         late AstToken _new;
         late Ast _PrimitiveType;
         late Ast _Dims;
         late ArrayInitializer _ArrayInitializer;

         AstToken getnew(){ return _new; }
         void setnew(AstToken _new){ this._new = _new; }
         Ast getPrimitiveType(){ return _PrimitiveType; }
         void setPrimitiveType(Ast _PrimitiveType){ this._PrimitiveType = _PrimitiveType; }
         Ast getDims(){ return _Dims; }
         void setDims(Ast _Dims){ this._Dims = _Dims; }
         ArrayInitializer getArrayInitializer(){ return _ArrayInitializer; }
         void setArrayInitializer(ArrayInitializer _ArrayInitializer){ this._ArrayInitializer = _ArrayInitializer; }

        ArrayCreationExpression2(IToken leftIToken, IToken rightIToken,
                                 AstToken _new,
                                 Ast _PrimitiveType,
                                 Ast _Dims,
                                 ArrayInitializer _ArrayInitializer)
            :super(leftIToken, rightIToken)

        {
            this._new = _new;
            (_new as Ast).setParent(this);
            this._PrimitiveType = _PrimitiveType;
            (_PrimitiveType as Ast).setParent(this);
            this._Dims = _Dims;
            (_Dims as Ast).setParent(this);
            this._ArrayInitializer = _ArrayInitializer;
            (_ArrayInitializer as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _new)  list.add(_new);
            if(null != _PrimitiveType)  list.add(_PrimitiveType);
            if(null != _Dims)  list.add(_Dims);
            if(null != _ArrayInitializer)  list.add(_ArrayInitializer);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitArrayCreationExpression2(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitArrayCreationExpression2(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitArrayCreationExpression2(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitArrayCreationExpression2(this, o); }
    }

/**
 *<b>
*<li>Rule 361:  ArrayCreationExpression ::= new ClassOrInterfaceType Dims ArrayInitializer
 *</b>
 */
class ArrayCreationExpression3 extends Ast implements IArrayCreationExpression
    {
         late AstToken _new;
         late ClassType _ClassOrInterfaceType;
         late Ast _Dims;
         late ArrayInitializer _ArrayInitializer;

         AstToken getnew(){ return _new; }
         void setnew(AstToken _new){ this._new = _new; }
         ClassType getClassOrInterfaceType(){ return _ClassOrInterfaceType; }
         void setClassOrInterfaceType(ClassType _ClassOrInterfaceType){ this._ClassOrInterfaceType = _ClassOrInterfaceType; }
         Ast getDims(){ return _Dims; }
         void setDims(Ast _Dims){ this._Dims = _Dims; }
         ArrayInitializer getArrayInitializer(){ return _ArrayInitializer; }
         void setArrayInitializer(ArrayInitializer _ArrayInitializer){ this._ArrayInitializer = _ArrayInitializer; }

        ArrayCreationExpression3(IToken leftIToken, IToken rightIToken,
                                 AstToken _new,
                                 ClassType _ClassOrInterfaceType,
                                 Ast _Dims,
                                 ArrayInitializer _ArrayInitializer)
            :super(leftIToken, rightIToken)

        {
            this._new = _new;
            (_new as Ast).setParent(this);
            this._ClassOrInterfaceType = _ClassOrInterfaceType;
            (_ClassOrInterfaceType as Ast).setParent(this);
            this._Dims = _Dims;
            (_Dims as Ast).setParent(this);
            this._ArrayInitializer = _ArrayInitializer;
            (_ArrayInitializer as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _new)  list.add(_new);
            if(null != _ClassOrInterfaceType)  list.add(_ClassOrInterfaceType);
            if(null != _Dims)  list.add(_Dims);
            if(null != _ArrayInitializer)  list.add(_ArrayInitializer);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitArrayCreationExpression3(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitArrayCreationExpression3(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitArrayCreationExpression3(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitArrayCreationExpression3(this, o); }
    }

/**
 *<b>
*<li>Rule 365:  Dims ::= [ ]
 *</b>
 */
class Dims0 extends Ast implements IDims
    {
         late AstToken _LBRACKET;
         late AstToken _RBRACKET;

         AstToken getLBRACKET(){ return _LBRACKET; }
         void setLBRACKET(AstToken _LBRACKET){ this._LBRACKET = _LBRACKET; }
         AstToken getRBRACKET(){ return _RBRACKET; }
         void setRBRACKET(AstToken _RBRACKET){ this._RBRACKET = _RBRACKET; }

        Dims0(IToken leftIToken, IToken rightIToken,
              AstToken _LBRACKET,
              AstToken _RBRACKET)
            :super(leftIToken, rightIToken)

        {
            this._LBRACKET = _LBRACKET;
            (_LBRACKET as Ast).setParent(this);
            this._RBRACKET = _RBRACKET;
            (_RBRACKET as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _LBRACKET)  list.add(_LBRACKET);
            if(null != _RBRACKET)  list.add(_RBRACKET);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitDims0(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitDims0(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitDims0(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitDims0(this, o); }
    }

/**
 *<b>
*<li>Rule 366:  Dims ::= Dims [ ]
 *</b>
 */
class Dims1 extends Ast implements IDims
    {
         late Ast _Dims;
         late AstToken _LBRACKET;
         late AstToken _RBRACKET;

         Ast getDims(){ return _Dims; }
         void setDims(Ast _Dims){ this._Dims = _Dims; }
         AstToken getLBRACKET(){ return _LBRACKET; }
         void setLBRACKET(AstToken _LBRACKET){ this._LBRACKET = _LBRACKET; }
         AstToken getRBRACKET(){ return _RBRACKET; }
         void setRBRACKET(AstToken _RBRACKET){ this._RBRACKET = _RBRACKET; }

        Dims1(IToken leftIToken, IToken rightIToken,
              Ast _Dims,
              AstToken _LBRACKET,
              AstToken _RBRACKET)
            :super(leftIToken, rightIToken)

        {
            this._Dims = _Dims;
            (_Dims as Ast).setParent(this);
            this._LBRACKET = _LBRACKET;
            (_LBRACKET as Ast).setParent(this);
            this._RBRACKET = _RBRACKET;
            (_RBRACKET as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _Dims)  list.add(_Dims);
            if(null != _LBRACKET)  list.add(_LBRACKET);
            if(null != _RBRACKET)  list.add(_RBRACKET);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitDims1(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitDims1(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitDims1(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitDims1(this, o); }
    }

/**
 *<b>
*<li>Rule 367:  FieldAccess ::= Primary . identifier
 *</b>
 */
class FieldAccess0 extends Ast implements IFieldAccess
    {
         late Ast _Primary;
         late AstToken _DOT;
         late identifier _identifier;

         Ast getPrimary(){ return _Primary; }
         void setPrimary(Ast _Primary){ this._Primary = _Primary; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }

        FieldAccess0(IToken leftIToken, IToken rightIToken,
                     Ast _Primary,
                     AstToken _DOT,
                     identifier _identifier)
            :super(leftIToken, rightIToken)

        {
            this._Primary = _Primary;
            (_Primary as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _Primary)  list.add(_Primary);
            if(null != _DOT)  list.add(_DOT);
            if(null != _identifier)  list.add(_identifier);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitFieldAccess0(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitFieldAccess0(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitFieldAccess0(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitFieldAccess0(this, o); }
    }

/**
 *<b>
*<li>Rule 368:  FieldAccess ::= super . identifier
 *</b>
 */
class FieldAccess1 extends Ast implements IFieldAccess
    {
         late AstToken _super;
         late AstToken _DOT;
         late identifier _identifier;

         AstToken getsuper(){ return _super; }
         void setsuper(AstToken _super){ this._super = _super; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }

        FieldAccess1(IToken leftIToken, IToken rightIToken,
                     AstToken _super,
                     AstToken _DOT,
                     identifier _identifier)
            :super(leftIToken, rightIToken)

        {
            this._super = _super;
            (_super as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _super)  list.add(_super);
            if(null != _DOT)  list.add(_DOT);
            if(null != _identifier)  list.add(_identifier);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitFieldAccess1(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitFieldAccess1(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitFieldAccess1(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitFieldAccess1(this, o); }
    }

/**
 *<b>
*<li>Rule 369:  FieldAccess ::= ClassName . super . identifier
 *</b>
 */
class FieldAccess2 extends Ast implements IFieldAccess
    {
         late Ast _ClassName;
         late AstToken _DOT;
         late AstToken _super;
         late AstToken _DOT4;
         late identifier _identifier;

         Ast getClassName(){ return _ClassName; }
         void setClassName(Ast _ClassName){ this._ClassName = _ClassName; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
         AstToken getsuper(){ return _super; }
         void setsuper(AstToken _super){ this._super = _super; }
         AstToken getDOT4(){ return _DOT4; }
         void setDOT4(AstToken _DOT4){ this._DOT4 = _DOT4; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }

        FieldAccess2(IToken leftIToken, IToken rightIToken,
                     Ast _ClassName,
                     AstToken _DOT,
                     AstToken _super,
                     AstToken _DOT4,
                     identifier _identifier)
            :super(leftIToken, rightIToken)

        {
            this._ClassName = _ClassName;
            (_ClassName as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._super = _super;
            (_super as Ast).setParent(this);
            this._DOT4 = _DOT4;
            (_DOT4 as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ClassName)  list.add(_ClassName);
            if(null != _DOT)  list.add(_DOT);
            if(null != _super)  list.add(_super);
            if(null != _DOT4)  list.add(_DOT4);
            if(null != _identifier)  list.add(_identifier);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitFieldAccess2(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitFieldAccess2(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitFieldAccess2(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitFieldAccess2(this, o); }
    }

/**
 *<b>
*<li>Rule 370:  MethodInvocation ::= MethodName ( ArgumentListopt )
 *</b>
 */
class MethodInvocation0 extends Ast implements IMethodInvocation
    {
         late Ast _MethodName;
         late AstToken _LPAREN;
         late Ast? _ArgumentListopt;
         late AstToken _RPAREN;

         Ast getMethodName(){ return _MethodName; }
         void setMethodName(Ast _MethodName){ this._MethodName = _MethodName; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
        /**
         * The value returned by <b>getArgumentListopt</b> may be <b>null</b>
         */
         Ast ?  getArgumentListopt(){ return _ArgumentListopt; }
         void setArgumentListopt(Ast _ArgumentListopt){ this._ArgumentListopt = _ArgumentListopt; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }

        MethodInvocation0(IToken leftIToken, IToken rightIToken,
                          Ast _MethodName,
                          AstToken _LPAREN,
                          Ast? _ArgumentListopt,
                          AstToken _RPAREN)
            :super(leftIToken, rightIToken)

        {
            this._MethodName = _MethodName;
            (_MethodName as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._ArgumentListopt = _ArgumentListopt;
            if (null != _ArgumentListopt) (_ArgumentListopt as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _MethodName)  list.add(_MethodName);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _ArgumentListopt)  list.add(_ArgumentListopt);
            if(null != _RPAREN)  list.add(_RPAREN);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitMethodInvocation0(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitMethodInvocation0(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitMethodInvocation0(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitMethodInvocation0(this, o); }
    }

/**
 *<b>
*<li>Rule 371:  MethodInvocation ::= Primary . TypeArgumentsopt identifier ( ArgumentListopt )
 *</b>
 */
class MethodInvocation1 extends Ast implements IMethodInvocation
    {
         late Ast _Primary;
         late AstToken _DOT;
         late TypeArguments? _TypeArgumentsopt;
         late identifier _identifier;
         late AstToken _LPAREN;
         late Ast? _ArgumentListopt;
         late AstToken _RPAREN;

         Ast getPrimary(){ return _Primary; }
         void setPrimary(Ast _Primary){ this._Primary = _Primary; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
        /**
         * The value returned by <b>getTypeArgumentsopt</b> may be <b>null</b>
         */
         TypeArguments ?  getTypeArgumentsopt(){ return _TypeArgumentsopt; }
         void setTypeArgumentsopt(TypeArguments _TypeArgumentsopt){ this._TypeArgumentsopt = _TypeArgumentsopt; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
        /**
         * The value returned by <b>getArgumentListopt</b> may be <b>null</b>
         */
         Ast ?  getArgumentListopt(){ return _ArgumentListopt; }
         void setArgumentListopt(Ast _ArgumentListopt){ this._ArgumentListopt = _ArgumentListopt; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }

        MethodInvocation1(IToken leftIToken, IToken rightIToken,
                          Ast _Primary,
                          AstToken _DOT,
                          TypeArguments? _TypeArgumentsopt,
                          identifier _identifier,
                          AstToken _LPAREN,
                          Ast? _ArgumentListopt,
                          AstToken _RPAREN)
            :super(leftIToken, rightIToken)

        {
            this._Primary = _Primary;
            (_Primary as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._TypeArgumentsopt = _TypeArgumentsopt;
            if (null != _TypeArgumentsopt) (_TypeArgumentsopt as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._ArgumentListopt = _ArgumentListopt;
            if (null != _ArgumentListopt) (_ArgumentListopt as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _Primary)  list.add(_Primary);
            if(null != _DOT)  list.add(_DOT);
            if(null != _TypeArgumentsopt)  list.add(_TypeArgumentsopt);
            if(null != _identifier)  list.add(_identifier);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _ArgumentListopt)  list.add(_ArgumentListopt);
            if(null != _RPAREN)  list.add(_RPAREN);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitMethodInvocation1(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitMethodInvocation1(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitMethodInvocation1(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitMethodInvocation1(this, o); }
    }

/**
 *<b>
*<li>Rule 372:  MethodInvocation ::= super . TypeArgumentsopt identifier ( ArgumentListopt )
 *</b>
 */
class MethodInvocation2 extends Ast implements IMethodInvocation
    {
         late AstToken _super;
         late AstToken _DOT;
         late TypeArguments? _TypeArgumentsopt;
         late identifier _identifier;
         late AstToken _LPAREN;
         late Ast? _ArgumentListopt;
         late AstToken _RPAREN;

         AstToken getsuper(){ return _super; }
         void setsuper(AstToken _super){ this._super = _super; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
        /**
         * The value returned by <b>getTypeArgumentsopt</b> may be <b>null</b>
         */
         TypeArguments ?  getTypeArgumentsopt(){ return _TypeArgumentsopt; }
         void setTypeArgumentsopt(TypeArguments _TypeArgumentsopt){ this._TypeArgumentsopt = _TypeArgumentsopt; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
        /**
         * The value returned by <b>getArgumentListopt</b> may be <b>null</b>
         */
         Ast ?  getArgumentListopt(){ return _ArgumentListopt; }
         void setArgumentListopt(Ast _ArgumentListopt){ this._ArgumentListopt = _ArgumentListopt; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }

        MethodInvocation2(IToken leftIToken, IToken rightIToken,
                          AstToken _super,
                          AstToken _DOT,
                          TypeArguments? _TypeArgumentsopt,
                          identifier _identifier,
                          AstToken _LPAREN,
                          Ast? _ArgumentListopt,
                          AstToken _RPAREN)
            :super(leftIToken, rightIToken)

        {
            this._super = _super;
            (_super as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._TypeArgumentsopt = _TypeArgumentsopt;
            if (null != _TypeArgumentsopt) (_TypeArgumentsopt as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._ArgumentListopt = _ArgumentListopt;
            if (null != _ArgumentListopt) (_ArgumentListopt as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _super)  list.add(_super);
            if(null != _DOT)  list.add(_DOT);
            if(null != _TypeArgumentsopt)  list.add(_TypeArgumentsopt);
            if(null != _identifier)  list.add(_identifier);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _ArgumentListopt)  list.add(_ArgumentListopt);
            if(null != _RPAREN)  list.add(_RPAREN);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitMethodInvocation2(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitMethodInvocation2(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitMethodInvocation2(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitMethodInvocation2(this, o); }
    }

/**
 *<b>
*<li>Rule 373:  MethodInvocation ::= ClassName . super . TypeArgumentsopt identifier ( ArgumentListopt )
 *</b>
 */
class MethodInvocation3 extends Ast implements IMethodInvocation
    {
         late Ast _ClassName;
         late AstToken _DOT;
         late AstToken _super;
         late AstToken _DOT4;
         late TypeArguments? _TypeArgumentsopt;
         late identifier _identifier;
         late AstToken _LPAREN;
         late Ast? _ArgumentListopt;
         late AstToken _RPAREN;

         Ast getClassName(){ return _ClassName; }
         void setClassName(Ast _ClassName){ this._ClassName = _ClassName; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
         AstToken getsuper(){ return _super; }
         void setsuper(AstToken _super){ this._super = _super; }
         AstToken getDOT4(){ return _DOT4; }
         void setDOT4(AstToken _DOT4){ this._DOT4 = _DOT4; }
        /**
         * The value returned by <b>getTypeArgumentsopt</b> may be <b>null</b>
         */
         TypeArguments ?  getTypeArgumentsopt(){ return _TypeArgumentsopt; }
         void setTypeArgumentsopt(TypeArguments _TypeArgumentsopt){ this._TypeArgumentsopt = _TypeArgumentsopt; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
        /**
         * The value returned by <b>getArgumentListopt</b> may be <b>null</b>
         */
         Ast ?  getArgumentListopt(){ return _ArgumentListopt; }
         void setArgumentListopt(Ast _ArgumentListopt){ this._ArgumentListopt = _ArgumentListopt; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }

        MethodInvocation3(IToken leftIToken, IToken rightIToken,
                          Ast _ClassName,
                          AstToken _DOT,
                          AstToken _super,
                          AstToken _DOT4,
                          TypeArguments? _TypeArgumentsopt,
                          identifier _identifier,
                          AstToken _LPAREN,
                          Ast? _ArgumentListopt,
                          AstToken _RPAREN)
            :super(leftIToken, rightIToken)

        {
            this._ClassName = _ClassName;
            (_ClassName as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._super = _super;
            (_super as Ast).setParent(this);
            this._DOT4 = _DOT4;
            (_DOT4 as Ast).setParent(this);
            this._TypeArgumentsopt = _TypeArgumentsopt;
            if (null != _TypeArgumentsopt) (_TypeArgumentsopt as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._ArgumentListopt = _ArgumentListopt;
            if (null != _ArgumentListopt) (_ArgumentListopt as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ClassName)  list.add(_ClassName);
            if(null != _DOT)  list.add(_DOT);
            if(null != _super)  list.add(_super);
            if(null != _DOT4)  list.add(_DOT4);
            if(null != _TypeArgumentsopt)  list.add(_TypeArgumentsopt);
            if(null != _identifier)  list.add(_identifier);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _ArgumentListopt)  list.add(_ArgumentListopt);
            if(null != _RPAREN)  list.add(_RPAREN);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitMethodInvocation3(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitMethodInvocation3(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitMethodInvocation3(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitMethodInvocation3(this, o); }
    }

/**
 *<b>
*<li>Rule 374:  MethodInvocation ::= TypeName . TypeArguments identifier ( ArgumentListopt )
 *</b>
 */
class MethodInvocation4 extends Ast implements IMethodInvocation
    {
         late Ast _TypeName;
         late AstToken _DOT;
         late TypeArguments _TypeArguments;
         late identifier _identifier;
         late AstToken _LPAREN;
         late Ast? _ArgumentListopt;
         late AstToken _RPAREN;

         Ast getTypeName(){ return _TypeName; }
         void setTypeName(Ast _TypeName){ this._TypeName = _TypeName; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
         TypeArguments getTypeArguments(){ return _TypeArguments; }
         void setTypeArguments(TypeArguments _TypeArguments){ this._TypeArguments = _TypeArguments; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
        /**
         * The value returned by <b>getArgumentListopt</b> may be <b>null</b>
         */
         Ast ?  getArgumentListopt(){ return _ArgumentListopt; }
         void setArgumentListopt(Ast _ArgumentListopt){ this._ArgumentListopt = _ArgumentListopt; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }

        MethodInvocation4(IToken leftIToken, IToken rightIToken,
                          Ast _TypeName,
                          AstToken _DOT,
                          TypeArguments _TypeArguments,
                          identifier _identifier,
                          AstToken _LPAREN,
                          Ast? _ArgumentListopt,
                          AstToken _RPAREN)
            :super(leftIToken, rightIToken)

        {
            this._TypeName = _TypeName;
            (_TypeName as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._TypeArguments = _TypeArguments;
            (_TypeArguments as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._ArgumentListopt = _ArgumentListopt;
            if (null != _ArgumentListopt) (_ArgumentListopt as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _TypeName)  list.add(_TypeName);
            if(null != _DOT)  list.add(_DOT);
            if(null != _TypeArguments)  list.add(_TypeArguments);
            if(null != _identifier)  list.add(_identifier);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _ArgumentListopt)  list.add(_ArgumentListopt);
            if(null != _RPAREN)  list.add(_RPAREN);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitMethodInvocation4(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitMethodInvocation4(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitMethodInvocation4(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitMethodInvocation4(this, o); }
    }

/**
 *<b>
*<li>Rule 375:  ArrayAccess ::= ExpressionName [ Expression ]
 *</b>
 */
class ArrayAccess0 extends Ast implements IArrayAccess
    {
         late Ast _ExpressionName;
         late AstToken _LBRACKET;
         late Ast _Expression;
         late AstToken _RBRACKET;

         Ast getExpressionName(){ return _ExpressionName; }
         void setExpressionName(Ast _ExpressionName){ this._ExpressionName = _ExpressionName; }
         AstToken getLBRACKET(){ return _LBRACKET; }
         void setLBRACKET(AstToken _LBRACKET){ this._LBRACKET = _LBRACKET; }
         Ast getExpression(){ return _Expression; }
         void setExpression(Ast _Expression){ this._Expression = _Expression; }
         AstToken getRBRACKET(){ return _RBRACKET; }
         void setRBRACKET(AstToken _RBRACKET){ this._RBRACKET = _RBRACKET; }

        ArrayAccess0(IToken leftIToken, IToken rightIToken,
                     Ast _ExpressionName,
                     AstToken _LBRACKET,
                     Ast _Expression,
                     AstToken _RBRACKET)
            :super(leftIToken, rightIToken)

        {
            this._ExpressionName = _ExpressionName;
            (_ExpressionName as Ast).setParent(this);
            this._LBRACKET = _LBRACKET;
            (_LBRACKET as Ast).setParent(this);
            this._Expression = _Expression;
            (_Expression as Ast).setParent(this);
            this._RBRACKET = _RBRACKET;
            (_RBRACKET as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ExpressionName)  list.add(_ExpressionName);
            if(null != _LBRACKET)  list.add(_LBRACKET);
            if(null != _Expression)  list.add(_Expression);
            if(null != _RBRACKET)  list.add(_RBRACKET);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitArrayAccess0(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitArrayAccess0(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitArrayAccess0(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitArrayAccess0(this, o); }
    }

/**
 *<b>
*<li>Rule 376:  ArrayAccess ::= PrimaryNoNewArray [ Expression ]
 *</b>
 */
class ArrayAccess1 extends Ast implements IArrayAccess
    {
         late Ast _PrimaryNoNewArray;
         late AstToken _LBRACKET;
         late Ast _Expression;
         late AstToken _RBRACKET;

         Ast getPrimaryNoNewArray(){ return _PrimaryNoNewArray; }
         void setPrimaryNoNewArray(Ast _PrimaryNoNewArray){ this._PrimaryNoNewArray = _PrimaryNoNewArray; }
         AstToken getLBRACKET(){ return _LBRACKET; }
         void setLBRACKET(AstToken _LBRACKET){ this._LBRACKET = _LBRACKET; }
         Ast getExpression(){ return _Expression; }
         void setExpression(Ast _Expression){ this._Expression = _Expression; }
         AstToken getRBRACKET(){ return _RBRACKET; }
         void setRBRACKET(AstToken _RBRACKET){ this._RBRACKET = _RBRACKET; }

        ArrayAccess1(IToken leftIToken, IToken rightIToken,
                     Ast _PrimaryNoNewArray,
                     AstToken _LBRACKET,
                     Ast _Expression,
                     AstToken _RBRACKET)
            :super(leftIToken, rightIToken)

        {
            this._PrimaryNoNewArray = _PrimaryNoNewArray;
            (_PrimaryNoNewArray as Ast).setParent(this);
            this._LBRACKET = _LBRACKET;
            (_LBRACKET as Ast).setParent(this);
            this._Expression = _Expression;
            (_Expression as Ast).setParent(this);
            this._RBRACKET = _RBRACKET;
            (_RBRACKET as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _PrimaryNoNewArray)  list.add(_PrimaryNoNewArray);
            if(null != _LBRACKET)  list.add(_LBRACKET);
            if(null != _Expression)  list.add(_Expression);
            if(null != _RBRACKET)  list.add(_RBRACKET);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitArrayAccess1(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitArrayAccess1(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitArrayAccess1(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitArrayAccess1(this, o); }
    }

/**
 *<b>
*<li>Rule 385:  UnaryExpression ::= + UnaryExpression
 *</b>
 */
class UnaryExpression0 extends Ast implements IUnaryExpression
    {
         late AstToken _PLUS;
         late Ast _UnaryExpression;

         AstToken getPLUS(){ return _PLUS; }
         void setPLUS(AstToken _PLUS){ this._PLUS = _PLUS; }
         Ast getUnaryExpression(){ return _UnaryExpression; }
         void setUnaryExpression(Ast _UnaryExpression){ this._UnaryExpression = _UnaryExpression; }

        UnaryExpression0(IToken leftIToken, IToken rightIToken,
                         AstToken _PLUS,
                         Ast _UnaryExpression)
            :super(leftIToken, rightIToken)

        {
            this._PLUS = _PLUS;
            (_PLUS as Ast).setParent(this);
            this._UnaryExpression = _UnaryExpression;
            (_UnaryExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _PLUS)  list.add(_PLUS);
            if(null != _UnaryExpression)  list.add(_UnaryExpression);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitUnaryExpression0(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitUnaryExpression0(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitUnaryExpression0(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitUnaryExpression0(this, o); }
    }

/**
 *<b>
*<li>Rule 386:  UnaryExpression ::= - UnaryExpression
 *</b>
 */
class UnaryExpression1 extends Ast implements IUnaryExpression
    {
         late AstToken _MINUS;
         late Ast _UnaryExpression;

         AstToken getMINUS(){ return _MINUS; }
         void setMINUS(AstToken _MINUS){ this._MINUS = _MINUS; }
         Ast getUnaryExpression(){ return _UnaryExpression; }
         void setUnaryExpression(Ast _UnaryExpression){ this._UnaryExpression = _UnaryExpression; }

        UnaryExpression1(IToken leftIToken, IToken rightIToken,
                         AstToken _MINUS,
                         Ast _UnaryExpression)
            :super(leftIToken, rightIToken)

        {
            this._MINUS = _MINUS;
            (_MINUS as Ast).setParent(this);
            this._UnaryExpression = _UnaryExpression;
            (_UnaryExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _MINUS)  list.add(_MINUS);
            if(null != _UnaryExpression)  list.add(_UnaryExpression);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitUnaryExpression1(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitUnaryExpression1(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitUnaryExpression1(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitUnaryExpression1(this, o); }
    }

/**
 *<b>
*<li>Rule 391:  UnaryExpressionNotPlusMinus ::= ~ UnaryExpression
 *</b>
 */
class UnaryExpressionNotPlusMinus0 extends Ast implements IUnaryExpressionNotPlusMinus
    {
         late AstToken _TWIDDLE;
         late Ast _UnaryExpression;

         AstToken getTWIDDLE(){ return _TWIDDLE; }
         void setTWIDDLE(AstToken _TWIDDLE){ this._TWIDDLE = _TWIDDLE; }
         Ast getUnaryExpression(){ return _UnaryExpression; }
         void setUnaryExpression(Ast _UnaryExpression){ this._UnaryExpression = _UnaryExpression; }

        UnaryExpressionNotPlusMinus0(IToken leftIToken, IToken rightIToken,
                                     AstToken _TWIDDLE,
                                     Ast _UnaryExpression)
            :super(leftIToken, rightIToken)

        {
            this._TWIDDLE = _TWIDDLE;
            (_TWIDDLE as Ast).setParent(this);
            this._UnaryExpression = _UnaryExpression;
            (_UnaryExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _TWIDDLE)  list.add(_TWIDDLE);
            if(null != _UnaryExpression)  list.add(_UnaryExpression);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitUnaryExpressionNotPlusMinus0(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitUnaryExpressionNotPlusMinus0(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitUnaryExpressionNotPlusMinus0(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitUnaryExpressionNotPlusMinus0(this, o); }
    }

/**
 *<b>
*<li>Rule 392:  UnaryExpressionNotPlusMinus ::= ! UnaryExpression
 *</b>
 */
class UnaryExpressionNotPlusMinus1 extends Ast implements IUnaryExpressionNotPlusMinus
    {
         late AstToken _NOT;
         late Ast _UnaryExpression;

         AstToken getNOT(){ return _NOT; }
         void setNOT(AstToken _NOT){ this._NOT = _NOT; }
         Ast getUnaryExpression(){ return _UnaryExpression; }
         void setUnaryExpression(Ast _UnaryExpression){ this._UnaryExpression = _UnaryExpression; }

        UnaryExpressionNotPlusMinus1(IToken leftIToken, IToken rightIToken,
                                     AstToken _NOT,
                                     Ast _UnaryExpression)
            :super(leftIToken, rightIToken)

        {
            this._NOT = _NOT;
            (_NOT as Ast).setParent(this);
            this._UnaryExpression = _UnaryExpression;
            (_UnaryExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _NOT)  list.add(_NOT);
            if(null != _UnaryExpression)  list.add(_UnaryExpression);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitUnaryExpressionNotPlusMinus1(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitUnaryExpressionNotPlusMinus1(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitUnaryExpressionNotPlusMinus1(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitUnaryExpressionNotPlusMinus1(this, o); }
    }

/**
 *<b>
*<li>Rule 394:  CastExpression ::= ( PrimitiveType Dimsopt ) UnaryExpression
 *</b>
 */
class CastExpression0 extends Ast implements ICastExpression
    {
         late AstToken _LPAREN;
         late Ast _PrimitiveType;
         late Ast? _Dimsopt;
         late AstToken _RPAREN;
         late Ast _UnaryExpression;

         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
         Ast getPrimitiveType(){ return _PrimitiveType; }
         void setPrimitiveType(Ast _PrimitiveType){ this._PrimitiveType = _PrimitiveType; }
        /**
         * The value returned by <b>getDimsopt</b> may be <b>null</b>
         */
         Ast ?  getDimsopt(){ return _Dimsopt; }
         void setDimsopt(Ast _Dimsopt){ this._Dimsopt = _Dimsopt; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
         Ast getUnaryExpression(){ return _UnaryExpression; }
         void setUnaryExpression(Ast _UnaryExpression){ this._UnaryExpression = _UnaryExpression; }

        CastExpression0(IToken leftIToken, IToken rightIToken,
                        AstToken _LPAREN,
                        Ast _PrimitiveType,
                        Ast? _Dimsopt,
                        AstToken _RPAREN,
                        Ast _UnaryExpression)
            :super(leftIToken, rightIToken)

        {
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._PrimitiveType = _PrimitiveType;
            (_PrimitiveType as Ast).setParent(this);
            this._Dimsopt = _Dimsopt;
            if (null != _Dimsopt) (_Dimsopt as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._UnaryExpression = _UnaryExpression;
            (_UnaryExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _PrimitiveType)  list.add(_PrimitiveType);
            if(null != _Dimsopt)  list.add(_Dimsopt);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _UnaryExpression)  list.add(_UnaryExpression);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitCastExpression0(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitCastExpression0(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitCastExpression0(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitCastExpression0(this, o); }
    }

/**
 *<b>
*<li>Rule 395:  CastExpression ::= ( ReferenceType ) UnaryExpressionNotPlusMinus
 *</b>
 */
class CastExpression1 extends Ast implements ICastExpression
    {
         late AstToken _LPAREN;
         late Ast _ReferenceType;
         late AstToken _RPAREN;
         late Ast _UnaryExpressionNotPlusMinus;

         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
         Ast getReferenceType(){ return _ReferenceType; }
         void setReferenceType(Ast _ReferenceType){ this._ReferenceType = _ReferenceType; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
         Ast getUnaryExpressionNotPlusMinus(){ return _UnaryExpressionNotPlusMinus; }
         void setUnaryExpressionNotPlusMinus(Ast _UnaryExpressionNotPlusMinus){ this._UnaryExpressionNotPlusMinus = _UnaryExpressionNotPlusMinus; }

        CastExpression1(IToken leftIToken, IToken rightIToken,
                        AstToken _LPAREN,
                        Ast _ReferenceType,
                        AstToken _RPAREN,
                        Ast _UnaryExpressionNotPlusMinus)
            :super(leftIToken, rightIToken)

        {
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._ReferenceType = _ReferenceType;
            (_ReferenceType as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._UnaryExpressionNotPlusMinus = _UnaryExpressionNotPlusMinus;
            (_UnaryExpressionNotPlusMinus as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _ReferenceType)  list.add(_ReferenceType);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _UnaryExpressionNotPlusMinus)  list.add(_UnaryExpressionNotPlusMinus);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitCastExpression1(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitCastExpression1(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitCastExpression1(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitCastExpression1(this, o); }
    }

/**
 *<b>
*<li>Rule 397:  MultiplicativeExpression ::= MultiplicativeExpression * UnaryExpression
 *</b>
 */
class MultiplicativeExpression0 extends Ast implements IMultiplicativeExpression
    {
         late Ast _MultiplicativeExpression;
         late AstToken _MULTIPLY;
         late Ast _UnaryExpression;

         Ast getMultiplicativeExpression(){ return _MultiplicativeExpression; }
         void setMultiplicativeExpression(Ast _MultiplicativeExpression){ this._MultiplicativeExpression = _MultiplicativeExpression; }
         AstToken getMULTIPLY(){ return _MULTIPLY; }
         void setMULTIPLY(AstToken _MULTIPLY){ this._MULTIPLY = _MULTIPLY; }
         Ast getUnaryExpression(){ return _UnaryExpression; }
         void setUnaryExpression(Ast _UnaryExpression){ this._UnaryExpression = _UnaryExpression; }

        MultiplicativeExpression0(IToken leftIToken, IToken rightIToken,
                                  Ast _MultiplicativeExpression,
                                  AstToken _MULTIPLY,
                                  Ast _UnaryExpression)
            :super(leftIToken, rightIToken)

        {
            this._MultiplicativeExpression = _MultiplicativeExpression;
            (_MultiplicativeExpression as Ast).setParent(this);
            this._MULTIPLY = _MULTIPLY;
            (_MULTIPLY as Ast).setParent(this);
            this._UnaryExpression = _UnaryExpression;
            (_UnaryExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _MultiplicativeExpression)  list.add(_MultiplicativeExpression);
            if(null != _MULTIPLY)  list.add(_MULTIPLY);
            if(null != _UnaryExpression)  list.add(_UnaryExpression);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitMultiplicativeExpression0(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitMultiplicativeExpression0(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitMultiplicativeExpression0(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitMultiplicativeExpression0(this, o); }
    }

/**
 *<b>
*<li>Rule 398:  MultiplicativeExpression ::= MultiplicativeExpression / UnaryExpression
 *</b>
 */
class MultiplicativeExpression1 extends Ast implements IMultiplicativeExpression
    {
         late Ast _MultiplicativeExpression;
         late AstToken _DIVIDE;
         late Ast _UnaryExpression;

         Ast getMultiplicativeExpression(){ return _MultiplicativeExpression; }
         void setMultiplicativeExpression(Ast _MultiplicativeExpression){ this._MultiplicativeExpression = _MultiplicativeExpression; }
         AstToken getDIVIDE(){ return _DIVIDE; }
         void setDIVIDE(AstToken _DIVIDE){ this._DIVIDE = _DIVIDE; }
         Ast getUnaryExpression(){ return _UnaryExpression; }
         void setUnaryExpression(Ast _UnaryExpression){ this._UnaryExpression = _UnaryExpression; }

        MultiplicativeExpression1(IToken leftIToken, IToken rightIToken,
                                  Ast _MultiplicativeExpression,
                                  AstToken _DIVIDE,
                                  Ast _UnaryExpression)
            :super(leftIToken, rightIToken)

        {
            this._MultiplicativeExpression = _MultiplicativeExpression;
            (_MultiplicativeExpression as Ast).setParent(this);
            this._DIVIDE = _DIVIDE;
            (_DIVIDE as Ast).setParent(this);
            this._UnaryExpression = _UnaryExpression;
            (_UnaryExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _MultiplicativeExpression)  list.add(_MultiplicativeExpression);
            if(null != _DIVIDE)  list.add(_DIVIDE);
            if(null != _UnaryExpression)  list.add(_UnaryExpression);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitMultiplicativeExpression1(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitMultiplicativeExpression1(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitMultiplicativeExpression1(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitMultiplicativeExpression1(this, o); }
    }

/**
 *<b>
*<li>Rule 399:  MultiplicativeExpression ::= MultiplicativeExpression % UnaryExpression
 *</b>
 */
class MultiplicativeExpression2 extends Ast implements IMultiplicativeExpression
    {
         late Ast _MultiplicativeExpression;
         late AstToken _REMAINDER;
         late Ast _UnaryExpression;

         Ast getMultiplicativeExpression(){ return _MultiplicativeExpression; }
         void setMultiplicativeExpression(Ast _MultiplicativeExpression){ this._MultiplicativeExpression = _MultiplicativeExpression; }
         AstToken getREMAINDER(){ return _REMAINDER; }
         void setREMAINDER(AstToken _REMAINDER){ this._REMAINDER = _REMAINDER; }
         Ast getUnaryExpression(){ return _UnaryExpression; }
         void setUnaryExpression(Ast _UnaryExpression){ this._UnaryExpression = _UnaryExpression; }

        MultiplicativeExpression2(IToken leftIToken, IToken rightIToken,
                                  Ast _MultiplicativeExpression,
                                  AstToken _REMAINDER,
                                  Ast _UnaryExpression)
            :super(leftIToken, rightIToken)

        {
            this._MultiplicativeExpression = _MultiplicativeExpression;
            (_MultiplicativeExpression as Ast).setParent(this);
            this._REMAINDER = _REMAINDER;
            (_REMAINDER as Ast).setParent(this);
            this._UnaryExpression = _UnaryExpression;
            (_UnaryExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _MultiplicativeExpression)  list.add(_MultiplicativeExpression);
            if(null != _REMAINDER)  list.add(_REMAINDER);
            if(null != _UnaryExpression)  list.add(_UnaryExpression);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitMultiplicativeExpression2(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitMultiplicativeExpression2(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitMultiplicativeExpression2(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitMultiplicativeExpression2(this, o); }
    }

/**
 *<b>
*<li>Rule 401:  AdditiveExpression ::= AdditiveExpression + MultiplicativeExpression
 *</b>
 */
class AdditiveExpression0 extends Ast implements IAdditiveExpression
    {
         late Ast _AdditiveExpression;
         late AstToken _PLUS;
         late Ast _MultiplicativeExpression;

         Ast getAdditiveExpression(){ return _AdditiveExpression; }
         void setAdditiveExpression(Ast _AdditiveExpression){ this._AdditiveExpression = _AdditiveExpression; }
         AstToken getPLUS(){ return _PLUS; }
         void setPLUS(AstToken _PLUS){ this._PLUS = _PLUS; }
         Ast getMultiplicativeExpression(){ return _MultiplicativeExpression; }
         void setMultiplicativeExpression(Ast _MultiplicativeExpression){ this._MultiplicativeExpression = _MultiplicativeExpression; }

        AdditiveExpression0(IToken leftIToken, IToken rightIToken,
                            Ast _AdditiveExpression,
                            AstToken _PLUS,
                            Ast _MultiplicativeExpression)
            :super(leftIToken, rightIToken)

        {
            this._AdditiveExpression = _AdditiveExpression;
            (_AdditiveExpression as Ast).setParent(this);
            this._PLUS = _PLUS;
            (_PLUS as Ast).setParent(this);
            this._MultiplicativeExpression = _MultiplicativeExpression;
            (_MultiplicativeExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _AdditiveExpression)  list.add(_AdditiveExpression);
            if(null != _PLUS)  list.add(_PLUS);
            if(null != _MultiplicativeExpression)  list.add(_MultiplicativeExpression);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitAdditiveExpression0(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitAdditiveExpression0(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitAdditiveExpression0(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitAdditiveExpression0(this, o); }
    }

/**
 *<b>
*<li>Rule 402:  AdditiveExpression ::= AdditiveExpression - MultiplicativeExpression
 *</b>
 */
class AdditiveExpression1 extends Ast implements IAdditiveExpression
    {
         late Ast _AdditiveExpression;
         late AstToken _MINUS;
         late Ast _MultiplicativeExpression;

         Ast getAdditiveExpression(){ return _AdditiveExpression; }
         void setAdditiveExpression(Ast _AdditiveExpression){ this._AdditiveExpression = _AdditiveExpression; }
         AstToken getMINUS(){ return _MINUS; }
         void setMINUS(AstToken _MINUS){ this._MINUS = _MINUS; }
         Ast getMultiplicativeExpression(){ return _MultiplicativeExpression; }
         void setMultiplicativeExpression(Ast _MultiplicativeExpression){ this._MultiplicativeExpression = _MultiplicativeExpression; }

        AdditiveExpression1(IToken leftIToken, IToken rightIToken,
                            Ast _AdditiveExpression,
                            AstToken _MINUS,
                            Ast _MultiplicativeExpression)
            :super(leftIToken, rightIToken)

        {
            this._AdditiveExpression = _AdditiveExpression;
            (_AdditiveExpression as Ast).setParent(this);
            this._MINUS = _MINUS;
            (_MINUS as Ast).setParent(this);
            this._MultiplicativeExpression = _MultiplicativeExpression;
            (_MultiplicativeExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _AdditiveExpression)  list.add(_AdditiveExpression);
            if(null != _MINUS)  list.add(_MINUS);
            if(null != _MultiplicativeExpression)  list.add(_MultiplicativeExpression);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitAdditiveExpression1(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitAdditiveExpression1(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitAdditiveExpression1(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitAdditiveExpression1(this, o); }
    }

/**
 *<b>
*<li>Rule 404:  ShiftExpression ::= ShiftExpression << AdditiveExpression
 *</b>
 */
class ShiftExpression0 extends Ast implements IShiftExpression
    {
         late Ast _ShiftExpression;
         late AstToken _LEFT_SHIFT;
         late Ast _AdditiveExpression;

         Ast getShiftExpression(){ return _ShiftExpression; }
         void setShiftExpression(Ast _ShiftExpression){ this._ShiftExpression = _ShiftExpression; }
         AstToken getLEFT_SHIFT(){ return _LEFT_SHIFT; }
         void setLEFT_SHIFT(AstToken _LEFT_SHIFT){ this._LEFT_SHIFT = _LEFT_SHIFT; }
         Ast getAdditiveExpression(){ return _AdditiveExpression; }
         void setAdditiveExpression(Ast _AdditiveExpression){ this._AdditiveExpression = _AdditiveExpression; }

        ShiftExpression0(IToken leftIToken, IToken rightIToken,
                         Ast _ShiftExpression,
                         AstToken _LEFT_SHIFT,
                         Ast _AdditiveExpression)
            :super(leftIToken, rightIToken)

        {
            this._ShiftExpression = _ShiftExpression;
            (_ShiftExpression as Ast).setParent(this);
            this._LEFT_SHIFT = _LEFT_SHIFT;
            (_LEFT_SHIFT as Ast).setParent(this);
            this._AdditiveExpression = _AdditiveExpression;
            (_AdditiveExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ShiftExpression)  list.add(_ShiftExpression);
            if(null != _LEFT_SHIFT)  list.add(_LEFT_SHIFT);
            if(null != _AdditiveExpression)  list.add(_AdditiveExpression);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitShiftExpression0(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitShiftExpression0(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitShiftExpression0(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitShiftExpression0(this, o); }
    }

/**
 *<b>
*<li>Rule 405:  ShiftExpression ::= ShiftExpression > > AdditiveExpression
 *</b>
 */
class ShiftExpression1 extends Ast implements IShiftExpression
    {
         late Ast _ShiftExpression;
         late AstToken _GREATER;
         late AstToken _GREATER3;
         late Ast _AdditiveExpression;

         Ast getShiftExpression(){ return _ShiftExpression; }
         void setShiftExpression(Ast _ShiftExpression){ this._ShiftExpression = _ShiftExpression; }
         AstToken getGREATER(){ return _GREATER; }
         void setGREATER(AstToken _GREATER){ this._GREATER = _GREATER; }
         AstToken getGREATER3(){ return _GREATER3; }
         void setGREATER3(AstToken _GREATER3){ this._GREATER3 = _GREATER3; }
         Ast getAdditiveExpression(){ return _AdditiveExpression; }
         void setAdditiveExpression(Ast _AdditiveExpression){ this._AdditiveExpression = _AdditiveExpression; }

        ShiftExpression1(IToken leftIToken, IToken rightIToken,
                         Ast _ShiftExpression,
                         AstToken _GREATER,
                         AstToken _GREATER3,
                         Ast _AdditiveExpression)
            :super(leftIToken, rightIToken)

        {
            this._ShiftExpression = _ShiftExpression;
            (_ShiftExpression as Ast).setParent(this);
            this._GREATER = _GREATER;
            (_GREATER as Ast).setParent(this);
            this._GREATER3 = _GREATER3;
            (_GREATER3 as Ast).setParent(this);
            this._AdditiveExpression = _AdditiveExpression;
            (_AdditiveExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ShiftExpression)  list.add(_ShiftExpression);
            if(null != _GREATER)  list.add(_GREATER);
            if(null != _GREATER3)  list.add(_GREATER3);
            if(null != _AdditiveExpression)  list.add(_AdditiveExpression);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitShiftExpression1(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitShiftExpression1(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitShiftExpression1(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitShiftExpression1(this, o); }
    }

/**
 *<b>
*<li>Rule 406:  ShiftExpression ::= ShiftExpression > > > AdditiveExpression
 *</b>
 */
class ShiftExpression2 extends Ast implements IShiftExpression
    {
         late Ast _ShiftExpression;
         late AstToken _GREATER;
         late AstToken _GREATER3;
         late AstToken _GREATER4;
         late Ast _AdditiveExpression;

         Ast getShiftExpression(){ return _ShiftExpression; }
         void setShiftExpression(Ast _ShiftExpression){ this._ShiftExpression = _ShiftExpression; }
         AstToken getGREATER(){ return _GREATER; }
         void setGREATER(AstToken _GREATER){ this._GREATER = _GREATER; }
         AstToken getGREATER3(){ return _GREATER3; }
         void setGREATER3(AstToken _GREATER3){ this._GREATER3 = _GREATER3; }
         AstToken getGREATER4(){ return _GREATER4; }
         void setGREATER4(AstToken _GREATER4){ this._GREATER4 = _GREATER4; }
         Ast getAdditiveExpression(){ return _AdditiveExpression; }
         void setAdditiveExpression(Ast _AdditiveExpression){ this._AdditiveExpression = _AdditiveExpression; }

        ShiftExpression2(IToken leftIToken, IToken rightIToken,
                         Ast _ShiftExpression,
                         AstToken _GREATER,
                         AstToken _GREATER3,
                         AstToken _GREATER4,
                         Ast _AdditiveExpression)
            :super(leftIToken, rightIToken)

        {
            this._ShiftExpression = _ShiftExpression;
            (_ShiftExpression as Ast).setParent(this);
            this._GREATER = _GREATER;
            (_GREATER as Ast).setParent(this);
            this._GREATER3 = _GREATER3;
            (_GREATER3 as Ast).setParent(this);
            this._GREATER4 = _GREATER4;
            (_GREATER4 as Ast).setParent(this);
            this._AdditiveExpression = _AdditiveExpression;
            (_AdditiveExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ShiftExpression)  list.add(_ShiftExpression);
            if(null != _GREATER)  list.add(_GREATER);
            if(null != _GREATER3)  list.add(_GREATER3);
            if(null != _GREATER4)  list.add(_GREATER4);
            if(null != _AdditiveExpression)  list.add(_AdditiveExpression);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitShiftExpression2(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitShiftExpression2(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitShiftExpression2(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitShiftExpression2(this, o); }
    }

/**
 *<b>
*<li>Rule 408:  RelationalExpression ::= RelationalExpression < ShiftExpression
 *</b>
 */
class RelationalExpression0 extends Ast implements IRelationalExpression
    {
         late Ast _RelationalExpression;
         late AstToken _LESS;
         late Ast _ShiftExpression;

         Ast getRelationalExpression(){ return _RelationalExpression; }
         void setRelationalExpression(Ast _RelationalExpression){ this._RelationalExpression = _RelationalExpression; }
         AstToken getLESS(){ return _LESS; }
         void setLESS(AstToken _LESS){ this._LESS = _LESS; }
         Ast getShiftExpression(){ return _ShiftExpression; }
         void setShiftExpression(Ast _ShiftExpression){ this._ShiftExpression = _ShiftExpression; }

        RelationalExpression0(IToken leftIToken, IToken rightIToken,
                              Ast _RelationalExpression,
                              AstToken _LESS,
                              Ast _ShiftExpression)
            :super(leftIToken, rightIToken)

        {
            this._RelationalExpression = _RelationalExpression;
            (_RelationalExpression as Ast).setParent(this);
            this._LESS = _LESS;
            (_LESS as Ast).setParent(this);
            this._ShiftExpression = _ShiftExpression;
            (_ShiftExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _RelationalExpression)  list.add(_RelationalExpression);
            if(null != _LESS)  list.add(_LESS);
            if(null != _ShiftExpression)  list.add(_ShiftExpression);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitRelationalExpression0(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitRelationalExpression0(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitRelationalExpression0(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitRelationalExpression0(this, o); }
    }

/**
 *<b>
*<li>Rule 409:  RelationalExpression ::= RelationalExpression > ShiftExpression
 *</b>
 */
class RelationalExpression1 extends Ast implements IRelationalExpression
    {
         late Ast _RelationalExpression;
         late AstToken _GREATER;
         late Ast _ShiftExpression;

         Ast getRelationalExpression(){ return _RelationalExpression; }
         void setRelationalExpression(Ast _RelationalExpression){ this._RelationalExpression = _RelationalExpression; }
         AstToken getGREATER(){ return _GREATER; }
         void setGREATER(AstToken _GREATER){ this._GREATER = _GREATER; }
         Ast getShiftExpression(){ return _ShiftExpression; }
         void setShiftExpression(Ast _ShiftExpression){ this._ShiftExpression = _ShiftExpression; }

        RelationalExpression1(IToken leftIToken, IToken rightIToken,
                              Ast _RelationalExpression,
                              AstToken _GREATER,
                              Ast _ShiftExpression)
            :super(leftIToken, rightIToken)

        {
            this._RelationalExpression = _RelationalExpression;
            (_RelationalExpression as Ast).setParent(this);
            this._GREATER = _GREATER;
            (_GREATER as Ast).setParent(this);
            this._ShiftExpression = _ShiftExpression;
            (_ShiftExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _RelationalExpression)  list.add(_RelationalExpression);
            if(null != _GREATER)  list.add(_GREATER);
            if(null != _ShiftExpression)  list.add(_ShiftExpression);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitRelationalExpression1(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitRelationalExpression1(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitRelationalExpression1(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitRelationalExpression1(this, o); }
    }

/**
 *<b>
*<li>Rule 410:  RelationalExpression ::= RelationalExpression <= ShiftExpression
 *</b>
 */
class RelationalExpression2 extends Ast implements IRelationalExpression
    {
         late Ast _RelationalExpression;
         late AstToken _LESS_EQUAL;
         late Ast _ShiftExpression;

         Ast getRelationalExpression(){ return _RelationalExpression; }
         void setRelationalExpression(Ast _RelationalExpression){ this._RelationalExpression = _RelationalExpression; }
         AstToken getLESS_EQUAL(){ return _LESS_EQUAL; }
         void setLESS_EQUAL(AstToken _LESS_EQUAL){ this._LESS_EQUAL = _LESS_EQUAL; }
         Ast getShiftExpression(){ return _ShiftExpression; }
         void setShiftExpression(Ast _ShiftExpression){ this._ShiftExpression = _ShiftExpression; }

        RelationalExpression2(IToken leftIToken, IToken rightIToken,
                              Ast _RelationalExpression,
                              AstToken _LESS_EQUAL,
                              Ast _ShiftExpression)
            :super(leftIToken, rightIToken)

        {
            this._RelationalExpression = _RelationalExpression;
            (_RelationalExpression as Ast).setParent(this);
            this._LESS_EQUAL = _LESS_EQUAL;
            (_LESS_EQUAL as Ast).setParent(this);
            this._ShiftExpression = _ShiftExpression;
            (_ShiftExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _RelationalExpression)  list.add(_RelationalExpression);
            if(null != _LESS_EQUAL)  list.add(_LESS_EQUAL);
            if(null != _ShiftExpression)  list.add(_ShiftExpression);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitRelationalExpression2(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitRelationalExpression2(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitRelationalExpression2(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitRelationalExpression2(this, o); }
    }

/**
 *<b>
*<li>Rule 411:  RelationalExpression ::= RelationalExpression > = ShiftExpression
 *</b>
 */
class RelationalExpression3 extends Ast implements IRelationalExpression
    {
         late Ast _RelationalExpression;
         late AstToken _GREATER;
         late AstToken _EQUAL;
         late Ast _ShiftExpression;

         Ast getRelationalExpression(){ return _RelationalExpression; }
         void setRelationalExpression(Ast _RelationalExpression){ this._RelationalExpression = _RelationalExpression; }
         AstToken getGREATER(){ return _GREATER; }
         void setGREATER(AstToken _GREATER){ this._GREATER = _GREATER; }
         AstToken getEQUAL(){ return _EQUAL; }
         void setEQUAL(AstToken _EQUAL){ this._EQUAL = _EQUAL; }
         Ast getShiftExpression(){ return _ShiftExpression; }
         void setShiftExpression(Ast _ShiftExpression){ this._ShiftExpression = _ShiftExpression; }

        RelationalExpression3(IToken leftIToken, IToken rightIToken,
                              Ast _RelationalExpression,
                              AstToken _GREATER,
                              AstToken _EQUAL,
                              Ast _ShiftExpression)
            :super(leftIToken, rightIToken)

        {
            this._RelationalExpression = _RelationalExpression;
            (_RelationalExpression as Ast).setParent(this);
            this._GREATER = _GREATER;
            (_GREATER as Ast).setParent(this);
            this._EQUAL = _EQUAL;
            (_EQUAL as Ast).setParent(this);
            this._ShiftExpression = _ShiftExpression;
            (_ShiftExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _RelationalExpression)  list.add(_RelationalExpression);
            if(null != _GREATER)  list.add(_GREATER);
            if(null != _EQUAL)  list.add(_EQUAL);
            if(null != _ShiftExpression)  list.add(_ShiftExpression);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitRelationalExpression3(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitRelationalExpression3(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitRelationalExpression3(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitRelationalExpression3(this, o); }
    }

/**
 *<b>
*<li>Rule 412:  RelationalExpression ::= RelationalExpression instanceof ReferenceType
 *</b>
 */
class RelationalExpression4 extends Ast implements IRelationalExpression
    {
         late Ast _RelationalExpression;
         late AstToken _instanceof;
         late Ast _ReferenceType;

         Ast getRelationalExpression(){ return _RelationalExpression; }
         void setRelationalExpression(Ast _RelationalExpression){ this._RelationalExpression = _RelationalExpression; }
         AstToken getinstanceof(){ return _instanceof; }
         void setinstanceof(AstToken _instanceof){ this._instanceof = _instanceof; }
         Ast getReferenceType(){ return _ReferenceType; }
         void setReferenceType(Ast _ReferenceType){ this._ReferenceType = _ReferenceType; }

        RelationalExpression4(IToken leftIToken, IToken rightIToken,
                              Ast _RelationalExpression,
                              AstToken _instanceof,
                              Ast _ReferenceType)
            :super(leftIToken, rightIToken)

        {
            this._RelationalExpression = _RelationalExpression;
            (_RelationalExpression as Ast).setParent(this);
            this._instanceof = _instanceof;
            (_instanceof as Ast).setParent(this);
            this._ReferenceType = _ReferenceType;
            (_ReferenceType as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _RelationalExpression)  list.add(_RelationalExpression);
            if(null != _instanceof)  list.add(_instanceof);
            if(null != _ReferenceType)  list.add(_ReferenceType);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitRelationalExpression4(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitRelationalExpression4(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitRelationalExpression4(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitRelationalExpression4(this, o); }
    }

/**
 *<b>
*<li>Rule 414:  EqualityExpression ::= EqualityExpression == RelationalExpression
 *</b>
 */
class EqualityExpression0 extends Ast implements IEqualityExpression
    {
         late Ast _EqualityExpression;
         late AstToken _EQUAL_EQUAL;
         late Ast _RelationalExpression;

         Ast getEqualityExpression(){ return _EqualityExpression; }
         void setEqualityExpression(Ast _EqualityExpression){ this._EqualityExpression = _EqualityExpression; }
         AstToken getEQUAL_EQUAL(){ return _EQUAL_EQUAL; }
         void setEQUAL_EQUAL(AstToken _EQUAL_EQUAL){ this._EQUAL_EQUAL = _EQUAL_EQUAL; }
         Ast getRelationalExpression(){ return _RelationalExpression; }
         void setRelationalExpression(Ast _RelationalExpression){ this._RelationalExpression = _RelationalExpression; }

        EqualityExpression0(IToken leftIToken, IToken rightIToken,
                            Ast _EqualityExpression,
                            AstToken _EQUAL_EQUAL,
                            Ast _RelationalExpression)
            :super(leftIToken, rightIToken)

        {
            this._EqualityExpression = _EqualityExpression;
            (_EqualityExpression as Ast).setParent(this);
            this._EQUAL_EQUAL = _EQUAL_EQUAL;
            (_EQUAL_EQUAL as Ast).setParent(this);
            this._RelationalExpression = _RelationalExpression;
            (_RelationalExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _EqualityExpression)  list.add(_EqualityExpression);
            if(null != _EQUAL_EQUAL)  list.add(_EQUAL_EQUAL);
            if(null != _RelationalExpression)  list.add(_RelationalExpression);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitEqualityExpression0(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitEqualityExpression0(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitEqualityExpression0(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitEqualityExpression0(this, o); }
    }

/**
 *<b>
*<li>Rule 415:  EqualityExpression ::= EqualityExpression != RelationalExpression
 *</b>
 */
class EqualityExpression1 extends Ast implements IEqualityExpression
    {
         late Ast _EqualityExpression;
         late AstToken _NOT_EQUAL;
         late Ast _RelationalExpression;

         Ast getEqualityExpression(){ return _EqualityExpression; }
         void setEqualityExpression(Ast _EqualityExpression){ this._EqualityExpression = _EqualityExpression; }
         AstToken getNOT_EQUAL(){ return _NOT_EQUAL; }
         void setNOT_EQUAL(AstToken _NOT_EQUAL){ this._NOT_EQUAL = _NOT_EQUAL; }
         Ast getRelationalExpression(){ return _RelationalExpression; }
         void setRelationalExpression(Ast _RelationalExpression){ this._RelationalExpression = _RelationalExpression; }

        EqualityExpression1(IToken leftIToken, IToken rightIToken,
                            Ast _EqualityExpression,
                            AstToken _NOT_EQUAL,
                            Ast _RelationalExpression)
            :super(leftIToken, rightIToken)

        {
            this._EqualityExpression = _EqualityExpression;
            (_EqualityExpression as Ast).setParent(this);
            this._NOT_EQUAL = _NOT_EQUAL;
            (_NOT_EQUAL as Ast).setParent(this);
            this._RelationalExpression = _RelationalExpression;
            (_RelationalExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _EqualityExpression)  list.add(_EqualityExpression);
            if(null != _NOT_EQUAL)  list.add(_NOT_EQUAL);
            if(null != _RelationalExpression)  list.add(_RelationalExpression);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitEqualityExpression1(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitEqualityExpression1(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitEqualityExpression1(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitEqualityExpression1(this, o); }
    }

/**
 *<b>
*<li>Rule 434:  AssignmentOperator ::= =
 *</b>
 */
class AssignmentOperator0 extends AstToken implements IAssignmentOperator
    {
         IToken getEQUAL(){ return leftIToken; }

    AssignmentOperator0(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitAssignmentOperator0(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitAssignmentOperator0(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitAssignmentOperator0(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitAssignmentOperator0(this, o); }
    }

/**
 *<b>
*<li>Rule 435:  AssignmentOperator ::= *=
 *</b>
 */
class AssignmentOperator1 extends AstToken implements IAssignmentOperator
    {
         IToken getMULTIPLY_EQUAL(){ return leftIToken; }

    AssignmentOperator1(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitAssignmentOperator1(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitAssignmentOperator1(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitAssignmentOperator1(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitAssignmentOperator1(this, o); }
    }

/**
 *<b>
*<li>Rule 436:  AssignmentOperator ::= /=
 *</b>
 */
class AssignmentOperator2 extends AstToken implements IAssignmentOperator
    {
         IToken getDIVIDE_EQUAL(){ return leftIToken; }

    AssignmentOperator2(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitAssignmentOperator2(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitAssignmentOperator2(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitAssignmentOperator2(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitAssignmentOperator2(this, o); }
    }

/**
 *<b>
*<li>Rule 437:  AssignmentOperator ::= %=
 *</b>
 */
class AssignmentOperator3 extends AstToken implements IAssignmentOperator
    {
         IToken getREMAINDER_EQUAL(){ return leftIToken; }

    AssignmentOperator3(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitAssignmentOperator3(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitAssignmentOperator3(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitAssignmentOperator3(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitAssignmentOperator3(this, o); }
    }

/**
 *<b>
*<li>Rule 438:  AssignmentOperator ::= +=
 *</b>
 */
class AssignmentOperator4 extends AstToken implements IAssignmentOperator
    {
         IToken getPLUS_EQUAL(){ return leftIToken; }

    AssignmentOperator4(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitAssignmentOperator4(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitAssignmentOperator4(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitAssignmentOperator4(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitAssignmentOperator4(this, o); }
    }

/**
 *<b>
*<li>Rule 439:  AssignmentOperator ::= -=
 *</b>
 */
class AssignmentOperator5 extends AstToken implements IAssignmentOperator
    {
         IToken getMINUS_EQUAL(){ return leftIToken; }

    AssignmentOperator5(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitAssignmentOperator5(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitAssignmentOperator5(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitAssignmentOperator5(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitAssignmentOperator5(this, o); }
    }

/**
 *<b>
*<li>Rule 440:  AssignmentOperator ::= <<=
 *</b>
 */
class AssignmentOperator6 extends AstToken implements IAssignmentOperator
    {
         IToken getLEFT_SHIFT_EQUAL(){ return leftIToken; }

    AssignmentOperator6(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitAssignmentOperator6(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitAssignmentOperator6(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitAssignmentOperator6(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitAssignmentOperator6(this, o); }
    }

/**
 *<b>
*<li>Rule 441:  AssignmentOperator ::= > > =
 *</b>
 */
class AssignmentOperator7 extends Ast implements IAssignmentOperator
    {
         late AstToken _GREATER;
         late AstToken _GREATER2;
         late AstToken _EQUAL;

         AstToken getGREATER(){ return _GREATER; }
         void setGREATER(AstToken _GREATER){ this._GREATER = _GREATER; }
         AstToken getGREATER2(){ return _GREATER2; }
         void setGREATER2(AstToken _GREATER2){ this._GREATER2 = _GREATER2; }
         AstToken getEQUAL(){ return _EQUAL; }
         void setEQUAL(AstToken _EQUAL){ this._EQUAL = _EQUAL; }

        AssignmentOperator7(IToken leftIToken, IToken rightIToken,
                            AstToken _GREATER,
                            AstToken _GREATER2,
                            AstToken _EQUAL)
            :super(leftIToken, rightIToken)

        {
            this._GREATER = _GREATER;
            (_GREATER as Ast).setParent(this);
            this._GREATER2 = _GREATER2;
            (_GREATER2 as Ast).setParent(this);
            this._EQUAL = _EQUAL;
            (_EQUAL as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _GREATER)  list.add(_GREATER);
            if(null != _GREATER2)  list.add(_GREATER2);
            if(null != _EQUAL)  list.add(_EQUAL);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitAssignmentOperator7(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitAssignmentOperator7(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitAssignmentOperator7(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitAssignmentOperator7(this, o); }
    }

/**
 *<b>
*<li>Rule 442:  AssignmentOperator ::= > > > =
 *</b>
 */
class AssignmentOperator8 extends Ast implements IAssignmentOperator
    {
         late AstToken _GREATER;
         late AstToken _GREATER2;
         late AstToken _GREATER3;
         late AstToken _EQUAL;

         AstToken getGREATER(){ return _GREATER; }
         void setGREATER(AstToken _GREATER){ this._GREATER = _GREATER; }
         AstToken getGREATER2(){ return _GREATER2; }
         void setGREATER2(AstToken _GREATER2){ this._GREATER2 = _GREATER2; }
         AstToken getGREATER3(){ return _GREATER3; }
         void setGREATER3(AstToken _GREATER3){ this._GREATER3 = _GREATER3; }
         AstToken getEQUAL(){ return _EQUAL; }
         void setEQUAL(AstToken _EQUAL){ this._EQUAL = _EQUAL; }

        AssignmentOperator8(IToken leftIToken, IToken rightIToken,
                            AstToken _GREATER,
                            AstToken _GREATER2,
                            AstToken _GREATER3,
                            AstToken _EQUAL)
            :super(leftIToken, rightIToken)

        {
            this._GREATER = _GREATER;
            (_GREATER as Ast).setParent(this);
            this._GREATER2 = _GREATER2;
            (_GREATER2 as Ast).setParent(this);
            this._GREATER3 = _GREATER3;
            (_GREATER3 as Ast).setParent(this);
            this._EQUAL = _EQUAL;
            (_EQUAL as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _GREATER)  list.add(_GREATER);
            if(null != _GREATER2)  list.add(_GREATER2);
            if(null != _GREATER3)  list.add(_GREATER3);
            if(null != _EQUAL)  list.add(_EQUAL);
            return list;
        }

          void acceptWithVisitor(Visitor v){ v.visitAssignmentOperator8(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitAssignmentOperator8(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitAssignmentOperator8(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitAssignmentOperator8(this, o); }
    }

/**
 *<b>
*<li>Rule 443:  AssignmentOperator ::= &=
 *</b>
 */
class AssignmentOperator9 extends AstToken implements IAssignmentOperator
    {
         IToken getAND_EQUAL(){ return leftIToken; }

    AssignmentOperator9(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitAssignmentOperator9(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitAssignmentOperator9(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitAssignmentOperator9(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitAssignmentOperator9(this, o); }
    }

/**
 *<b>
*<li>Rule 444:  AssignmentOperator ::= ^=
 *</b>
 */
class AssignmentOperator10 extends AstToken implements IAssignmentOperator
    {
         IToken getXOR_EQUAL(){ return leftIToken; }

    AssignmentOperator10(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitAssignmentOperator10(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitAssignmentOperator10(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitAssignmentOperator10(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitAssignmentOperator10(this, o); }
    }

/**
 *<b>
*<li>Rule 445:  AssignmentOperator ::= |=
 *</b>
 */
class AssignmentOperator11 extends AstToken implements IAssignmentOperator
    {
         IToken getOR_EQUAL(){ return leftIToken; }

    AssignmentOperator11(IToken token) :super(token){ initialize(); }

          void acceptWithVisitor(Visitor v){ v.visitAssignmentOperator11(this); }
         void acceptWithArg(ArgumentVisitor v, Object o){ v.visitAssignmentOperator11(this, o); }
         Object acceptWithResult(ResultVisitor v) { return v.visitAssignmentOperator11(this); }
          Object acceptWithResultArgument(ResultArgumentVisitor v, Object o)  { return v.visitAssignmentOperator11(this, o); }
    }

abstract class Visitor
    {
       void visitAstToken(AstToken n);
       void visitidentifier(identifier n);
       void visitPrimitiveType(PrimitiveType n);
       void visitClassType(ClassType n);
       void visitInterfaceType(InterfaceType n);
       void visitTypeName(TypeName n);
       void visitArrayType(ArrayType n);
       void visitTypeParameter(TypeParameter n);
       void visitTypeBound(TypeBound n);
       void visitAdditionalBoundList(AdditionalBoundList n);
       void visitAdditionalBound(AdditionalBound n);
       void visitTypeArguments(TypeArguments n);
       void visitActualTypeArgumentList(ActualTypeArgumentList n);
       void visitWildcard(Wildcard n);
       void visitPackageName(PackageName n);
       void visitExpressionName(ExpressionName n);
       void visitMethodName(MethodName n);
       void visitPackageOrTypeName(PackageOrTypeName n);
       void visitAmbiguousName(AmbiguousName n);
       void visitCompilationUnit(CompilationUnit n);
       void visitImportDeclarations(ImportDeclarations n);
       void visitTypeDeclarations(TypeDeclarations n);
       void visitPackageDeclaration(PackageDeclaration n);
       void visitSingleTypeImportDeclaration(SingleTypeImportDeclaration n);
       void visitTypeImportOnDemandDeclaration(TypeImportOnDemandDeclaration n);
       void visitSingleStaticImportDeclaration(SingleStaticImportDeclaration n);
       void visitStaticImportOnDemandDeclaration(StaticImportOnDemandDeclaration n);
       void visitTypeDeclaration(TypeDeclaration n);
       void visitNormalClassDeclaration(NormalClassDeclaration n);
       void visitClassModifiers(ClassModifiers n);
       void visitTypeParameters(TypeParameters n);
       void visitTypeParameterList(TypeParameterList n);
       void visitSuper(Super n);
       void visitInterfaces(Interfaces n);
       void visitInterfaceTypeList(InterfaceTypeList n);
       void visitClassBody(ClassBody n);
       void visitClassBodyDeclarations(ClassBodyDeclarations n);
       void visitClassMemberDeclaration(ClassMemberDeclaration n);
       void visitFieldDeclaration(FieldDeclaration n);
       void visitVariableDeclarators(VariableDeclarators n);
       void visitVariableDeclarator(VariableDeclarator n);
       void visitVariableDeclaratorId(VariableDeclaratorId n);
       void visitFieldModifiers(FieldModifiers n);
       void visitMethodDeclaration(MethodDeclaration n);
       void visitMethodHeader(MethodHeader n);
       void visitResultType(ResultType n);
       void visitFormalParameterList(FormalParameterList n);
       void visitFormalParameters(FormalParameters n);
       void visitFormalParameter(FormalParameter n);
       void visitVariableModifiers(VariableModifiers n);
       void visitVariableModifier(VariableModifier n);
       void visitLastFormalParameter(LastFormalParameter n);
       void visitMethodModifiers(MethodModifiers n);
       void visitThrows(Throws n);
       void visitExceptionTypeList(ExceptionTypeList n);
       void visitMethodBody(MethodBody n);
       void visitStaticInitializer(StaticInitializer n);
       void visitConstructorDeclaration(ConstructorDeclaration n);
       void visitConstructorDeclarator(ConstructorDeclarator n);
       void visitConstructorModifiers(ConstructorModifiers n);
       void visitConstructorBody(ConstructorBody n);
       void visitEnumDeclaration(EnumDeclaration n);
       void visitEnumBody(EnumBody n);
       void visitEnumConstants(EnumConstants n);
       void visitEnumConstant(EnumConstant n);
       void visitArguments(Arguments n);
       void visitEnumBodyDeclarations(EnumBodyDeclarations n);
       void visitNormalInterfaceDeclaration(NormalInterfaceDeclaration n);
       void visitInterfaceModifiers(InterfaceModifiers n);
       void visitInterfaceBody(InterfaceBody n);
       void visitInterfaceMemberDeclarations(InterfaceMemberDeclarations n);
       void visitInterfaceMemberDeclaration(InterfaceMemberDeclaration n);
       void visitConstantDeclaration(ConstantDeclaration n);
       void visitConstantModifiers(ConstantModifiers n);
       void visitAbstractMethodDeclaration(AbstractMethodDeclaration n);
       void visitAbstractMethodModifiers(AbstractMethodModifiers n);
       void visitAnnotationTypeDeclaration(AnnotationTypeDeclaration n);
       void visitAnnotationTypeBody(AnnotationTypeBody n);
       void visitAnnotationTypeElementDeclarations(AnnotationTypeElementDeclarations n);
       void visitDefaultValue(DefaultValue n);
       void visitAnnotations(Annotations n);
       void visitNormalAnnotation(NormalAnnotation n);
       void visitElementValuePairs(ElementValuePairs n);
       void visitElementValuePair(ElementValuePair n);
       void visitElementValueArrayInitializer(ElementValueArrayInitializer n);
       void visitElementValues(ElementValues n);
       void visitMarkerAnnotation(MarkerAnnotation n);
       void visitSingleElementAnnotation(SingleElementAnnotation n);
       void visitArrayInitializer(ArrayInitializer n);
       void visitVariableInitializers(VariableInitializers n);
       void visitBlock(Block n);
       void visitBlockStatements(BlockStatements n);
       void visitLocalVariableDeclarationStatement(LocalVariableDeclarationStatement n);
       void visitLocalVariableDeclaration(LocalVariableDeclaration n);
       void visitIfThenStatement(IfThenStatement n);
       void visitIfThenElseStatement(IfThenElseStatement n);
       void visitIfThenElseStatementNoShortIf(IfThenElseStatementNoShortIf n);
       void visitEmptyStatement(EmptyStatement n);
       void visitLabeledStatement(LabeledStatement n);
       void visitLabeledStatementNoShortIf(LabeledStatementNoShortIf n);
       void visitExpressionStatement(ExpressionStatement n);
       void visitSwitchStatement(SwitchStatement n);
       void visitSwitchBlock(SwitchBlock n);
       void visitSwitchBlockStatementGroups(SwitchBlockStatementGroups n);
       void visitSwitchBlockStatementGroup(SwitchBlockStatementGroup n);
       void visitSwitchLabels(SwitchLabels n);
       void visitWhileStatement(WhileStatement n);
       void visitWhileStatementNoShortIf(WhileStatementNoShortIf n);
       void visitDoStatement(DoStatement n);
       void visitBasicForStatement(BasicForStatement n);
       void visitForStatementNoShortIf(ForStatementNoShortIf n);
       void visitStatementExpressionList(StatementExpressionList n);
       void visitEnhancedForStatement(EnhancedForStatement n);
       void visitBreakStatement(BreakStatement n);
       void visitContinueStatement(ContinueStatement n);
       void visitReturnStatement(ReturnStatement n);
       void visitThrowStatement(ThrowStatement n);
       void visitSynchronizedStatement(SynchronizedStatement n);
       void visitCatches(Catches n);
       void visitCatchClause(CatchClause n);
       void visitFinally(Finally n);
       void visitArgumentList(ArgumentList n);
       void visitDimExprs(DimExprs n);
       void visitDimExpr(DimExpr n);
       void visitPostIncrementExpression(PostIncrementExpression n);
       void visitPostDecrementExpression(PostDecrementExpression n);
       void visitPreIncrementExpression(PreIncrementExpression n);
       void visitPreDecrementExpression(PreDecrementExpression n);
       void visitAndExpression(AndExpression n);
       void visitExclusiveOrExpression(ExclusiveOrExpression n);
       void visitInclusiveOrExpression(InclusiveOrExpression n);
       void visitConditionalAndExpression(ConditionalAndExpression n);
       void visitConditionalOrExpression(ConditionalOrExpression n);
       void visitConditionalExpression(ConditionalExpression n);
       void visitAssignment(Assignment n);
       void visitCommaopt(Commaopt n);
       void visitEllipsisopt(Ellipsisopt n);
       void visitLPGUserAction0(LPGUserAction0 n);
       void visitLPGUserAction1(LPGUserAction1 n);
       void visitLPGUserAction2(LPGUserAction2 n);
       void visitLPGUserAction3(LPGUserAction3 n);
       void visitLPGUserAction4(LPGUserAction4 n);
       void visitIntegralType0(IntegralType0 n);
       void visitIntegralType1(IntegralType1 n);
       void visitIntegralType2(IntegralType2 n);
       void visitIntegralType3(IntegralType3 n);
       void visitIntegralType4(IntegralType4 n);
       void visitFloatingPointType0(FloatingPointType0 n);
       void visitFloatingPointType1(FloatingPointType1 n);
       void visitWildcardBounds0(WildcardBounds0 n);
       void visitWildcardBounds1(WildcardBounds1 n);
       void visitClassModifier0(ClassModifier0 n);
       void visitClassModifier1(ClassModifier1 n);
       void visitClassModifier2(ClassModifier2 n);
       void visitClassModifier3(ClassModifier3 n);
       void visitClassModifier4(ClassModifier4 n);
       void visitClassModifier5(ClassModifier5 n);
       void visitClassModifier6(ClassModifier6 n);
       void visitFieldModifier0(FieldModifier0 n);
       void visitFieldModifier1(FieldModifier1 n);
       void visitFieldModifier2(FieldModifier2 n);
       void visitFieldModifier3(FieldModifier3 n);
       void visitFieldModifier4(FieldModifier4 n);
       void visitFieldModifier5(FieldModifier5 n);
       void visitFieldModifier6(FieldModifier6 n);
       void visitMethodDeclarator0(MethodDeclarator0 n);
       void visitMethodDeclarator1(MethodDeclarator1 n);
       void visitMethodModifier0(MethodModifier0 n);
       void visitMethodModifier1(MethodModifier1 n);
       void visitMethodModifier2(MethodModifier2 n);
       void visitMethodModifier3(MethodModifier3 n);
       void visitMethodModifier4(MethodModifier4 n);
       void visitMethodModifier5(MethodModifier5 n);
       void visitMethodModifier6(MethodModifier6 n);
       void visitMethodModifier7(MethodModifier7 n);
       void visitMethodModifier8(MethodModifier8 n);
       void visitConstructorModifier0(ConstructorModifier0 n);
       void visitConstructorModifier1(ConstructorModifier1 n);
       void visitConstructorModifier2(ConstructorModifier2 n);
       void visitExplicitConstructorInvocation0(ExplicitConstructorInvocation0 n);
       void visitExplicitConstructorInvocation1(ExplicitConstructorInvocation1 n);
       void visitExplicitConstructorInvocation2(ExplicitConstructorInvocation2 n);
       void visitInterfaceModifier0(InterfaceModifier0 n);
       void visitInterfaceModifier1(InterfaceModifier1 n);
       void visitInterfaceModifier2(InterfaceModifier2 n);
       void visitInterfaceModifier3(InterfaceModifier3 n);
       void visitInterfaceModifier4(InterfaceModifier4 n);
       void visitInterfaceModifier5(InterfaceModifier5 n);
       void visitExtendsInterfaces0(ExtendsInterfaces0 n);
       void visitExtendsInterfaces1(ExtendsInterfaces1 n);
       void visitConstantModifier0(ConstantModifier0 n);
       void visitConstantModifier1(ConstantModifier1 n);
       void visitConstantModifier2(ConstantModifier2 n);
       void visitAbstractMethodModifier0(AbstractMethodModifier0 n);
       void visitAbstractMethodModifier1(AbstractMethodModifier1 n);
       void visitAnnotationTypeElementDeclaration0(AnnotationTypeElementDeclaration0 n);
       void visitAnnotationTypeElementDeclaration1(AnnotationTypeElementDeclaration1 n);
       void visitAssertStatement0(AssertStatement0 n);
       void visitAssertStatement1(AssertStatement1 n);
       void visitSwitchLabel0(SwitchLabel0 n);
       void visitSwitchLabel1(SwitchLabel1 n);
       void visitSwitchLabel2(SwitchLabel2 n);
       void visitTryStatement0(TryStatement0 n);
       void visitTryStatement1(TryStatement1 n);
       void visitPrimaryNoNewArray0(PrimaryNoNewArray0 n);
       void visitPrimaryNoNewArray1(PrimaryNoNewArray1 n);
       void visitPrimaryNoNewArray2(PrimaryNoNewArray2 n);
       void visitPrimaryNoNewArray3(PrimaryNoNewArray3 n);
       void visitPrimaryNoNewArray4(PrimaryNoNewArray4 n);
       void visitLiteral0(Literal0 n);
       void visitLiteral1(Literal1 n);
       void visitLiteral2(Literal2 n);
       void visitLiteral3(Literal3 n);
       void visitLiteral4(Literal4 n);
       void visitLiteral5(Literal5 n);
       void visitLiteral6(Literal6 n);
       void visitBooleanLiteral0(BooleanLiteral0 n);
       void visitBooleanLiteral1(BooleanLiteral1 n);
       void visitClassInstanceCreationExpression0(ClassInstanceCreationExpression0 n);
       void visitClassInstanceCreationExpression1(ClassInstanceCreationExpression1 n);
       void visitArrayCreationExpression0(ArrayCreationExpression0 n);
       void visitArrayCreationExpression1(ArrayCreationExpression1 n);
       void visitArrayCreationExpression2(ArrayCreationExpression2 n);
       void visitArrayCreationExpression3(ArrayCreationExpression3 n);
       void visitDims0(Dims0 n);
       void visitDims1(Dims1 n);
       void visitFieldAccess0(FieldAccess0 n);
       void visitFieldAccess1(FieldAccess1 n);
       void visitFieldAccess2(FieldAccess2 n);
       void visitMethodInvocation0(MethodInvocation0 n);
       void visitMethodInvocation1(MethodInvocation1 n);
       void visitMethodInvocation2(MethodInvocation2 n);
       void visitMethodInvocation3(MethodInvocation3 n);
       void visitMethodInvocation4(MethodInvocation4 n);
       void visitArrayAccess0(ArrayAccess0 n);
       void visitArrayAccess1(ArrayAccess1 n);
       void visitUnaryExpression0(UnaryExpression0 n);
       void visitUnaryExpression1(UnaryExpression1 n);
       void visitUnaryExpressionNotPlusMinus0(UnaryExpressionNotPlusMinus0 n);
       void visitUnaryExpressionNotPlusMinus1(UnaryExpressionNotPlusMinus1 n);
       void visitCastExpression0(CastExpression0 n);
       void visitCastExpression1(CastExpression1 n);
       void visitMultiplicativeExpression0(MultiplicativeExpression0 n);
       void visitMultiplicativeExpression1(MultiplicativeExpression1 n);
       void visitMultiplicativeExpression2(MultiplicativeExpression2 n);
       void visitAdditiveExpression0(AdditiveExpression0 n);
       void visitAdditiveExpression1(AdditiveExpression1 n);
       void visitShiftExpression0(ShiftExpression0 n);
       void visitShiftExpression1(ShiftExpression1 n);
       void visitShiftExpression2(ShiftExpression2 n);
       void visitRelationalExpression0(RelationalExpression0 n);
       void visitRelationalExpression1(RelationalExpression1 n);
       void visitRelationalExpression2(RelationalExpression2 n);
       void visitRelationalExpression3(RelationalExpression3 n);
       void visitRelationalExpression4(RelationalExpression4 n);
       void visitEqualityExpression0(EqualityExpression0 n);
       void visitEqualityExpression1(EqualityExpression1 n);
       void visitAssignmentOperator0(AssignmentOperator0 n);
       void visitAssignmentOperator1(AssignmentOperator1 n);
       void visitAssignmentOperator2(AssignmentOperator2 n);
       void visitAssignmentOperator3(AssignmentOperator3 n);
       void visitAssignmentOperator4(AssignmentOperator4 n);
       void visitAssignmentOperator5(AssignmentOperator5 n);
       void visitAssignmentOperator6(AssignmentOperator6 n);
       void visitAssignmentOperator7(AssignmentOperator7 n);
       void visitAssignmentOperator8(AssignmentOperator8 n);
       void visitAssignmentOperator9(AssignmentOperator9 n);
       void visitAssignmentOperator10(AssignmentOperator10 n);
       void visitAssignmentOperator11(AssignmentOperator11 n);

       void visit(Ast n);
    }
abstract class ArgumentVisitor
    {
       void visitAstToken(AstToken n, Object o);
       void visitidentifier(identifier n, Object o);
       void visitPrimitiveType(PrimitiveType n, Object o);
       void visitClassType(ClassType n, Object o);
       void visitInterfaceType(InterfaceType n, Object o);
       void visitTypeName(TypeName n, Object o);
       void visitArrayType(ArrayType n, Object o);
       void visitTypeParameter(TypeParameter n, Object o);
       void visitTypeBound(TypeBound n, Object o);
       void visitAdditionalBoundList(AdditionalBoundList n, Object o);
       void visitAdditionalBound(AdditionalBound n, Object o);
       void visitTypeArguments(TypeArguments n, Object o);
       void visitActualTypeArgumentList(ActualTypeArgumentList n, Object o);
       void visitWildcard(Wildcard n, Object o);
       void visitPackageName(PackageName n, Object o);
       void visitExpressionName(ExpressionName n, Object o);
       void visitMethodName(MethodName n, Object o);
       void visitPackageOrTypeName(PackageOrTypeName n, Object o);
       void visitAmbiguousName(AmbiguousName n, Object o);
       void visitCompilationUnit(CompilationUnit n, Object o);
       void visitImportDeclarations(ImportDeclarations n, Object o);
       void visitTypeDeclarations(TypeDeclarations n, Object o);
       void visitPackageDeclaration(PackageDeclaration n, Object o);
       void visitSingleTypeImportDeclaration(SingleTypeImportDeclaration n, Object o);
       void visitTypeImportOnDemandDeclaration(TypeImportOnDemandDeclaration n, Object o);
       void visitSingleStaticImportDeclaration(SingleStaticImportDeclaration n, Object o);
       void visitStaticImportOnDemandDeclaration(StaticImportOnDemandDeclaration n, Object o);
       void visitTypeDeclaration(TypeDeclaration n, Object o);
       void visitNormalClassDeclaration(NormalClassDeclaration n, Object o);
       void visitClassModifiers(ClassModifiers n, Object o);
       void visitTypeParameters(TypeParameters n, Object o);
       void visitTypeParameterList(TypeParameterList n, Object o);
       void visitSuper(Super n, Object o);
       void visitInterfaces(Interfaces n, Object o);
       void visitInterfaceTypeList(InterfaceTypeList n, Object o);
       void visitClassBody(ClassBody n, Object o);
       void visitClassBodyDeclarations(ClassBodyDeclarations n, Object o);
       void visitClassMemberDeclaration(ClassMemberDeclaration n, Object o);
       void visitFieldDeclaration(FieldDeclaration n, Object o);
       void visitVariableDeclarators(VariableDeclarators n, Object o);
       void visitVariableDeclarator(VariableDeclarator n, Object o);
       void visitVariableDeclaratorId(VariableDeclaratorId n, Object o);
       void visitFieldModifiers(FieldModifiers n, Object o);
       void visitMethodDeclaration(MethodDeclaration n, Object o);
       void visitMethodHeader(MethodHeader n, Object o);
       void visitResultType(ResultType n, Object o);
       void visitFormalParameterList(FormalParameterList n, Object o);
       void visitFormalParameters(FormalParameters n, Object o);
       void visitFormalParameter(FormalParameter n, Object o);
       void visitVariableModifiers(VariableModifiers n, Object o);
       void visitVariableModifier(VariableModifier n, Object o);
       void visitLastFormalParameter(LastFormalParameter n, Object o);
       void visitMethodModifiers(MethodModifiers n, Object o);
       void visitThrows(Throws n, Object o);
       void visitExceptionTypeList(ExceptionTypeList n, Object o);
       void visitMethodBody(MethodBody n, Object o);
       void visitStaticInitializer(StaticInitializer n, Object o);
       void visitConstructorDeclaration(ConstructorDeclaration n, Object o);
       void visitConstructorDeclarator(ConstructorDeclarator n, Object o);
       void visitConstructorModifiers(ConstructorModifiers n, Object o);
       void visitConstructorBody(ConstructorBody n, Object o);
       void visitEnumDeclaration(EnumDeclaration n, Object o);
       void visitEnumBody(EnumBody n, Object o);
       void visitEnumConstants(EnumConstants n, Object o);
       void visitEnumConstant(EnumConstant n, Object o);
       void visitArguments(Arguments n, Object o);
       void visitEnumBodyDeclarations(EnumBodyDeclarations n, Object o);
       void visitNormalInterfaceDeclaration(NormalInterfaceDeclaration n, Object o);
       void visitInterfaceModifiers(InterfaceModifiers n, Object o);
       void visitInterfaceBody(InterfaceBody n, Object o);
       void visitInterfaceMemberDeclarations(InterfaceMemberDeclarations n, Object o);
       void visitInterfaceMemberDeclaration(InterfaceMemberDeclaration n, Object o);
       void visitConstantDeclaration(ConstantDeclaration n, Object o);
       void visitConstantModifiers(ConstantModifiers n, Object o);
       void visitAbstractMethodDeclaration(AbstractMethodDeclaration n, Object o);
       void visitAbstractMethodModifiers(AbstractMethodModifiers n, Object o);
       void visitAnnotationTypeDeclaration(AnnotationTypeDeclaration n, Object o);
       void visitAnnotationTypeBody(AnnotationTypeBody n, Object o);
       void visitAnnotationTypeElementDeclarations(AnnotationTypeElementDeclarations n, Object o);
       void visitDefaultValue(DefaultValue n, Object o);
       void visitAnnotations(Annotations n, Object o);
       void visitNormalAnnotation(NormalAnnotation n, Object o);
       void visitElementValuePairs(ElementValuePairs n, Object o);
       void visitElementValuePair(ElementValuePair n, Object o);
       void visitElementValueArrayInitializer(ElementValueArrayInitializer n, Object o);
       void visitElementValues(ElementValues n, Object o);
       void visitMarkerAnnotation(MarkerAnnotation n, Object o);
       void visitSingleElementAnnotation(SingleElementAnnotation n, Object o);
       void visitArrayInitializer(ArrayInitializer n, Object o);
       void visitVariableInitializers(VariableInitializers n, Object o);
       void visitBlock(Block n, Object o);
       void visitBlockStatements(BlockStatements n, Object o);
       void visitLocalVariableDeclarationStatement(LocalVariableDeclarationStatement n, Object o);
       void visitLocalVariableDeclaration(LocalVariableDeclaration n, Object o);
       void visitIfThenStatement(IfThenStatement n, Object o);
       void visitIfThenElseStatement(IfThenElseStatement n, Object o);
       void visitIfThenElseStatementNoShortIf(IfThenElseStatementNoShortIf n, Object o);
       void visitEmptyStatement(EmptyStatement n, Object o);
       void visitLabeledStatement(LabeledStatement n, Object o);
       void visitLabeledStatementNoShortIf(LabeledStatementNoShortIf n, Object o);
       void visitExpressionStatement(ExpressionStatement n, Object o);
       void visitSwitchStatement(SwitchStatement n, Object o);
       void visitSwitchBlock(SwitchBlock n, Object o);
       void visitSwitchBlockStatementGroups(SwitchBlockStatementGroups n, Object o);
       void visitSwitchBlockStatementGroup(SwitchBlockStatementGroup n, Object o);
       void visitSwitchLabels(SwitchLabels n, Object o);
       void visitWhileStatement(WhileStatement n, Object o);
       void visitWhileStatementNoShortIf(WhileStatementNoShortIf n, Object o);
       void visitDoStatement(DoStatement n, Object o);
       void visitBasicForStatement(BasicForStatement n, Object o);
       void visitForStatementNoShortIf(ForStatementNoShortIf n, Object o);
       void visitStatementExpressionList(StatementExpressionList n, Object o);
       void visitEnhancedForStatement(EnhancedForStatement n, Object o);
       void visitBreakStatement(BreakStatement n, Object o);
       void visitContinueStatement(ContinueStatement n, Object o);
       void visitReturnStatement(ReturnStatement n, Object o);
       void visitThrowStatement(ThrowStatement n, Object o);
       void visitSynchronizedStatement(SynchronizedStatement n, Object o);
       void visitCatches(Catches n, Object o);
       void visitCatchClause(CatchClause n, Object o);
       void visitFinally(Finally n, Object o);
       void visitArgumentList(ArgumentList n, Object o);
       void visitDimExprs(DimExprs n, Object o);
       void visitDimExpr(DimExpr n, Object o);
       void visitPostIncrementExpression(PostIncrementExpression n, Object o);
       void visitPostDecrementExpression(PostDecrementExpression n, Object o);
       void visitPreIncrementExpression(PreIncrementExpression n, Object o);
       void visitPreDecrementExpression(PreDecrementExpression n, Object o);
       void visitAndExpression(AndExpression n, Object o);
       void visitExclusiveOrExpression(ExclusiveOrExpression n, Object o);
       void visitInclusiveOrExpression(InclusiveOrExpression n, Object o);
       void visitConditionalAndExpression(ConditionalAndExpression n, Object o);
       void visitConditionalOrExpression(ConditionalOrExpression n, Object o);
       void visitConditionalExpression(ConditionalExpression n, Object o);
       void visitAssignment(Assignment n, Object o);
       void visitCommaopt(Commaopt n, Object o);
       void visitEllipsisopt(Ellipsisopt n, Object o);
       void visitLPGUserAction0(LPGUserAction0 n, Object o);
       void visitLPGUserAction1(LPGUserAction1 n, Object o);
       void visitLPGUserAction2(LPGUserAction2 n, Object o);
       void visitLPGUserAction3(LPGUserAction3 n, Object o);
       void visitLPGUserAction4(LPGUserAction4 n, Object o);
       void visitIntegralType0(IntegralType0 n, Object o);
       void visitIntegralType1(IntegralType1 n, Object o);
       void visitIntegralType2(IntegralType2 n, Object o);
       void visitIntegralType3(IntegralType3 n, Object o);
       void visitIntegralType4(IntegralType4 n, Object o);
       void visitFloatingPointType0(FloatingPointType0 n, Object o);
       void visitFloatingPointType1(FloatingPointType1 n, Object o);
       void visitWildcardBounds0(WildcardBounds0 n, Object o);
       void visitWildcardBounds1(WildcardBounds1 n, Object o);
       void visitClassModifier0(ClassModifier0 n, Object o);
       void visitClassModifier1(ClassModifier1 n, Object o);
       void visitClassModifier2(ClassModifier2 n, Object o);
       void visitClassModifier3(ClassModifier3 n, Object o);
       void visitClassModifier4(ClassModifier4 n, Object o);
       void visitClassModifier5(ClassModifier5 n, Object o);
       void visitClassModifier6(ClassModifier6 n, Object o);
       void visitFieldModifier0(FieldModifier0 n, Object o);
       void visitFieldModifier1(FieldModifier1 n, Object o);
       void visitFieldModifier2(FieldModifier2 n, Object o);
       void visitFieldModifier3(FieldModifier3 n, Object o);
       void visitFieldModifier4(FieldModifier4 n, Object o);
       void visitFieldModifier5(FieldModifier5 n, Object o);
       void visitFieldModifier6(FieldModifier6 n, Object o);
       void visitMethodDeclarator0(MethodDeclarator0 n, Object o);
       void visitMethodDeclarator1(MethodDeclarator1 n, Object o);
       void visitMethodModifier0(MethodModifier0 n, Object o);
       void visitMethodModifier1(MethodModifier1 n, Object o);
       void visitMethodModifier2(MethodModifier2 n, Object o);
       void visitMethodModifier3(MethodModifier3 n, Object o);
       void visitMethodModifier4(MethodModifier4 n, Object o);
       void visitMethodModifier5(MethodModifier5 n, Object o);
       void visitMethodModifier6(MethodModifier6 n, Object o);
       void visitMethodModifier7(MethodModifier7 n, Object o);
       void visitMethodModifier8(MethodModifier8 n, Object o);
       void visitConstructorModifier0(ConstructorModifier0 n, Object o);
       void visitConstructorModifier1(ConstructorModifier1 n, Object o);
       void visitConstructorModifier2(ConstructorModifier2 n, Object o);
       void visitExplicitConstructorInvocation0(ExplicitConstructorInvocation0 n, Object o);
       void visitExplicitConstructorInvocation1(ExplicitConstructorInvocation1 n, Object o);
       void visitExplicitConstructorInvocation2(ExplicitConstructorInvocation2 n, Object o);
       void visitInterfaceModifier0(InterfaceModifier0 n, Object o);
       void visitInterfaceModifier1(InterfaceModifier1 n, Object o);
       void visitInterfaceModifier2(InterfaceModifier2 n, Object o);
       void visitInterfaceModifier3(InterfaceModifier3 n, Object o);
       void visitInterfaceModifier4(InterfaceModifier4 n, Object o);
       void visitInterfaceModifier5(InterfaceModifier5 n, Object o);
       void visitExtendsInterfaces0(ExtendsInterfaces0 n, Object o);
       void visitExtendsInterfaces1(ExtendsInterfaces1 n, Object o);
       void visitConstantModifier0(ConstantModifier0 n, Object o);
       void visitConstantModifier1(ConstantModifier1 n, Object o);
       void visitConstantModifier2(ConstantModifier2 n, Object o);
       void visitAbstractMethodModifier0(AbstractMethodModifier0 n, Object o);
       void visitAbstractMethodModifier1(AbstractMethodModifier1 n, Object o);
       void visitAnnotationTypeElementDeclaration0(AnnotationTypeElementDeclaration0 n, Object o);
       void visitAnnotationTypeElementDeclaration1(AnnotationTypeElementDeclaration1 n, Object o);
       void visitAssertStatement0(AssertStatement0 n, Object o);
       void visitAssertStatement1(AssertStatement1 n, Object o);
       void visitSwitchLabel0(SwitchLabel0 n, Object o);
       void visitSwitchLabel1(SwitchLabel1 n, Object o);
       void visitSwitchLabel2(SwitchLabel2 n, Object o);
       void visitTryStatement0(TryStatement0 n, Object o);
       void visitTryStatement1(TryStatement1 n, Object o);
       void visitPrimaryNoNewArray0(PrimaryNoNewArray0 n, Object o);
       void visitPrimaryNoNewArray1(PrimaryNoNewArray1 n, Object o);
       void visitPrimaryNoNewArray2(PrimaryNoNewArray2 n, Object o);
       void visitPrimaryNoNewArray3(PrimaryNoNewArray3 n, Object o);
       void visitPrimaryNoNewArray4(PrimaryNoNewArray4 n, Object o);
       void visitLiteral0(Literal0 n, Object o);
       void visitLiteral1(Literal1 n, Object o);
       void visitLiteral2(Literal2 n, Object o);
       void visitLiteral3(Literal3 n, Object o);
       void visitLiteral4(Literal4 n, Object o);
       void visitLiteral5(Literal5 n, Object o);
       void visitLiteral6(Literal6 n, Object o);
       void visitBooleanLiteral0(BooleanLiteral0 n, Object o);
       void visitBooleanLiteral1(BooleanLiteral1 n, Object o);
       void visitClassInstanceCreationExpression0(ClassInstanceCreationExpression0 n, Object o);
       void visitClassInstanceCreationExpression1(ClassInstanceCreationExpression1 n, Object o);
       void visitArrayCreationExpression0(ArrayCreationExpression0 n, Object o);
       void visitArrayCreationExpression1(ArrayCreationExpression1 n, Object o);
       void visitArrayCreationExpression2(ArrayCreationExpression2 n, Object o);
       void visitArrayCreationExpression3(ArrayCreationExpression3 n, Object o);
       void visitDims0(Dims0 n, Object o);
       void visitDims1(Dims1 n, Object o);
       void visitFieldAccess0(FieldAccess0 n, Object o);
       void visitFieldAccess1(FieldAccess1 n, Object o);
       void visitFieldAccess2(FieldAccess2 n, Object o);
       void visitMethodInvocation0(MethodInvocation0 n, Object o);
       void visitMethodInvocation1(MethodInvocation1 n, Object o);
       void visitMethodInvocation2(MethodInvocation2 n, Object o);
       void visitMethodInvocation3(MethodInvocation3 n, Object o);
       void visitMethodInvocation4(MethodInvocation4 n, Object o);
       void visitArrayAccess0(ArrayAccess0 n, Object o);
       void visitArrayAccess1(ArrayAccess1 n, Object o);
       void visitUnaryExpression0(UnaryExpression0 n, Object o);
       void visitUnaryExpression1(UnaryExpression1 n, Object o);
       void visitUnaryExpressionNotPlusMinus0(UnaryExpressionNotPlusMinus0 n, Object o);
       void visitUnaryExpressionNotPlusMinus1(UnaryExpressionNotPlusMinus1 n, Object o);
       void visitCastExpression0(CastExpression0 n, Object o);
       void visitCastExpression1(CastExpression1 n, Object o);
       void visitMultiplicativeExpression0(MultiplicativeExpression0 n, Object o);
       void visitMultiplicativeExpression1(MultiplicativeExpression1 n, Object o);
       void visitMultiplicativeExpression2(MultiplicativeExpression2 n, Object o);
       void visitAdditiveExpression0(AdditiveExpression0 n, Object o);
       void visitAdditiveExpression1(AdditiveExpression1 n, Object o);
       void visitShiftExpression0(ShiftExpression0 n, Object o);
       void visitShiftExpression1(ShiftExpression1 n, Object o);
       void visitShiftExpression2(ShiftExpression2 n, Object o);
       void visitRelationalExpression0(RelationalExpression0 n, Object o);
       void visitRelationalExpression1(RelationalExpression1 n, Object o);
       void visitRelationalExpression2(RelationalExpression2 n, Object o);
       void visitRelationalExpression3(RelationalExpression3 n, Object o);
       void visitRelationalExpression4(RelationalExpression4 n, Object o);
       void visitEqualityExpression0(EqualityExpression0 n, Object o);
       void visitEqualityExpression1(EqualityExpression1 n, Object o);
       void visitAssignmentOperator0(AssignmentOperator0 n, Object o);
       void visitAssignmentOperator1(AssignmentOperator1 n, Object o);
       void visitAssignmentOperator2(AssignmentOperator2 n, Object o);
       void visitAssignmentOperator3(AssignmentOperator3 n, Object o);
       void visitAssignmentOperator4(AssignmentOperator4 n, Object o);
       void visitAssignmentOperator5(AssignmentOperator5 n, Object o);
       void visitAssignmentOperator6(AssignmentOperator6 n, Object o);
       void visitAssignmentOperator7(AssignmentOperator7 n, Object o);
       void visitAssignmentOperator8(AssignmentOperator8 n, Object o);
       void visitAssignmentOperator9(AssignmentOperator9 n, Object o);
       void visitAssignmentOperator10(AssignmentOperator10 n, Object o);
       void visitAssignmentOperator11(AssignmentOperator11 n, Object o);

       void visit(Ast n, Object o);
    }
abstract class ResultVisitor
    {
        Object visitAstToken(AstToken n);
        Object visitidentifier(identifier n);
        Object visitPrimitiveType(PrimitiveType n);
        Object visitClassType(ClassType n);
        Object visitInterfaceType(InterfaceType n);
        Object visitTypeName(TypeName n);
        Object visitArrayType(ArrayType n);
        Object visitTypeParameter(TypeParameter n);
        Object visitTypeBound(TypeBound n);
        Object visitAdditionalBoundList(AdditionalBoundList n);
        Object visitAdditionalBound(AdditionalBound n);
        Object visitTypeArguments(TypeArguments n);
        Object visitActualTypeArgumentList(ActualTypeArgumentList n);
        Object visitWildcard(Wildcard n);
        Object visitPackageName(PackageName n);
        Object visitExpressionName(ExpressionName n);
        Object visitMethodName(MethodName n);
        Object visitPackageOrTypeName(PackageOrTypeName n);
        Object visitAmbiguousName(AmbiguousName n);
        Object visitCompilationUnit(CompilationUnit n);
        Object visitImportDeclarations(ImportDeclarations n);
        Object visitTypeDeclarations(TypeDeclarations n);
        Object visitPackageDeclaration(PackageDeclaration n);
        Object visitSingleTypeImportDeclaration(SingleTypeImportDeclaration n);
        Object visitTypeImportOnDemandDeclaration(TypeImportOnDemandDeclaration n);
        Object visitSingleStaticImportDeclaration(SingleStaticImportDeclaration n);
        Object visitStaticImportOnDemandDeclaration(StaticImportOnDemandDeclaration n);
        Object visitTypeDeclaration(TypeDeclaration n);
        Object visitNormalClassDeclaration(NormalClassDeclaration n);
        Object visitClassModifiers(ClassModifiers n);
        Object visitTypeParameters(TypeParameters n);
        Object visitTypeParameterList(TypeParameterList n);
        Object visitSuper(Super n);
        Object visitInterfaces(Interfaces n);
        Object visitInterfaceTypeList(InterfaceTypeList n);
        Object visitClassBody(ClassBody n);
        Object visitClassBodyDeclarations(ClassBodyDeclarations n);
        Object visitClassMemberDeclaration(ClassMemberDeclaration n);
        Object visitFieldDeclaration(FieldDeclaration n);
        Object visitVariableDeclarators(VariableDeclarators n);
        Object visitVariableDeclarator(VariableDeclarator n);
        Object visitVariableDeclaratorId(VariableDeclaratorId n);
        Object visitFieldModifiers(FieldModifiers n);
        Object visitMethodDeclaration(MethodDeclaration n);
        Object visitMethodHeader(MethodHeader n);
        Object visitResultType(ResultType n);
        Object visitFormalParameterList(FormalParameterList n);
        Object visitFormalParameters(FormalParameters n);
        Object visitFormalParameter(FormalParameter n);
        Object visitVariableModifiers(VariableModifiers n);
        Object visitVariableModifier(VariableModifier n);
        Object visitLastFormalParameter(LastFormalParameter n);
        Object visitMethodModifiers(MethodModifiers n);
        Object visitThrows(Throws n);
        Object visitExceptionTypeList(ExceptionTypeList n);
        Object visitMethodBody(MethodBody n);
        Object visitStaticInitializer(StaticInitializer n);
        Object visitConstructorDeclaration(ConstructorDeclaration n);
        Object visitConstructorDeclarator(ConstructorDeclarator n);
        Object visitConstructorModifiers(ConstructorModifiers n);
        Object visitConstructorBody(ConstructorBody n);
        Object visitEnumDeclaration(EnumDeclaration n);
        Object visitEnumBody(EnumBody n);
        Object visitEnumConstants(EnumConstants n);
        Object visitEnumConstant(EnumConstant n);
        Object visitArguments(Arguments n);
        Object visitEnumBodyDeclarations(EnumBodyDeclarations n);
        Object visitNormalInterfaceDeclaration(NormalInterfaceDeclaration n);
        Object visitInterfaceModifiers(InterfaceModifiers n);
        Object visitInterfaceBody(InterfaceBody n);
        Object visitInterfaceMemberDeclarations(InterfaceMemberDeclarations n);
        Object visitInterfaceMemberDeclaration(InterfaceMemberDeclaration n);
        Object visitConstantDeclaration(ConstantDeclaration n);
        Object visitConstantModifiers(ConstantModifiers n);
        Object visitAbstractMethodDeclaration(AbstractMethodDeclaration n);
        Object visitAbstractMethodModifiers(AbstractMethodModifiers n);
        Object visitAnnotationTypeDeclaration(AnnotationTypeDeclaration n);
        Object visitAnnotationTypeBody(AnnotationTypeBody n);
        Object visitAnnotationTypeElementDeclarations(AnnotationTypeElementDeclarations n);
        Object visitDefaultValue(DefaultValue n);
        Object visitAnnotations(Annotations n);
        Object visitNormalAnnotation(NormalAnnotation n);
        Object visitElementValuePairs(ElementValuePairs n);
        Object visitElementValuePair(ElementValuePair n);
        Object visitElementValueArrayInitializer(ElementValueArrayInitializer n);
        Object visitElementValues(ElementValues n);
        Object visitMarkerAnnotation(MarkerAnnotation n);
        Object visitSingleElementAnnotation(SingleElementAnnotation n);
        Object visitArrayInitializer(ArrayInitializer n);
        Object visitVariableInitializers(VariableInitializers n);
        Object visitBlock(Block n);
        Object visitBlockStatements(BlockStatements n);
        Object visitLocalVariableDeclarationStatement(LocalVariableDeclarationStatement n);
        Object visitLocalVariableDeclaration(LocalVariableDeclaration n);
        Object visitIfThenStatement(IfThenStatement n);
        Object visitIfThenElseStatement(IfThenElseStatement n);
        Object visitIfThenElseStatementNoShortIf(IfThenElseStatementNoShortIf n);
        Object visitEmptyStatement(EmptyStatement n);
        Object visitLabeledStatement(LabeledStatement n);
        Object visitLabeledStatementNoShortIf(LabeledStatementNoShortIf n);
        Object visitExpressionStatement(ExpressionStatement n);
        Object visitSwitchStatement(SwitchStatement n);
        Object visitSwitchBlock(SwitchBlock n);
        Object visitSwitchBlockStatementGroups(SwitchBlockStatementGroups n);
        Object visitSwitchBlockStatementGroup(SwitchBlockStatementGroup n);
        Object visitSwitchLabels(SwitchLabels n);
        Object visitWhileStatement(WhileStatement n);
        Object visitWhileStatementNoShortIf(WhileStatementNoShortIf n);
        Object visitDoStatement(DoStatement n);
        Object visitBasicForStatement(BasicForStatement n);
        Object visitForStatementNoShortIf(ForStatementNoShortIf n);
        Object visitStatementExpressionList(StatementExpressionList n);
        Object visitEnhancedForStatement(EnhancedForStatement n);
        Object visitBreakStatement(BreakStatement n);
        Object visitContinueStatement(ContinueStatement n);
        Object visitReturnStatement(ReturnStatement n);
        Object visitThrowStatement(ThrowStatement n);
        Object visitSynchronizedStatement(SynchronizedStatement n);
        Object visitCatches(Catches n);
        Object visitCatchClause(CatchClause n);
        Object visitFinally(Finally n);
        Object visitArgumentList(ArgumentList n);
        Object visitDimExprs(DimExprs n);
        Object visitDimExpr(DimExpr n);
        Object visitPostIncrementExpression(PostIncrementExpression n);
        Object visitPostDecrementExpression(PostDecrementExpression n);
        Object visitPreIncrementExpression(PreIncrementExpression n);
        Object visitPreDecrementExpression(PreDecrementExpression n);
        Object visitAndExpression(AndExpression n);
        Object visitExclusiveOrExpression(ExclusiveOrExpression n);
        Object visitInclusiveOrExpression(InclusiveOrExpression n);
        Object visitConditionalAndExpression(ConditionalAndExpression n);
        Object visitConditionalOrExpression(ConditionalOrExpression n);
        Object visitConditionalExpression(ConditionalExpression n);
        Object visitAssignment(Assignment n);
        Object visitCommaopt(Commaopt n);
        Object visitEllipsisopt(Ellipsisopt n);
        Object visitLPGUserAction0(LPGUserAction0 n);
        Object visitLPGUserAction1(LPGUserAction1 n);
        Object visitLPGUserAction2(LPGUserAction2 n);
        Object visitLPGUserAction3(LPGUserAction3 n);
        Object visitLPGUserAction4(LPGUserAction4 n);
        Object visitIntegralType0(IntegralType0 n);
        Object visitIntegralType1(IntegralType1 n);
        Object visitIntegralType2(IntegralType2 n);
        Object visitIntegralType3(IntegralType3 n);
        Object visitIntegralType4(IntegralType4 n);
        Object visitFloatingPointType0(FloatingPointType0 n);
        Object visitFloatingPointType1(FloatingPointType1 n);
        Object visitWildcardBounds0(WildcardBounds0 n);
        Object visitWildcardBounds1(WildcardBounds1 n);
        Object visitClassModifier0(ClassModifier0 n);
        Object visitClassModifier1(ClassModifier1 n);
        Object visitClassModifier2(ClassModifier2 n);
        Object visitClassModifier3(ClassModifier3 n);
        Object visitClassModifier4(ClassModifier4 n);
        Object visitClassModifier5(ClassModifier5 n);
        Object visitClassModifier6(ClassModifier6 n);
        Object visitFieldModifier0(FieldModifier0 n);
        Object visitFieldModifier1(FieldModifier1 n);
        Object visitFieldModifier2(FieldModifier2 n);
        Object visitFieldModifier3(FieldModifier3 n);
        Object visitFieldModifier4(FieldModifier4 n);
        Object visitFieldModifier5(FieldModifier5 n);
        Object visitFieldModifier6(FieldModifier6 n);
        Object visitMethodDeclarator0(MethodDeclarator0 n);
        Object visitMethodDeclarator1(MethodDeclarator1 n);
        Object visitMethodModifier0(MethodModifier0 n);
        Object visitMethodModifier1(MethodModifier1 n);
        Object visitMethodModifier2(MethodModifier2 n);
        Object visitMethodModifier3(MethodModifier3 n);
        Object visitMethodModifier4(MethodModifier4 n);
        Object visitMethodModifier5(MethodModifier5 n);
        Object visitMethodModifier6(MethodModifier6 n);
        Object visitMethodModifier7(MethodModifier7 n);
        Object visitMethodModifier8(MethodModifier8 n);
        Object visitConstructorModifier0(ConstructorModifier0 n);
        Object visitConstructorModifier1(ConstructorModifier1 n);
        Object visitConstructorModifier2(ConstructorModifier2 n);
        Object visitExplicitConstructorInvocation0(ExplicitConstructorInvocation0 n);
        Object visitExplicitConstructorInvocation1(ExplicitConstructorInvocation1 n);
        Object visitExplicitConstructorInvocation2(ExplicitConstructorInvocation2 n);
        Object visitInterfaceModifier0(InterfaceModifier0 n);
        Object visitInterfaceModifier1(InterfaceModifier1 n);
        Object visitInterfaceModifier2(InterfaceModifier2 n);
        Object visitInterfaceModifier3(InterfaceModifier3 n);
        Object visitInterfaceModifier4(InterfaceModifier4 n);
        Object visitInterfaceModifier5(InterfaceModifier5 n);
        Object visitExtendsInterfaces0(ExtendsInterfaces0 n);
        Object visitExtendsInterfaces1(ExtendsInterfaces1 n);
        Object visitConstantModifier0(ConstantModifier0 n);
        Object visitConstantModifier1(ConstantModifier1 n);
        Object visitConstantModifier2(ConstantModifier2 n);
        Object visitAbstractMethodModifier0(AbstractMethodModifier0 n);
        Object visitAbstractMethodModifier1(AbstractMethodModifier1 n);
        Object visitAnnotationTypeElementDeclaration0(AnnotationTypeElementDeclaration0 n);
        Object visitAnnotationTypeElementDeclaration1(AnnotationTypeElementDeclaration1 n);
        Object visitAssertStatement0(AssertStatement0 n);
        Object visitAssertStatement1(AssertStatement1 n);
        Object visitSwitchLabel0(SwitchLabel0 n);
        Object visitSwitchLabel1(SwitchLabel1 n);
        Object visitSwitchLabel2(SwitchLabel2 n);
        Object visitTryStatement0(TryStatement0 n);
        Object visitTryStatement1(TryStatement1 n);
        Object visitPrimaryNoNewArray0(PrimaryNoNewArray0 n);
        Object visitPrimaryNoNewArray1(PrimaryNoNewArray1 n);
        Object visitPrimaryNoNewArray2(PrimaryNoNewArray2 n);
        Object visitPrimaryNoNewArray3(PrimaryNoNewArray3 n);
        Object visitPrimaryNoNewArray4(PrimaryNoNewArray4 n);
        Object visitLiteral0(Literal0 n);
        Object visitLiteral1(Literal1 n);
        Object visitLiteral2(Literal2 n);
        Object visitLiteral3(Literal3 n);
        Object visitLiteral4(Literal4 n);
        Object visitLiteral5(Literal5 n);
        Object visitLiteral6(Literal6 n);
        Object visitBooleanLiteral0(BooleanLiteral0 n);
        Object visitBooleanLiteral1(BooleanLiteral1 n);
        Object visitClassInstanceCreationExpression0(ClassInstanceCreationExpression0 n);
        Object visitClassInstanceCreationExpression1(ClassInstanceCreationExpression1 n);
        Object visitArrayCreationExpression0(ArrayCreationExpression0 n);
        Object visitArrayCreationExpression1(ArrayCreationExpression1 n);
        Object visitArrayCreationExpression2(ArrayCreationExpression2 n);
        Object visitArrayCreationExpression3(ArrayCreationExpression3 n);
        Object visitDims0(Dims0 n);
        Object visitDims1(Dims1 n);
        Object visitFieldAccess0(FieldAccess0 n);
        Object visitFieldAccess1(FieldAccess1 n);
        Object visitFieldAccess2(FieldAccess2 n);
        Object visitMethodInvocation0(MethodInvocation0 n);
        Object visitMethodInvocation1(MethodInvocation1 n);
        Object visitMethodInvocation2(MethodInvocation2 n);
        Object visitMethodInvocation3(MethodInvocation3 n);
        Object visitMethodInvocation4(MethodInvocation4 n);
        Object visitArrayAccess0(ArrayAccess0 n);
        Object visitArrayAccess1(ArrayAccess1 n);
        Object visitUnaryExpression0(UnaryExpression0 n);
        Object visitUnaryExpression1(UnaryExpression1 n);
        Object visitUnaryExpressionNotPlusMinus0(UnaryExpressionNotPlusMinus0 n);
        Object visitUnaryExpressionNotPlusMinus1(UnaryExpressionNotPlusMinus1 n);
        Object visitCastExpression0(CastExpression0 n);
        Object visitCastExpression1(CastExpression1 n);
        Object visitMultiplicativeExpression0(MultiplicativeExpression0 n);
        Object visitMultiplicativeExpression1(MultiplicativeExpression1 n);
        Object visitMultiplicativeExpression2(MultiplicativeExpression2 n);
        Object visitAdditiveExpression0(AdditiveExpression0 n);
        Object visitAdditiveExpression1(AdditiveExpression1 n);
        Object visitShiftExpression0(ShiftExpression0 n);
        Object visitShiftExpression1(ShiftExpression1 n);
        Object visitShiftExpression2(ShiftExpression2 n);
        Object visitRelationalExpression0(RelationalExpression0 n);
        Object visitRelationalExpression1(RelationalExpression1 n);
        Object visitRelationalExpression2(RelationalExpression2 n);
        Object visitRelationalExpression3(RelationalExpression3 n);
        Object visitRelationalExpression4(RelationalExpression4 n);
        Object visitEqualityExpression0(EqualityExpression0 n);
        Object visitEqualityExpression1(EqualityExpression1 n);
        Object visitAssignmentOperator0(AssignmentOperator0 n);
        Object visitAssignmentOperator1(AssignmentOperator1 n);
        Object visitAssignmentOperator2(AssignmentOperator2 n);
        Object visitAssignmentOperator3(AssignmentOperator3 n);
        Object visitAssignmentOperator4(AssignmentOperator4 n);
        Object visitAssignmentOperator5(AssignmentOperator5 n);
        Object visitAssignmentOperator6(AssignmentOperator6 n);
        Object visitAssignmentOperator7(AssignmentOperator7 n);
        Object visitAssignmentOperator8(AssignmentOperator8 n);
        Object visitAssignmentOperator9(AssignmentOperator9 n);
        Object visitAssignmentOperator10(AssignmentOperator10 n);
        Object visitAssignmentOperator11(AssignmentOperator11 n);

       Object visit(Ast n);
    }
abstract class ResultArgumentVisitor
    {
       Object visitAstToken(AstToken n, Object o);
       Object visitidentifier(identifier n, Object o);
       Object visitPrimitiveType(PrimitiveType n, Object o);
       Object visitClassType(ClassType n, Object o);
       Object visitInterfaceType(InterfaceType n, Object o);
       Object visitTypeName(TypeName n, Object o);
       Object visitArrayType(ArrayType n, Object o);
       Object visitTypeParameter(TypeParameter n, Object o);
       Object visitTypeBound(TypeBound n, Object o);
       Object visitAdditionalBoundList(AdditionalBoundList n, Object o);
       Object visitAdditionalBound(AdditionalBound n, Object o);
       Object visitTypeArguments(TypeArguments n, Object o);
       Object visitActualTypeArgumentList(ActualTypeArgumentList n, Object o);
       Object visitWildcard(Wildcard n, Object o);
       Object visitPackageName(PackageName n, Object o);
       Object visitExpressionName(ExpressionName n, Object o);
       Object visitMethodName(MethodName n, Object o);
       Object visitPackageOrTypeName(PackageOrTypeName n, Object o);
       Object visitAmbiguousName(AmbiguousName n, Object o);
       Object visitCompilationUnit(CompilationUnit n, Object o);
       Object visitImportDeclarations(ImportDeclarations n, Object o);
       Object visitTypeDeclarations(TypeDeclarations n, Object o);
       Object visitPackageDeclaration(PackageDeclaration n, Object o);
       Object visitSingleTypeImportDeclaration(SingleTypeImportDeclaration n, Object o);
       Object visitTypeImportOnDemandDeclaration(TypeImportOnDemandDeclaration n, Object o);
       Object visitSingleStaticImportDeclaration(SingleStaticImportDeclaration n, Object o);
       Object visitStaticImportOnDemandDeclaration(StaticImportOnDemandDeclaration n, Object o);
       Object visitTypeDeclaration(TypeDeclaration n, Object o);
       Object visitNormalClassDeclaration(NormalClassDeclaration n, Object o);
       Object visitClassModifiers(ClassModifiers n, Object o);
       Object visitTypeParameters(TypeParameters n, Object o);
       Object visitTypeParameterList(TypeParameterList n, Object o);
       Object visitSuper(Super n, Object o);
       Object visitInterfaces(Interfaces n, Object o);
       Object visitInterfaceTypeList(InterfaceTypeList n, Object o);
       Object visitClassBody(ClassBody n, Object o);
       Object visitClassBodyDeclarations(ClassBodyDeclarations n, Object o);
       Object visitClassMemberDeclaration(ClassMemberDeclaration n, Object o);
       Object visitFieldDeclaration(FieldDeclaration n, Object o);
       Object visitVariableDeclarators(VariableDeclarators n, Object o);
       Object visitVariableDeclarator(VariableDeclarator n, Object o);
       Object visitVariableDeclaratorId(VariableDeclaratorId n, Object o);
       Object visitFieldModifiers(FieldModifiers n, Object o);
       Object visitMethodDeclaration(MethodDeclaration n, Object o);
       Object visitMethodHeader(MethodHeader n, Object o);
       Object visitResultType(ResultType n, Object o);
       Object visitFormalParameterList(FormalParameterList n, Object o);
       Object visitFormalParameters(FormalParameters n, Object o);
       Object visitFormalParameter(FormalParameter n, Object o);
       Object visitVariableModifiers(VariableModifiers n, Object o);
       Object visitVariableModifier(VariableModifier n, Object o);
       Object visitLastFormalParameter(LastFormalParameter n, Object o);
       Object visitMethodModifiers(MethodModifiers n, Object o);
       Object visitThrows(Throws n, Object o);
       Object visitExceptionTypeList(ExceptionTypeList n, Object o);
       Object visitMethodBody(MethodBody n, Object o);
       Object visitStaticInitializer(StaticInitializer n, Object o);
       Object visitConstructorDeclaration(ConstructorDeclaration n, Object o);
       Object visitConstructorDeclarator(ConstructorDeclarator n, Object o);
       Object visitConstructorModifiers(ConstructorModifiers n, Object o);
       Object visitConstructorBody(ConstructorBody n, Object o);
       Object visitEnumDeclaration(EnumDeclaration n, Object o);
       Object visitEnumBody(EnumBody n, Object o);
       Object visitEnumConstants(EnumConstants n, Object o);
       Object visitEnumConstant(EnumConstant n, Object o);
       Object visitArguments(Arguments n, Object o);
       Object visitEnumBodyDeclarations(EnumBodyDeclarations n, Object o);
       Object visitNormalInterfaceDeclaration(NormalInterfaceDeclaration n, Object o);
       Object visitInterfaceModifiers(InterfaceModifiers n, Object o);
       Object visitInterfaceBody(InterfaceBody n, Object o);
       Object visitInterfaceMemberDeclarations(InterfaceMemberDeclarations n, Object o);
       Object visitInterfaceMemberDeclaration(InterfaceMemberDeclaration n, Object o);
       Object visitConstantDeclaration(ConstantDeclaration n, Object o);
       Object visitConstantModifiers(ConstantModifiers n, Object o);
       Object visitAbstractMethodDeclaration(AbstractMethodDeclaration n, Object o);
       Object visitAbstractMethodModifiers(AbstractMethodModifiers n, Object o);
       Object visitAnnotationTypeDeclaration(AnnotationTypeDeclaration n, Object o);
       Object visitAnnotationTypeBody(AnnotationTypeBody n, Object o);
       Object visitAnnotationTypeElementDeclarations(AnnotationTypeElementDeclarations n, Object o);
       Object visitDefaultValue(DefaultValue n, Object o);
       Object visitAnnotations(Annotations n, Object o);
       Object visitNormalAnnotation(NormalAnnotation n, Object o);
       Object visitElementValuePairs(ElementValuePairs n, Object o);
       Object visitElementValuePair(ElementValuePair n, Object o);
       Object visitElementValueArrayInitializer(ElementValueArrayInitializer n, Object o);
       Object visitElementValues(ElementValues n, Object o);
       Object visitMarkerAnnotation(MarkerAnnotation n, Object o);
       Object visitSingleElementAnnotation(SingleElementAnnotation n, Object o);
       Object visitArrayInitializer(ArrayInitializer n, Object o);
       Object visitVariableInitializers(VariableInitializers n, Object o);
       Object visitBlock(Block n, Object o);
       Object visitBlockStatements(BlockStatements n, Object o);
       Object visitLocalVariableDeclarationStatement(LocalVariableDeclarationStatement n, Object o);
       Object visitLocalVariableDeclaration(LocalVariableDeclaration n, Object o);
       Object visitIfThenStatement(IfThenStatement n, Object o);
       Object visitIfThenElseStatement(IfThenElseStatement n, Object o);
       Object visitIfThenElseStatementNoShortIf(IfThenElseStatementNoShortIf n, Object o);
       Object visitEmptyStatement(EmptyStatement n, Object o);
       Object visitLabeledStatement(LabeledStatement n, Object o);
       Object visitLabeledStatementNoShortIf(LabeledStatementNoShortIf n, Object o);
       Object visitExpressionStatement(ExpressionStatement n, Object o);
       Object visitSwitchStatement(SwitchStatement n, Object o);
       Object visitSwitchBlock(SwitchBlock n, Object o);
       Object visitSwitchBlockStatementGroups(SwitchBlockStatementGroups n, Object o);
       Object visitSwitchBlockStatementGroup(SwitchBlockStatementGroup n, Object o);
       Object visitSwitchLabels(SwitchLabels n, Object o);
       Object visitWhileStatement(WhileStatement n, Object o);
       Object visitWhileStatementNoShortIf(WhileStatementNoShortIf n, Object o);
       Object visitDoStatement(DoStatement n, Object o);
       Object visitBasicForStatement(BasicForStatement n, Object o);
       Object visitForStatementNoShortIf(ForStatementNoShortIf n, Object o);
       Object visitStatementExpressionList(StatementExpressionList n, Object o);
       Object visitEnhancedForStatement(EnhancedForStatement n, Object o);
       Object visitBreakStatement(BreakStatement n, Object o);
       Object visitContinueStatement(ContinueStatement n, Object o);
       Object visitReturnStatement(ReturnStatement n, Object o);
       Object visitThrowStatement(ThrowStatement n, Object o);
       Object visitSynchronizedStatement(SynchronizedStatement n, Object o);
       Object visitCatches(Catches n, Object o);
       Object visitCatchClause(CatchClause n, Object o);
       Object visitFinally(Finally n, Object o);
       Object visitArgumentList(ArgumentList n, Object o);
       Object visitDimExprs(DimExprs n, Object o);
       Object visitDimExpr(DimExpr n, Object o);
       Object visitPostIncrementExpression(PostIncrementExpression n, Object o);
       Object visitPostDecrementExpression(PostDecrementExpression n, Object o);
       Object visitPreIncrementExpression(PreIncrementExpression n, Object o);
       Object visitPreDecrementExpression(PreDecrementExpression n, Object o);
       Object visitAndExpression(AndExpression n, Object o);
       Object visitExclusiveOrExpression(ExclusiveOrExpression n, Object o);
       Object visitInclusiveOrExpression(InclusiveOrExpression n, Object o);
       Object visitConditionalAndExpression(ConditionalAndExpression n, Object o);
       Object visitConditionalOrExpression(ConditionalOrExpression n, Object o);
       Object visitConditionalExpression(ConditionalExpression n, Object o);
       Object visitAssignment(Assignment n, Object o);
       Object visitCommaopt(Commaopt n, Object o);
       Object visitEllipsisopt(Ellipsisopt n, Object o);
       Object visitLPGUserAction0(LPGUserAction0 n, Object o);
       Object visitLPGUserAction1(LPGUserAction1 n, Object o);
       Object visitLPGUserAction2(LPGUserAction2 n, Object o);
       Object visitLPGUserAction3(LPGUserAction3 n, Object o);
       Object visitLPGUserAction4(LPGUserAction4 n, Object o);
       Object visitIntegralType0(IntegralType0 n, Object o);
       Object visitIntegralType1(IntegralType1 n, Object o);
       Object visitIntegralType2(IntegralType2 n, Object o);
       Object visitIntegralType3(IntegralType3 n, Object o);
       Object visitIntegralType4(IntegralType4 n, Object o);
       Object visitFloatingPointType0(FloatingPointType0 n, Object o);
       Object visitFloatingPointType1(FloatingPointType1 n, Object o);
       Object visitWildcardBounds0(WildcardBounds0 n, Object o);
       Object visitWildcardBounds1(WildcardBounds1 n, Object o);
       Object visitClassModifier0(ClassModifier0 n, Object o);
       Object visitClassModifier1(ClassModifier1 n, Object o);
       Object visitClassModifier2(ClassModifier2 n, Object o);
       Object visitClassModifier3(ClassModifier3 n, Object o);
       Object visitClassModifier4(ClassModifier4 n, Object o);
       Object visitClassModifier5(ClassModifier5 n, Object o);
       Object visitClassModifier6(ClassModifier6 n, Object o);
       Object visitFieldModifier0(FieldModifier0 n, Object o);
       Object visitFieldModifier1(FieldModifier1 n, Object o);
       Object visitFieldModifier2(FieldModifier2 n, Object o);
       Object visitFieldModifier3(FieldModifier3 n, Object o);
       Object visitFieldModifier4(FieldModifier4 n, Object o);
       Object visitFieldModifier5(FieldModifier5 n, Object o);
       Object visitFieldModifier6(FieldModifier6 n, Object o);
       Object visitMethodDeclarator0(MethodDeclarator0 n, Object o);
       Object visitMethodDeclarator1(MethodDeclarator1 n, Object o);
       Object visitMethodModifier0(MethodModifier0 n, Object o);
       Object visitMethodModifier1(MethodModifier1 n, Object o);
       Object visitMethodModifier2(MethodModifier2 n, Object o);
       Object visitMethodModifier3(MethodModifier3 n, Object o);
       Object visitMethodModifier4(MethodModifier4 n, Object o);
       Object visitMethodModifier5(MethodModifier5 n, Object o);
       Object visitMethodModifier6(MethodModifier6 n, Object o);
       Object visitMethodModifier7(MethodModifier7 n, Object o);
       Object visitMethodModifier8(MethodModifier8 n, Object o);
       Object visitConstructorModifier0(ConstructorModifier0 n, Object o);
       Object visitConstructorModifier1(ConstructorModifier1 n, Object o);
       Object visitConstructorModifier2(ConstructorModifier2 n, Object o);
       Object visitExplicitConstructorInvocation0(ExplicitConstructorInvocation0 n, Object o);
       Object visitExplicitConstructorInvocation1(ExplicitConstructorInvocation1 n, Object o);
       Object visitExplicitConstructorInvocation2(ExplicitConstructorInvocation2 n, Object o);
       Object visitInterfaceModifier0(InterfaceModifier0 n, Object o);
       Object visitInterfaceModifier1(InterfaceModifier1 n, Object o);
       Object visitInterfaceModifier2(InterfaceModifier2 n, Object o);
       Object visitInterfaceModifier3(InterfaceModifier3 n, Object o);
       Object visitInterfaceModifier4(InterfaceModifier4 n, Object o);
       Object visitInterfaceModifier5(InterfaceModifier5 n, Object o);
       Object visitExtendsInterfaces0(ExtendsInterfaces0 n, Object o);
       Object visitExtendsInterfaces1(ExtendsInterfaces1 n, Object o);
       Object visitConstantModifier0(ConstantModifier0 n, Object o);
       Object visitConstantModifier1(ConstantModifier1 n, Object o);
       Object visitConstantModifier2(ConstantModifier2 n, Object o);
       Object visitAbstractMethodModifier0(AbstractMethodModifier0 n, Object o);
       Object visitAbstractMethodModifier1(AbstractMethodModifier1 n, Object o);
       Object visitAnnotationTypeElementDeclaration0(AnnotationTypeElementDeclaration0 n, Object o);
       Object visitAnnotationTypeElementDeclaration1(AnnotationTypeElementDeclaration1 n, Object o);
       Object visitAssertStatement0(AssertStatement0 n, Object o);
       Object visitAssertStatement1(AssertStatement1 n, Object o);
       Object visitSwitchLabel0(SwitchLabel0 n, Object o);
       Object visitSwitchLabel1(SwitchLabel1 n, Object o);
       Object visitSwitchLabel2(SwitchLabel2 n, Object o);
       Object visitTryStatement0(TryStatement0 n, Object o);
       Object visitTryStatement1(TryStatement1 n, Object o);
       Object visitPrimaryNoNewArray0(PrimaryNoNewArray0 n, Object o);
       Object visitPrimaryNoNewArray1(PrimaryNoNewArray1 n, Object o);
       Object visitPrimaryNoNewArray2(PrimaryNoNewArray2 n, Object o);
       Object visitPrimaryNoNewArray3(PrimaryNoNewArray3 n, Object o);
       Object visitPrimaryNoNewArray4(PrimaryNoNewArray4 n, Object o);
       Object visitLiteral0(Literal0 n, Object o);
       Object visitLiteral1(Literal1 n, Object o);
       Object visitLiteral2(Literal2 n, Object o);
       Object visitLiteral3(Literal3 n, Object o);
       Object visitLiteral4(Literal4 n, Object o);
       Object visitLiteral5(Literal5 n, Object o);
       Object visitLiteral6(Literal6 n, Object o);
       Object visitBooleanLiteral0(BooleanLiteral0 n, Object o);
       Object visitBooleanLiteral1(BooleanLiteral1 n, Object o);
       Object visitClassInstanceCreationExpression0(ClassInstanceCreationExpression0 n, Object o);
       Object visitClassInstanceCreationExpression1(ClassInstanceCreationExpression1 n, Object o);
       Object visitArrayCreationExpression0(ArrayCreationExpression0 n, Object o);
       Object visitArrayCreationExpression1(ArrayCreationExpression1 n, Object o);
       Object visitArrayCreationExpression2(ArrayCreationExpression2 n, Object o);
       Object visitArrayCreationExpression3(ArrayCreationExpression3 n, Object o);
       Object visitDims0(Dims0 n, Object o);
       Object visitDims1(Dims1 n, Object o);
       Object visitFieldAccess0(FieldAccess0 n, Object o);
       Object visitFieldAccess1(FieldAccess1 n, Object o);
       Object visitFieldAccess2(FieldAccess2 n, Object o);
       Object visitMethodInvocation0(MethodInvocation0 n, Object o);
       Object visitMethodInvocation1(MethodInvocation1 n, Object o);
       Object visitMethodInvocation2(MethodInvocation2 n, Object o);
       Object visitMethodInvocation3(MethodInvocation3 n, Object o);
       Object visitMethodInvocation4(MethodInvocation4 n, Object o);
       Object visitArrayAccess0(ArrayAccess0 n, Object o);
       Object visitArrayAccess1(ArrayAccess1 n, Object o);
       Object visitUnaryExpression0(UnaryExpression0 n, Object o);
       Object visitUnaryExpression1(UnaryExpression1 n, Object o);
       Object visitUnaryExpressionNotPlusMinus0(UnaryExpressionNotPlusMinus0 n, Object o);
       Object visitUnaryExpressionNotPlusMinus1(UnaryExpressionNotPlusMinus1 n, Object o);
       Object visitCastExpression0(CastExpression0 n, Object o);
       Object visitCastExpression1(CastExpression1 n, Object o);
       Object visitMultiplicativeExpression0(MultiplicativeExpression0 n, Object o);
       Object visitMultiplicativeExpression1(MultiplicativeExpression1 n, Object o);
       Object visitMultiplicativeExpression2(MultiplicativeExpression2 n, Object o);
       Object visitAdditiveExpression0(AdditiveExpression0 n, Object o);
       Object visitAdditiveExpression1(AdditiveExpression1 n, Object o);
       Object visitShiftExpression0(ShiftExpression0 n, Object o);
       Object visitShiftExpression1(ShiftExpression1 n, Object o);
       Object visitShiftExpression2(ShiftExpression2 n, Object o);
       Object visitRelationalExpression0(RelationalExpression0 n, Object o);
       Object visitRelationalExpression1(RelationalExpression1 n, Object o);
       Object visitRelationalExpression2(RelationalExpression2 n, Object o);
       Object visitRelationalExpression3(RelationalExpression3 n, Object o);
       Object visitRelationalExpression4(RelationalExpression4 n, Object o);
       Object visitEqualityExpression0(EqualityExpression0 n, Object o);
       Object visitEqualityExpression1(EqualityExpression1 n, Object o);
       Object visitAssignmentOperator0(AssignmentOperator0 n, Object o);
       Object visitAssignmentOperator1(AssignmentOperator1 n, Object o);
       Object visitAssignmentOperator2(AssignmentOperator2 n, Object o);
       Object visitAssignmentOperator3(AssignmentOperator3 n, Object o);
       Object visitAssignmentOperator4(AssignmentOperator4 n, Object o);
       Object visitAssignmentOperator5(AssignmentOperator5 n, Object o);
       Object visitAssignmentOperator6(AssignmentOperator6 n, Object o);
       Object visitAssignmentOperator7(AssignmentOperator7 n, Object o);
       Object visitAssignmentOperator8(AssignmentOperator8 n, Object o);
       Object visitAssignmentOperator9(AssignmentOperator9 n, Object o);
       Object visitAssignmentOperator10(AssignmentOperator10 n, Object o);
       Object visitAssignmentOperator11(AssignmentOperator11 n, Object o);

       Object visit(Ast n, Object o);
    }
abstract class AbstractVisitor implements Visitor, ArgumentVisitor
    {
          void unimplementedVisitor(String s);

          void visitAstToken(AstToken n, [Object? o]) { unimplementedVisitor("visitAstToken(AstToken, Object)"); }

          void visitidentifier(identifier n, [Object? o]) { unimplementedVisitor("visitidentifier(identifier, Object)"); }

          void visitPrimitiveType(PrimitiveType n, [Object? o]) { unimplementedVisitor("visitPrimitiveType(PrimitiveType, Object)"); }

          void visitClassType(ClassType n, [Object? o]) { unimplementedVisitor("visitClassType(ClassType, Object)"); }

          void visitInterfaceType(InterfaceType n, [Object? o]) { unimplementedVisitor("visitInterfaceType(InterfaceType, Object)"); }

          void visitTypeName(TypeName n, [Object? o]) { unimplementedVisitor("visitTypeName(TypeName, Object)"); }

          void visitArrayType(ArrayType n, [Object? o]) { unimplementedVisitor("visitArrayType(ArrayType, Object)"); }

          void visitTypeParameter(TypeParameter n, [Object? o]) { unimplementedVisitor("visitTypeParameter(TypeParameter, Object)"); }

          void visitTypeBound(TypeBound n, [Object? o]) { unimplementedVisitor("visitTypeBound(TypeBound, Object)"); }

          void visitAdditionalBoundList(AdditionalBoundList n, [Object? o]) { unimplementedVisitor("visitAdditionalBoundList(AdditionalBoundList, Object)"); }

          void visitAdditionalBound(AdditionalBound n, [Object? o]) { unimplementedVisitor("visitAdditionalBound(AdditionalBound, Object)"); }

          void visitTypeArguments(TypeArguments n, [Object? o]) { unimplementedVisitor("visitTypeArguments(TypeArguments, Object)"); }

          void visitActualTypeArgumentList(ActualTypeArgumentList n, [Object? o]) { unimplementedVisitor("visitActualTypeArgumentList(ActualTypeArgumentList, Object)"); }

          void visitWildcard(Wildcard n, [Object? o]) { unimplementedVisitor("visitWildcard(Wildcard, Object)"); }

          void visitPackageName(PackageName n, [Object? o]) { unimplementedVisitor("visitPackageName(PackageName, Object)"); }

          void visitExpressionName(ExpressionName n, [Object? o]) { unimplementedVisitor("visitExpressionName(ExpressionName, Object)"); }

          void visitMethodName(MethodName n, [Object? o]) { unimplementedVisitor("visitMethodName(MethodName, Object)"); }

          void visitPackageOrTypeName(PackageOrTypeName n, [Object? o]) { unimplementedVisitor("visitPackageOrTypeName(PackageOrTypeName, Object)"); }

          void visitAmbiguousName(AmbiguousName n, [Object? o]) { unimplementedVisitor("visitAmbiguousName(AmbiguousName, Object)"); }

          void visitCompilationUnit(CompilationUnit n, [Object? o]) { unimplementedVisitor("visitCompilationUnit(CompilationUnit, Object)"); }

          void visitImportDeclarations(ImportDeclarations n, [Object? o]) { unimplementedVisitor("visitImportDeclarations(ImportDeclarations, Object)"); }

          void visitTypeDeclarations(TypeDeclarations n, [Object? o]) { unimplementedVisitor("visitTypeDeclarations(TypeDeclarations, Object)"); }

          void visitPackageDeclaration(PackageDeclaration n, [Object? o]) { unimplementedVisitor("visitPackageDeclaration(PackageDeclaration, Object)"); }

          void visitSingleTypeImportDeclaration(SingleTypeImportDeclaration n, [Object? o]) { unimplementedVisitor("visitSingleTypeImportDeclaration(SingleTypeImportDeclaration, Object)"); }

          void visitTypeImportOnDemandDeclaration(TypeImportOnDemandDeclaration n, [Object? o]) { unimplementedVisitor("visitTypeImportOnDemandDeclaration(TypeImportOnDemandDeclaration, Object)"); }

          void visitSingleStaticImportDeclaration(SingleStaticImportDeclaration n, [Object? o]) { unimplementedVisitor("visitSingleStaticImportDeclaration(SingleStaticImportDeclaration, Object)"); }

          void visitStaticImportOnDemandDeclaration(StaticImportOnDemandDeclaration n, [Object? o]) { unimplementedVisitor("visitStaticImportOnDemandDeclaration(StaticImportOnDemandDeclaration, Object)"); }

          void visitTypeDeclaration(TypeDeclaration n, [Object? o]) { unimplementedVisitor("visitTypeDeclaration(TypeDeclaration, Object)"); }

          void visitNormalClassDeclaration(NormalClassDeclaration n, [Object? o]) { unimplementedVisitor("visitNormalClassDeclaration(NormalClassDeclaration, Object)"); }

          void visitClassModifiers(ClassModifiers n, [Object? o]) { unimplementedVisitor("visitClassModifiers(ClassModifiers, Object)"); }

          void visitTypeParameters(TypeParameters n, [Object? o]) { unimplementedVisitor("visitTypeParameters(TypeParameters, Object)"); }

          void visitTypeParameterList(TypeParameterList n, [Object? o]) { unimplementedVisitor("visitTypeParameterList(TypeParameterList, Object)"); }

          void visitSuper(Super n, [Object? o]) { unimplementedVisitor("visitSuper(Super, Object)"); }

          void visitInterfaces(Interfaces n, [Object? o]) { unimplementedVisitor("visitInterfaces(Interfaces, Object)"); }

          void visitInterfaceTypeList(InterfaceTypeList n, [Object? o]) { unimplementedVisitor("visitInterfaceTypeList(InterfaceTypeList, Object)"); }

          void visitClassBody(ClassBody n, [Object? o]) { unimplementedVisitor("visitClassBody(ClassBody, Object)"); }

          void visitClassBodyDeclarations(ClassBodyDeclarations n, [Object? o]) { unimplementedVisitor("visitClassBodyDeclarations(ClassBodyDeclarations, Object)"); }

          void visitClassMemberDeclaration(ClassMemberDeclaration n, [Object? o]) { unimplementedVisitor("visitClassMemberDeclaration(ClassMemberDeclaration, Object)"); }

          void visitFieldDeclaration(FieldDeclaration n, [Object? o]) { unimplementedVisitor("visitFieldDeclaration(FieldDeclaration, Object)"); }

          void visitVariableDeclarators(VariableDeclarators n, [Object? o]) { unimplementedVisitor("visitVariableDeclarators(VariableDeclarators, Object)"); }

          void visitVariableDeclarator(VariableDeclarator n, [Object? o]) { unimplementedVisitor("visitVariableDeclarator(VariableDeclarator, Object)"); }

          void visitVariableDeclaratorId(VariableDeclaratorId n, [Object? o]) { unimplementedVisitor("visitVariableDeclaratorId(VariableDeclaratorId, Object)"); }

          void visitFieldModifiers(FieldModifiers n, [Object? o]) { unimplementedVisitor("visitFieldModifiers(FieldModifiers, Object)"); }

          void visitMethodDeclaration(MethodDeclaration n, [Object? o]) { unimplementedVisitor("visitMethodDeclaration(MethodDeclaration, Object)"); }

          void visitMethodHeader(MethodHeader n, [Object? o]) { unimplementedVisitor("visitMethodHeader(MethodHeader, Object)"); }

          void visitResultType(ResultType n, [Object? o]) { unimplementedVisitor("visitResultType(ResultType, Object)"); }

          void visitFormalParameterList(FormalParameterList n, [Object? o]) { unimplementedVisitor("visitFormalParameterList(FormalParameterList, Object)"); }

          void visitFormalParameters(FormalParameters n, [Object? o]) { unimplementedVisitor("visitFormalParameters(FormalParameters, Object)"); }

          void visitFormalParameter(FormalParameter n, [Object? o]) { unimplementedVisitor("visitFormalParameter(FormalParameter, Object)"); }

          void visitVariableModifiers(VariableModifiers n, [Object? o]) { unimplementedVisitor("visitVariableModifiers(VariableModifiers, Object)"); }

          void visitVariableModifier(VariableModifier n, [Object? o]) { unimplementedVisitor("visitVariableModifier(VariableModifier, Object)"); }

          void visitLastFormalParameter(LastFormalParameter n, [Object? o]) { unimplementedVisitor("visitLastFormalParameter(LastFormalParameter, Object)"); }

          void visitMethodModifiers(MethodModifiers n, [Object? o]) { unimplementedVisitor("visitMethodModifiers(MethodModifiers, Object)"); }

          void visitThrows(Throws n, [Object? o]) { unimplementedVisitor("visitThrows(Throws, Object)"); }

          void visitExceptionTypeList(ExceptionTypeList n, [Object? o]) { unimplementedVisitor("visitExceptionTypeList(ExceptionTypeList, Object)"); }

          void visitMethodBody(MethodBody n, [Object? o]) { unimplementedVisitor("visitMethodBody(MethodBody, Object)"); }

          void visitStaticInitializer(StaticInitializer n, [Object? o]) { unimplementedVisitor("visitStaticInitializer(StaticInitializer, Object)"); }

          void visitConstructorDeclaration(ConstructorDeclaration n, [Object? o]) { unimplementedVisitor("visitConstructorDeclaration(ConstructorDeclaration, Object)"); }

          void visitConstructorDeclarator(ConstructorDeclarator n, [Object? o]) { unimplementedVisitor("visitConstructorDeclarator(ConstructorDeclarator, Object)"); }

          void visitConstructorModifiers(ConstructorModifiers n, [Object? o]) { unimplementedVisitor("visitConstructorModifiers(ConstructorModifiers, Object)"); }

          void visitConstructorBody(ConstructorBody n, [Object? o]) { unimplementedVisitor("visitConstructorBody(ConstructorBody, Object)"); }

          void visitEnumDeclaration(EnumDeclaration n, [Object? o]) { unimplementedVisitor("visitEnumDeclaration(EnumDeclaration, Object)"); }

          void visitEnumBody(EnumBody n, [Object? o]) { unimplementedVisitor("visitEnumBody(EnumBody, Object)"); }

          void visitEnumConstants(EnumConstants n, [Object? o]) { unimplementedVisitor("visitEnumConstants(EnumConstants, Object)"); }

          void visitEnumConstant(EnumConstant n, [Object? o]) { unimplementedVisitor("visitEnumConstant(EnumConstant, Object)"); }

          void visitArguments(Arguments n, [Object? o]) { unimplementedVisitor("visitArguments(Arguments, Object)"); }

          void visitEnumBodyDeclarations(EnumBodyDeclarations n, [Object? o]) { unimplementedVisitor("visitEnumBodyDeclarations(EnumBodyDeclarations, Object)"); }

          void visitNormalInterfaceDeclaration(NormalInterfaceDeclaration n, [Object? o]) { unimplementedVisitor("visitNormalInterfaceDeclaration(NormalInterfaceDeclaration, Object)"); }

          void visitInterfaceModifiers(InterfaceModifiers n, [Object? o]) { unimplementedVisitor("visitInterfaceModifiers(InterfaceModifiers, Object)"); }

          void visitInterfaceBody(InterfaceBody n, [Object? o]) { unimplementedVisitor("visitInterfaceBody(InterfaceBody, Object)"); }

          void visitInterfaceMemberDeclarations(InterfaceMemberDeclarations n, [Object? o]) { unimplementedVisitor("visitInterfaceMemberDeclarations(InterfaceMemberDeclarations, Object)"); }

          void visitInterfaceMemberDeclaration(InterfaceMemberDeclaration n, [Object? o]) { unimplementedVisitor("visitInterfaceMemberDeclaration(InterfaceMemberDeclaration, Object)"); }

          void visitConstantDeclaration(ConstantDeclaration n, [Object? o]) { unimplementedVisitor("visitConstantDeclaration(ConstantDeclaration, Object)"); }

          void visitConstantModifiers(ConstantModifiers n, [Object? o]) { unimplementedVisitor("visitConstantModifiers(ConstantModifiers, Object)"); }

          void visitAbstractMethodDeclaration(AbstractMethodDeclaration n, [Object? o]) { unimplementedVisitor("visitAbstractMethodDeclaration(AbstractMethodDeclaration, Object)"); }

          void visitAbstractMethodModifiers(AbstractMethodModifiers n, [Object? o]) { unimplementedVisitor("visitAbstractMethodModifiers(AbstractMethodModifiers, Object)"); }

          void visitAnnotationTypeDeclaration(AnnotationTypeDeclaration n, [Object? o]) { unimplementedVisitor("visitAnnotationTypeDeclaration(AnnotationTypeDeclaration, Object)"); }

          void visitAnnotationTypeBody(AnnotationTypeBody n, [Object? o]) { unimplementedVisitor("visitAnnotationTypeBody(AnnotationTypeBody, Object)"); }

          void visitAnnotationTypeElementDeclarations(AnnotationTypeElementDeclarations n, [Object? o]) { unimplementedVisitor("visitAnnotationTypeElementDeclarations(AnnotationTypeElementDeclarations, Object)"); }

          void visitDefaultValue(DefaultValue n, [Object? o]) { unimplementedVisitor("visitDefaultValue(DefaultValue, Object)"); }

          void visitAnnotations(Annotations n, [Object? o]) { unimplementedVisitor("visitAnnotations(Annotations, Object)"); }

          void visitNormalAnnotation(NormalAnnotation n, [Object? o]) { unimplementedVisitor("visitNormalAnnotation(NormalAnnotation, Object)"); }

          void visitElementValuePairs(ElementValuePairs n, [Object? o]) { unimplementedVisitor("visitElementValuePairs(ElementValuePairs, Object)"); }

          void visitElementValuePair(ElementValuePair n, [Object? o]) { unimplementedVisitor("visitElementValuePair(ElementValuePair, Object)"); }

          void visitElementValueArrayInitializer(ElementValueArrayInitializer n, [Object? o]) { unimplementedVisitor("visitElementValueArrayInitializer(ElementValueArrayInitializer, Object)"); }

          void visitElementValues(ElementValues n, [Object? o]) { unimplementedVisitor("visitElementValues(ElementValues, Object)"); }

          void visitMarkerAnnotation(MarkerAnnotation n, [Object? o]) { unimplementedVisitor("visitMarkerAnnotation(MarkerAnnotation, Object)"); }

          void visitSingleElementAnnotation(SingleElementAnnotation n, [Object? o]) { unimplementedVisitor("visitSingleElementAnnotation(SingleElementAnnotation, Object)"); }

          void visitArrayInitializer(ArrayInitializer n, [Object? o]) { unimplementedVisitor("visitArrayInitializer(ArrayInitializer, Object)"); }

          void visitVariableInitializers(VariableInitializers n, [Object? o]) { unimplementedVisitor("visitVariableInitializers(VariableInitializers, Object)"); }

          void visitBlock(Block n, [Object? o]) { unimplementedVisitor("visitBlock(Block, Object)"); }

          void visitBlockStatements(BlockStatements n, [Object? o]) { unimplementedVisitor("visitBlockStatements(BlockStatements, Object)"); }

          void visitLocalVariableDeclarationStatement(LocalVariableDeclarationStatement n, [Object? o]) { unimplementedVisitor("visitLocalVariableDeclarationStatement(LocalVariableDeclarationStatement, Object)"); }

          void visitLocalVariableDeclaration(LocalVariableDeclaration n, [Object? o]) { unimplementedVisitor("visitLocalVariableDeclaration(LocalVariableDeclaration, Object)"); }

          void visitIfThenStatement(IfThenStatement n, [Object? o]) { unimplementedVisitor("visitIfThenStatement(IfThenStatement, Object)"); }

          void visitIfThenElseStatement(IfThenElseStatement n, [Object? o]) { unimplementedVisitor("visitIfThenElseStatement(IfThenElseStatement, Object)"); }

          void visitIfThenElseStatementNoShortIf(IfThenElseStatementNoShortIf n, [Object? o]) { unimplementedVisitor("visitIfThenElseStatementNoShortIf(IfThenElseStatementNoShortIf, Object)"); }

          void visitEmptyStatement(EmptyStatement n, [Object? o]) { unimplementedVisitor("visitEmptyStatement(EmptyStatement, Object)"); }

          void visitLabeledStatement(LabeledStatement n, [Object? o]) { unimplementedVisitor("visitLabeledStatement(LabeledStatement, Object)"); }

          void visitLabeledStatementNoShortIf(LabeledStatementNoShortIf n, [Object? o]) { unimplementedVisitor("visitLabeledStatementNoShortIf(LabeledStatementNoShortIf, Object)"); }

          void visitExpressionStatement(ExpressionStatement n, [Object? o]) { unimplementedVisitor("visitExpressionStatement(ExpressionStatement, Object)"); }

          void visitSwitchStatement(SwitchStatement n, [Object? o]) { unimplementedVisitor("visitSwitchStatement(SwitchStatement, Object)"); }

          void visitSwitchBlock(SwitchBlock n, [Object? o]) { unimplementedVisitor("visitSwitchBlock(SwitchBlock, Object)"); }

          void visitSwitchBlockStatementGroups(SwitchBlockStatementGroups n, [Object? o]) { unimplementedVisitor("visitSwitchBlockStatementGroups(SwitchBlockStatementGroups, Object)"); }

          void visitSwitchBlockStatementGroup(SwitchBlockStatementGroup n, [Object? o]) { unimplementedVisitor("visitSwitchBlockStatementGroup(SwitchBlockStatementGroup, Object)"); }

          void visitSwitchLabels(SwitchLabels n, [Object? o]) { unimplementedVisitor("visitSwitchLabels(SwitchLabels, Object)"); }

          void visitWhileStatement(WhileStatement n, [Object? o]) { unimplementedVisitor("visitWhileStatement(WhileStatement, Object)"); }

          void visitWhileStatementNoShortIf(WhileStatementNoShortIf n, [Object? o]) { unimplementedVisitor("visitWhileStatementNoShortIf(WhileStatementNoShortIf, Object)"); }

          void visitDoStatement(DoStatement n, [Object? o]) { unimplementedVisitor("visitDoStatement(DoStatement, Object)"); }

          void visitBasicForStatement(BasicForStatement n, [Object? o]) { unimplementedVisitor("visitBasicForStatement(BasicForStatement, Object)"); }

          void visitForStatementNoShortIf(ForStatementNoShortIf n, [Object? o]) { unimplementedVisitor("visitForStatementNoShortIf(ForStatementNoShortIf, Object)"); }

          void visitStatementExpressionList(StatementExpressionList n, [Object? o]) { unimplementedVisitor("visitStatementExpressionList(StatementExpressionList, Object)"); }

          void visitEnhancedForStatement(EnhancedForStatement n, [Object? o]) { unimplementedVisitor("visitEnhancedForStatement(EnhancedForStatement, Object)"); }

          void visitBreakStatement(BreakStatement n, [Object? o]) { unimplementedVisitor("visitBreakStatement(BreakStatement, Object)"); }

          void visitContinueStatement(ContinueStatement n, [Object? o]) { unimplementedVisitor("visitContinueStatement(ContinueStatement, Object)"); }

          void visitReturnStatement(ReturnStatement n, [Object? o]) { unimplementedVisitor("visitReturnStatement(ReturnStatement, Object)"); }

          void visitThrowStatement(ThrowStatement n, [Object? o]) { unimplementedVisitor("visitThrowStatement(ThrowStatement, Object)"); }

          void visitSynchronizedStatement(SynchronizedStatement n, [Object? o]) { unimplementedVisitor("visitSynchronizedStatement(SynchronizedStatement, Object)"); }

          void visitCatches(Catches n, [Object? o]) { unimplementedVisitor("visitCatches(Catches, Object)"); }

          void visitCatchClause(CatchClause n, [Object? o]) { unimplementedVisitor("visitCatchClause(CatchClause, Object)"); }

          void visitFinally(Finally n, [Object? o]) { unimplementedVisitor("visitFinally(Finally, Object)"); }

          void visitArgumentList(ArgumentList n, [Object? o]) { unimplementedVisitor("visitArgumentList(ArgumentList, Object)"); }

          void visitDimExprs(DimExprs n, [Object? o]) { unimplementedVisitor("visitDimExprs(DimExprs, Object)"); }

          void visitDimExpr(DimExpr n, [Object? o]) { unimplementedVisitor("visitDimExpr(DimExpr, Object)"); }

          void visitPostIncrementExpression(PostIncrementExpression n, [Object? o]) { unimplementedVisitor("visitPostIncrementExpression(PostIncrementExpression, Object)"); }

          void visitPostDecrementExpression(PostDecrementExpression n, [Object? o]) { unimplementedVisitor("visitPostDecrementExpression(PostDecrementExpression, Object)"); }

          void visitPreIncrementExpression(PreIncrementExpression n, [Object? o]) { unimplementedVisitor("visitPreIncrementExpression(PreIncrementExpression, Object)"); }

          void visitPreDecrementExpression(PreDecrementExpression n, [Object? o]) { unimplementedVisitor("visitPreDecrementExpression(PreDecrementExpression, Object)"); }

          void visitAndExpression(AndExpression n, [Object? o]) { unimplementedVisitor("visitAndExpression(AndExpression, Object)"); }

          void visitExclusiveOrExpression(ExclusiveOrExpression n, [Object? o]) { unimplementedVisitor("visitExclusiveOrExpression(ExclusiveOrExpression, Object)"); }

          void visitInclusiveOrExpression(InclusiveOrExpression n, [Object? o]) { unimplementedVisitor("visitInclusiveOrExpression(InclusiveOrExpression, Object)"); }

          void visitConditionalAndExpression(ConditionalAndExpression n, [Object? o]) { unimplementedVisitor("visitConditionalAndExpression(ConditionalAndExpression, Object)"); }

          void visitConditionalOrExpression(ConditionalOrExpression n, [Object? o]) { unimplementedVisitor("visitConditionalOrExpression(ConditionalOrExpression, Object)"); }

          void visitConditionalExpression(ConditionalExpression n, [Object? o]) { unimplementedVisitor("visitConditionalExpression(ConditionalExpression, Object)"); }

          void visitAssignment(Assignment n, [Object? o]) { unimplementedVisitor("visitAssignment(Assignment, Object)"); }

          void visitCommaopt(Commaopt n, [Object? o]) { unimplementedVisitor("visitCommaopt(Commaopt, Object)"); }

          void visitEllipsisopt(Ellipsisopt n, [Object? o]) { unimplementedVisitor("visitEllipsisopt(Ellipsisopt, Object)"); }

          void visitLPGUserAction0(LPGUserAction0 n, [Object? o]) { unimplementedVisitor("visitLPGUserAction0(LPGUserAction0, Object)"); }

          void visitLPGUserAction1(LPGUserAction1 n, [Object? o]) { unimplementedVisitor("visitLPGUserAction1(LPGUserAction1, Object)"); }

          void visitLPGUserAction2(LPGUserAction2 n, [Object? o]) { unimplementedVisitor("visitLPGUserAction2(LPGUserAction2, Object)"); }

          void visitLPGUserAction3(LPGUserAction3 n, [Object? o]) { unimplementedVisitor("visitLPGUserAction3(LPGUserAction3, Object)"); }

          void visitLPGUserAction4(LPGUserAction4 n, [Object? o]) { unimplementedVisitor("visitLPGUserAction4(LPGUserAction4, Object)"); }

          void visitIntegralType0(IntegralType0 n, [Object? o]) { unimplementedVisitor("visitIntegralType0(IntegralType0, Object)"); }

          void visitIntegralType1(IntegralType1 n, [Object? o]) { unimplementedVisitor("visitIntegralType1(IntegralType1, Object)"); }

          void visitIntegralType2(IntegralType2 n, [Object? o]) { unimplementedVisitor("visitIntegralType2(IntegralType2, Object)"); }

          void visitIntegralType3(IntegralType3 n, [Object? o]) { unimplementedVisitor("visitIntegralType3(IntegralType3, Object)"); }

          void visitIntegralType4(IntegralType4 n, [Object? o]) { unimplementedVisitor("visitIntegralType4(IntegralType4, Object)"); }

          void visitFloatingPointType0(FloatingPointType0 n, [Object? o]) { unimplementedVisitor("visitFloatingPointType0(FloatingPointType0, Object)"); }

          void visitFloatingPointType1(FloatingPointType1 n, [Object? o]) { unimplementedVisitor("visitFloatingPointType1(FloatingPointType1, Object)"); }

          void visitWildcardBounds0(WildcardBounds0 n, [Object? o]) { unimplementedVisitor("visitWildcardBounds0(WildcardBounds0, Object)"); }

          void visitWildcardBounds1(WildcardBounds1 n, [Object? o]) { unimplementedVisitor("visitWildcardBounds1(WildcardBounds1, Object)"); }

          void visitClassModifier0(ClassModifier0 n, [Object? o]) { unimplementedVisitor("visitClassModifier0(ClassModifier0, Object)"); }

          void visitClassModifier1(ClassModifier1 n, [Object? o]) { unimplementedVisitor("visitClassModifier1(ClassModifier1, Object)"); }

          void visitClassModifier2(ClassModifier2 n, [Object? o]) { unimplementedVisitor("visitClassModifier2(ClassModifier2, Object)"); }

          void visitClassModifier3(ClassModifier3 n, [Object? o]) { unimplementedVisitor("visitClassModifier3(ClassModifier3, Object)"); }

          void visitClassModifier4(ClassModifier4 n, [Object? o]) { unimplementedVisitor("visitClassModifier4(ClassModifier4, Object)"); }

          void visitClassModifier5(ClassModifier5 n, [Object? o]) { unimplementedVisitor("visitClassModifier5(ClassModifier5, Object)"); }

          void visitClassModifier6(ClassModifier6 n, [Object? o]) { unimplementedVisitor("visitClassModifier6(ClassModifier6, Object)"); }

          void visitFieldModifier0(FieldModifier0 n, [Object? o]) { unimplementedVisitor("visitFieldModifier0(FieldModifier0, Object)"); }

          void visitFieldModifier1(FieldModifier1 n, [Object? o]) { unimplementedVisitor("visitFieldModifier1(FieldModifier1, Object)"); }

          void visitFieldModifier2(FieldModifier2 n, [Object? o]) { unimplementedVisitor("visitFieldModifier2(FieldModifier2, Object)"); }

          void visitFieldModifier3(FieldModifier3 n, [Object? o]) { unimplementedVisitor("visitFieldModifier3(FieldModifier3, Object)"); }

          void visitFieldModifier4(FieldModifier4 n, [Object? o]) { unimplementedVisitor("visitFieldModifier4(FieldModifier4, Object)"); }

          void visitFieldModifier5(FieldModifier5 n, [Object? o]) { unimplementedVisitor("visitFieldModifier5(FieldModifier5, Object)"); }

          void visitFieldModifier6(FieldModifier6 n, [Object? o]) { unimplementedVisitor("visitFieldModifier6(FieldModifier6, Object)"); }

          void visitMethodDeclarator0(MethodDeclarator0 n, [Object? o]) { unimplementedVisitor("visitMethodDeclarator0(MethodDeclarator0, Object)"); }

          void visitMethodDeclarator1(MethodDeclarator1 n, [Object? o]) { unimplementedVisitor("visitMethodDeclarator1(MethodDeclarator1, Object)"); }

          void visitMethodModifier0(MethodModifier0 n, [Object? o]) { unimplementedVisitor("visitMethodModifier0(MethodModifier0, Object)"); }

          void visitMethodModifier1(MethodModifier1 n, [Object? o]) { unimplementedVisitor("visitMethodModifier1(MethodModifier1, Object)"); }

          void visitMethodModifier2(MethodModifier2 n, [Object? o]) { unimplementedVisitor("visitMethodModifier2(MethodModifier2, Object)"); }

          void visitMethodModifier3(MethodModifier3 n, [Object? o]) { unimplementedVisitor("visitMethodModifier3(MethodModifier3, Object)"); }

          void visitMethodModifier4(MethodModifier4 n, [Object? o]) { unimplementedVisitor("visitMethodModifier4(MethodModifier4, Object)"); }

          void visitMethodModifier5(MethodModifier5 n, [Object? o]) { unimplementedVisitor("visitMethodModifier5(MethodModifier5, Object)"); }

          void visitMethodModifier6(MethodModifier6 n, [Object? o]) { unimplementedVisitor("visitMethodModifier6(MethodModifier6, Object)"); }

          void visitMethodModifier7(MethodModifier7 n, [Object? o]) { unimplementedVisitor("visitMethodModifier7(MethodModifier7, Object)"); }

          void visitMethodModifier8(MethodModifier8 n, [Object? o]) { unimplementedVisitor("visitMethodModifier8(MethodModifier8, Object)"); }

          void visitConstructorModifier0(ConstructorModifier0 n, [Object? o]) { unimplementedVisitor("visitConstructorModifier0(ConstructorModifier0, Object)"); }

          void visitConstructorModifier1(ConstructorModifier1 n, [Object? o]) { unimplementedVisitor("visitConstructorModifier1(ConstructorModifier1, Object)"); }

          void visitConstructorModifier2(ConstructorModifier2 n, [Object? o]) { unimplementedVisitor("visitConstructorModifier2(ConstructorModifier2, Object)"); }

          void visitExplicitConstructorInvocation0(ExplicitConstructorInvocation0 n, [Object? o]) { unimplementedVisitor("visitExplicitConstructorInvocation0(ExplicitConstructorInvocation0, Object)"); }

          void visitExplicitConstructorInvocation1(ExplicitConstructorInvocation1 n, [Object? o]) { unimplementedVisitor("visitExplicitConstructorInvocation1(ExplicitConstructorInvocation1, Object)"); }

          void visitExplicitConstructorInvocation2(ExplicitConstructorInvocation2 n, [Object? o]) { unimplementedVisitor("visitExplicitConstructorInvocation2(ExplicitConstructorInvocation2, Object)"); }

          void visitInterfaceModifier0(InterfaceModifier0 n, [Object? o]) { unimplementedVisitor("visitInterfaceModifier0(InterfaceModifier0, Object)"); }

          void visitInterfaceModifier1(InterfaceModifier1 n, [Object? o]) { unimplementedVisitor("visitInterfaceModifier1(InterfaceModifier1, Object)"); }

          void visitInterfaceModifier2(InterfaceModifier2 n, [Object? o]) { unimplementedVisitor("visitInterfaceModifier2(InterfaceModifier2, Object)"); }

          void visitInterfaceModifier3(InterfaceModifier3 n, [Object? o]) { unimplementedVisitor("visitInterfaceModifier3(InterfaceModifier3, Object)"); }

          void visitInterfaceModifier4(InterfaceModifier4 n, [Object? o]) { unimplementedVisitor("visitInterfaceModifier4(InterfaceModifier4, Object)"); }

          void visitInterfaceModifier5(InterfaceModifier5 n, [Object? o]) { unimplementedVisitor("visitInterfaceModifier5(InterfaceModifier5, Object)"); }

          void visitExtendsInterfaces0(ExtendsInterfaces0 n, [Object? o]) { unimplementedVisitor("visitExtendsInterfaces0(ExtendsInterfaces0, Object)"); }

          void visitExtendsInterfaces1(ExtendsInterfaces1 n, [Object? o]) { unimplementedVisitor("visitExtendsInterfaces1(ExtendsInterfaces1, Object)"); }

          void visitConstantModifier0(ConstantModifier0 n, [Object? o]) { unimplementedVisitor("visitConstantModifier0(ConstantModifier0, Object)"); }

          void visitConstantModifier1(ConstantModifier1 n, [Object? o]) { unimplementedVisitor("visitConstantModifier1(ConstantModifier1, Object)"); }

          void visitConstantModifier2(ConstantModifier2 n, [Object? o]) { unimplementedVisitor("visitConstantModifier2(ConstantModifier2, Object)"); }

          void visitAbstractMethodModifier0(AbstractMethodModifier0 n, [Object? o]) { unimplementedVisitor("visitAbstractMethodModifier0(AbstractMethodModifier0, Object)"); }

          void visitAbstractMethodModifier1(AbstractMethodModifier1 n, [Object? o]) { unimplementedVisitor("visitAbstractMethodModifier1(AbstractMethodModifier1, Object)"); }

          void visitAnnotationTypeElementDeclaration0(AnnotationTypeElementDeclaration0 n, [Object? o]) { unimplementedVisitor("visitAnnotationTypeElementDeclaration0(AnnotationTypeElementDeclaration0, Object)"); }

          void visitAnnotationTypeElementDeclaration1(AnnotationTypeElementDeclaration1 n, [Object? o]) { unimplementedVisitor("visitAnnotationTypeElementDeclaration1(AnnotationTypeElementDeclaration1, Object)"); }

          void visitAssertStatement0(AssertStatement0 n, [Object? o]) { unimplementedVisitor("visitAssertStatement0(AssertStatement0, Object)"); }

          void visitAssertStatement1(AssertStatement1 n, [Object? o]) { unimplementedVisitor("visitAssertStatement1(AssertStatement1, Object)"); }

          void visitSwitchLabel0(SwitchLabel0 n, [Object? o]) { unimplementedVisitor("visitSwitchLabel0(SwitchLabel0, Object)"); }

          void visitSwitchLabel1(SwitchLabel1 n, [Object? o]) { unimplementedVisitor("visitSwitchLabel1(SwitchLabel1, Object)"); }

          void visitSwitchLabel2(SwitchLabel2 n, [Object? o]) { unimplementedVisitor("visitSwitchLabel2(SwitchLabel2, Object)"); }

          void visitTryStatement0(TryStatement0 n, [Object? o]) { unimplementedVisitor("visitTryStatement0(TryStatement0, Object)"); }

          void visitTryStatement1(TryStatement1 n, [Object? o]) { unimplementedVisitor("visitTryStatement1(TryStatement1, Object)"); }

          void visitPrimaryNoNewArray0(PrimaryNoNewArray0 n, [Object? o]) { unimplementedVisitor("visitPrimaryNoNewArray0(PrimaryNoNewArray0, Object)"); }

          void visitPrimaryNoNewArray1(PrimaryNoNewArray1 n, [Object? o]) { unimplementedVisitor("visitPrimaryNoNewArray1(PrimaryNoNewArray1, Object)"); }

          void visitPrimaryNoNewArray2(PrimaryNoNewArray2 n, [Object? o]) { unimplementedVisitor("visitPrimaryNoNewArray2(PrimaryNoNewArray2, Object)"); }

          void visitPrimaryNoNewArray3(PrimaryNoNewArray3 n, [Object? o]) { unimplementedVisitor("visitPrimaryNoNewArray3(PrimaryNoNewArray3, Object)"); }

          void visitPrimaryNoNewArray4(PrimaryNoNewArray4 n, [Object? o]) { unimplementedVisitor("visitPrimaryNoNewArray4(PrimaryNoNewArray4, Object)"); }

          void visitLiteral0(Literal0 n, [Object? o]) { unimplementedVisitor("visitLiteral0(Literal0, Object)"); }

          void visitLiteral1(Literal1 n, [Object? o]) { unimplementedVisitor("visitLiteral1(Literal1, Object)"); }

          void visitLiteral2(Literal2 n, [Object? o]) { unimplementedVisitor("visitLiteral2(Literal2, Object)"); }

          void visitLiteral3(Literal3 n, [Object? o]) { unimplementedVisitor("visitLiteral3(Literal3, Object)"); }

          void visitLiteral4(Literal4 n, [Object? o]) { unimplementedVisitor("visitLiteral4(Literal4, Object)"); }

          void visitLiteral5(Literal5 n, [Object? o]) { unimplementedVisitor("visitLiteral5(Literal5, Object)"); }

          void visitLiteral6(Literal6 n, [Object? o]) { unimplementedVisitor("visitLiteral6(Literal6, Object)"); }

          void visitBooleanLiteral0(BooleanLiteral0 n, [Object? o]) { unimplementedVisitor("visitBooleanLiteral0(BooleanLiteral0, Object)"); }

          void visitBooleanLiteral1(BooleanLiteral1 n, [Object? o]) { unimplementedVisitor("visitBooleanLiteral1(BooleanLiteral1, Object)"); }

          void visitClassInstanceCreationExpression0(ClassInstanceCreationExpression0 n, [Object? o]) { unimplementedVisitor("visitClassInstanceCreationExpression0(ClassInstanceCreationExpression0, Object)"); }

          void visitClassInstanceCreationExpression1(ClassInstanceCreationExpression1 n, [Object? o]) { unimplementedVisitor("visitClassInstanceCreationExpression1(ClassInstanceCreationExpression1, Object)"); }

          void visitArrayCreationExpression0(ArrayCreationExpression0 n, [Object? o]) { unimplementedVisitor("visitArrayCreationExpression0(ArrayCreationExpression0, Object)"); }

          void visitArrayCreationExpression1(ArrayCreationExpression1 n, [Object? o]) { unimplementedVisitor("visitArrayCreationExpression1(ArrayCreationExpression1, Object)"); }

          void visitArrayCreationExpression2(ArrayCreationExpression2 n, [Object? o]) { unimplementedVisitor("visitArrayCreationExpression2(ArrayCreationExpression2, Object)"); }

          void visitArrayCreationExpression3(ArrayCreationExpression3 n, [Object? o]) { unimplementedVisitor("visitArrayCreationExpression3(ArrayCreationExpression3, Object)"); }

          void visitDims0(Dims0 n, [Object? o]) { unimplementedVisitor("visitDims0(Dims0, Object)"); }

          void visitDims1(Dims1 n, [Object? o]) { unimplementedVisitor("visitDims1(Dims1, Object)"); }

          void visitFieldAccess0(FieldAccess0 n, [Object? o]) { unimplementedVisitor("visitFieldAccess0(FieldAccess0, Object)"); }

          void visitFieldAccess1(FieldAccess1 n, [Object? o]) { unimplementedVisitor("visitFieldAccess1(FieldAccess1, Object)"); }

          void visitFieldAccess2(FieldAccess2 n, [Object? o]) { unimplementedVisitor("visitFieldAccess2(FieldAccess2, Object)"); }

          void visitMethodInvocation0(MethodInvocation0 n, [Object? o]) { unimplementedVisitor("visitMethodInvocation0(MethodInvocation0, Object)"); }

          void visitMethodInvocation1(MethodInvocation1 n, [Object? o]) { unimplementedVisitor("visitMethodInvocation1(MethodInvocation1, Object)"); }

          void visitMethodInvocation2(MethodInvocation2 n, [Object? o]) { unimplementedVisitor("visitMethodInvocation2(MethodInvocation2, Object)"); }

          void visitMethodInvocation3(MethodInvocation3 n, [Object? o]) { unimplementedVisitor("visitMethodInvocation3(MethodInvocation3, Object)"); }

          void visitMethodInvocation4(MethodInvocation4 n, [Object? o]) { unimplementedVisitor("visitMethodInvocation4(MethodInvocation4, Object)"); }

          void visitArrayAccess0(ArrayAccess0 n, [Object? o]) { unimplementedVisitor("visitArrayAccess0(ArrayAccess0, Object)"); }

          void visitArrayAccess1(ArrayAccess1 n, [Object? o]) { unimplementedVisitor("visitArrayAccess1(ArrayAccess1, Object)"); }

          void visitUnaryExpression0(UnaryExpression0 n, [Object? o]) { unimplementedVisitor("visitUnaryExpression0(UnaryExpression0, Object)"); }

          void visitUnaryExpression1(UnaryExpression1 n, [Object? o]) { unimplementedVisitor("visitUnaryExpression1(UnaryExpression1, Object)"); }

          void visitUnaryExpressionNotPlusMinus0(UnaryExpressionNotPlusMinus0 n, [Object? o]) { unimplementedVisitor("visitUnaryExpressionNotPlusMinus0(UnaryExpressionNotPlusMinus0, Object)"); }

          void visitUnaryExpressionNotPlusMinus1(UnaryExpressionNotPlusMinus1 n, [Object? o]) { unimplementedVisitor("visitUnaryExpressionNotPlusMinus1(UnaryExpressionNotPlusMinus1, Object)"); }

          void visitCastExpression0(CastExpression0 n, [Object? o]) { unimplementedVisitor("visitCastExpression0(CastExpression0, Object)"); }

          void visitCastExpression1(CastExpression1 n, [Object? o]) { unimplementedVisitor("visitCastExpression1(CastExpression1, Object)"); }

          void visitMultiplicativeExpression0(MultiplicativeExpression0 n, [Object? o]) { unimplementedVisitor("visitMultiplicativeExpression0(MultiplicativeExpression0, Object)"); }

          void visitMultiplicativeExpression1(MultiplicativeExpression1 n, [Object? o]) { unimplementedVisitor("visitMultiplicativeExpression1(MultiplicativeExpression1, Object)"); }

          void visitMultiplicativeExpression2(MultiplicativeExpression2 n, [Object? o]) { unimplementedVisitor("visitMultiplicativeExpression2(MultiplicativeExpression2, Object)"); }

          void visitAdditiveExpression0(AdditiveExpression0 n, [Object? o]) { unimplementedVisitor("visitAdditiveExpression0(AdditiveExpression0, Object)"); }

          void visitAdditiveExpression1(AdditiveExpression1 n, [Object? o]) { unimplementedVisitor("visitAdditiveExpression1(AdditiveExpression1, Object)"); }

          void visitShiftExpression0(ShiftExpression0 n, [Object? o]) { unimplementedVisitor("visitShiftExpression0(ShiftExpression0, Object)"); }

          void visitShiftExpression1(ShiftExpression1 n, [Object? o]) { unimplementedVisitor("visitShiftExpression1(ShiftExpression1, Object)"); }

          void visitShiftExpression2(ShiftExpression2 n, [Object? o]) { unimplementedVisitor("visitShiftExpression2(ShiftExpression2, Object)"); }

          void visitRelationalExpression0(RelationalExpression0 n, [Object? o]) { unimplementedVisitor("visitRelationalExpression0(RelationalExpression0, Object)"); }

          void visitRelationalExpression1(RelationalExpression1 n, [Object? o]) { unimplementedVisitor("visitRelationalExpression1(RelationalExpression1, Object)"); }

          void visitRelationalExpression2(RelationalExpression2 n, [Object? o]) { unimplementedVisitor("visitRelationalExpression2(RelationalExpression2, Object)"); }

          void visitRelationalExpression3(RelationalExpression3 n, [Object? o]) { unimplementedVisitor("visitRelationalExpression3(RelationalExpression3, Object)"); }

          void visitRelationalExpression4(RelationalExpression4 n, [Object? o]) { unimplementedVisitor("visitRelationalExpression4(RelationalExpression4, Object)"); }

          void visitEqualityExpression0(EqualityExpression0 n, [Object? o]) { unimplementedVisitor("visitEqualityExpression0(EqualityExpression0, Object)"); }

          void visitEqualityExpression1(EqualityExpression1 n, [Object? o]) { unimplementedVisitor("visitEqualityExpression1(EqualityExpression1, Object)"); }

          void visitAssignmentOperator0(AssignmentOperator0 n, [Object? o]) { unimplementedVisitor("visitAssignmentOperator0(AssignmentOperator0, Object)"); }

          void visitAssignmentOperator1(AssignmentOperator1 n, [Object? o]) { unimplementedVisitor("visitAssignmentOperator1(AssignmentOperator1, Object)"); }

          void visitAssignmentOperator2(AssignmentOperator2 n, [Object? o]) { unimplementedVisitor("visitAssignmentOperator2(AssignmentOperator2, Object)"); }

          void visitAssignmentOperator3(AssignmentOperator3 n, [Object? o]) { unimplementedVisitor("visitAssignmentOperator3(AssignmentOperator3, Object)"); }

          void visitAssignmentOperator4(AssignmentOperator4 n, [Object? o]) { unimplementedVisitor("visitAssignmentOperator4(AssignmentOperator4, Object)"); }

          void visitAssignmentOperator5(AssignmentOperator5 n, [Object? o]) { unimplementedVisitor("visitAssignmentOperator5(AssignmentOperator5, Object)"); }

          void visitAssignmentOperator6(AssignmentOperator6 n, [Object? o]) { unimplementedVisitor("visitAssignmentOperator6(AssignmentOperator6, Object)"); }

          void visitAssignmentOperator7(AssignmentOperator7 n, [Object? o]) { unimplementedVisitor("visitAssignmentOperator7(AssignmentOperator7, Object)"); }

          void visitAssignmentOperator8(AssignmentOperator8 n, [Object? o]) { unimplementedVisitor("visitAssignmentOperator8(AssignmentOperator8, Object)"); }

          void visitAssignmentOperator9(AssignmentOperator9 n, [Object? o]) { unimplementedVisitor("visitAssignmentOperator9(AssignmentOperator9, Object)"); }

          void visitAssignmentOperator10(AssignmentOperator10 n, [Object? o]) { unimplementedVisitor("visitAssignmentOperator10(AssignmentOperator10, Object)"); }

          void visitAssignmentOperator11(AssignmentOperator11 n, [Object? o]) { unimplementedVisitor("visitAssignmentOperator11(AssignmentOperator11, Object)"); }


          void visit(Ast n, [Object? o])
        {
            if (n is AstToken) visitAstToken(n, o);
            else if (n is identifier) visitidentifier(n, o);
            else if (n is PrimitiveType) visitPrimitiveType(n, o);
            else if (n is ClassType) visitClassType(n, o);
            else if (n is InterfaceType) visitInterfaceType(n, o);
            else if (n is TypeName) visitTypeName(n, o);
            else if (n is ArrayType) visitArrayType(n, o);
            else if (n is TypeParameter) visitTypeParameter(n, o);
            else if (n is TypeBound) visitTypeBound(n, o);
            else if (n is AdditionalBoundList) visitAdditionalBoundList(n, o);
            else if (n is AdditionalBound) visitAdditionalBound(n, o);
            else if (n is TypeArguments) visitTypeArguments(n, o);
            else if (n is ActualTypeArgumentList) visitActualTypeArgumentList(n, o);
            else if (n is Wildcard) visitWildcard(n, o);
            else if (n is PackageName) visitPackageName(n, o);
            else if (n is ExpressionName) visitExpressionName(n, o);
            else if (n is MethodName) visitMethodName(n, o);
            else if (n is PackageOrTypeName) visitPackageOrTypeName(n, o);
            else if (n is AmbiguousName) visitAmbiguousName(n, o);
            else if (n is CompilationUnit) visitCompilationUnit(n, o);
            else if (n is ImportDeclarations) visitImportDeclarations(n, o);
            else if (n is TypeDeclarations) visitTypeDeclarations(n, o);
            else if (n is PackageDeclaration) visitPackageDeclaration(n, o);
            else if (n is SingleTypeImportDeclaration) visitSingleTypeImportDeclaration(n, o);
            else if (n is TypeImportOnDemandDeclaration) visitTypeImportOnDemandDeclaration(n, o);
            else if (n is SingleStaticImportDeclaration) visitSingleStaticImportDeclaration(n, o);
            else if (n is StaticImportOnDemandDeclaration) visitStaticImportOnDemandDeclaration(n, o);
            else if (n is TypeDeclaration) visitTypeDeclaration(n, o);
            else if (n is NormalClassDeclaration) visitNormalClassDeclaration(n, o);
            else if (n is ClassModifiers) visitClassModifiers(n, o);
            else if (n is TypeParameters) visitTypeParameters(n, o);
            else if (n is TypeParameterList) visitTypeParameterList(n, o);
            else if (n is Super) visitSuper(n, o);
            else if (n is Interfaces) visitInterfaces(n, o);
            else if (n is InterfaceTypeList) visitInterfaceTypeList(n, o);
            else if (n is ClassBody) visitClassBody(n, o);
            else if (n is ClassBodyDeclarations) visitClassBodyDeclarations(n, o);
            else if (n is ClassMemberDeclaration) visitClassMemberDeclaration(n, o);
            else if (n is FieldDeclaration) visitFieldDeclaration(n, o);
            else if (n is VariableDeclarators) visitVariableDeclarators(n, o);
            else if (n is VariableDeclarator) visitVariableDeclarator(n, o);
            else if (n is VariableDeclaratorId) visitVariableDeclaratorId(n, o);
            else if (n is FieldModifiers) visitFieldModifiers(n, o);
            else if (n is MethodDeclaration) visitMethodDeclaration(n, o);
            else if (n is MethodHeader) visitMethodHeader(n, o);
            else if (n is ResultType) visitResultType(n, o);
            else if (n is FormalParameterList) visitFormalParameterList(n, o);
            else if (n is FormalParameters) visitFormalParameters(n, o);
            else if (n is FormalParameter) visitFormalParameter(n, o);
            else if (n is VariableModifiers) visitVariableModifiers(n, o);
            else if (n is VariableModifier) visitVariableModifier(n, o);
            else if (n is LastFormalParameter) visitLastFormalParameter(n, o);
            else if (n is MethodModifiers) visitMethodModifiers(n, o);
            else if (n is Throws) visitThrows(n, o);
            else if (n is ExceptionTypeList) visitExceptionTypeList(n, o);
            else if (n is MethodBody) visitMethodBody(n, o);
            else if (n is StaticInitializer) visitStaticInitializer(n, o);
            else if (n is ConstructorDeclaration) visitConstructorDeclaration(n, o);
            else if (n is ConstructorDeclarator) visitConstructorDeclarator(n, o);
            else if (n is ConstructorModifiers) visitConstructorModifiers(n, o);
            else if (n is ConstructorBody) visitConstructorBody(n, o);
            else if (n is EnumDeclaration) visitEnumDeclaration(n, o);
            else if (n is EnumBody) visitEnumBody(n, o);
            else if (n is EnumConstants) visitEnumConstants(n, o);
            else if (n is EnumConstant) visitEnumConstant(n, o);
            else if (n is Arguments) visitArguments(n, o);
            else if (n is EnumBodyDeclarations) visitEnumBodyDeclarations(n, o);
            else if (n is NormalInterfaceDeclaration) visitNormalInterfaceDeclaration(n, o);
            else if (n is InterfaceModifiers) visitInterfaceModifiers(n, o);
            else if (n is InterfaceBody) visitInterfaceBody(n, o);
            else if (n is InterfaceMemberDeclarations) visitInterfaceMemberDeclarations(n, o);
            else if (n is InterfaceMemberDeclaration) visitInterfaceMemberDeclaration(n, o);
            else if (n is ConstantDeclaration) visitConstantDeclaration(n, o);
            else if (n is ConstantModifiers) visitConstantModifiers(n, o);
            else if (n is AbstractMethodDeclaration) visitAbstractMethodDeclaration(n, o);
            else if (n is AbstractMethodModifiers) visitAbstractMethodModifiers(n, o);
            else if (n is AnnotationTypeDeclaration) visitAnnotationTypeDeclaration(n, o);
            else if (n is AnnotationTypeBody) visitAnnotationTypeBody(n, o);
            else if (n is AnnotationTypeElementDeclarations) visitAnnotationTypeElementDeclarations(n, o);
            else if (n is DefaultValue) visitDefaultValue(n, o);
            else if (n is Annotations) visitAnnotations(n, o);
            else if (n is NormalAnnotation) visitNormalAnnotation(n, o);
            else if (n is ElementValuePairs) visitElementValuePairs(n, o);
            else if (n is ElementValuePair) visitElementValuePair(n, o);
            else if (n is ElementValueArrayInitializer) visitElementValueArrayInitializer(n, o);
            else if (n is ElementValues) visitElementValues(n, o);
            else if (n is MarkerAnnotation) visitMarkerAnnotation(n, o);
            else if (n is SingleElementAnnotation) visitSingleElementAnnotation(n, o);
            else if (n is ArrayInitializer) visitArrayInitializer(n, o);
            else if (n is VariableInitializers) visitVariableInitializers(n, o);
            else if (n is Block) visitBlock(n, o);
            else if (n is BlockStatements) visitBlockStatements(n, o);
            else if (n is LocalVariableDeclarationStatement) visitLocalVariableDeclarationStatement(n, o);
            else if (n is LocalVariableDeclaration) visitLocalVariableDeclaration(n, o);
            else if (n is IfThenStatement) visitIfThenStatement(n, o);
            else if (n is IfThenElseStatement) visitIfThenElseStatement(n, o);
            else if (n is IfThenElseStatementNoShortIf) visitIfThenElseStatementNoShortIf(n, o);
            else if (n is EmptyStatement) visitEmptyStatement(n, o);
            else if (n is LabeledStatement) visitLabeledStatement(n, o);
            else if (n is LabeledStatementNoShortIf) visitLabeledStatementNoShortIf(n, o);
            else if (n is ExpressionStatement) visitExpressionStatement(n, o);
            else if (n is SwitchStatement) visitSwitchStatement(n, o);
            else if (n is SwitchBlock) visitSwitchBlock(n, o);
            else if (n is SwitchBlockStatementGroups) visitSwitchBlockStatementGroups(n, o);
            else if (n is SwitchBlockStatementGroup) visitSwitchBlockStatementGroup(n, o);
            else if (n is SwitchLabels) visitSwitchLabels(n, o);
            else if (n is WhileStatement) visitWhileStatement(n, o);
            else if (n is WhileStatementNoShortIf) visitWhileStatementNoShortIf(n, o);
            else if (n is DoStatement) visitDoStatement(n, o);
            else if (n is BasicForStatement) visitBasicForStatement(n, o);
            else if (n is ForStatementNoShortIf) visitForStatementNoShortIf(n, o);
            else if (n is StatementExpressionList) visitStatementExpressionList(n, o);
            else if (n is EnhancedForStatement) visitEnhancedForStatement(n, o);
            else if (n is BreakStatement) visitBreakStatement(n, o);
            else if (n is ContinueStatement) visitContinueStatement(n, o);
            else if (n is ReturnStatement) visitReturnStatement(n, o);
            else if (n is ThrowStatement) visitThrowStatement(n, o);
            else if (n is SynchronizedStatement) visitSynchronizedStatement(n, o);
            else if (n is Catches) visitCatches(n, o);
            else if (n is CatchClause) visitCatchClause(n, o);
            else if (n is Finally) visitFinally(n, o);
            else if (n is ArgumentList) visitArgumentList(n, o);
            else if (n is DimExprs) visitDimExprs(n, o);
            else if (n is DimExpr) visitDimExpr(n, o);
            else if (n is PostIncrementExpression) visitPostIncrementExpression(n, o);
            else if (n is PostDecrementExpression) visitPostDecrementExpression(n, o);
            else if (n is PreIncrementExpression) visitPreIncrementExpression(n, o);
            else if (n is PreDecrementExpression) visitPreDecrementExpression(n, o);
            else if (n is AndExpression) visitAndExpression(n, o);
            else if (n is ExclusiveOrExpression) visitExclusiveOrExpression(n, o);
            else if (n is InclusiveOrExpression) visitInclusiveOrExpression(n, o);
            else if (n is ConditionalAndExpression) visitConditionalAndExpression(n, o);
            else if (n is ConditionalOrExpression) visitConditionalOrExpression(n, o);
            else if (n is ConditionalExpression) visitConditionalExpression(n, o);
            else if (n is Assignment) visitAssignment(n, o);
            else if (n is Commaopt) visitCommaopt(n, o);
            else if (n is Ellipsisopt) visitEllipsisopt(n, o);
            else if (n is LPGUserAction0) visitLPGUserAction0(n, o);
            else if (n is LPGUserAction1) visitLPGUserAction1(n, o);
            else if (n is LPGUserAction2) visitLPGUserAction2(n, o);
            else if (n is LPGUserAction3) visitLPGUserAction3(n, o);
            else if (n is LPGUserAction4) visitLPGUserAction4(n, o);
            else if (n is IntegralType0) visitIntegralType0(n, o);
            else if (n is IntegralType1) visitIntegralType1(n, o);
            else if (n is IntegralType2) visitIntegralType2(n, o);
            else if (n is IntegralType3) visitIntegralType3(n, o);
            else if (n is IntegralType4) visitIntegralType4(n, o);
            else if (n is FloatingPointType0) visitFloatingPointType0(n, o);
            else if (n is FloatingPointType1) visitFloatingPointType1(n, o);
            else if (n is WildcardBounds0) visitWildcardBounds0(n, o);
            else if (n is WildcardBounds1) visitWildcardBounds1(n, o);
            else if (n is ClassModifier0) visitClassModifier0(n, o);
            else if (n is ClassModifier1) visitClassModifier1(n, o);
            else if (n is ClassModifier2) visitClassModifier2(n, o);
            else if (n is ClassModifier3) visitClassModifier3(n, o);
            else if (n is ClassModifier4) visitClassModifier4(n, o);
            else if (n is ClassModifier5) visitClassModifier5(n, o);
            else if (n is ClassModifier6) visitClassModifier6(n, o);
            else if (n is FieldModifier0) visitFieldModifier0(n, o);
            else if (n is FieldModifier1) visitFieldModifier1(n, o);
            else if (n is FieldModifier2) visitFieldModifier2(n, o);
            else if (n is FieldModifier3) visitFieldModifier3(n, o);
            else if (n is FieldModifier4) visitFieldModifier4(n, o);
            else if (n is FieldModifier5) visitFieldModifier5(n, o);
            else if (n is FieldModifier6) visitFieldModifier6(n, o);
            else if (n is MethodDeclarator0) visitMethodDeclarator0(n, o);
            else if (n is MethodDeclarator1) visitMethodDeclarator1(n, o);
            else if (n is MethodModifier0) visitMethodModifier0(n, o);
            else if (n is MethodModifier1) visitMethodModifier1(n, o);
            else if (n is MethodModifier2) visitMethodModifier2(n, o);
            else if (n is MethodModifier3) visitMethodModifier3(n, o);
            else if (n is MethodModifier4) visitMethodModifier4(n, o);
            else if (n is MethodModifier5) visitMethodModifier5(n, o);
            else if (n is MethodModifier6) visitMethodModifier6(n, o);
            else if (n is MethodModifier7) visitMethodModifier7(n, o);
            else if (n is MethodModifier8) visitMethodModifier8(n, o);
            else if (n is ConstructorModifier0) visitConstructorModifier0(n, o);
            else if (n is ConstructorModifier1) visitConstructorModifier1(n, o);
            else if (n is ConstructorModifier2) visitConstructorModifier2(n, o);
            else if (n is ExplicitConstructorInvocation0) visitExplicitConstructorInvocation0(n, o);
            else if (n is ExplicitConstructorInvocation1) visitExplicitConstructorInvocation1(n, o);
            else if (n is ExplicitConstructorInvocation2) visitExplicitConstructorInvocation2(n, o);
            else if (n is InterfaceModifier0) visitInterfaceModifier0(n, o);
            else if (n is InterfaceModifier1) visitInterfaceModifier1(n, o);
            else if (n is InterfaceModifier2) visitInterfaceModifier2(n, o);
            else if (n is InterfaceModifier3) visitInterfaceModifier3(n, o);
            else if (n is InterfaceModifier4) visitInterfaceModifier4(n, o);
            else if (n is InterfaceModifier5) visitInterfaceModifier5(n, o);
            else if (n is ExtendsInterfaces0) visitExtendsInterfaces0(n, o);
            else if (n is ExtendsInterfaces1) visitExtendsInterfaces1(n, o);
            else if (n is ConstantModifier0) visitConstantModifier0(n, o);
            else if (n is ConstantModifier1) visitConstantModifier1(n, o);
            else if (n is ConstantModifier2) visitConstantModifier2(n, o);
            else if (n is AbstractMethodModifier0) visitAbstractMethodModifier0(n, o);
            else if (n is AbstractMethodModifier1) visitAbstractMethodModifier1(n, o);
            else if (n is AnnotationTypeElementDeclaration0) visitAnnotationTypeElementDeclaration0(n, o);
            else if (n is AnnotationTypeElementDeclaration1) visitAnnotationTypeElementDeclaration1(n, o);
            else if (n is AssertStatement0) visitAssertStatement0(n, o);
            else if (n is AssertStatement1) visitAssertStatement1(n, o);
            else if (n is SwitchLabel0) visitSwitchLabel0(n, o);
            else if (n is SwitchLabel1) visitSwitchLabel1(n, o);
            else if (n is SwitchLabel2) visitSwitchLabel2(n, o);
            else if (n is TryStatement0) visitTryStatement0(n, o);
            else if (n is TryStatement1) visitTryStatement1(n, o);
            else if (n is PrimaryNoNewArray0) visitPrimaryNoNewArray0(n, o);
            else if (n is PrimaryNoNewArray1) visitPrimaryNoNewArray1(n, o);
            else if (n is PrimaryNoNewArray2) visitPrimaryNoNewArray2(n, o);
            else if (n is PrimaryNoNewArray3) visitPrimaryNoNewArray3(n, o);
            else if (n is PrimaryNoNewArray4) visitPrimaryNoNewArray4(n, o);
            else if (n is Literal0) visitLiteral0(n, o);
            else if (n is Literal1) visitLiteral1(n, o);
            else if (n is Literal2) visitLiteral2(n, o);
            else if (n is Literal3) visitLiteral3(n, o);
            else if (n is Literal4) visitLiteral4(n, o);
            else if (n is Literal5) visitLiteral5(n, o);
            else if (n is Literal6) visitLiteral6(n, o);
            else if (n is BooleanLiteral0) visitBooleanLiteral0(n, o);
            else if (n is BooleanLiteral1) visitBooleanLiteral1(n, o);
            else if (n is ClassInstanceCreationExpression0) visitClassInstanceCreationExpression0(n, o);
            else if (n is ClassInstanceCreationExpression1) visitClassInstanceCreationExpression1(n, o);
            else if (n is ArrayCreationExpression0) visitArrayCreationExpression0(n, o);
            else if (n is ArrayCreationExpression1) visitArrayCreationExpression1(n, o);
            else if (n is ArrayCreationExpression2) visitArrayCreationExpression2(n, o);
            else if (n is ArrayCreationExpression3) visitArrayCreationExpression3(n, o);
            else if (n is Dims0) visitDims0(n, o);
            else if (n is Dims1) visitDims1(n, o);
            else if (n is FieldAccess0) visitFieldAccess0(n, o);
            else if (n is FieldAccess1) visitFieldAccess1(n, o);
            else if (n is FieldAccess2) visitFieldAccess2(n, o);
            else if (n is MethodInvocation0) visitMethodInvocation0(n, o);
            else if (n is MethodInvocation1) visitMethodInvocation1(n, o);
            else if (n is MethodInvocation2) visitMethodInvocation2(n, o);
            else if (n is MethodInvocation3) visitMethodInvocation3(n, o);
            else if (n is MethodInvocation4) visitMethodInvocation4(n, o);
            else if (n is ArrayAccess0) visitArrayAccess0(n, o);
            else if (n is ArrayAccess1) visitArrayAccess1(n, o);
            else if (n is UnaryExpression0) visitUnaryExpression0(n, o);
            else if (n is UnaryExpression1) visitUnaryExpression1(n, o);
            else if (n is UnaryExpressionNotPlusMinus0) visitUnaryExpressionNotPlusMinus0(n, o);
            else if (n is UnaryExpressionNotPlusMinus1) visitUnaryExpressionNotPlusMinus1(n, o);
            else if (n is CastExpression0) visitCastExpression0(n, o);
            else if (n is CastExpression1) visitCastExpression1(n, o);
            else if (n is MultiplicativeExpression0) visitMultiplicativeExpression0(n, o);
            else if (n is MultiplicativeExpression1) visitMultiplicativeExpression1(n, o);
            else if (n is MultiplicativeExpression2) visitMultiplicativeExpression2(n, o);
            else if (n is AdditiveExpression0) visitAdditiveExpression0(n, o);
            else if (n is AdditiveExpression1) visitAdditiveExpression1(n, o);
            else if (n is ShiftExpression0) visitShiftExpression0(n, o);
            else if (n is ShiftExpression1) visitShiftExpression1(n, o);
            else if (n is ShiftExpression2) visitShiftExpression2(n, o);
            else if (n is RelationalExpression0) visitRelationalExpression0(n, o);
            else if (n is RelationalExpression1) visitRelationalExpression1(n, o);
            else if (n is RelationalExpression2) visitRelationalExpression2(n, o);
            else if (n is RelationalExpression3) visitRelationalExpression3(n, o);
            else if (n is RelationalExpression4) visitRelationalExpression4(n, o);
            else if (n is EqualityExpression0) visitEqualityExpression0(n, o);
            else if (n is EqualityExpression1) visitEqualityExpression1(n, o);
            else if (n is AssignmentOperator0) visitAssignmentOperator0(n, o);
            else if (n is AssignmentOperator1) visitAssignmentOperator1(n, o);
            else if (n is AssignmentOperator2) visitAssignmentOperator2(n, o);
            else if (n is AssignmentOperator3) visitAssignmentOperator3(n, o);
            else if (n is AssignmentOperator4) visitAssignmentOperator4(n, o);
            else if (n is AssignmentOperator5) visitAssignmentOperator5(n, o);
            else if (n is AssignmentOperator6) visitAssignmentOperator6(n, o);
            else if (n is AssignmentOperator7) visitAssignmentOperator7(n, o);
            else if (n is AssignmentOperator8) visitAssignmentOperator8(n, o);
            else if (n is AssignmentOperator9) visitAssignmentOperator9(n, o);
            else if (n is AssignmentOperator10) visitAssignmentOperator10(n, o);
            else if (n is AssignmentOperator11) visitAssignmentOperator11(n, o);
            else throw  ArgumentError("visit(" + n.toString() + ")");
        }
    }
abstract class AbstractResultVisitor implements ResultVisitor, ResultArgumentVisitor
    {
         Object unimplementedVisitor(String s);

        Object visitAstToken(AstToken n, [Object? o]){ return  unimplementedVisitor("visitAstToken(AstToken, Object)"); }

        Object visitidentifier(identifier n, [Object? o]){ return  unimplementedVisitor("visitidentifier(identifier, Object)"); }

        Object visitPrimitiveType(PrimitiveType n, [Object? o]){ return  unimplementedVisitor("visitPrimitiveType(PrimitiveType, Object)"); }

        Object visitClassType(ClassType n, [Object? o]){ return  unimplementedVisitor("visitClassType(ClassType, Object)"); }

        Object visitInterfaceType(InterfaceType n, [Object? o]){ return  unimplementedVisitor("visitInterfaceType(InterfaceType, Object)"); }

        Object visitTypeName(TypeName n, [Object? o]){ return  unimplementedVisitor("visitTypeName(TypeName, Object)"); }

        Object visitArrayType(ArrayType n, [Object? o]){ return  unimplementedVisitor("visitArrayType(ArrayType, Object)"); }

        Object visitTypeParameter(TypeParameter n, [Object? o]){ return  unimplementedVisitor("visitTypeParameter(TypeParameter, Object)"); }

        Object visitTypeBound(TypeBound n, [Object? o]){ return  unimplementedVisitor("visitTypeBound(TypeBound, Object)"); }

        Object visitAdditionalBoundList(AdditionalBoundList n, [Object? o]){ return  unimplementedVisitor("visitAdditionalBoundList(AdditionalBoundList, Object)"); }

        Object visitAdditionalBound(AdditionalBound n, [Object? o]){ return  unimplementedVisitor("visitAdditionalBound(AdditionalBound, Object)"); }

        Object visitTypeArguments(TypeArguments n, [Object? o]){ return  unimplementedVisitor("visitTypeArguments(TypeArguments, Object)"); }

        Object visitActualTypeArgumentList(ActualTypeArgumentList n, [Object? o]){ return  unimplementedVisitor("visitActualTypeArgumentList(ActualTypeArgumentList, Object)"); }

        Object visitWildcard(Wildcard n, [Object? o]){ return  unimplementedVisitor("visitWildcard(Wildcard, Object)"); }

        Object visitPackageName(PackageName n, [Object? o]){ return  unimplementedVisitor("visitPackageName(PackageName, Object)"); }

        Object visitExpressionName(ExpressionName n, [Object? o]){ return  unimplementedVisitor("visitExpressionName(ExpressionName, Object)"); }

        Object visitMethodName(MethodName n, [Object? o]){ return  unimplementedVisitor("visitMethodName(MethodName, Object)"); }

        Object visitPackageOrTypeName(PackageOrTypeName n, [Object? o]){ return  unimplementedVisitor("visitPackageOrTypeName(PackageOrTypeName, Object)"); }

        Object visitAmbiguousName(AmbiguousName n, [Object? o]){ return  unimplementedVisitor("visitAmbiguousName(AmbiguousName, Object)"); }

        Object visitCompilationUnit(CompilationUnit n, [Object? o]){ return  unimplementedVisitor("visitCompilationUnit(CompilationUnit, Object)"); }

        Object visitImportDeclarations(ImportDeclarations n, [Object? o]){ return  unimplementedVisitor("visitImportDeclarations(ImportDeclarations, Object)"); }

        Object visitTypeDeclarations(TypeDeclarations n, [Object? o]){ return  unimplementedVisitor("visitTypeDeclarations(TypeDeclarations, Object)"); }

        Object visitPackageDeclaration(PackageDeclaration n, [Object? o]){ return  unimplementedVisitor("visitPackageDeclaration(PackageDeclaration, Object)"); }

        Object visitSingleTypeImportDeclaration(SingleTypeImportDeclaration n, [Object? o]){ return  unimplementedVisitor("visitSingleTypeImportDeclaration(SingleTypeImportDeclaration, Object)"); }

        Object visitTypeImportOnDemandDeclaration(TypeImportOnDemandDeclaration n, [Object? o]){ return  unimplementedVisitor("visitTypeImportOnDemandDeclaration(TypeImportOnDemandDeclaration, Object)"); }

        Object visitSingleStaticImportDeclaration(SingleStaticImportDeclaration n, [Object? o]){ return  unimplementedVisitor("visitSingleStaticImportDeclaration(SingleStaticImportDeclaration, Object)"); }

        Object visitStaticImportOnDemandDeclaration(StaticImportOnDemandDeclaration n, [Object? o]){ return  unimplementedVisitor("visitStaticImportOnDemandDeclaration(StaticImportOnDemandDeclaration, Object)"); }

        Object visitTypeDeclaration(TypeDeclaration n, [Object? o]){ return  unimplementedVisitor("visitTypeDeclaration(TypeDeclaration, Object)"); }

        Object visitNormalClassDeclaration(NormalClassDeclaration n, [Object? o]){ return  unimplementedVisitor("visitNormalClassDeclaration(NormalClassDeclaration, Object)"); }

        Object visitClassModifiers(ClassModifiers n, [Object? o]){ return  unimplementedVisitor("visitClassModifiers(ClassModifiers, Object)"); }

        Object visitTypeParameters(TypeParameters n, [Object? o]){ return  unimplementedVisitor("visitTypeParameters(TypeParameters, Object)"); }

        Object visitTypeParameterList(TypeParameterList n, [Object? o]){ return  unimplementedVisitor("visitTypeParameterList(TypeParameterList, Object)"); }

        Object visitSuper(Super n, [Object? o]){ return  unimplementedVisitor("visitSuper(Super, Object)"); }

        Object visitInterfaces(Interfaces n, [Object? o]){ return  unimplementedVisitor("visitInterfaces(Interfaces, Object)"); }

        Object visitInterfaceTypeList(InterfaceTypeList n, [Object? o]){ return  unimplementedVisitor("visitInterfaceTypeList(InterfaceTypeList, Object)"); }

        Object visitClassBody(ClassBody n, [Object? o]){ return  unimplementedVisitor("visitClassBody(ClassBody, Object)"); }

        Object visitClassBodyDeclarations(ClassBodyDeclarations n, [Object? o]){ return  unimplementedVisitor("visitClassBodyDeclarations(ClassBodyDeclarations, Object)"); }

        Object visitClassMemberDeclaration(ClassMemberDeclaration n, [Object? o]){ return  unimplementedVisitor("visitClassMemberDeclaration(ClassMemberDeclaration, Object)"); }

        Object visitFieldDeclaration(FieldDeclaration n, [Object? o]){ return  unimplementedVisitor("visitFieldDeclaration(FieldDeclaration, Object)"); }

        Object visitVariableDeclarators(VariableDeclarators n, [Object? o]){ return  unimplementedVisitor("visitVariableDeclarators(VariableDeclarators, Object)"); }

        Object visitVariableDeclarator(VariableDeclarator n, [Object? o]){ return  unimplementedVisitor("visitVariableDeclarator(VariableDeclarator, Object)"); }

        Object visitVariableDeclaratorId(VariableDeclaratorId n, [Object? o]){ return  unimplementedVisitor("visitVariableDeclaratorId(VariableDeclaratorId, Object)"); }

        Object visitFieldModifiers(FieldModifiers n, [Object? o]){ return  unimplementedVisitor("visitFieldModifiers(FieldModifiers, Object)"); }

        Object visitMethodDeclaration(MethodDeclaration n, [Object? o]){ return  unimplementedVisitor("visitMethodDeclaration(MethodDeclaration, Object)"); }

        Object visitMethodHeader(MethodHeader n, [Object? o]){ return  unimplementedVisitor("visitMethodHeader(MethodHeader, Object)"); }

        Object visitResultType(ResultType n, [Object? o]){ return  unimplementedVisitor("visitResultType(ResultType, Object)"); }

        Object visitFormalParameterList(FormalParameterList n, [Object? o]){ return  unimplementedVisitor("visitFormalParameterList(FormalParameterList, Object)"); }

        Object visitFormalParameters(FormalParameters n, [Object? o]){ return  unimplementedVisitor("visitFormalParameters(FormalParameters, Object)"); }

        Object visitFormalParameter(FormalParameter n, [Object? o]){ return  unimplementedVisitor("visitFormalParameter(FormalParameter, Object)"); }

        Object visitVariableModifiers(VariableModifiers n, [Object? o]){ return  unimplementedVisitor("visitVariableModifiers(VariableModifiers, Object)"); }

        Object visitVariableModifier(VariableModifier n, [Object? o]){ return  unimplementedVisitor("visitVariableModifier(VariableModifier, Object)"); }

        Object visitLastFormalParameter(LastFormalParameter n, [Object? o]){ return  unimplementedVisitor("visitLastFormalParameter(LastFormalParameter, Object)"); }

        Object visitMethodModifiers(MethodModifiers n, [Object? o]){ return  unimplementedVisitor("visitMethodModifiers(MethodModifiers, Object)"); }

        Object visitThrows(Throws n, [Object? o]){ return  unimplementedVisitor("visitThrows(Throws, Object)"); }

        Object visitExceptionTypeList(ExceptionTypeList n, [Object? o]){ return  unimplementedVisitor("visitExceptionTypeList(ExceptionTypeList, Object)"); }

        Object visitMethodBody(MethodBody n, [Object? o]){ return  unimplementedVisitor("visitMethodBody(MethodBody, Object)"); }

        Object visitStaticInitializer(StaticInitializer n, [Object? o]){ return  unimplementedVisitor("visitStaticInitializer(StaticInitializer, Object)"); }

        Object visitConstructorDeclaration(ConstructorDeclaration n, [Object? o]){ return  unimplementedVisitor("visitConstructorDeclaration(ConstructorDeclaration, Object)"); }

        Object visitConstructorDeclarator(ConstructorDeclarator n, [Object? o]){ return  unimplementedVisitor("visitConstructorDeclarator(ConstructorDeclarator, Object)"); }

        Object visitConstructorModifiers(ConstructorModifiers n, [Object? o]){ return  unimplementedVisitor("visitConstructorModifiers(ConstructorModifiers, Object)"); }

        Object visitConstructorBody(ConstructorBody n, [Object? o]){ return  unimplementedVisitor("visitConstructorBody(ConstructorBody, Object)"); }

        Object visitEnumDeclaration(EnumDeclaration n, [Object? o]){ return  unimplementedVisitor("visitEnumDeclaration(EnumDeclaration, Object)"); }

        Object visitEnumBody(EnumBody n, [Object? o]){ return  unimplementedVisitor("visitEnumBody(EnumBody, Object)"); }

        Object visitEnumConstants(EnumConstants n, [Object? o]){ return  unimplementedVisitor("visitEnumConstants(EnumConstants, Object)"); }

        Object visitEnumConstant(EnumConstant n, [Object? o]){ return  unimplementedVisitor("visitEnumConstant(EnumConstant, Object)"); }

        Object visitArguments(Arguments n, [Object? o]){ return  unimplementedVisitor("visitArguments(Arguments, Object)"); }

        Object visitEnumBodyDeclarations(EnumBodyDeclarations n, [Object? o]){ return  unimplementedVisitor("visitEnumBodyDeclarations(EnumBodyDeclarations, Object)"); }

        Object visitNormalInterfaceDeclaration(NormalInterfaceDeclaration n, [Object? o]){ return  unimplementedVisitor("visitNormalInterfaceDeclaration(NormalInterfaceDeclaration, Object)"); }

        Object visitInterfaceModifiers(InterfaceModifiers n, [Object? o]){ return  unimplementedVisitor("visitInterfaceModifiers(InterfaceModifiers, Object)"); }

        Object visitInterfaceBody(InterfaceBody n, [Object? o]){ return  unimplementedVisitor("visitInterfaceBody(InterfaceBody, Object)"); }

        Object visitInterfaceMemberDeclarations(InterfaceMemberDeclarations n, [Object? o]){ return  unimplementedVisitor("visitInterfaceMemberDeclarations(InterfaceMemberDeclarations, Object)"); }

        Object visitInterfaceMemberDeclaration(InterfaceMemberDeclaration n, [Object? o]){ return  unimplementedVisitor("visitInterfaceMemberDeclaration(InterfaceMemberDeclaration, Object)"); }

        Object visitConstantDeclaration(ConstantDeclaration n, [Object? o]){ return  unimplementedVisitor("visitConstantDeclaration(ConstantDeclaration, Object)"); }

        Object visitConstantModifiers(ConstantModifiers n, [Object? o]){ return  unimplementedVisitor("visitConstantModifiers(ConstantModifiers, Object)"); }

        Object visitAbstractMethodDeclaration(AbstractMethodDeclaration n, [Object? o]){ return  unimplementedVisitor("visitAbstractMethodDeclaration(AbstractMethodDeclaration, Object)"); }

        Object visitAbstractMethodModifiers(AbstractMethodModifiers n, [Object? o]){ return  unimplementedVisitor("visitAbstractMethodModifiers(AbstractMethodModifiers, Object)"); }

        Object visitAnnotationTypeDeclaration(AnnotationTypeDeclaration n, [Object? o]){ return  unimplementedVisitor("visitAnnotationTypeDeclaration(AnnotationTypeDeclaration, Object)"); }

        Object visitAnnotationTypeBody(AnnotationTypeBody n, [Object? o]){ return  unimplementedVisitor("visitAnnotationTypeBody(AnnotationTypeBody, Object)"); }

        Object visitAnnotationTypeElementDeclarations(AnnotationTypeElementDeclarations n, [Object? o]){ return  unimplementedVisitor("visitAnnotationTypeElementDeclarations(AnnotationTypeElementDeclarations, Object)"); }

        Object visitDefaultValue(DefaultValue n, [Object? o]){ return  unimplementedVisitor("visitDefaultValue(DefaultValue, Object)"); }

        Object visitAnnotations(Annotations n, [Object? o]){ return  unimplementedVisitor("visitAnnotations(Annotations, Object)"); }

        Object visitNormalAnnotation(NormalAnnotation n, [Object? o]){ return  unimplementedVisitor("visitNormalAnnotation(NormalAnnotation, Object)"); }

        Object visitElementValuePairs(ElementValuePairs n, [Object? o]){ return  unimplementedVisitor("visitElementValuePairs(ElementValuePairs, Object)"); }

        Object visitElementValuePair(ElementValuePair n, [Object? o]){ return  unimplementedVisitor("visitElementValuePair(ElementValuePair, Object)"); }

        Object visitElementValueArrayInitializer(ElementValueArrayInitializer n, [Object? o]){ return  unimplementedVisitor("visitElementValueArrayInitializer(ElementValueArrayInitializer, Object)"); }

        Object visitElementValues(ElementValues n, [Object? o]){ return  unimplementedVisitor("visitElementValues(ElementValues, Object)"); }

        Object visitMarkerAnnotation(MarkerAnnotation n, [Object? o]){ return  unimplementedVisitor("visitMarkerAnnotation(MarkerAnnotation, Object)"); }

        Object visitSingleElementAnnotation(SingleElementAnnotation n, [Object? o]){ return  unimplementedVisitor("visitSingleElementAnnotation(SingleElementAnnotation, Object)"); }

        Object visitArrayInitializer(ArrayInitializer n, [Object? o]){ return  unimplementedVisitor("visitArrayInitializer(ArrayInitializer, Object)"); }

        Object visitVariableInitializers(VariableInitializers n, [Object? o]){ return  unimplementedVisitor("visitVariableInitializers(VariableInitializers, Object)"); }

        Object visitBlock(Block n, [Object? o]){ return  unimplementedVisitor("visitBlock(Block, Object)"); }

        Object visitBlockStatements(BlockStatements n, [Object? o]){ return  unimplementedVisitor("visitBlockStatements(BlockStatements, Object)"); }

        Object visitLocalVariableDeclarationStatement(LocalVariableDeclarationStatement n, [Object? o]){ return  unimplementedVisitor("visitLocalVariableDeclarationStatement(LocalVariableDeclarationStatement, Object)"); }

        Object visitLocalVariableDeclaration(LocalVariableDeclaration n, [Object? o]){ return  unimplementedVisitor("visitLocalVariableDeclaration(LocalVariableDeclaration, Object)"); }

        Object visitIfThenStatement(IfThenStatement n, [Object? o]){ return  unimplementedVisitor("visitIfThenStatement(IfThenStatement, Object)"); }

        Object visitIfThenElseStatement(IfThenElseStatement n, [Object? o]){ return  unimplementedVisitor("visitIfThenElseStatement(IfThenElseStatement, Object)"); }

        Object visitIfThenElseStatementNoShortIf(IfThenElseStatementNoShortIf n, [Object? o]){ return  unimplementedVisitor("visitIfThenElseStatementNoShortIf(IfThenElseStatementNoShortIf, Object)"); }

        Object visitEmptyStatement(EmptyStatement n, [Object? o]){ return  unimplementedVisitor("visitEmptyStatement(EmptyStatement, Object)"); }

        Object visitLabeledStatement(LabeledStatement n, [Object? o]){ return  unimplementedVisitor("visitLabeledStatement(LabeledStatement, Object)"); }

        Object visitLabeledStatementNoShortIf(LabeledStatementNoShortIf n, [Object? o]){ return  unimplementedVisitor("visitLabeledStatementNoShortIf(LabeledStatementNoShortIf, Object)"); }

        Object visitExpressionStatement(ExpressionStatement n, [Object? o]){ return  unimplementedVisitor("visitExpressionStatement(ExpressionStatement, Object)"); }

        Object visitSwitchStatement(SwitchStatement n, [Object? o]){ return  unimplementedVisitor("visitSwitchStatement(SwitchStatement, Object)"); }

        Object visitSwitchBlock(SwitchBlock n, [Object? o]){ return  unimplementedVisitor("visitSwitchBlock(SwitchBlock, Object)"); }

        Object visitSwitchBlockStatementGroups(SwitchBlockStatementGroups n, [Object? o]){ return  unimplementedVisitor("visitSwitchBlockStatementGroups(SwitchBlockStatementGroups, Object)"); }

        Object visitSwitchBlockStatementGroup(SwitchBlockStatementGroup n, [Object? o]){ return  unimplementedVisitor("visitSwitchBlockStatementGroup(SwitchBlockStatementGroup, Object)"); }

        Object visitSwitchLabels(SwitchLabels n, [Object? o]){ return  unimplementedVisitor("visitSwitchLabels(SwitchLabels, Object)"); }

        Object visitWhileStatement(WhileStatement n, [Object? o]){ return  unimplementedVisitor("visitWhileStatement(WhileStatement, Object)"); }

        Object visitWhileStatementNoShortIf(WhileStatementNoShortIf n, [Object? o]){ return  unimplementedVisitor("visitWhileStatementNoShortIf(WhileStatementNoShortIf, Object)"); }

        Object visitDoStatement(DoStatement n, [Object? o]){ return  unimplementedVisitor("visitDoStatement(DoStatement, Object)"); }

        Object visitBasicForStatement(BasicForStatement n, [Object? o]){ return  unimplementedVisitor("visitBasicForStatement(BasicForStatement, Object)"); }

        Object visitForStatementNoShortIf(ForStatementNoShortIf n, [Object? o]){ return  unimplementedVisitor("visitForStatementNoShortIf(ForStatementNoShortIf, Object)"); }

        Object visitStatementExpressionList(StatementExpressionList n, [Object? o]){ return  unimplementedVisitor("visitStatementExpressionList(StatementExpressionList, Object)"); }

        Object visitEnhancedForStatement(EnhancedForStatement n, [Object? o]){ return  unimplementedVisitor("visitEnhancedForStatement(EnhancedForStatement, Object)"); }

        Object visitBreakStatement(BreakStatement n, [Object? o]){ return  unimplementedVisitor("visitBreakStatement(BreakStatement, Object)"); }

        Object visitContinueStatement(ContinueStatement n, [Object? o]){ return  unimplementedVisitor("visitContinueStatement(ContinueStatement, Object)"); }

        Object visitReturnStatement(ReturnStatement n, [Object? o]){ return  unimplementedVisitor("visitReturnStatement(ReturnStatement, Object)"); }

        Object visitThrowStatement(ThrowStatement n, [Object? o]){ return  unimplementedVisitor("visitThrowStatement(ThrowStatement, Object)"); }

        Object visitSynchronizedStatement(SynchronizedStatement n, [Object? o]){ return  unimplementedVisitor("visitSynchronizedStatement(SynchronizedStatement, Object)"); }

        Object visitCatches(Catches n, [Object? o]){ return  unimplementedVisitor("visitCatches(Catches, Object)"); }

        Object visitCatchClause(CatchClause n, [Object? o]){ return  unimplementedVisitor("visitCatchClause(CatchClause, Object)"); }

        Object visitFinally(Finally n, [Object? o]){ return  unimplementedVisitor("visitFinally(Finally, Object)"); }

        Object visitArgumentList(ArgumentList n, [Object? o]){ return  unimplementedVisitor("visitArgumentList(ArgumentList, Object)"); }

        Object visitDimExprs(DimExprs n, [Object? o]){ return  unimplementedVisitor("visitDimExprs(DimExprs, Object)"); }

        Object visitDimExpr(DimExpr n, [Object? o]){ return  unimplementedVisitor("visitDimExpr(DimExpr, Object)"); }

        Object visitPostIncrementExpression(PostIncrementExpression n, [Object? o]){ return  unimplementedVisitor("visitPostIncrementExpression(PostIncrementExpression, Object)"); }

        Object visitPostDecrementExpression(PostDecrementExpression n, [Object? o]){ return  unimplementedVisitor("visitPostDecrementExpression(PostDecrementExpression, Object)"); }

        Object visitPreIncrementExpression(PreIncrementExpression n, [Object? o]){ return  unimplementedVisitor("visitPreIncrementExpression(PreIncrementExpression, Object)"); }

        Object visitPreDecrementExpression(PreDecrementExpression n, [Object? o]){ return  unimplementedVisitor("visitPreDecrementExpression(PreDecrementExpression, Object)"); }

        Object visitAndExpression(AndExpression n, [Object? o]){ return  unimplementedVisitor("visitAndExpression(AndExpression, Object)"); }

        Object visitExclusiveOrExpression(ExclusiveOrExpression n, [Object? o]){ return  unimplementedVisitor("visitExclusiveOrExpression(ExclusiveOrExpression, Object)"); }

        Object visitInclusiveOrExpression(InclusiveOrExpression n, [Object? o]){ return  unimplementedVisitor("visitInclusiveOrExpression(InclusiveOrExpression, Object)"); }

        Object visitConditionalAndExpression(ConditionalAndExpression n, [Object? o]){ return  unimplementedVisitor("visitConditionalAndExpression(ConditionalAndExpression, Object)"); }

        Object visitConditionalOrExpression(ConditionalOrExpression n, [Object? o]){ return  unimplementedVisitor("visitConditionalOrExpression(ConditionalOrExpression, Object)"); }

        Object visitConditionalExpression(ConditionalExpression n, [Object? o]){ return  unimplementedVisitor("visitConditionalExpression(ConditionalExpression, Object)"); }

        Object visitAssignment(Assignment n, [Object? o]){ return  unimplementedVisitor("visitAssignment(Assignment, Object)"); }

        Object visitCommaopt(Commaopt n, [Object? o]){ return  unimplementedVisitor("visitCommaopt(Commaopt, Object)"); }

        Object visitEllipsisopt(Ellipsisopt n, [Object? o]){ return  unimplementedVisitor("visitEllipsisopt(Ellipsisopt, Object)"); }

        Object visitLPGUserAction0(LPGUserAction0 n, [Object? o]){ return  unimplementedVisitor("visitLPGUserAction0(LPGUserAction0, Object)"); }

        Object visitLPGUserAction1(LPGUserAction1 n, [Object? o]){ return  unimplementedVisitor("visitLPGUserAction1(LPGUserAction1, Object)"); }

        Object visitLPGUserAction2(LPGUserAction2 n, [Object? o]){ return  unimplementedVisitor("visitLPGUserAction2(LPGUserAction2, Object)"); }

        Object visitLPGUserAction3(LPGUserAction3 n, [Object? o]){ return  unimplementedVisitor("visitLPGUserAction3(LPGUserAction3, Object)"); }

        Object visitLPGUserAction4(LPGUserAction4 n, [Object? o]){ return  unimplementedVisitor("visitLPGUserAction4(LPGUserAction4, Object)"); }

        Object visitIntegralType0(IntegralType0 n, [Object? o]){ return  unimplementedVisitor("visitIntegralType0(IntegralType0, Object)"); }

        Object visitIntegralType1(IntegralType1 n, [Object? o]){ return  unimplementedVisitor("visitIntegralType1(IntegralType1, Object)"); }

        Object visitIntegralType2(IntegralType2 n, [Object? o]){ return  unimplementedVisitor("visitIntegralType2(IntegralType2, Object)"); }

        Object visitIntegralType3(IntegralType3 n, [Object? o]){ return  unimplementedVisitor("visitIntegralType3(IntegralType3, Object)"); }

        Object visitIntegralType4(IntegralType4 n, [Object? o]){ return  unimplementedVisitor("visitIntegralType4(IntegralType4, Object)"); }

        Object visitFloatingPointType0(FloatingPointType0 n, [Object? o]){ return  unimplementedVisitor("visitFloatingPointType0(FloatingPointType0, Object)"); }

        Object visitFloatingPointType1(FloatingPointType1 n, [Object? o]){ return  unimplementedVisitor("visitFloatingPointType1(FloatingPointType1, Object)"); }

        Object visitWildcardBounds0(WildcardBounds0 n, [Object? o]){ return  unimplementedVisitor("visitWildcardBounds0(WildcardBounds0, Object)"); }

        Object visitWildcardBounds1(WildcardBounds1 n, [Object? o]){ return  unimplementedVisitor("visitWildcardBounds1(WildcardBounds1, Object)"); }

        Object visitClassModifier0(ClassModifier0 n, [Object? o]){ return  unimplementedVisitor("visitClassModifier0(ClassModifier0, Object)"); }

        Object visitClassModifier1(ClassModifier1 n, [Object? o]){ return  unimplementedVisitor("visitClassModifier1(ClassModifier1, Object)"); }

        Object visitClassModifier2(ClassModifier2 n, [Object? o]){ return  unimplementedVisitor("visitClassModifier2(ClassModifier2, Object)"); }

        Object visitClassModifier3(ClassModifier3 n, [Object? o]){ return  unimplementedVisitor("visitClassModifier3(ClassModifier3, Object)"); }

        Object visitClassModifier4(ClassModifier4 n, [Object? o]){ return  unimplementedVisitor("visitClassModifier4(ClassModifier4, Object)"); }

        Object visitClassModifier5(ClassModifier5 n, [Object? o]){ return  unimplementedVisitor("visitClassModifier5(ClassModifier5, Object)"); }

        Object visitClassModifier6(ClassModifier6 n, [Object? o]){ return  unimplementedVisitor("visitClassModifier6(ClassModifier6, Object)"); }

        Object visitFieldModifier0(FieldModifier0 n, [Object? o]){ return  unimplementedVisitor("visitFieldModifier0(FieldModifier0, Object)"); }

        Object visitFieldModifier1(FieldModifier1 n, [Object? o]){ return  unimplementedVisitor("visitFieldModifier1(FieldModifier1, Object)"); }

        Object visitFieldModifier2(FieldModifier2 n, [Object? o]){ return  unimplementedVisitor("visitFieldModifier2(FieldModifier2, Object)"); }

        Object visitFieldModifier3(FieldModifier3 n, [Object? o]){ return  unimplementedVisitor("visitFieldModifier3(FieldModifier3, Object)"); }

        Object visitFieldModifier4(FieldModifier4 n, [Object? o]){ return  unimplementedVisitor("visitFieldModifier4(FieldModifier4, Object)"); }

        Object visitFieldModifier5(FieldModifier5 n, [Object? o]){ return  unimplementedVisitor("visitFieldModifier5(FieldModifier5, Object)"); }

        Object visitFieldModifier6(FieldModifier6 n, [Object? o]){ return  unimplementedVisitor("visitFieldModifier6(FieldModifier6, Object)"); }

        Object visitMethodDeclarator0(MethodDeclarator0 n, [Object? o]){ return  unimplementedVisitor("visitMethodDeclarator0(MethodDeclarator0, Object)"); }

        Object visitMethodDeclarator1(MethodDeclarator1 n, [Object? o]){ return  unimplementedVisitor("visitMethodDeclarator1(MethodDeclarator1, Object)"); }

        Object visitMethodModifier0(MethodModifier0 n, [Object? o]){ return  unimplementedVisitor("visitMethodModifier0(MethodModifier0, Object)"); }

        Object visitMethodModifier1(MethodModifier1 n, [Object? o]){ return  unimplementedVisitor("visitMethodModifier1(MethodModifier1, Object)"); }

        Object visitMethodModifier2(MethodModifier2 n, [Object? o]){ return  unimplementedVisitor("visitMethodModifier2(MethodModifier2, Object)"); }

        Object visitMethodModifier3(MethodModifier3 n, [Object? o]){ return  unimplementedVisitor("visitMethodModifier3(MethodModifier3, Object)"); }

        Object visitMethodModifier4(MethodModifier4 n, [Object? o]){ return  unimplementedVisitor("visitMethodModifier4(MethodModifier4, Object)"); }

        Object visitMethodModifier5(MethodModifier5 n, [Object? o]){ return  unimplementedVisitor("visitMethodModifier5(MethodModifier5, Object)"); }

        Object visitMethodModifier6(MethodModifier6 n, [Object? o]){ return  unimplementedVisitor("visitMethodModifier6(MethodModifier6, Object)"); }

        Object visitMethodModifier7(MethodModifier7 n, [Object? o]){ return  unimplementedVisitor("visitMethodModifier7(MethodModifier7, Object)"); }

        Object visitMethodModifier8(MethodModifier8 n, [Object? o]){ return  unimplementedVisitor("visitMethodModifier8(MethodModifier8, Object)"); }

        Object visitConstructorModifier0(ConstructorModifier0 n, [Object? o]){ return  unimplementedVisitor("visitConstructorModifier0(ConstructorModifier0, Object)"); }

        Object visitConstructorModifier1(ConstructorModifier1 n, [Object? o]){ return  unimplementedVisitor("visitConstructorModifier1(ConstructorModifier1, Object)"); }

        Object visitConstructorModifier2(ConstructorModifier2 n, [Object? o]){ return  unimplementedVisitor("visitConstructorModifier2(ConstructorModifier2, Object)"); }

        Object visitExplicitConstructorInvocation0(ExplicitConstructorInvocation0 n, [Object? o]){ return  unimplementedVisitor("visitExplicitConstructorInvocation0(ExplicitConstructorInvocation0, Object)"); }

        Object visitExplicitConstructorInvocation1(ExplicitConstructorInvocation1 n, [Object? o]){ return  unimplementedVisitor("visitExplicitConstructorInvocation1(ExplicitConstructorInvocation1, Object)"); }

        Object visitExplicitConstructorInvocation2(ExplicitConstructorInvocation2 n, [Object? o]){ return  unimplementedVisitor("visitExplicitConstructorInvocation2(ExplicitConstructorInvocation2, Object)"); }

        Object visitInterfaceModifier0(InterfaceModifier0 n, [Object? o]){ return  unimplementedVisitor("visitInterfaceModifier0(InterfaceModifier0, Object)"); }

        Object visitInterfaceModifier1(InterfaceModifier1 n, [Object? o]){ return  unimplementedVisitor("visitInterfaceModifier1(InterfaceModifier1, Object)"); }

        Object visitInterfaceModifier2(InterfaceModifier2 n, [Object? o]){ return  unimplementedVisitor("visitInterfaceModifier2(InterfaceModifier2, Object)"); }

        Object visitInterfaceModifier3(InterfaceModifier3 n, [Object? o]){ return  unimplementedVisitor("visitInterfaceModifier3(InterfaceModifier3, Object)"); }

        Object visitInterfaceModifier4(InterfaceModifier4 n, [Object? o]){ return  unimplementedVisitor("visitInterfaceModifier4(InterfaceModifier4, Object)"); }

        Object visitInterfaceModifier5(InterfaceModifier5 n, [Object? o]){ return  unimplementedVisitor("visitInterfaceModifier5(InterfaceModifier5, Object)"); }

        Object visitExtendsInterfaces0(ExtendsInterfaces0 n, [Object? o]){ return  unimplementedVisitor("visitExtendsInterfaces0(ExtendsInterfaces0, Object)"); }

        Object visitExtendsInterfaces1(ExtendsInterfaces1 n, [Object? o]){ return  unimplementedVisitor("visitExtendsInterfaces1(ExtendsInterfaces1, Object)"); }

        Object visitConstantModifier0(ConstantModifier0 n, [Object? o]){ return  unimplementedVisitor("visitConstantModifier0(ConstantModifier0, Object)"); }

        Object visitConstantModifier1(ConstantModifier1 n, [Object? o]){ return  unimplementedVisitor("visitConstantModifier1(ConstantModifier1, Object)"); }

        Object visitConstantModifier2(ConstantModifier2 n, [Object? o]){ return  unimplementedVisitor("visitConstantModifier2(ConstantModifier2, Object)"); }

        Object visitAbstractMethodModifier0(AbstractMethodModifier0 n, [Object? o]){ return  unimplementedVisitor("visitAbstractMethodModifier0(AbstractMethodModifier0, Object)"); }

        Object visitAbstractMethodModifier1(AbstractMethodModifier1 n, [Object? o]){ return  unimplementedVisitor("visitAbstractMethodModifier1(AbstractMethodModifier1, Object)"); }

        Object visitAnnotationTypeElementDeclaration0(AnnotationTypeElementDeclaration0 n, [Object? o]){ return  unimplementedVisitor("visitAnnotationTypeElementDeclaration0(AnnotationTypeElementDeclaration0, Object)"); }

        Object visitAnnotationTypeElementDeclaration1(AnnotationTypeElementDeclaration1 n, [Object? o]){ return  unimplementedVisitor("visitAnnotationTypeElementDeclaration1(AnnotationTypeElementDeclaration1, Object)"); }

        Object visitAssertStatement0(AssertStatement0 n, [Object? o]){ return  unimplementedVisitor("visitAssertStatement0(AssertStatement0, Object)"); }

        Object visitAssertStatement1(AssertStatement1 n, [Object? o]){ return  unimplementedVisitor("visitAssertStatement1(AssertStatement1, Object)"); }

        Object visitSwitchLabel0(SwitchLabel0 n, [Object? o]){ return  unimplementedVisitor("visitSwitchLabel0(SwitchLabel0, Object)"); }

        Object visitSwitchLabel1(SwitchLabel1 n, [Object? o]){ return  unimplementedVisitor("visitSwitchLabel1(SwitchLabel1, Object)"); }

        Object visitSwitchLabel2(SwitchLabel2 n, [Object? o]){ return  unimplementedVisitor("visitSwitchLabel2(SwitchLabel2, Object)"); }

        Object visitTryStatement0(TryStatement0 n, [Object? o]){ return  unimplementedVisitor("visitTryStatement0(TryStatement0, Object)"); }

        Object visitTryStatement1(TryStatement1 n, [Object? o]){ return  unimplementedVisitor("visitTryStatement1(TryStatement1, Object)"); }

        Object visitPrimaryNoNewArray0(PrimaryNoNewArray0 n, [Object? o]){ return  unimplementedVisitor("visitPrimaryNoNewArray0(PrimaryNoNewArray0, Object)"); }

        Object visitPrimaryNoNewArray1(PrimaryNoNewArray1 n, [Object? o]){ return  unimplementedVisitor("visitPrimaryNoNewArray1(PrimaryNoNewArray1, Object)"); }

        Object visitPrimaryNoNewArray2(PrimaryNoNewArray2 n, [Object? o]){ return  unimplementedVisitor("visitPrimaryNoNewArray2(PrimaryNoNewArray2, Object)"); }

        Object visitPrimaryNoNewArray3(PrimaryNoNewArray3 n, [Object? o]){ return  unimplementedVisitor("visitPrimaryNoNewArray3(PrimaryNoNewArray3, Object)"); }

        Object visitPrimaryNoNewArray4(PrimaryNoNewArray4 n, [Object? o]){ return  unimplementedVisitor("visitPrimaryNoNewArray4(PrimaryNoNewArray4, Object)"); }

        Object visitLiteral0(Literal0 n, [Object? o]){ return  unimplementedVisitor("visitLiteral0(Literal0, Object)"); }

        Object visitLiteral1(Literal1 n, [Object? o]){ return  unimplementedVisitor("visitLiteral1(Literal1, Object)"); }

        Object visitLiteral2(Literal2 n, [Object? o]){ return  unimplementedVisitor("visitLiteral2(Literal2, Object)"); }

        Object visitLiteral3(Literal3 n, [Object? o]){ return  unimplementedVisitor("visitLiteral3(Literal3, Object)"); }

        Object visitLiteral4(Literal4 n, [Object? o]){ return  unimplementedVisitor("visitLiteral4(Literal4, Object)"); }

        Object visitLiteral5(Literal5 n, [Object? o]){ return  unimplementedVisitor("visitLiteral5(Literal5, Object)"); }

        Object visitLiteral6(Literal6 n, [Object? o]){ return  unimplementedVisitor("visitLiteral6(Literal6, Object)"); }

        Object visitBooleanLiteral0(BooleanLiteral0 n, [Object? o]){ return  unimplementedVisitor("visitBooleanLiteral0(BooleanLiteral0, Object)"); }

        Object visitBooleanLiteral1(BooleanLiteral1 n, [Object? o]){ return  unimplementedVisitor("visitBooleanLiteral1(BooleanLiteral1, Object)"); }

        Object visitClassInstanceCreationExpression0(ClassInstanceCreationExpression0 n, [Object? o]){ return  unimplementedVisitor("visitClassInstanceCreationExpression0(ClassInstanceCreationExpression0, Object)"); }

        Object visitClassInstanceCreationExpression1(ClassInstanceCreationExpression1 n, [Object? o]){ return  unimplementedVisitor("visitClassInstanceCreationExpression1(ClassInstanceCreationExpression1, Object)"); }

        Object visitArrayCreationExpression0(ArrayCreationExpression0 n, [Object? o]){ return  unimplementedVisitor("visitArrayCreationExpression0(ArrayCreationExpression0, Object)"); }

        Object visitArrayCreationExpression1(ArrayCreationExpression1 n, [Object? o]){ return  unimplementedVisitor("visitArrayCreationExpression1(ArrayCreationExpression1, Object)"); }

        Object visitArrayCreationExpression2(ArrayCreationExpression2 n, [Object? o]){ return  unimplementedVisitor("visitArrayCreationExpression2(ArrayCreationExpression2, Object)"); }

        Object visitArrayCreationExpression3(ArrayCreationExpression3 n, [Object? o]){ return  unimplementedVisitor("visitArrayCreationExpression3(ArrayCreationExpression3, Object)"); }

        Object visitDims0(Dims0 n, [Object? o]){ return  unimplementedVisitor("visitDims0(Dims0, Object)"); }

        Object visitDims1(Dims1 n, [Object? o]){ return  unimplementedVisitor("visitDims1(Dims1, Object)"); }

        Object visitFieldAccess0(FieldAccess0 n, [Object? o]){ return  unimplementedVisitor("visitFieldAccess0(FieldAccess0, Object)"); }

        Object visitFieldAccess1(FieldAccess1 n, [Object? o]){ return  unimplementedVisitor("visitFieldAccess1(FieldAccess1, Object)"); }

        Object visitFieldAccess2(FieldAccess2 n, [Object? o]){ return  unimplementedVisitor("visitFieldAccess2(FieldAccess2, Object)"); }

        Object visitMethodInvocation0(MethodInvocation0 n, [Object? o]){ return  unimplementedVisitor("visitMethodInvocation0(MethodInvocation0, Object)"); }

        Object visitMethodInvocation1(MethodInvocation1 n, [Object? o]){ return  unimplementedVisitor("visitMethodInvocation1(MethodInvocation1, Object)"); }

        Object visitMethodInvocation2(MethodInvocation2 n, [Object? o]){ return  unimplementedVisitor("visitMethodInvocation2(MethodInvocation2, Object)"); }

        Object visitMethodInvocation3(MethodInvocation3 n, [Object? o]){ return  unimplementedVisitor("visitMethodInvocation3(MethodInvocation3, Object)"); }

        Object visitMethodInvocation4(MethodInvocation4 n, [Object? o]){ return  unimplementedVisitor("visitMethodInvocation4(MethodInvocation4, Object)"); }

        Object visitArrayAccess0(ArrayAccess0 n, [Object? o]){ return  unimplementedVisitor("visitArrayAccess0(ArrayAccess0, Object)"); }

        Object visitArrayAccess1(ArrayAccess1 n, [Object? o]){ return  unimplementedVisitor("visitArrayAccess1(ArrayAccess1, Object)"); }

        Object visitUnaryExpression0(UnaryExpression0 n, [Object? o]){ return  unimplementedVisitor("visitUnaryExpression0(UnaryExpression0, Object)"); }

        Object visitUnaryExpression1(UnaryExpression1 n, [Object? o]){ return  unimplementedVisitor("visitUnaryExpression1(UnaryExpression1, Object)"); }

        Object visitUnaryExpressionNotPlusMinus0(UnaryExpressionNotPlusMinus0 n, [Object? o]){ return  unimplementedVisitor("visitUnaryExpressionNotPlusMinus0(UnaryExpressionNotPlusMinus0, Object)"); }

        Object visitUnaryExpressionNotPlusMinus1(UnaryExpressionNotPlusMinus1 n, [Object? o]){ return  unimplementedVisitor("visitUnaryExpressionNotPlusMinus1(UnaryExpressionNotPlusMinus1, Object)"); }

        Object visitCastExpression0(CastExpression0 n, [Object? o]){ return  unimplementedVisitor("visitCastExpression0(CastExpression0, Object)"); }

        Object visitCastExpression1(CastExpression1 n, [Object? o]){ return  unimplementedVisitor("visitCastExpression1(CastExpression1, Object)"); }

        Object visitMultiplicativeExpression0(MultiplicativeExpression0 n, [Object? o]){ return  unimplementedVisitor("visitMultiplicativeExpression0(MultiplicativeExpression0, Object)"); }

        Object visitMultiplicativeExpression1(MultiplicativeExpression1 n, [Object? o]){ return  unimplementedVisitor("visitMultiplicativeExpression1(MultiplicativeExpression1, Object)"); }

        Object visitMultiplicativeExpression2(MultiplicativeExpression2 n, [Object? o]){ return  unimplementedVisitor("visitMultiplicativeExpression2(MultiplicativeExpression2, Object)"); }

        Object visitAdditiveExpression0(AdditiveExpression0 n, [Object? o]){ return  unimplementedVisitor("visitAdditiveExpression0(AdditiveExpression0, Object)"); }

        Object visitAdditiveExpression1(AdditiveExpression1 n, [Object? o]){ return  unimplementedVisitor("visitAdditiveExpression1(AdditiveExpression1, Object)"); }

        Object visitShiftExpression0(ShiftExpression0 n, [Object? o]){ return  unimplementedVisitor("visitShiftExpression0(ShiftExpression0, Object)"); }

        Object visitShiftExpression1(ShiftExpression1 n, [Object? o]){ return  unimplementedVisitor("visitShiftExpression1(ShiftExpression1, Object)"); }

        Object visitShiftExpression2(ShiftExpression2 n, [Object? o]){ return  unimplementedVisitor("visitShiftExpression2(ShiftExpression2, Object)"); }

        Object visitRelationalExpression0(RelationalExpression0 n, [Object? o]){ return  unimplementedVisitor("visitRelationalExpression0(RelationalExpression0, Object)"); }

        Object visitRelationalExpression1(RelationalExpression1 n, [Object? o]){ return  unimplementedVisitor("visitRelationalExpression1(RelationalExpression1, Object)"); }

        Object visitRelationalExpression2(RelationalExpression2 n, [Object? o]){ return  unimplementedVisitor("visitRelationalExpression2(RelationalExpression2, Object)"); }

        Object visitRelationalExpression3(RelationalExpression3 n, [Object? o]){ return  unimplementedVisitor("visitRelationalExpression3(RelationalExpression3, Object)"); }

        Object visitRelationalExpression4(RelationalExpression4 n, [Object? o]){ return  unimplementedVisitor("visitRelationalExpression4(RelationalExpression4, Object)"); }

        Object visitEqualityExpression0(EqualityExpression0 n, [Object? o]){ return  unimplementedVisitor("visitEqualityExpression0(EqualityExpression0, Object)"); }

        Object visitEqualityExpression1(EqualityExpression1 n, [Object? o]){ return  unimplementedVisitor("visitEqualityExpression1(EqualityExpression1, Object)"); }

        Object visitAssignmentOperator0(AssignmentOperator0 n, [Object? o]){ return  unimplementedVisitor("visitAssignmentOperator0(AssignmentOperator0, Object)"); }

        Object visitAssignmentOperator1(AssignmentOperator1 n, [Object? o]){ return  unimplementedVisitor("visitAssignmentOperator1(AssignmentOperator1, Object)"); }

        Object visitAssignmentOperator2(AssignmentOperator2 n, [Object? o]){ return  unimplementedVisitor("visitAssignmentOperator2(AssignmentOperator2, Object)"); }

        Object visitAssignmentOperator3(AssignmentOperator3 n, [Object? o]){ return  unimplementedVisitor("visitAssignmentOperator3(AssignmentOperator3, Object)"); }

        Object visitAssignmentOperator4(AssignmentOperator4 n, [Object? o]){ return  unimplementedVisitor("visitAssignmentOperator4(AssignmentOperator4, Object)"); }

        Object visitAssignmentOperator5(AssignmentOperator5 n, [Object? o]){ return  unimplementedVisitor("visitAssignmentOperator5(AssignmentOperator5, Object)"); }

        Object visitAssignmentOperator6(AssignmentOperator6 n, [Object? o]){ return  unimplementedVisitor("visitAssignmentOperator6(AssignmentOperator6, Object)"); }

        Object visitAssignmentOperator7(AssignmentOperator7 n, [Object? o]){ return  unimplementedVisitor("visitAssignmentOperator7(AssignmentOperator7, Object)"); }

        Object visitAssignmentOperator8(AssignmentOperator8 n, [Object? o]){ return  unimplementedVisitor("visitAssignmentOperator8(AssignmentOperator8, Object)"); }

        Object visitAssignmentOperator9(AssignmentOperator9 n, [Object? o]){ return  unimplementedVisitor("visitAssignmentOperator9(AssignmentOperator9, Object)"); }

        Object visitAssignmentOperator10(AssignmentOperator10 n, [Object? o]){ return  unimplementedVisitor("visitAssignmentOperator10(AssignmentOperator10, Object)"); }

        Object visitAssignmentOperator11(AssignmentOperator11 n, [Object? o]){ return  unimplementedVisitor("visitAssignmentOperator11(AssignmentOperator11, Object)"); }


        Object visit(Ast n, [Object? o])
        {
            if (n is AstToken) return visitAstToken(n, o);
            else if (n is identifier) return visitidentifier(n, o);
            else if (n is PrimitiveType) return visitPrimitiveType(n, o);
            else if (n is ClassType) return visitClassType(n, o);
            else if (n is InterfaceType) return visitInterfaceType(n, o);
            else if (n is TypeName) return visitTypeName(n, o);
            else if (n is ArrayType) return visitArrayType(n, o);
            else if (n is TypeParameter) return visitTypeParameter(n, o);
            else if (n is TypeBound) return visitTypeBound(n, o);
            else if (n is AdditionalBoundList) return visitAdditionalBoundList(n, o);
            else if (n is AdditionalBound) return visitAdditionalBound(n, o);
            else if (n is TypeArguments) return visitTypeArguments(n, o);
            else if (n is ActualTypeArgumentList) return visitActualTypeArgumentList(n, o);
            else if (n is Wildcard) return visitWildcard(n, o);
            else if (n is PackageName) return visitPackageName(n, o);
            else if (n is ExpressionName) return visitExpressionName(n, o);
            else if (n is MethodName) return visitMethodName(n, o);
            else if (n is PackageOrTypeName) return visitPackageOrTypeName(n, o);
            else if (n is AmbiguousName) return visitAmbiguousName(n, o);
            else if (n is CompilationUnit) return visitCompilationUnit(n, o);
            else if (n is ImportDeclarations) return visitImportDeclarations(n, o);
            else if (n is TypeDeclarations) return visitTypeDeclarations(n, o);
            else if (n is PackageDeclaration) return visitPackageDeclaration(n, o);
            else if (n is SingleTypeImportDeclaration) return visitSingleTypeImportDeclaration(n, o);
            else if (n is TypeImportOnDemandDeclaration) return visitTypeImportOnDemandDeclaration(n, o);
            else if (n is SingleStaticImportDeclaration) return visitSingleStaticImportDeclaration(n, o);
            else if (n is StaticImportOnDemandDeclaration) return visitStaticImportOnDemandDeclaration(n, o);
            else if (n is TypeDeclaration) return visitTypeDeclaration(n, o);
            else if (n is NormalClassDeclaration) return visitNormalClassDeclaration(n, o);
            else if (n is ClassModifiers) return visitClassModifiers(n, o);
            else if (n is TypeParameters) return visitTypeParameters(n, o);
            else if (n is TypeParameterList) return visitTypeParameterList(n, o);
            else if (n is Super) return visitSuper(n, o);
            else if (n is Interfaces) return visitInterfaces(n, o);
            else if (n is InterfaceTypeList) return visitInterfaceTypeList(n, o);
            else if (n is ClassBody) return visitClassBody(n, o);
            else if (n is ClassBodyDeclarations) return visitClassBodyDeclarations(n, o);
            else if (n is ClassMemberDeclaration) return visitClassMemberDeclaration(n, o);
            else if (n is FieldDeclaration) return visitFieldDeclaration(n, o);
            else if (n is VariableDeclarators) return visitVariableDeclarators(n, o);
            else if (n is VariableDeclarator) return visitVariableDeclarator(n, o);
            else if (n is VariableDeclaratorId) return visitVariableDeclaratorId(n, o);
            else if (n is FieldModifiers) return visitFieldModifiers(n, o);
            else if (n is MethodDeclaration) return visitMethodDeclaration(n, o);
            else if (n is MethodHeader) return visitMethodHeader(n, o);
            else if (n is ResultType) return visitResultType(n, o);
            else if (n is FormalParameterList) return visitFormalParameterList(n, o);
            else if (n is FormalParameters) return visitFormalParameters(n, o);
            else if (n is FormalParameter) return visitFormalParameter(n, o);
            else if (n is VariableModifiers) return visitVariableModifiers(n, o);
            else if (n is VariableModifier) return visitVariableModifier(n, o);
            else if (n is LastFormalParameter) return visitLastFormalParameter(n, o);
            else if (n is MethodModifiers) return visitMethodModifiers(n, o);
            else if (n is Throws) return visitThrows(n, o);
            else if (n is ExceptionTypeList) return visitExceptionTypeList(n, o);
            else if (n is MethodBody) return visitMethodBody(n, o);
            else if (n is StaticInitializer) return visitStaticInitializer(n, o);
            else if (n is ConstructorDeclaration) return visitConstructorDeclaration(n, o);
            else if (n is ConstructorDeclarator) return visitConstructorDeclarator(n, o);
            else if (n is ConstructorModifiers) return visitConstructorModifiers(n, o);
            else if (n is ConstructorBody) return visitConstructorBody(n, o);
            else if (n is EnumDeclaration) return visitEnumDeclaration(n, o);
            else if (n is EnumBody) return visitEnumBody(n, o);
            else if (n is EnumConstants) return visitEnumConstants(n, o);
            else if (n is EnumConstant) return visitEnumConstant(n, o);
            else if (n is Arguments) return visitArguments(n, o);
            else if (n is EnumBodyDeclarations) return visitEnumBodyDeclarations(n, o);
            else if (n is NormalInterfaceDeclaration) return visitNormalInterfaceDeclaration(n, o);
            else if (n is InterfaceModifiers) return visitInterfaceModifiers(n, o);
            else if (n is InterfaceBody) return visitInterfaceBody(n, o);
            else if (n is InterfaceMemberDeclarations) return visitInterfaceMemberDeclarations(n, o);
            else if (n is InterfaceMemberDeclaration) return visitInterfaceMemberDeclaration(n, o);
            else if (n is ConstantDeclaration) return visitConstantDeclaration(n, o);
            else if (n is ConstantModifiers) return visitConstantModifiers(n, o);
            else if (n is AbstractMethodDeclaration) return visitAbstractMethodDeclaration(n, o);
            else if (n is AbstractMethodModifiers) return visitAbstractMethodModifiers(n, o);
            else if (n is AnnotationTypeDeclaration) return visitAnnotationTypeDeclaration(n, o);
            else if (n is AnnotationTypeBody) return visitAnnotationTypeBody(n, o);
            else if (n is AnnotationTypeElementDeclarations) return visitAnnotationTypeElementDeclarations(n, o);
            else if (n is DefaultValue) return visitDefaultValue(n, o);
            else if (n is Annotations) return visitAnnotations(n, o);
            else if (n is NormalAnnotation) return visitNormalAnnotation(n, o);
            else if (n is ElementValuePairs) return visitElementValuePairs(n, o);
            else if (n is ElementValuePair) return visitElementValuePair(n, o);
            else if (n is ElementValueArrayInitializer) return visitElementValueArrayInitializer(n, o);
            else if (n is ElementValues) return visitElementValues(n, o);
            else if (n is MarkerAnnotation) return visitMarkerAnnotation(n, o);
            else if (n is SingleElementAnnotation) return visitSingleElementAnnotation(n, o);
            else if (n is ArrayInitializer) return visitArrayInitializer(n, o);
            else if (n is VariableInitializers) return visitVariableInitializers(n, o);
            else if (n is Block) return visitBlock(n, o);
            else if (n is BlockStatements) return visitBlockStatements(n, o);
            else if (n is LocalVariableDeclarationStatement) return visitLocalVariableDeclarationStatement(n, o);
            else if (n is LocalVariableDeclaration) return visitLocalVariableDeclaration(n, o);
            else if (n is IfThenStatement) return visitIfThenStatement(n, o);
            else if (n is IfThenElseStatement) return visitIfThenElseStatement(n, o);
            else if (n is IfThenElseStatementNoShortIf) return visitIfThenElseStatementNoShortIf(n, o);
            else if (n is EmptyStatement) return visitEmptyStatement(n, o);
            else if (n is LabeledStatement) return visitLabeledStatement(n, o);
            else if (n is LabeledStatementNoShortIf) return visitLabeledStatementNoShortIf(n, o);
            else if (n is ExpressionStatement) return visitExpressionStatement(n, o);
            else if (n is SwitchStatement) return visitSwitchStatement(n, o);
            else if (n is SwitchBlock) return visitSwitchBlock(n, o);
            else if (n is SwitchBlockStatementGroups) return visitSwitchBlockStatementGroups(n, o);
            else if (n is SwitchBlockStatementGroup) return visitSwitchBlockStatementGroup(n, o);
            else if (n is SwitchLabels) return visitSwitchLabels(n, o);
            else if (n is WhileStatement) return visitWhileStatement(n, o);
            else if (n is WhileStatementNoShortIf) return visitWhileStatementNoShortIf(n, o);
            else if (n is DoStatement) return visitDoStatement(n, o);
            else if (n is BasicForStatement) return visitBasicForStatement(n, o);
            else if (n is ForStatementNoShortIf) return visitForStatementNoShortIf(n, o);
            else if (n is StatementExpressionList) return visitStatementExpressionList(n, o);
            else if (n is EnhancedForStatement) return visitEnhancedForStatement(n, o);
            else if (n is BreakStatement) return visitBreakStatement(n, o);
            else if (n is ContinueStatement) return visitContinueStatement(n, o);
            else if (n is ReturnStatement) return visitReturnStatement(n, o);
            else if (n is ThrowStatement) return visitThrowStatement(n, o);
            else if (n is SynchronizedStatement) return visitSynchronizedStatement(n, o);
            else if (n is Catches) return visitCatches(n, o);
            else if (n is CatchClause) return visitCatchClause(n, o);
            else if (n is Finally) return visitFinally(n, o);
            else if (n is ArgumentList) return visitArgumentList(n, o);
            else if (n is DimExprs) return visitDimExprs(n, o);
            else if (n is DimExpr) return visitDimExpr(n, o);
            else if (n is PostIncrementExpression) return visitPostIncrementExpression(n, o);
            else if (n is PostDecrementExpression) return visitPostDecrementExpression(n, o);
            else if (n is PreIncrementExpression) return visitPreIncrementExpression(n, o);
            else if (n is PreDecrementExpression) return visitPreDecrementExpression(n, o);
            else if (n is AndExpression) return visitAndExpression(n, o);
            else if (n is ExclusiveOrExpression) return visitExclusiveOrExpression(n, o);
            else if (n is InclusiveOrExpression) return visitInclusiveOrExpression(n, o);
            else if (n is ConditionalAndExpression) return visitConditionalAndExpression(n, o);
            else if (n is ConditionalOrExpression) return visitConditionalOrExpression(n, o);
            else if (n is ConditionalExpression) return visitConditionalExpression(n, o);
            else if (n is Assignment) return visitAssignment(n, o);
            else if (n is Commaopt) return visitCommaopt(n, o);
            else if (n is Ellipsisopt) return visitEllipsisopt(n, o);
            else if (n is LPGUserAction0) return visitLPGUserAction0(n, o);
            else if (n is LPGUserAction1) return visitLPGUserAction1(n, o);
            else if (n is LPGUserAction2) return visitLPGUserAction2(n, o);
            else if (n is LPGUserAction3) return visitLPGUserAction3(n, o);
            else if (n is LPGUserAction4) return visitLPGUserAction4(n, o);
            else if (n is IntegralType0) return visitIntegralType0(n, o);
            else if (n is IntegralType1) return visitIntegralType1(n, o);
            else if (n is IntegralType2) return visitIntegralType2(n, o);
            else if (n is IntegralType3) return visitIntegralType3(n, o);
            else if (n is IntegralType4) return visitIntegralType4(n, o);
            else if (n is FloatingPointType0) return visitFloatingPointType0(n, o);
            else if (n is FloatingPointType1) return visitFloatingPointType1(n, o);
            else if (n is WildcardBounds0) return visitWildcardBounds0(n, o);
            else if (n is WildcardBounds1) return visitWildcardBounds1(n, o);
            else if (n is ClassModifier0) return visitClassModifier0(n, o);
            else if (n is ClassModifier1) return visitClassModifier1(n, o);
            else if (n is ClassModifier2) return visitClassModifier2(n, o);
            else if (n is ClassModifier3) return visitClassModifier3(n, o);
            else if (n is ClassModifier4) return visitClassModifier4(n, o);
            else if (n is ClassModifier5) return visitClassModifier5(n, o);
            else if (n is ClassModifier6) return visitClassModifier6(n, o);
            else if (n is FieldModifier0) return visitFieldModifier0(n, o);
            else if (n is FieldModifier1) return visitFieldModifier1(n, o);
            else if (n is FieldModifier2) return visitFieldModifier2(n, o);
            else if (n is FieldModifier3) return visitFieldModifier3(n, o);
            else if (n is FieldModifier4) return visitFieldModifier4(n, o);
            else if (n is FieldModifier5) return visitFieldModifier5(n, o);
            else if (n is FieldModifier6) return visitFieldModifier6(n, o);
            else if (n is MethodDeclarator0) return visitMethodDeclarator0(n, o);
            else if (n is MethodDeclarator1) return visitMethodDeclarator1(n, o);
            else if (n is MethodModifier0) return visitMethodModifier0(n, o);
            else if (n is MethodModifier1) return visitMethodModifier1(n, o);
            else if (n is MethodModifier2) return visitMethodModifier2(n, o);
            else if (n is MethodModifier3) return visitMethodModifier3(n, o);
            else if (n is MethodModifier4) return visitMethodModifier4(n, o);
            else if (n is MethodModifier5) return visitMethodModifier5(n, o);
            else if (n is MethodModifier6) return visitMethodModifier6(n, o);
            else if (n is MethodModifier7) return visitMethodModifier7(n, o);
            else if (n is MethodModifier8) return visitMethodModifier8(n, o);
            else if (n is ConstructorModifier0) return visitConstructorModifier0(n, o);
            else if (n is ConstructorModifier1) return visitConstructorModifier1(n, o);
            else if (n is ConstructorModifier2) return visitConstructorModifier2(n, o);
            else if (n is ExplicitConstructorInvocation0) return visitExplicitConstructorInvocation0(n, o);
            else if (n is ExplicitConstructorInvocation1) return visitExplicitConstructorInvocation1(n, o);
            else if (n is ExplicitConstructorInvocation2) return visitExplicitConstructorInvocation2(n, o);
            else if (n is InterfaceModifier0) return visitInterfaceModifier0(n, o);
            else if (n is InterfaceModifier1) return visitInterfaceModifier1(n, o);
            else if (n is InterfaceModifier2) return visitInterfaceModifier2(n, o);
            else if (n is InterfaceModifier3) return visitInterfaceModifier3(n, o);
            else if (n is InterfaceModifier4) return visitInterfaceModifier4(n, o);
            else if (n is InterfaceModifier5) return visitInterfaceModifier5(n, o);
            else if (n is ExtendsInterfaces0) return visitExtendsInterfaces0(n, o);
            else if (n is ExtendsInterfaces1) return visitExtendsInterfaces1(n, o);
            else if (n is ConstantModifier0) return visitConstantModifier0(n, o);
            else if (n is ConstantModifier1) return visitConstantModifier1(n, o);
            else if (n is ConstantModifier2) return visitConstantModifier2(n, o);
            else if (n is AbstractMethodModifier0) return visitAbstractMethodModifier0(n, o);
            else if (n is AbstractMethodModifier1) return visitAbstractMethodModifier1(n, o);
            else if (n is AnnotationTypeElementDeclaration0) return visitAnnotationTypeElementDeclaration0(n, o);
            else if (n is AnnotationTypeElementDeclaration1) return visitAnnotationTypeElementDeclaration1(n, o);
            else if (n is AssertStatement0) return visitAssertStatement0(n, o);
            else if (n is AssertStatement1) return visitAssertStatement1(n, o);
            else if (n is SwitchLabel0) return visitSwitchLabel0(n, o);
            else if (n is SwitchLabel1) return visitSwitchLabel1(n, o);
            else if (n is SwitchLabel2) return visitSwitchLabel2(n, o);
            else if (n is TryStatement0) return visitTryStatement0(n, o);
            else if (n is TryStatement1) return visitTryStatement1(n, o);
            else if (n is PrimaryNoNewArray0) return visitPrimaryNoNewArray0(n, o);
            else if (n is PrimaryNoNewArray1) return visitPrimaryNoNewArray1(n, o);
            else if (n is PrimaryNoNewArray2) return visitPrimaryNoNewArray2(n, o);
            else if (n is PrimaryNoNewArray3) return visitPrimaryNoNewArray3(n, o);
            else if (n is PrimaryNoNewArray4) return visitPrimaryNoNewArray4(n, o);
            else if (n is Literal0) return visitLiteral0(n, o);
            else if (n is Literal1) return visitLiteral1(n, o);
            else if (n is Literal2) return visitLiteral2(n, o);
            else if (n is Literal3) return visitLiteral3(n, o);
            else if (n is Literal4) return visitLiteral4(n, o);
            else if (n is Literal5) return visitLiteral5(n, o);
            else if (n is Literal6) return visitLiteral6(n, o);
            else if (n is BooleanLiteral0) return visitBooleanLiteral0(n, o);
            else if (n is BooleanLiteral1) return visitBooleanLiteral1(n, o);
            else if (n is ClassInstanceCreationExpression0) return visitClassInstanceCreationExpression0(n, o);
            else if (n is ClassInstanceCreationExpression1) return visitClassInstanceCreationExpression1(n, o);
            else if (n is ArrayCreationExpression0) return visitArrayCreationExpression0(n, o);
            else if (n is ArrayCreationExpression1) return visitArrayCreationExpression1(n, o);
            else if (n is ArrayCreationExpression2) return visitArrayCreationExpression2(n, o);
            else if (n is ArrayCreationExpression3) return visitArrayCreationExpression3(n, o);
            else if (n is Dims0) return visitDims0(n, o);
            else if (n is Dims1) return visitDims1(n, o);
            else if (n is FieldAccess0) return visitFieldAccess0(n, o);
            else if (n is FieldAccess1) return visitFieldAccess1(n, o);
            else if (n is FieldAccess2) return visitFieldAccess2(n, o);
            else if (n is MethodInvocation0) return visitMethodInvocation0(n, o);
            else if (n is MethodInvocation1) return visitMethodInvocation1(n, o);
            else if (n is MethodInvocation2) return visitMethodInvocation2(n, o);
            else if (n is MethodInvocation3) return visitMethodInvocation3(n, o);
            else if (n is MethodInvocation4) return visitMethodInvocation4(n, o);
            else if (n is ArrayAccess0) return visitArrayAccess0(n, o);
            else if (n is ArrayAccess1) return visitArrayAccess1(n, o);
            else if (n is UnaryExpression0) return visitUnaryExpression0(n, o);
            else if (n is UnaryExpression1) return visitUnaryExpression1(n, o);
            else if (n is UnaryExpressionNotPlusMinus0) return visitUnaryExpressionNotPlusMinus0(n, o);
            else if (n is UnaryExpressionNotPlusMinus1) return visitUnaryExpressionNotPlusMinus1(n, o);
            else if (n is CastExpression0) return visitCastExpression0(n, o);
            else if (n is CastExpression1) return visitCastExpression1(n, o);
            else if (n is MultiplicativeExpression0) return visitMultiplicativeExpression0(n, o);
            else if (n is MultiplicativeExpression1) return visitMultiplicativeExpression1(n, o);
            else if (n is MultiplicativeExpression2) return visitMultiplicativeExpression2(n, o);
            else if (n is AdditiveExpression0) return visitAdditiveExpression0(n, o);
            else if (n is AdditiveExpression1) return visitAdditiveExpression1(n, o);
            else if (n is ShiftExpression0) return visitShiftExpression0(n, o);
            else if (n is ShiftExpression1) return visitShiftExpression1(n, o);
            else if (n is ShiftExpression2) return visitShiftExpression2(n, o);
            else if (n is RelationalExpression0) return visitRelationalExpression0(n, o);
            else if (n is RelationalExpression1) return visitRelationalExpression1(n, o);
            else if (n is RelationalExpression2) return visitRelationalExpression2(n, o);
            else if (n is RelationalExpression3) return visitRelationalExpression3(n, o);
            else if (n is RelationalExpression4) return visitRelationalExpression4(n, o);
            else if (n is EqualityExpression0) return visitEqualityExpression0(n, o);
            else if (n is EqualityExpression1) return visitEqualityExpression1(n, o);
            else if (n is AssignmentOperator0) return visitAssignmentOperator0(n, o);
            else if (n is AssignmentOperator1) return visitAssignmentOperator1(n, o);
            else if (n is AssignmentOperator2) return visitAssignmentOperator2(n, o);
            else if (n is AssignmentOperator3) return visitAssignmentOperator3(n, o);
            else if (n is AssignmentOperator4) return visitAssignmentOperator4(n, o);
            else if (n is AssignmentOperator5) return visitAssignmentOperator5(n, o);
            else if (n is AssignmentOperator6) return visitAssignmentOperator6(n, o);
            else if (n is AssignmentOperator7) return visitAssignmentOperator7(n, o);
            else if (n is AssignmentOperator8) return visitAssignmentOperator8(n, o);
            else if (n is AssignmentOperator9) return visitAssignmentOperator9(n, o);
            else if (n is AssignmentOperator10) return visitAssignmentOperator10(n, o);
            else if (n is AssignmentOperator11) return visitAssignmentOperator11(n, o);
            else throw  ArgumentError("visit(" + n.toString() + ")");
        }
    }

