//
// This is the grammar specification from the Final Draft of the generic spec.
//
////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2007 IBM Corporation.
// All rights reserved. This program and the accompanying materials
// are made available under the terms of the Eclipse Public License v1.0
// which accompanies this distribution, and is available at
// http://www.eclipse.org/legal/epl-v10.html
//
//Contributors:
//    Philippe Charles (pcharles@us.ibm.com) - initial API and implementation

////////////////////////////////////////////////////////////////////////////////


    //#line 146 "btParserTemplateS.gi

import 'package:lpg2/lpg2.dart';
import 'dart:io';
import 'JavaParserprs.dart';
import 'JavaParsersym.dart';

    //#line 18 "GJavaParser.g


    //#line 155 "btParserTemplateS.gi

class JavaParser extends Object implements RuleAction
{
      PrsStream prsStream = PrsStream();
    
      bool unimplementedSymbolsWarning = false;

      static  ParseTable prsTable  = JavaParserprs();
      ParseTable getParseTable()  { return JavaParser.prsTable; }

      late BacktrackingParser btParser;
      BacktrackingParser getParser(){ return btParser; }

      void setResult(Object? object1){ btParser.setSym1(object1); }
      Object? getRhsSym(int i){ return btParser.getSym(i); }

     int getRhsTokenIndex(int i)  { return btParser.getToken(i); }
     IToken getRhsIToken(int i)   { return prsStream.getIToken(getRhsTokenIndex(i)); }
    
     int getRhsFirstTokenIndex(int i)   { return btParser.getFirstToken(i); }
     IToken getRhsFirstIToken(int i)  { return prsStream.getIToken(getRhsFirstTokenIndex(i)); }

     int getRhsLastTokenIndex(int i)  { return btParser.getLastToken(i); }
     IToken getRhsLastIToken(int i)  { return prsStream.getIToken(getRhsLastTokenIndex(i)); }

     int getLeftSpan() { return btParser.getFirstToken(); }
     IToken getLeftIToken()   { return prsStream.getIToken(getLeftSpan()); }

     int getRightSpan() { return btParser.getLastToken(); }
     IToken getRightIToken() { return prsStream.getIToken(getRightSpan()); }

     int getRhsErrorTokenIndex(int i)  
     {
        var index = btParser.getToken(i);
        var err = prsStream.getIToken(index);
        return (err is ErrorToken ? index : 0);
     }
     ErrorToken? getRhsErrorIToken(int i)  
    {
        var index = btParser.getToken(i);
        var err = prsStream.getIToken(index);
        return err as ErrorToken?;
    }

    void  reset(ILexStream lexStream)   
    {
        prsStream.resetLexStream(lexStream);
        btParser.reset(prsStream);

        try
        {
            prsStream.remapTerminalSymbols(orderedTerminalSymbols(), JavaParser.prsTable.getEoftSymbol());
        } 
        on NullExportedSymbolsException{}
        on UnimplementedTerminalsException catch (e)
        {
            if (unimplementedSymbolsWarning) {
                var unimplemented_symbols = e.getSymbols();
                stdout.writeln("The Lexer will not scan the following token(s):");
                for (var i  = 0; i < unimplemented_symbols!.size(); i++)
                {
                    int id = unimplemented_symbols.get(i);
                    stdout.writeln("    " + JavaParsersym.orderedTerminalSymbols[id]);               
                }
                stdout.writeln();
            }
        }
        on UndefinedEofSymbolException catch (e)
        {
            throw (UndefinedEofSymbolException
                ("The Lexer does not implement the Eof symbol " +
                JavaParsersym.orderedTerminalSymbols[JavaParser.prsTable.getEoftSymbol()]));
        }

    }
    
    JavaParser([ILexStream? lexStream])
    {
        try
        {
            btParser = BacktrackingParser(null, JavaParser.prsTable, this);
        }
        on  NotBacktrackParseTableException
        {
            throw (NotBacktrackParseTableException
                ("Regenerate JavaParserprs.dart with -BACKTRACK option"));
        }
        on BadParseSymFileException
        {
            throw (BadParseSymFileException("Bad Parser Symbol File -- JavaParsersym.dart"));
        }

        if(lexStream != null){
          reset(lexStream);
        }
    }
    
   
    
    int numTokenKinds(){ return JavaParsersym.numTokenKinds; }
    List<String>  orderedTerminalSymbols()  { return JavaParsersym.orderedTerminalSymbols; }
    String  getTokenKindName(int kind)   { return JavaParsersym.orderedTerminalSymbols[kind]; }
    int  getEOFTokenKind() { return JavaParser.prsTable.getEoftSymbol(); }
    IPrsStream getIPrsStream(){ return prsStream; }


    Ast? parser([int error_repair_count = 0 ,Monitor?  monitor])
    {
        btParser.setMonitor(monitor);
        
        try{
            return btParser.fuzzyParse(error_repair_count) as Ast?;
        }
        on BadParseException catch(e){
            prsStream.reset(e.error_token); // point to error token
            var diagnoseParser = DiagnoseParser(prsStream, JavaParser.prsTable);
            diagnoseParser.diagnose(e.error_token);
        }
        return null;
    }

    //
    // Additional entry points, if any
    //
    
   
    Ast?  parseClassBodyDeclarationsopt([Monitor? monitor, int error_repair_count= 0]) 
    {
        btParser.setMonitor(monitor);
        
        try
        {
            return btParser.fuzzyParseEntry(JavaParsersym.TK_ClassBodyDeclarationsoptMarker, error_repair_count) as Ast?;
        }
        on BadParseException catch(e)
        {
            prsStream.reset(e.error_token); // point to error token
            var diagnoseParser = DiagnoseParser(prsStream, JavaParser.prsTable);
            diagnoseParser.diagnoseEntry(JavaParsersym.TK_ClassBodyDeclarationsoptMarker, e.error_token);
        }

        return null;
    }

   
    Ast?  parseLPGUserAction([Monitor? monitor, int error_repair_count= 0]) 
    {
        btParser.setMonitor(monitor);
        
        try
        {
            return btParser.fuzzyParseEntry(JavaParsersym.TK_LPGUserActionMarker, error_repair_count) as Ast?;
        }
        on BadParseException catch(e)
        {
            prsStream.reset(e.error_token); // point to error token
            var diagnoseParser = DiagnoseParser(prsStream, JavaParser.prsTable);
            diagnoseParser.diagnoseEntry(JavaParsersym.TK_LPGUserActionMarker, e.error_token);
        }

        return null;
    }


    //#line 185 "GJavaParser.g


    
    //#line 285 "btParserTemplateS.gi

    
    void ruleAction(int ruleNumber ) 
    {
        switch (ruleNumber)
        {

            //
            // Rule 3:  identifier ::= IDENTIFIER
            //
            case 3: {
               //#line 184 "GJavaParser.g"
                setResult(
                    //#line 184 GJavaParser.g
                    identifier(this, getRhsIToken(1))
                //#line 184 GJavaParser.g
                );
            break;
            }
            //
            // Rule 4:  LPGUserAction ::= BlockStatementsopt
            //
            case 4:
                break;
            //
            // Rule 5:  LPGUserAction ::= %BeginAction BlockStatementsopt %EndAction
            //
            case 5: {
               //#line 190 "GJavaParser.g"
                setResult(
                    //#line 190 GJavaParser.g
                    LPGUserAction0(getLeftIToken(), getRightIToken(),
                                   //#line 190 GJavaParser.g
                                   AstToken(getRhsIToken(1)),
                                   //#line 190 GJavaParser.g
                                   getRhsSym(2) as IBlockStatementsopt?,
                                   //#line 190 GJavaParser.g
                                   AstToken(getRhsIToken(3)))
                //#line 190 GJavaParser.g
                );
            break;
            }
            //
            // Rule 6:  LPGUserAction ::= $BeginJava BlockStatementsopt $EndJava
            //
            case 6: {
               //#line 191 "GJavaParser.g"
                setResult(
                    //#line 191 GJavaParser.g
                    LPGUserAction1(getLeftIToken(), getRightIToken(),
                                   //#line 191 GJavaParser.g
                                   AstToken(getRhsIToken(1)),
                                   //#line 191 GJavaParser.g
                                   getRhsSym(2) as IBlockStatementsopt?,
                                   //#line 191 GJavaParser.g
                                   AstToken(getRhsIToken(3)))
                //#line 191 GJavaParser.g
                );
            break;
            }
            //
            // Rule 7:  LPGUserAction ::= $NoAction
            //
            case 7: {
               //#line 192 "GJavaParser.g"
                setResult(
                    //#line 192 GJavaParser.g
                    LPGUserAction2(getRhsIToken(1))
                //#line 192 GJavaParser.g
                );
            break;
            }
            //
            // Rule 8:  LPGUserAction ::= $NullAction
            //
            case 8: {
               //#line 193 "GJavaParser.g"
                setResult(
                    //#line 193 GJavaParser.g
                    LPGUserAction3(getRhsIToken(1))
                //#line 193 GJavaParser.g
                );
            break;
            }
            //
            // Rule 9:  LPGUserAction ::= $BadAction
            //
            case 9: {
               //#line 194 "GJavaParser.g"
                setResult(
                    //#line 194 GJavaParser.g
                    LPGUserAction4(getRhsIToken(1))
                //#line 194 GJavaParser.g
                );
            break;
            }
            //
            // Rule 10:  Type ::= PrimitiveType
            //
            case 10:
                break;
            //
            // Rule 11:  Type ::= ReferenceType
            //
            case 11:
                break;
            //
            // Rule 12:  PrimitiveType ::= NumericType
            //
            case 12:
                break;
            //
            // Rule 13:  PrimitiveType ::= boolean
            //
            case 13: {
               //#line 203 "GJavaParser.g"
                setResult(
                    //#line 203 GJavaParser.g
                    PrimitiveType(getRhsIToken(1))
                //#line 203 GJavaParser.g
                );
            break;
            }
            //
            // Rule 14:  NumericType ::= IntegralType
            //
            case 14:
                break;
            //
            // Rule 15:  NumericType ::= FloatingPointType
            //
            case 15:
                break;
            //
            // Rule 16:  IntegralType ::= byte
            //
            case 16: {
               //#line 208 "GJavaParser.g"
                setResult(
                    //#line 208 GJavaParser.g
                    IntegralType0(getRhsIToken(1))
                //#line 208 GJavaParser.g
                );
            break;
            }
            //
            // Rule 17:  IntegralType ::= short
            //
            case 17: {
               //#line 209 "GJavaParser.g"
                setResult(
                    //#line 209 GJavaParser.g
                    IntegralType1(getRhsIToken(1))
                //#line 209 GJavaParser.g
                );
            break;
            }
            //
            // Rule 18:  IntegralType ::= int
            //
            case 18: {
               //#line 210 "GJavaParser.g"
                setResult(
                    //#line 210 GJavaParser.g
                    IntegralType2(getRhsIToken(1))
                //#line 210 GJavaParser.g
                );
            break;
            }
            //
            // Rule 19:  IntegralType ::= long
            //
            case 19: {
               //#line 211 "GJavaParser.g"
                setResult(
                    //#line 211 GJavaParser.g
                    IntegralType3(getRhsIToken(1))
                //#line 211 GJavaParser.g
                );
            break;
            }
            //
            // Rule 20:  IntegralType ::= char
            //
            case 20: {
               //#line 212 "GJavaParser.g"
                setResult(
                    //#line 212 GJavaParser.g
                    IntegralType4(getRhsIToken(1))
                //#line 212 GJavaParser.g
                );
            break;
            }
            //
            // Rule 21:  FloatingPointType ::= float
            //
            case 21: {
               //#line 214 "GJavaParser.g"
                setResult(
                    //#line 214 GJavaParser.g
                    FloatingPointType0(getRhsIToken(1))
                //#line 214 GJavaParser.g
                );
            break;
            }
            //
            // Rule 22:  FloatingPointType ::= double
            //
            case 22: {
               //#line 215 "GJavaParser.g"
                setResult(
                    //#line 215 GJavaParser.g
                    FloatingPointType1(getRhsIToken(1))
                //#line 215 GJavaParser.g
                );
            break;
            }
            //
            // Rule 23:  ReferenceType ::= ClassOrInterfaceType
            //
            case 23:
                break;
            //
            // Rule 24:  ReferenceType ::= TypeVariable
            //
            case 24:
                break;
            //
            // Rule 25:  ReferenceType ::= ArrayType
            //
            case 25:
                break;
            //
            // Rule 26:  ClassOrInterfaceType ::= ClassType
            //
            case 26:
                break;
            //
            // Rule 27:  ClassType ::= TypeName TypeArgumentsopt
            //
            case 27: {
               //#line 227 "GJavaParser.g"
                setResult(
                    //#line 227 GJavaParser.g
                    ClassType(getLeftIToken(), getRightIToken(),
                              //#line 227 GJavaParser.g
                              getRhsSym(1) as ITypeName,
                              //#line 227 GJavaParser.g
                              getRhsSym(2) as TypeArguments?)
                //#line 227 GJavaParser.g
                );
            break;
            }
            //
            // Rule 28:  InterfaceType ::= TypeName TypeArgumentsopt
            //
            case 28: {
               //#line 229 "GJavaParser.g"
                setResult(
                    //#line 229 GJavaParser.g
                    InterfaceType(getLeftIToken(), getRightIToken(),
                                  //#line 229 GJavaParser.g
                                  getRhsSym(1) as ITypeName,
                                  //#line 229 GJavaParser.g
                                  getRhsSym(2) as TypeArguments?)
                //#line 229 GJavaParser.g
                );
            break;
            }
            //
            // Rule 29:  TypeName ::= identifier
            //
            case 29:
                break;
            //
            // Rule 30:  TypeName ::= TypeName . identifier
            //
            case 30: {
               //#line 232 "GJavaParser.g"
                setResult(
                    //#line 232 GJavaParser.g
                    TypeName(getLeftIToken(), getRightIToken(),
                             //#line 232 GJavaParser.g
                             getRhsSym(1) as ITypeName,
                             //#line 232 GJavaParser.g
                             AstToken(getRhsIToken(2)),
                             //#line 232 GJavaParser.g
                             getRhsSym(3) as identifier)
                //#line 232 GJavaParser.g
                );
            break;
            }
            //
            // Rule 31:  ClassName ::= TypeName
            //
            case 31:
                break;
            //
            // Rule 32:  TypeVariable ::= identifier
            //
            case 32:
                break;
            //
            // Rule 33:  ArrayType ::= Type [ ]
            //
            case 33: {
               //#line 238 "GJavaParser.g"
                setResult(
                    //#line 238 GJavaParser.g
                    ArrayType(getLeftIToken(), getRightIToken(),
                              //#line 238 GJavaParser.g
                              getRhsSym(1) as IType,
                              //#line 238 GJavaParser.g
                              AstToken(getRhsIToken(2)),
                              //#line 238 GJavaParser.g
                              AstToken(getRhsIToken(3)))
                //#line 238 GJavaParser.g
                );
            break;
            }
            //
            // Rule 34:  TypeParameter ::= TypeVariable TypeBoundopt
            //
            case 34: {
               //#line 240 "GJavaParser.g"
                setResult(
                    //#line 240 GJavaParser.g
                    TypeParameter(getLeftIToken(), getRightIToken(),
                                  //#line 240 GJavaParser.g
                                  getRhsSym(1) as identifier,
                                  //#line 240 GJavaParser.g
                                  getRhsSym(2) as TypeBound?)
                //#line 240 GJavaParser.g
                );
            break;
            }
            //
            // Rule 35:  TypeBound ::= extends ClassOrInterfaceType AdditionalBoundListopt
            //
            case 35: {
               //#line 242 "GJavaParser.g"
                setResult(
                    //#line 242 GJavaParser.g
                    TypeBound(getLeftIToken(), getRightIToken(),
                              //#line 242 GJavaParser.g
                              AstToken(getRhsIToken(1)),
                              //#line 242 GJavaParser.g
                              getRhsSym(2) as ClassType,
                              //#line 242 GJavaParser.g
                              getRhsSym(3) as IAdditionalBoundListopt?)
                //#line 242 GJavaParser.g
                );
            break;
            }
            //
            // Rule 36:  AdditionalBoundList ::= AdditionalBound
            //
            case 36:
                break;
            //
            // Rule 37:  AdditionalBoundList ::= AdditionalBoundList AdditionalBound
            //
            case 37: {
               //#line 245 "GJavaParser.g"
                setResult(
                    //#line 245 GJavaParser.g
                    AdditionalBoundList(getLeftIToken(), getRightIToken(),
                                        //#line 245 GJavaParser.g
                                        getRhsSym(1) as IAdditionalBoundList,
                                        //#line 245 GJavaParser.g
                                        getRhsSym(2) as AdditionalBound)
                //#line 245 GJavaParser.g
                );
            break;
            }
            //
            // Rule 38:  AdditionalBound ::= & InterfaceType
            //
            case 38: {
               //#line 247 "GJavaParser.g"
                setResult(
                    //#line 247 GJavaParser.g
                    AdditionalBound(getLeftIToken(), getRightIToken(),
                                    //#line 247 GJavaParser.g
                                    AstToken(getRhsIToken(1)),
                                    //#line 247 GJavaParser.g
                                    getRhsSym(2) as InterfaceType)
                //#line 247 GJavaParser.g
                );
            break;
            }
            //
            // Rule 39:  TypeArguments ::= < ActualTypeArgumentList >
            //
            case 39: {
               //#line 249 "GJavaParser.g"
                setResult(
                    //#line 249 GJavaParser.g
                    TypeArguments(getLeftIToken(), getRightIToken(),
                                  //#line 249 GJavaParser.g
                                  AstToken(getRhsIToken(1)),
                                  //#line 249 GJavaParser.g
                                  getRhsSym(2) as IActualTypeArgumentList,
                                  //#line 249 GJavaParser.g
                                  AstToken(getRhsIToken(3)))
                //#line 249 GJavaParser.g
                );
            break;
            }
            //
            // Rule 40:  ActualTypeArgumentList ::= ActualTypeArgument
            //
            case 40:
                break;
            //
            // Rule 41:  ActualTypeArgumentList ::= ActualTypeArgumentList , ActualTypeArgument
            //
            case 41: {
               //#line 252 "GJavaParser.g"
                setResult(
                    //#line 252 GJavaParser.g
                    ActualTypeArgumentList(getLeftIToken(), getRightIToken(),
                                           //#line 252 GJavaParser.g
                                           getRhsSym(1) as IActualTypeArgumentList,
                                           //#line 252 GJavaParser.g
                                           AstToken(getRhsIToken(2)),
                                           //#line 252 GJavaParser.g
                                           getRhsSym(3) as IActualTypeArgument)
                //#line 252 GJavaParser.g
                );
            break;
            }
            //
            // Rule 42:  ActualTypeArgument ::= ReferenceType
            //
            case 42:
                break;
            //
            // Rule 43:  ActualTypeArgument ::= Wildcard
            //
            case 43:
                break;
            //
            // Rule 44:  Wildcard ::= ? WildcardBoundsOpt
            //
            case 44: {
               //#line 257 "GJavaParser.g"
                setResult(
                    //#line 257 GJavaParser.g
                    Wildcard(getLeftIToken(), getRightIToken(),
                             //#line 257 GJavaParser.g
                             AstToken(getRhsIToken(1)),
                             //#line 257 GJavaParser.g
                             getRhsSym(2) as IWildcardBoundsOpt?)
                //#line 257 GJavaParser.g
                );
            break;
            }
            //
            // Rule 45:  WildcardBounds ::= extends ReferenceType
            //
            case 45: {
               //#line 259 "GJavaParser.g"
                setResult(
                    //#line 259 GJavaParser.g
                    WildcardBounds0(getLeftIToken(), getRightIToken(),
                                    //#line 259 GJavaParser.g
                                    AstToken(getRhsIToken(1)),
                                    //#line 259 GJavaParser.g
                                    getRhsSym(2) as IReferenceType)
                //#line 259 GJavaParser.g
                );
            break;
            }
            //
            // Rule 46:  WildcardBounds ::= super ReferenceType
            //
            case 46: {
               //#line 260 "GJavaParser.g"
                setResult(
                    //#line 260 GJavaParser.g
                    WildcardBounds1(getLeftIToken(), getRightIToken(),
                                    //#line 260 GJavaParser.g
                                    AstToken(getRhsIToken(1)),
                                    //#line 260 GJavaParser.g
                                    getRhsSym(2) as IReferenceType)
                //#line 260 GJavaParser.g
                );
            break;
            }
            //
            // Rule 47:  PackageName ::= identifier
            //
            case 47:
                break;
            //
            // Rule 48:  PackageName ::= PackageName . identifier
            //
            case 48: {
               //#line 267 "GJavaParser.g"
                setResult(
                    //#line 267 GJavaParser.g
                    PackageName(getLeftIToken(), getRightIToken(),
                                //#line 267 GJavaParser.g
                                getRhsSym(1) as IPackageName,
                                //#line 267 GJavaParser.g
                                AstToken(getRhsIToken(2)),
                                //#line 267 GJavaParser.g
                                getRhsSym(3) as identifier)
                //#line 267 GJavaParser.g
                );
            break;
            }
            //
            // Rule 49:  ExpressionName ::= identifier
            //
            case 49:
                break;
            //
            // Rule 50:  ExpressionName ::= AmbiguousName . identifier
            //
            case 50: {
               //#line 276 "GJavaParser.g"
                setResult(
                    //#line 276 GJavaParser.g
                    ExpressionName(getLeftIToken(), getRightIToken(),
                                   //#line 276 GJavaParser.g
                                   getRhsSym(1) as IAmbiguousName,
                                   //#line 276 GJavaParser.g
                                   AstToken(getRhsIToken(2)),
                                   //#line 276 GJavaParser.g
                                   getRhsSym(3) as identifier)
                //#line 276 GJavaParser.g
                );
            break;
            }
            //
            // Rule 51:  MethodName ::= identifier
            //
            case 51:
                break;
            //
            // Rule 52:  MethodName ::= AmbiguousName . identifier
            //
            case 52: {
               //#line 279 "GJavaParser.g"
                setResult(
                    //#line 279 GJavaParser.g
                    MethodName(getLeftIToken(), getRightIToken(),
                               //#line 279 GJavaParser.g
                               getRhsSym(1) as IAmbiguousName,
                               //#line 279 GJavaParser.g
                               AstToken(getRhsIToken(2)),
                               //#line 279 GJavaParser.g
                               getRhsSym(3) as identifier)
                //#line 279 GJavaParser.g
                );
            break;
            }
            //
            // Rule 53:  PackageOrTypeName ::= identifier
            //
            case 53:
                break;
            //
            // Rule 54:  PackageOrTypeName ::= PackageOrTypeName . identifier
            //
            case 54: {
               //#line 282 "GJavaParser.g"
                setResult(
                    //#line 282 GJavaParser.g
                    PackageOrTypeName(getLeftIToken(), getRightIToken(),
                                      //#line 282 GJavaParser.g
                                      getRhsSym(1) as IPackageOrTypeName,
                                      //#line 282 GJavaParser.g
                                      AstToken(getRhsIToken(2)),
                                      //#line 282 GJavaParser.g
                                      getRhsSym(3) as identifier)
                //#line 282 GJavaParser.g
                );
            break;
            }
            //
            // Rule 55:  AmbiguousName ::= identifier
            //
            case 55:
                break;
            //
            // Rule 56:  AmbiguousName ::= AmbiguousName . identifier
            //
            case 56: {
               //#line 285 "GJavaParser.g"
                setResult(
                    //#line 285 GJavaParser.g
                    AmbiguousName(getLeftIToken(), getRightIToken(),
                                  //#line 285 GJavaParser.g
                                  getRhsSym(1) as IAmbiguousName,
                                  //#line 285 GJavaParser.g
                                  AstToken(getRhsIToken(2)),
                                  //#line 285 GJavaParser.g
                                  getRhsSym(3) as identifier)
                //#line 285 GJavaParser.g
                );
            break;
            }
            //
            // Rule 57:  CompilationUnit ::= PackageDeclarationopt ImportDeclarationsopt TypeDeclarationsopt
            //
            case 57: {
               //#line 289 "GJavaParser.g"
                setResult(
                    //#line 289 GJavaParser.g
                    CompilationUnit(getLeftIToken(), getRightIToken(),
                                    //#line 289 GJavaParser.g
                                    getRhsSym(1) as PackageDeclaration?,
                                    //#line 289 GJavaParser.g
                                    getRhsSym(2) as IImportDeclarationsopt?,
                                    //#line 289 GJavaParser.g
                                    getRhsSym(3) as ITypeDeclarationsopt?)
                //#line 289 GJavaParser.g
                );
            break;
            }
            //
            // Rule 58:  ImportDeclarations ::= ImportDeclaration
            //
            case 58:
                break;
            //
            // Rule 59:  ImportDeclarations ::= ImportDeclarations ImportDeclaration
            //
            case 59: {
               //#line 292 "GJavaParser.g"
                setResult(
                    //#line 292 GJavaParser.g
                    ImportDeclarations(getLeftIToken(), getRightIToken(),
                                       //#line 292 GJavaParser.g
                                       getRhsSym(1) as IImportDeclarations,
                                       //#line 292 GJavaParser.g
                                       getRhsSym(2) as IImportDeclaration)
                //#line 292 GJavaParser.g
                );
            break;
            }
            //
            // Rule 60:  TypeDeclarations ::= TypeDeclaration
            //
            case 60:
                break;
            //
            // Rule 61:  TypeDeclarations ::= TypeDeclarations TypeDeclaration
            //
            case 61: {
               //#line 295 "GJavaParser.g"
                setResult(
                    //#line 295 GJavaParser.g
                    TypeDeclarations(getLeftIToken(), getRightIToken(),
                                     //#line 295 GJavaParser.g
                                     getRhsSym(1) as ITypeDeclarations,
                                     //#line 295 GJavaParser.g
                                     getRhsSym(2) as ITypeDeclaration)
                //#line 295 GJavaParser.g
                );
            break;
            }
            //
            // Rule 62:  PackageDeclaration ::= Annotationsopt package PackageName ;
            //
            case 62: {
               //#line 297 "GJavaParser.g"
                setResult(
                    //#line 297 GJavaParser.g
                    PackageDeclaration(getLeftIToken(), getRightIToken(),
                                       //#line 297 GJavaParser.g
                                       getRhsSym(1) as IAnnotationsopt?,
                                       //#line 297 GJavaParser.g
                                       AstToken(getRhsIToken(2)),
                                       //#line 297 GJavaParser.g
                                       getRhsSym(3) as IPackageName,
                                       //#line 297 GJavaParser.g
                                       AstToken(getRhsIToken(4)))
                //#line 297 GJavaParser.g
                );
            break;
            }
            //
            // Rule 63:  ImportDeclaration ::= SingleTypeImportDeclaration
            //
            case 63:
                break;
            //
            // Rule 64:  ImportDeclaration ::= TypeImportOnDemandDeclaration
            //
            case 64:
                break;
            //
            // Rule 65:  ImportDeclaration ::= SingleStaticImportDeclaration
            //
            case 65:
                break;
            //
            // Rule 66:  ImportDeclaration ::= StaticImportOnDemandDeclaration
            //
            case 66:
                break;
            //
            // Rule 67:  SingleTypeImportDeclaration ::= import TypeName ;
            //
            case 67: {
               //#line 304 "GJavaParser.g"
                setResult(
                    //#line 304 GJavaParser.g
                    SingleTypeImportDeclaration(getLeftIToken(), getRightIToken(),
                                                //#line 304 GJavaParser.g
                                                AstToken(getRhsIToken(1)),
                                                //#line 304 GJavaParser.g
                                                getRhsSym(2) as ITypeName,
                                                //#line 304 GJavaParser.g
                                                AstToken(getRhsIToken(3)))
                //#line 304 GJavaParser.g
                );
            break;
            }
            //
            // Rule 68:  TypeImportOnDemandDeclaration ::= import PackageOrTypeName . * ;
            //
            case 68: {
               //#line 306 "GJavaParser.g"
                setResult(
                    //#line 306 GJavaParser.g
                    TypeImportOnDemandDeclaration(getLeftIToken(), getRightIToken(),
                                                  //#line 306 GJavaParser.g
                                                  AstToken(getRhsIToken(1)),
                                                  //#line 306 GJavaParser.g
                                                  getRhsSym(2) as IPackageOrTypeName,
                                                  //#line 306 GJavaParser.g
                                                  AstToken(getRhsIToken(3)),
                                                  //#line 306 GJavaParser.g
                                                  AstToken(getRhsIToken(4)),
                                                  //#line 306 GJavaParser.g
                                                  AstToken(getRhsIToken(5)))
                //#line 306 GJavaParser.g
                );
            break;
            }
            //
            // Rule 69:  SingleStaticImportDeclaration ::= import static TypeName . identifier ;
            //
            case 69: {
               //#line 308 "GJavaParser.g"
                setResult(
                    //#line 308 GJavaParser.g
                    SingleStaticImportDeclaration(getLeftIToken(), getRightIToken(),
                                                  //#line 308 GJavaParser.g
                                                  AstToken(getRhsIToken(1)),
                                                  //#line 308 GJavaParser.g
                                                  AstToken(getRhsIToken(2)),
                                                  //#line 308 GJavaParser.g
                                                  getRhsSym(3) as ITypeName,
                                                  //#line 308 GJavaParser.g
                                                  AstToken(getRhsIToken(4)),
                                                  //#line 308 GJavaParser.g
                                                  getRhsSym(5) as identifier,
                                                  //#line 308 GJavaParser.g
                                                  AstToken(getRhsIToken(6)))
                //#line 308 GJavaParser.g
                );
            break;
            }
            //
            // Rule 70:  StaticImportOnDemandDeclaration ::= import static TypeName . * ;
            //
            case 70: {
               //#line 310 "GJavaParser.g"
                setResult(
                    //#line 310 GJavaParser.g
                    StaticImportOnDemandDeclaration(getLeftIToken(), getRightIToken(),
                                                    //#line 310 GJavaParser.g
                                                    AstToken(getRhsIToken(1)),
                                                    //#line 310 GJavaParser.g
                                                    AstToken(getRhsIToken(2)),
                                                    //#line 310 GJavaParser.g
                                                    getRhsSym(3) as ITypeName,
                                                    //#line 310 GJavaParser.g
                                                    AstToken(getRhsIToken(4)),
                                                    //#line 310 GJavaParser.g
                                                    AstToken(getRhsIToken(5)),
                                                    //#line 310 GJavaParser.g
                                                    AstToken(getRhsIToken(6)))
                //#line 310 GJavaParser.g
                );
            break;
            }
            //
            // Rule 71:  TypeDeclaration ::= ClassDeclaration
            //
            case 71:
                break;
            //
            // Rule 72:  TypeDeclaration ::= InterfaceDeclaration
            //
            case 72:
                break;
            //
            // Rule 73:  TypeDeclaration ::= ;
            //
            case 73: {
               //#line 314 "GJavaParser.g"
                setResult(
                    //#line 314 GJavaParser.g
                    TypeDeclaration(getRhsIToken(1))
                //#line 314 GJavaParser.g
                );
            break;
            }
            //
            // Rule 74:  ClassDeclaration ::= NormalClassDeclaration
            //
            case 74:
                break;
            //
            // Rule 75:  ClassDeclaration ::= EnumDeclaration
            //
            case 75:
                break;
            //
            // Rule 76:  NormalClassDeclaration ::= ClassModifiersopt class identifier TypeParametersopt Superopt Interfacesopt ClassBody
            //
            case 76: {
               //#line 321 "GJavaParser.g"
                setResult(
                    //#line 321 GJavaParser.g
                    NormalClassDeclaration(getLeftIToken(), getRightIToken(),
                                           //#line 321 GJavaParser.g
                                           getRhsSym(1) as IClassModifiersopt?,
                                           //#line 321 GJavaParser.g
                                           AstToken(getRhsIToken(2)),
                                           //#line 321 GJavaParser.g
                                           getRhsSym(3) as identifier,
                                           //#line 321 GJavaParser.g
                                           getRhsSym(4) as TypeParameters?,
                                           //#line 321 GJavaParser.g
                                           getRhsSym(5) as Super?,
                                           //#line 321 GJavaParser.g
                                           getRhsSym(6) as Interfaces?,
                                           //#line 321 GJavaParser.g
                                           getRhsSym(7) as ClassBody)
                //#line 321 GJavaParser.g
                );
            break;
            }
            //
            // Rule 77:  ClassModifiers ::= ClassModifier
            //
            case 77:
                break;
            //
            // Rule 78:  ClassModifiers ::= ClassModifiers ClassModifier
            //
            case 78: {
               //#line 324 "GJavaParser.g"
                setResult(
                    //#line 324 GJavaParser.g
                    ClassModifiers(getLeftIToken(), getRightIToken(),
                                   //#line 324 GJavaParser.g
                                   getRhsSym(1) as IClassModifiers,
                                   //#line 324 GJavaParser.g
                                   getRhsSym(2) as IClassModifier)
                //#line 324 GJavaParser.g
                );
            break;
            }
            //
            // Rule 79:  ClassModifier ::= Annotation
            //
            case 79:
                break;
            //
            // Rule 80:  ClassModifier ::= public
            //
            case 80: {
               //#line 327 "GJavaParser.g"
                setResult(
                    //#line 327 GJavaParser.g
                    ClassModifier0(getRhsIToken(1))
                //#line 327 GJavaParser.g
                );
            break;
            }
            //
            // Rule 81:  ClassModifier ::= protected
            //
            case 81: {
               //#line 328 "GJavaParser.g"
                setResult(
                    //#line 328 GJavaParser.g
                    ClassModifier1(getRhsIToken(1))
                //#line 328 GJavaParser.g
                );
            break;
            }
            //
            // Rule 82:  ClassModifier ::= private
            //
            case 82: {
               //#line 329 "GJavaParser.g"
                setResult(
                    //#line 329 GJavaParser.g
                    ClassModifier2(getRhsIToken(1))
                //#line 329 GJavaParser.g
                );
            break;
            }
            //
            // Rule 83:  ClassModifier ::= abstract
            //
            case 83: {
               //#line 330 "GJavaParser.g"
                setResult(
                    //#line 330 GJavaParser.g
                    ClassModifier3(getRhsIToken(1))
                //#line 330 GJavaParser.g
                );
            break;
            }
            //
            // Rule 84:  ClassModifier ::= static
            //
            case 84: {
               //#line 331 "GJavaParser.g"
                setResult(
                    //#line 331 GJavaParser.g
                    ClassModifier4(getRhsIToken(1))
                //#line 331 GJavaParser.g
                );
            break;
            }
            //
            // Rule 85:  ClassModifier ::= final
            //
            case 85: {
               //#line 332 "GJavaParser.g"
                setResult(
                    //#line 332 GJavaParser.g
                    ClassModifier5(getRhsIToken(1))
                //#line 332 GJavaParser.g
                );
            break;
            }
            //
            // Rule 86:  ClassModifier ::= strictfp
            //
            case 86: {
               //#line 333 "GJavaParser.g"
                setResult(
                    //#line 333 GJavaParser.g
                    ClassModifier6(getRhsIToken(1))
                //#line 333 GJavaParser.g
                );
            break;
            }
            //
            // Rule 87:  TypeParameters ::= < TypeParameterList >
            //
            case 87: {
               //#line 335 "GJavaParser.g"
                setResult(
                    //#line 335 GJavaParser.g
                    TypeParameters(getLeftIToken(), getRightIToken(),
                                   //#line 335 GJavaParser.g
                                   AstToken(getRhsIToken(1)),
                                   //#line 335 GJavaParser.g
                                   getRhsSym(2) as ITypeParameterList,
                                   //#line 335 GJavaParser.g
                                   AstToken(getRhsIToken(3)))
                //#line 335 GJavaParser.g
                );
            break;
            }
            //
            // Rule 88:  TypeParameterList ::= TypeParameter
            //
            case 88:
                break;
            //
            // Rule 89:  TypeParameterList ::= TypeParameterList , TypeParameter
            //
            case 89: {
               //#line 338 "GJavaParser.g"
                setResult(
                    //#line 338 GJavaParser.g
                    TypeParameterList(getLeftIToken(), getRightIToken(),
                                      //#line 338 GJavaParser.g
                                      getRhsSym(1) as ITypeParameterList,
                                      //#line 338 GJavaParser.g
                                      AstToken(getRhsIToken(2)),
                                      //#line 338 GJavaParser.g
                                      getRhsSym(3) as TypeParameter)
                //#line 338 GJavaParser.g
                );
            break;
            }
            //
            // Rule 90:  Super ::= extends ClassType
            //
            case 90: {
               //#line 340 "GJavaParser.g"
                setResult(
                    //#line 340 GJavaParser.g
                    Super(getLeftIToken(), getRightIToken(),
                          //#line 340 GJavaParser.g
                          AstToken(getRhsIToken(1)),
                          //#line 340 GJavaParser.g
                          getRhsSym(2) as ClassType)
                //#line 340 GJavaParser.g
                );
            break;
            }
            //
            // Rule 91:  Interfaces ::= implements InterfaceTypeList
            //
            case 91: {
               //#line 347 "GJavaParser.g"
                setResult(
                    //#line 347 GJavaParser.g
                    Interfaces(getLeftIToken(), getRightIToken(),
                               //#line 347 GJavaParser.g
                               AstToken(getRhsIToken(1)),
                               //#line 347 GJavaParser.g
                               getRhsSym(2) as IInterfaceTypeList)
                //#line 347 GJavaParser.g
                );
            break;
            }
            //
            // Rule 92:  InterfaceTypeList ::= InterfaceType
            //
            case 92:
                break;
            //
            // Rule 93:  InterfaceTypeList ::= InterfaceTypeList , InterfaceType
            //
            case 93: {
               //#line 350 "GJavaParser.g"
                setResult(
                    //#line 350 GJavaParser.g
                    InterfaceTypeList(getLeftIToken(), getRightIToken(),
                                      //#line 350 GJavaParser.g
                                      getRhsSym(1) as IInterfaceTypeList,
                                      //#line 350 GJavaParser.g
                                      AstToken(getRhsIToken(2)),
                                      //#line 350 GJavaParser.g
                                      getRhsSym(3) as InterfaceType)
                //#line 350 GJavaParser.g
                );
            break;
            }
            //
            // Rule 94:  ClassBody ::= { ClassBodyDeclarationsopt }
            //
            case 94: {
               //#line 357 "GJavaParser.g"
                setResult(
                    //#line 357 GJavaParser.g
                    ClassBody(getLeftIToken(), getRightIToken(),
                              //#line 357 GJavaParser.g
                              AstToken(getRhsIToken(1)),
                              //#line 357 GJavaParser.g
                              getRhsSym(2) as IClassBodyDeclarationsopt?,
                              //#line 357 GJavaParser.g
                              AstToken(getRhsIToken(3)))
                //#line 357 GJavaParser.g
                );
            break;
            }
            //
            // Rule 95:  ClassBodyDeclarations ::= ClassBodyDeclaration
            //
            case 95:
                break;
            //
            // Rule 96:  ClassBodyDeclarations ::= ClassBodyDeclarations ClassBodyDeclaration
            //
            case 96: {
               //#line 360 "GJavaParser.g"
                setResult(
                    //#line 360 GJavaParser.g
                    ClassBodyDeclarations(getLeftIToken(), getRightIToken(),
                                          //#line 360 GJavaParser.g
                                          getRhsSym(1) as IClassBodyDeclarations,
                                          //#line 360 GJavaParser.g
                                          getRhsSym(2) as IClassBodyDeclaration)
                //#line 360 GJavaParser.g
                );
            break;
            }
            //
            // Rule 97:  ClassBodyDeclaration ::= ClassMemberDeclaration
            //
            case 97:
                break;
            //
            // Rule 98:  ClassBodyDeclaration ::= InstanceInitializer
            //
            case 98:
                break;
            //
            // Rule 99:  ClassBodyDeclaration ::= StaticInitializer
            //
            case 99:
                break;
            //
            // Rule 100:  ClassBodyDeclaration ::= ConstructorDeclaration
            //
            case 100:
                break;
            //
            // Rule 101:  ClassMemberDeclaration ::= FieldDeclaration
            //
            case 101:
                break;
            //
            // Rule 102:  ClassMemberDeclaration ::= MethodDeclaration
            //
            case 102:
                break;
            //
            // Rule 103:  ClassMemberDeclaration ::= ClassDeclaration
            //
            case 103:
                break;
            //
            // Rule 104:  ClassMemberDeclaration ::= InterfaceDeclaration
            //
            case 104:
                break;
            //
            // Rule 105:  ClassMemberDeclaration ::= ;
            //
            case 105: {
               //#line 371 "GJavaParser.g"
                setResult(
                    //#line 371 GJavaParser.g
                    ClassMemberDeclaration(getRhsIToken(1))
                //#line 371 GJavaParser.g
                );
            break;
            }
            //
            // Rule 106:  FieldDeclaration ::= FieldModifiersopt Type VariableDeclarators ;
            //
            case 106: {
               //#line 373 "GJavaParser.g"
                setResult(
                    //#line 373 GJavaParser.g
                    FieldDeclaration(getLeftIToken(), getRightIToken(),
                                     //#line 373 GJavaParser.g
                                     getRhsSym(1) as IFieldModifiersopt?,
                                     //#line 373 GJavaParser.g
                                     getRhsSym(2) as IType,
                                     //#line 373 GJavaParser.g
                                     getRhsSym(3) as IVariableDeclarators,
                                     //#line 373 GJavaParser.g
                                     AstToken(getRhsIToken(4)))
                //#line 373 GJavaParser.g
                );
            break;
            }
            //
            // Rule 107:  VariableDeclarators ::= VariableDeclarator
            //
            case 107:
                break;
            //
            // Rule 108:  VariableDeclarators ::= VariableDeclarators , VariableDeclarator
            //
            case 108: {
               //#line 376 "GJavaParser.g"
                setResult(
                    //#line 376 GJavaParser.g
                    VariableDeclarators(getLeftIToken(), getRightIToken(),
                                        //#line 376 GJavaParser.g
                                        getRhsSym(1) as IVariableDeclarators,
                                        //#line 376 GJavaParser.g
                                        AstToken(getRhsIToken(2)),
                                        //#line 376 GJavaParser.g
                                        getRhsSym(3) as IVariableDeclarator)
                //#line 376 GJavaParser.g
                );
            break;
            }
            //
            // Rule 109:  VariableDeclarator ::= VariableDeclaratorId
            //
            case 109:
                break;
            //
            // Rule 110:  VariableDeclarator ::= VariableDeclaratorId = VariableInitializer
            //
            case 110: {
               //#line 379 "GJavaParser.g"
                setResult(
                    //#line 379 GJavaParser.g
                    VariableDeclarator(getLeftIToken(), getRightIToken(),
                                       //#line 379 GJavaParser.g
                                       getRhsSym(1) as IVariableDeclaratorId,
                                       //#line 379 GJavaParser.g
                                       AstToken(getRhsIToken(2)),
                                       //#line 379 GJavaParser.g
                                       getRhsSym(3) as IVariableInitializer)
                //#line 379 GJavaParser.g
                );
            break;
            }
            //
            // Rule 111:  VariableDeclaratorId ::= identifier
            //
            case 111:
                break;
            //
            // Rule 112:  VariableDeclaratorId ::= VariableDeclaratorId [ ]
            //
            case 112: {
               //#line 382 "GJavaParser.g"
                setResult(
                    //#line 382 GJavaParser.g
                    VariableDeclaratorId(getLeftIToken(), getRightIToken(),
                                         //#line 382 GJavaParser.g
                                         getRhsSym(1) as IVariableDeclaratorId,
                                         //#line 382 GJavaParser.g
                                         AstToken(getRhsIToken(2)),
                                         //#line 382 GJavaParser.g
                                         AstToken(getRhsIToken(3)))
                //#line 382 GJavaParser.g
                );
            break;
            }
            //
            // Rule 113:  VariableInitializer ::= Expression
            //
            case 113:
                break;
            //
            // Rule 114:  VariableInitializer ::= ArrayInitializer
            //
            case 114:
                break;
            //
            // Rule 115:  FieldModifiers ::= FieldModifier
            //
            case 115:
                break;
            //
            // Rule 116:  FieldModifiers ::= FieldModifiers FieldModifier
            //
            case 116: {
               //#line 388 "GJavaParser.g"
                setResult(
                    //#line 388 GJavaParser.g
                    FieldModifiers(getLeftIToken(), getRightIToken(),
                                   //#line 388 GJavaParser.g
                                   getRhsSym(1) as IFieldModifiers,
                                   //#line 388 GJavaParser.g
                                   getRhsSym(2) as IFieldModifier)
                //#line 388 GJavaParser.g
                );
            break;
            }
            //
            // Rule 117:  FieldModifier ::= Annotation
            //
            case 117:
                break;
            //
            // Rule 118:  FieldModifier ::= public
            //
            case 118: {
               //#line 391 "GJavaParser.g"
                setResult(
                    //#line 391 GJavaParser.g
                    FieldModifier0(getRhsIToken(1))
                //#line 391 GJavaParser.g
                );
            break;
            }
            //
            // Rule 119:  FieldModifier ::= protected
            //
            case 119: {
               //#line 392 "GJavaParser.g"
                setResult(
                    //#line 392 GJavaParser.g
                    FieldModifier1(getRhsIToken(1))
                //#line 392 GJavaParser.g
                );
            break;
            }
            //
            // Rule 120:  FieldModifier ::= private
            //
            case 120: {
               //#line 393 "GJavaParser.g"
                setResult(
                    //#line 393 GJavaParser.g
                    FieldModifier2(getRhsIToken(1))
                //#line 393 GJavaParser.g
                );
            break;
            }
            //
            // Rule 121:  FieldModifier ::= static
            //
            case 121: {
               //#line 394 "GJavaParser.g"
                setResult(
                    //#line 394 GJavaParser.g
                    FieldModifier3(getRhsIToken(1))
                //#line 394 GJavaParser.g
                );
            break;
            }
            //
            // Rule 122:  FieldModifier ::= final
            //
            case 122: {
               //#line 395 "GJavaParser.g"
                setResult(
                    //#line 395 GJavaParser.g
                    FieldModifier4(getRhsIToken(1))
                //#line 395 GJavaParser.g
                );
            break;
            }
            //
            // Rule 123:  FieldModifier ::= transient
            //
            case 123: {
               //#line 396 "GJavaParser.g"
                setResult(
                    //#line 396 GJavaParser.g
                    FieldModifier5(getRhsIToken(1))
                //#line 396 GJavaParser.g
                );
            break;
            }
            //
            // Rule 124:  FieldModifier ::= volatile
            //
            case 124: {
               //#line 397 "GJavaParser.g"
                setResult(
                    //#line 397 GJavaParser.g
                    FieldModifier6(getRhsIToken(1))
                //#line 397 GJavaParser.g
                );
            break;
            }
            //
            // Rule 125:  MethodDeclaration ::= MethodHeader MethodBody
            //
            case 125: {
               //#line 399 "GJavaParser.g"
                setResult(
                    //#line 399 GJavaParser.g
                    MethodDeclaration(getLeftIToken(), getRightIToken(),
                                      //#line 399 GJavaParser.g
                                      getRhsSym(1) as MethodHeader,
                                      //#line 399 GJavaParser.g
                                      getRhsSym(2) as IMethodBody)
                //#line 399 GJavaParser.g
                );
            break;
            }
            //
            // Rule 126:  MethodHeader ::= MethodModifiersopt TypeParametersopt ResultType MethodDeclarator Throwsopt
            //
            case 126: {
               //#line 401 "GJavaParser.g"
                setResult(
                    //#line 401 GJavaParser.g
                    MethodHeader(getLeftIToken(), getRightIToken(),
                                 //#line 401 GJavaParser.g
                                 getRhsSym(1) as IMethodModifiersopt?,
                                 //#line 401 GJavaParser.g
                                 getRhsSym(2) as TypeParameters?,
                                 //#line 401 GJavaParser.g
                                 getRhsSym(3) as IResultType,
                                 //#line 401 GJavaParser.g
                                 getRhsSym(4) as IMethodDeclarator,
                                 //#line 401 GJavaParser.g
                                 getRhsSym(5) as Throws?)
                //#line 401 GJavaParser.g
                );
            break;
            }
            //
            // Rule 127:  ResultType ::= Type
            //
            case 127:
                break;
            //
            // Rule 128:  ResultType ::= void
            //
            case 128: {
               //#line 404 "GJavaParser.g"
                setResult(
                    //#line 404 GJavaParser.g
                    ResultType(getRhsIToken(1))
                //#line 404 GJavaParser.g
                );
            break;
            }
            //
            // Rule 129:  MethodDeclarator ::= identifier ( FormalParameterListopt )
            //
            case 129: {
               //#line 406 "GJavaParser.g"
                setResult(
                    //#line 406 GJavaParser.g
                    MethodDeclarator0(getLeftIToken(), getRightIToken(),
                                      //#line 406 GJavaParser.g
                                      getRhsSym(1) as identifier,
                                      //#line 406 GJavaParser.g
                                      AstToken(getRhsIToken(2)),
                                      //#line 406 GJavaParser.g
                                      getRhsSym(3) as IFormalParameterListopt?,
                                      //#line 406 GJavaParser.g
                                      AstToken(getRhsIToken(4)))
                //#line 406 GJavaParser.g
                );
            break;
            }
            //
            // Rule 130:  MethodDeclarator ::= MethodDeclarator [ ]
            //
            case 130: {
               //#line 408 "GJavaParser.g"
                setResult(
                    //#line 408 GJavaParser.g
                    MethodDeclarator1(getLeftIToken(), getRightIToken(),
                                      //#line 408 GJavaParser.g
                                      getRhsSym(1) as IMethodDeclarator,
                                      //#line 408 GJavaParser.g
                                      AstToken(getRhsIToken(2)),
                                      //#line 408 GJavaParser.g
                                      AstToken(getRhsIToken(3)))
                //#line 408 GJavaParser.g
                );
            break;
            }
            //
            // Rule 131:  FormalParameterList ::= LastFormalParameter
            //
            case 131:
                break;
            //
            // Rule 132:  FormalParameterList ::= FormalParameters , LastFormalParameter
            //
            case 132: {
               //#line 411 "GJavaParser.g"
                setResult(
                    //#line 411 GJavaParser.g
                    FormalParameterList(getLeftIToken(), getRightIToken(),
                                        //#line 411 GJavaParser.g
                                        getRhsSym(1) as IFormalParameters,
                                        //#line 411 GJavaParser.g
                                        AstToken(getRhsIToken(2)),
                                        //#line 411 GJavaParser.g
                                        getRhsSym(3) as LastFormalParameter)
                //#line 411 GJavaParser.g
                );
            break;
            }
            //
            // Rule 133:  FormalParameters ::= FormalParameter
            //
            case 133:
                break;
            //
            // Rule 134:  FormalParameters ::= FormalParameters , FormalParameter
            //
            case 134: {
               //#line 414 "GJavaParser.g"
                setResult(
                    //#line 414 GJavaParser.g
                    FormalParameters(getLeftIToken(), getRightIToken(),
                                     //#line 414 GJavaParser.g
                                     getRhsSym(1) as IFormalParameters,
                                     //#line 414 GJavaParser.g
                                     AstToken(getRhsIToken(2)),
                                     //#line 414 GJavaParser.g
                                     getRhsSym(3) as FormalParameter)
                //#line 414 GJavaParser.g
                );
            break;
            }
            //
            // Rule 135:  FormalParameter ::= VariableModifiersopt Type VariableDeclaratorId
            //
            case 135: {
               //#line 416 "GJavaParser.g"
                setResult(
                    //#line 416 GJavaParser.g
                    FormalParameter(getLeftIToken(), getRightIToken(),
                                    //#line 416 GJavaParser.g
                                    getRhsSym(1) as IVariableModifiersopt?,
                                    //#line 416 GJavaParser.g
                                    getRhsSym(2) as IType,
                                    //#line 416 GJavaParser.g
                                    getRhsSym(3) as IVariableDeclaratorId)
                //#line 416 GJavaParser.g
                );
            break;
            }
            //
            // Rule 136:  VariableModifiers ::= VariableModifier
            //
            case 136:
                break;
            //
            // Rule 137:  VariableModifiers ::= VariableModifiers VariableModifier
            //
            case 137: {
               //#line 419 "GJavaParser.g"
                setResult(
                    //#line 419 GJavaParser.g
                    VariableModifiers(getLeftIToken(), getRightIToken(),
                                      //#line 419 GJavaParser.g
                                      getRhsSym(1) as IVariableModifiers,
                                      //#line 419 GJavaParser.g
                                      getRhsSym(2) as IVariableModifier)
                //#line 419 GJavaParser.g
                );
            break;
            }
            //
            // Rule 138:  VariableModifier ::= final
            //
            case 138: {
               //#line 421 "GJavaParser.g"
                setResult(
                    //#line 421 GJavaParser.g
                    VariableModifier(getRhsIToken(1))
                //#line 421 GJavaParser.g
                );
            break;
            }
            //
            // Rule 139:  VariableModifier ::= Annotations
            //
            case 139:
                break;
            //
            // Rule 140:  LastFormalParameter ::= VariableModifiersopt Type ...opt VariableDeclaratorId
            //
            case 140: {
               //#line 424 "GJavaParser.g"
                setResult(
                    //#line 424 GJavaParser.g
                    LastFormalParameter(getLeftIToken(), getRightIToken(),
                                        //#line 424 GJavaParser.g
                                        getRhsSym(1) as IVariableModifiersopt?,
                                        //#line 424 GJavaParser.g
                                        getRhsSym(2) as IType,
                                        //#line 424 GJavaParser.g
                                        getRhsSym(3) as Ellipsisopt?,
                                        //#line 424 GJavaParser.g
                                        getRhsSym(4) as IVariableDeclaratorId)
                //#line 424 GJavaParser.g
                );
            break;
            }
            //
            // Rule 141:  MethodModifiers ::= MethodModifier
            //
            case 141:
                break;
            //
            // Rule 142:  MethodModifiers ::= MethodModifiers MethodModifier
            //
            case 142: {
               //#line 433 "GJavaParser.g"
                setResult(
                    //#line 433 GJavaParser.g
                    MethodModifiers(getLeftIToken(), getRightIToken(),
                                    //#line 433 GJavaParser.g
                                    getRhsSym(1) as IMethodModifiers,
                                    //#line 433 GJavaParser.g
                                    getRhsSym(2) as IMethodModifier)
                //#line 433 GJavaParser.g
                );
            break;
            }
            //
            // Rule 143:  MethodModifier ::= Annotations
            //
            case 143:
                break;
            //
            // Rule 144:  MethodModifier ::= public
            //
            case 144: {
               //#line 436 "GJavaParser.g"
                setResult(
                    //#line 436 GJavaParser.g
                    MethodModifier0(getRhsIToken(1))
                //#line 436 GJavaParser.g
                );
            break;
            }
            //
            // Rule 145:  MethodModifier ::= protected
            //
            case 145: {
               //#line 437 "GJavaParser.g"
                setResult(
                    //#line 437 GJavaParser.g
                    MethodModifier1(getRhsIToken(1))
                //#line 437 GJavaParser.g
                );
            break;
            }
            //
            // Rule 146:  MethodModifier ::= private
            //
            case 146: {
               //#line 438 "GJavaParser.g"
                setResult(
                    //#line 438 GJavaParser.g
                    MethodModifier2(getRhsIToken(1))
                //#line 438 GJavaParser.g
                );
            break;
            }
            //
            // Rule 147:  MethodModifier ::= abstract
            //
            case 147: {
               //#line 439 "GJavaParser.g"
                setResult(
                    //#line 439 GJavaParser.g
                    MethodModifier3(getRhsIToken(1))
                //#line 439 GJavaParser.g
                );
            break;
            }
            //
            // Rule 148:  MethodModifier ::= static
            //
            case 148: {
               //#line 440 "GJavaParser.g"
                setResult(
                    //#line 440 GJavaParser.g
                    MethodModifier4(getRhsIToken(1))
                //#line 440 GJavaParser.g
                );
            break;
            }
            //
            // Rule 149:  MethodModifier ::= final
            //
            case 149: {
               //#line 441 "GJavaParser.g"
                setResult(
                    //#line 441 GJavaParser.g
                    MethodModifier5(getRhsIToken(1))
                //#line 441 GJavaParser.g
                );
            break;
            }
            //
            // Rule 150:  MethodModifier ::= synchronized
            //
            case 150: {
               //#line 442 "GJavaParser.g"
                setResult(
                    //#line 442 GJavaParser.g
                    MethodModifier6(getRhsIToken(1))
                //#line 442 GJavaParser.g
                );
            break;
            }
            //
            // Rule 151:  MethodModifier ::= native
            //
            case 151: {
               //#line 443 "GJavaParser.g"
                setResult(
                    //#line 443 GJavaParser.g
                    MethodModifier7(getRhsIToken(1))
                //#line 443 GJavaParser.g
                );
            break;
            }
            //
            // Rule 152:  MethodModifier ::= strictfp
            //
            case 152: {
               //#line 444 "GJavaParser.g"
                setResult(
                    //#line 444 GJavaParser.g
                    MethodModifier8(getRhsIToken(1))
                //#line 444 GJavaParser.g
                );
            break;
            }
            //
            // Rule 153:  Throws ::= throws ExceptionTypeList
            //
            case 153: {
               //#line 446 "GJavaParser.g"
                setResult(
                    //#line 446 GJavaParser.g
                    Throws(getLeftIToken(), getRightIToken(),
                           //#line 446 GJavaParser.g
                           AstToken(getRhsIToken(1)),
                           //#line 446 GJavaParser.g
                           getRhsSym(2) as IExceptionTypeList)
                //#line 446 GJavaParser.g
                );
            break;
            }
            //
            // Rule 154:  ExceptionTypeList ::= ExceptionType
            //
            case 154:
                break;
            //
            // Rule 155:  ExceptionTypeList ::= ExceptionTypeList , ExceptionType
            //
            case 155: {
               //#line 449 "GJavaParser.g"
                setResult(
                    //#line 449 GJavaParser.g
                    ExceptionTypeList(getLeftIToken(), getRightIToken(),
                                      //#line 449 GJavaParser.g
                                      getRhsSym(1) as IExceptionTypeList,
                                      //#line 449 GJavaParser.g
                                      AstToken(getRhsIToken(2)),
                                      //#line 449 GJavaParser.g
                                      getRhsSym(3) as IExceptionType)
                //#line 449 GJavaParser.g
                );
            break;
            }
            //
            // Rule 156:  ExceptionType ::= ClassType
            //
            case 156:
                break;
            //
            // Rule 157:  ExceptionType ::= TypeVariable
            //
            case 157:
                break;
            //
            // Rule 158:  MethodBody ::= Block
            //
            case 158:
                break;
            //
            // Rule 159:  MethodBody ::= ;
            //
            case 159: {
               //#line 455 "GJavaParser.g"
                setResult(
                    //#line 455 GJavaParser.g
                    MethodBody(getRhsIToken(1))
                //#line 455 GJavaParser.g
                );
            break;
            }
            //
            // Rule 160:  InstanceInitializer ::= Block
            //
            case 160:
                break;
            //
            // Rule 161:  StaticInitializer ::= static Block
            //
            case 161: {
               //#line 459 "GJavaParser.g"
                setResult(
                    //#line 459 GJavaParser.g
                    StaticInitializer(getLeftIToken(), getRightIToken(),
                                      //#line 459 GJavaParser.g
                                      AstToken(getRhsIToken(1)),
                                      //#line 459 GJavaParser.g
                                      getRhsSym(2) as Block)
                //#line 459 GJavaParser.g
                );
            break;
            }
            //
            // Rule 162:  ConstructorDeclaration ::= ConstructorModifiersopt ConstructorDeclarator Throwsopt ConstructorBody
            //
            case 162: {
               //#line 461 "GJavaParser.g"
                setResult(
                    //#line 461 GJavaParser.g
                    ConstructorDeclaration(getLeftIToken(), getRightIToken(),
                                           //#line 461 GJavaParser.g
                                           getRhsSym(1) as IConstructorModifiersopt?,
                                           //#line 461 GJavaParser.g
                                           getRhsSym(2) as ConstructorDeclarator,
                                           //#line 461 GJavaParser.g
                                           getRhsSym(3) as Throws?,
                                           //#line 461 GJavaParser.g
                                           getRhsSym(4) as ConstructorBody)
                //#line 461 GJavaParser.g
                );
            break;
            }
            //
            // Rule 163:  ConstructorDeclarator ::= TypeParametersopt SimpleTypeName ( FormalParameterListopt )
            //
            case 163: {
               //#line 463 "GJavaParser.g"
                setResult(
                    //#line 463 GJavaParser.g
                    ConstructorDeclarator(getLeftIToken(), getRightIToken(),
                                          //#line 463 GJavaParser.g
                                          getRhsSym(1) as TypeParameters?,
                                          //#line 463 GJavaParser.g
                                          getRhsSym(2) as identifier,
                                          //#line 463 GJavaParser.g
                                          AstToken(getRhsIToken(3)),
                                          //#line 463 GJavaParser.g
                                          getRhsSym(4) as IFormalParameterListopt?,
                                          //#line 463 GJavaParser.g
                                          AstToken(getRhsIToken(5)))
                //#line 463 GJavaParser.g
                );
            break;
            }
            //
            // Rule 164:  SimpleTypeName ::= identifier
            //
            case 164:
                break;
            //
            // Rule 165:  ConstructorModifiers ::= ConstructorModifier
            //
            case 165:
                break;
            //
            // Rule 166:  ConstructorModifiers ::= ConstructorModifiers ConstructorModifier
            //
            case 166: {
               //#line 468 "GJavaParser.g"
                setResult(
                    //#line 468 GJavaParser.g
                    ConstructorModifiers(getLeftIToken(), getRightIToken(),
                                         //#line 468 GJavaParser.g
                                         getRhsSym(1) as IConstructorModifiers,
                                         //#line 468 GJavaParser.g
                                         getRhsSym(2) as IConstructorModifier)
                //#line 468 GJavaParser.g
                );
            break;
            }
            //
            // Rule 167:  ConstructorModifier ::= Annotations
            //
            case 167:
                break;
            //
            // Rule 168:  ConstructorModifier ::= public
            //
            case 168: {
               //#line 471 "GJavaParser.g"
                setResult(
                    //#line 471 GJavaParser.g
                    ConstructorModifier0(getRhsIToken(1))
                //#line 471 GJavaParser.g
                );
            break;
            }
            //
            // Rule 169:  ConstructorModifier ::= protected
            //
            case 169: {
               //#line 472 "GJavaParser.g"
                setResult(
                    //#line 472 GJavaParser.g
                    ConstructorModifier1(getRhsIToken(1))
                //#line 472 GJavaParser.g
                );
            break;
            }
            //
            // Rule 170:  ConstructorModifier ::= private
            //
            case 170: {
               //#line 473 "GJavaParser.g"
                setResult(
                    //#line 473 GJavaParser.g
                    ConstructorModifier2(getRhsIToken(1))
                //#line 473 GJavaParser.g
                );
            break;
            }
            //
            // Rule 171:  ConstructorBody ::= { ExplicitConstructorInvocationopt BlockStatementsopt }
            //
            case 171: {
               //#line 475 "GJavaParser.g"
                setResult(
                    //#line 475 GJavaParser.g
                    ConstructorBody(getLeftIToken(), getRightIToken(),
                                    //#line 475 GJavaParser.g
                                    AstToken(getRhsIToken(1)),
                                    //#line 475 GJavaParser.g
                                    getRhsSym(2) as IExplicitConstructorInvocationopt?,
                                    //#line 475 GJavaParser.g
                                    getRhsSym(3) as IBlockStatementsopt?,
                                    //#line 475 GJavaParser.g
                                    AstToken(getRhsIToken(4)))
                //#line 475 GJavaParser.g
                );
            break;
            }
            //
            // Rule 172:  ExplicitConstructorInvocation ::= TypeArgumentsopt this ( ArgumentListopt ) ;
            //
            case 172: {
               //#line 477 "GJavaParser.g"
                setResult(
                    //#line 477 GJavaParser.g
                    ExplicitConstructorInvocation0(getLeftIToken(), getRightIToken(),
                                                   //#line 477 GJavaParser.g
                                                   getRhsSym(1) as TypeArguments?,
                                                   //#line 477 GJavaParser.g
                                                   AstToken(getRhsIToken(2)),
                                                   //#line 477 GJavaParser.g
                                                   AstToken(getRhsIToken(3)),
                                                   //#line 477 GJavaParser.g
                                                   getRhsSym(4) as IArgumentListopt?,
                                                   //#line 477 GJavaParser.g
                                                   AstToken(getRhsIToken(5)),
                                                   //#line 477 GJavaParser.g
                                                   AstToken(getRhsIToken(6)))
                //#line 477 GJavaParser.g
                );
            break;
            }
            //
            // Rule 173:  ExplicitConstructorInvocation ::= TypeArgumentsopt super ( ArgumentListopt ) ;
            //
            case 173: {
               //#line 478 "GJavaParser.g"
                setResult(
                    //#line 478 GJavaParser.g
                    ExplicitConstructorInvocation1(getLeftIToken(), getRightIToken(),
                                                   //#line 478 GJavaParser.g
                                                   getRhsSym(1) as TypeArguments?,
                                                   //#line 478 GJavaParser.g
                                                   AstToken(getRhsIToken(2)),
                                                   //#line 478 GJavaParser.g
                                                   AstToken(getRhsIToken(3)),
                                                   //#line 478 GJavaParser.g
                                                   getRhsSym(4) as IArgumentListopt?,
                                                   //#line 478 GJavaParser.g
                                                   AstToken(getRhsIToken(5)),
                                                   //#line 478 GJavaParser.g
                                                   AstToken(getRhsIToken(6)))
                //#line 478 GJavaParser.g
                );
            break;
            }
            //
            // Rule 174:  ExplicitConstructorInvocation ::= Primary . TypeArgumentsopt super ( ArgumentListopt ) ;
            //
            case 174: {
               //#line 479 "GJavaParser.g"
                setResult(
                    //#line 479 GJavaParser.g
                    ExplicitConstructorInvocation2(getLeftIToken(), getRightIToken(),
                                                   //#line 479 GJavaParser.g
                                                   getRhsSym(1) as IPrimary,
                                                   //#line 479 GJavaParser.g
                                                   AstToken(getRhsIToken(2)),
                                                   //#line 479 GJavaParser.g
                                                   getRhsSym(3) as TypeArguments?,
                                                   //#line 479 GJavaParser.g
                                                   AstToken(getRhsIToken(4)),
                                                   //#line 479 GJavaParser.g
                                                   AstToken(getRhsIToken(5)),
                                                   //#line 479 GJavaParser.g
                                                   getRhsSym(6) as IArgumentListopt?,
                                                   //#line 479 GJavaParser.g
                                                   AstToken(getRhsIToken(7)),
                                                   //#line 479 GJavaParser.g
                                                   AstToken(getRhsIToken(8)))
                //#line 479 GJavaParser.g
                );
            break;
            }
            //
            // Rule 175:  EnumDeclaration ::= ClassModifiersopt enum identifier Interfacesopt EnumBody
            //
            case 175: {
               //#line 481 "GJavaParser.g"
                setResult(
                    //#line 481 GJavaParser.g
                    EnumDeclaration(getLeftIToken(), getRightIToken(),
                                    //#line 481 GJavaParser.g
                                    getRhsSym(1) as IClassModifiersopt?,
                                    //#line 481 GJavaParser.g
                                    AstToken(getRhsIToken(2)),
                                    //#line 481 GJavaParser.g
                                    getRhsSym(3) as identifier,
                                    //#line 481 GJavaParser.g
                                    getRhsSym(4) as Interfaces?,
                                    //#line 481 GJavaParser.g
                                    getRhsSym(5) as EnumBody)
                //#line 481 GJavaParser.g
                );
            break;
            }
            //
            // Rule 176:  EnumBody ::= { EnumConstantsopt ,opt EnumBodyDeclarationsopt }
            //
            case 176: {
               //#line 483 "GJavaParser.g"
                setResult(
                    //#line 483 GJavaParser.g
                    EnumBody(getLeftIToken(), getRightIToken(),
                             //#line 483 GJavaParser.g
                             AstToken(getRhsIToken(1)),
                             //#line 483 GJavaParser.g
                             getRhsSym(2) as IEnumConstantsopt?,
                             //#line 483 GJavaParser.g
                             getRhsSym(3) as Commaopt?,
                             //#line 483 GJavaParser.g
                             getRhsSym(4) as EnumBodyDeclarations?,
                             //#line 483 GJavaParser.g
                             AstToken(getRhsIToken(5)))
                //#line 483 GJavaParser.g
                );
            break;
            }
            //
            // Rule 177:  EnumConstants ::= EnumConstant
            //
            case 177:
                break;
            //
            // Rule 178:  EnumConstants ::= EnumConstants , EnumConstant
            //
            case 178: {
               //#line 486 "GJavaParser.g"
                setResult(
                    //#line 486 GJavaParser.g
                    EnumConstants(getLeftIToken(), getRightIToken(),
                                  //#line 486 GJavaParser.g
                                  getRhsSym(1) as IEnumConstants,
                                  //#line 486 GJavaParser.g
                                  AstToken(getRhsIToken(2)),
                                  //#line 486 GJavaParser.g
                                  getRhsSym(3) as IEnumConstant)
                //#line 486 GJavaParser.g
                );
            break;
            }
            //
            // Rule 179:  EnumConstant ::= Annotationsopt identifier Argumentsopt ClassBodyopt
            //
            case 179: {
               //#line 488 "GJavaParser.g"
                setResult(
                    //#line 488 GJavaParser.g
                    EnumConstant(getLeftIToken(), getRightIToken(),
                                 //#line 488 GJavaParser.g
                                 getRhsSym(1) as IAnnotationsopt?,
                                 //#line 488 GJavaParser.g
                                 getRhsSym(2) as identifier,
                                 //#line 488 GJavaParser.g
                                 getRhsSym(3) as Arguments?,
                                 //#line 488 GJavaParser.g
                                 getRhsSym(4) as ClassBody?)
                //#line 488 GJavaParser.g
                );
            break;
            }
            //
            // Rule 180:  Arguments ::= ( ArgumentListopt )
            //
            case 180: {
               //#line 490 "GJavaParser.g"
                setResult(
                    //#line 490 GJavaParser.g
                    Arguments(getLeftIToken(), getRightIToken(),
                              //#line 490 GJavaParser.g
                              AstToken(getRhsIToken(1)),
                              //#line 490 GJavaParser.g
                              getRhsSym(2) as IArgumentListopt?,
                              //#line 490 GJavaParser.g
                              AstToken(getRhsIToken(3)))
                //#line 490 GJavaParser.g
                );
            break;
            }
            //
            // Rule 181:  EnumBodyDeclarations ::= ; ClassBodyDeclarationsopt
            //
            case 181: {
               //#line 492 "GJavaParser.g"
                setResult(
                    //#line 492 GJavaParser.g
                    EnumBodyDeclarations(getLeftIToken(), getRightIToken(),
                                         //#line 492 GJavaParser.g
                                         AstToken(getRhsIToken(1)),
                                         //#line 492 GJavaParser.g
                                         getRhsSym(2) as IClassBodyDeclarationsopt?)
                //#line 492 GJavaParser.g
                );
            break;
            }
            //
            // Rule 182:  InterfaceDeclaration ::= NormalInterfaceDeclaration
            //
            case 182:
                break;
            //
            // Rule 183:  InterfaceDeclaration ::= AnnotationTypeDeclaration
            //
            case 183:
                break;
            //
            // Rule 184:  NormalInterfaceDeclaration ::= InterfaceModifiersopt interface identifier TypeParametersopt ExtendsInterfacesopt InterfaceBody
            //
            case 184: {
               //#line 499 "GJavaParser.g"
                setResult(
                    //#line 499 GJavaParser.g
                    NormalInterfaceDeclaration(getLeftIToken(), getRightIToken(),
                                               //#line 499 GJavaParser.g
                                               getRhsSym(1) as IInterfaceModifiersopt?,
                                               //#line 499 GJavaParser.g
                                               AstToken(getRhsIToken(2)),
                                               //#line 499 GJavaParser.g
                                               getRhsSym(3) as identifier,
                                               //#line 499 GJavaParser.g
                                               getRhsSym(4) as TypeParameters?,
                                               //#line 499 GJavaParser.g
                                               getRhsSym(5) as IExtendsInterfacesopt?,
                                               //#line 499 GJavaParser.g
                                               getRhsSym(6) as InterfaceBody)
                //#line 499 GJavaParser.g
                );
            break;
            }
            //
            // Rule 185:  InterfaceModifiers ::= InterfaceModifier
            //
            case 185:
                break;
            //
            // Rule 186:  InterfaceModifiers ::= InterfaceModifiers InterfaceModifier
            //
            case 186: {
               //#line 502 "GJavaParser.g"
                setResult(
                    //#line 502 GJavaParser.g
                    InterfaceModifiers(getLeftIToken(), getRightIToken(),
                                       //#line 502 GJavaParser.g
                                       getRhsSym(1) as IInterfaceModifiers,
                                       //#line 502 GJavaParser.g
                                       getRhsSym(2) as IInterfaceModifier)
                //#line 502 GJavaParser.g
                );
            break;
            }
            //
            // Rule 187:  InterfaceModifier ::= Annotation
            //
            case 187:
                break;
            //
            // Rule 188:  InterfaceModifier ::= public
            //
            case 188: {
               //#line 505 "GJavaParser.g"
                setResult(
                    //#line 505 GJavaParser.g
                    InterfaceModifier0(getRhsIToken(1))
                //#line 505 GJavaParser.g
                );
            break;
            }
            //
            // Rule 189:  InterfaceModifier ::= protected
            //
            case 189: {
               //#line 506 "GJavaParser.g"
                setResult(
                    //#line 506 GJavaParser.g
                    InterfaceModifier1(getRhsIToken(1))
                //#line 506 GJavaParser.g
                );
            break;
            }
            //
            // Rule 190:  InterfaceModifier ::= private
            //
            case 190: {
               //#line 507 "GJavaParser.g"
                setResult(
                    //#line 507 GJavaParser.g
                    InterfaceModifier2(getRhsIToken(1))
                //#line 507 GJavaParser.g
                );
            break;
            }
            //
            // Rule 191:  InterfaceModifier ::= abstract
            //
            case 191: {
               //#line 508 "GJavaParser.g"
                setResult(
                    //#line 508 GJavaParser.g
                    InterfaceModifier3(getRhsIToken(1))
                //#line 508 GJavaParser.g
                );
            break;
            }
            //
            // Rule 192:  InterfaceModifier ::= static
            //
            case 192: {
               //#line 509 "GJavaParser.g"
                setResult(
                    //#line 509 GJavaParser.g
                    InterfaceModifier4(getRhsIToken(1))
                //#line 509 GJavaParser.g
                );
            break;
            }
            //
            // Rule 193:  InterfaceModifier ::= strictfp
            //
            case 193: {
               //#line 510 "GJavaParser.g"
                setResult(
                    //#line 510 GJavaParser.g
                    InterfaceModifier5(getRhsIToken(1))
                //#line 510 GJavaParser.g
                );
            break;
            }
            //
            // Rule 194:  ExtendsInterfaces ::= extends InterfaceType
            //
            case 194: {
               //#line 512 "GJavaParser.g"
                setResult(
                    //#line 512 GJavaParser.g
                    ExtendsInterfaces0(getLeftIToken(), getRightIToken(),
                                       //#line 512 GJavaParser.g
                                       AstToken(getRhsIToken(1)),
                                       //#line 512 GJavaParser.g
                                       getRhsSym(2) as InterfaceType)
                //#line 512 GJavaParser.g
                );
            break;
            }
            //
            // Rule 195:  ExtendsInterfaces ::= ExtendsInterfaces , InterfaceType
            //
            case 195: {
               //#line 513 "GJavaParser.g"
                setResult(
                    //#line 513 GJavaParser.g
                    ExtendsInterfaces1(getLeftIToken(), getRightIToken(),
                                       //#line 513 GJavaParser.g
                                       getRhsSym(1) as IExtendsInterfaces,
                                       //#line 513 GJavaParser.g
                                       AstToken(getRhsIToken(2)),
                                       //#line 513 GJavaParser.g
                                       getRhsSym(3) as InterfaceType)
                //#line 513 GJavaParser.g
                );
            break;
            }
            //
            // Rule 196:  InterfaceBody ::= { InterfaceMemberDeclarationsopt }
            //
            case 196: {
               //#line 520 "GJavaParser.g"
                setResult(
                    //#line 520 GJavaParser.g
                    InterfaceBody(getLeftIToken(), getRightIToken(),
                                  //#line 520 GJavaParser.g
                                  AstToken(getRhsIToken(1)),
                                  //#line 520 GJavaParser.g
                                  getRhsSym(2) as IInterfaceMemberDeclarationsopt?,
                                  //#line 520 GJavaParser.g
                                  AstToken(getRhsIToken(3)))
                //#line 520 GJavaParser.g
                );
            break;
            }
            //
            // Rule 197:  InterfaceMemberDeclarations ::= InterfaceMemberDeclaration
            //
            case 197:
                break;
            //
            // Rule 198:  InterfaceMemberDeclarations ::= InterfaceMemberDeclarations InterfaceMemberDeclaration
            //
            case 198: {
               //#line 523 "GJavaParser.g"
                setResult(
                    //#line 523 GJavaParser.g
                    InterfaceMemberDeclarations(getLeftIToken(), getRightIToken(),
                                                //#line 523 GJavaParser.g
                                                getRhsSym(1) as IInterfaceMemberDeclarations,
                                                //#line 523 GJavaParser.g
                                                getRhsSym(2) as IInterfaceMemberDeclaration)
                //#line 523 GJavaParser.g
                );
            break;
            }
            //
            // Rule 199:  InterfaceMemberDeclaration ::= ConstantDeclaration
            //
            case 199:
                break;
            //
            // Rule 200:  InterfaceMemberDeclaration ::= AbstractMethodDeclaration
            //
            case 200:
                break;
            //
            // Rule 201:  InterfaceMemberDeclaration ::= ClassDeclaration
            //
            case 201:
                break;
            //
            // Rule 202:  InterfaceMemberDeclaration ::= InterfaceDeclaration
            //
            case 202:
                break;
            //
            // Rule 203:  InterfaceMemberDeclaration ::= ;
            //
            case 203: {
               //#line 529 "GJavaParser.g"
                setResult(
                    //#line 529 GJavaParser.g
                    InterfaceMemberDeclaration(getRhsIToken(1))
                //#line 529 GJavaParser.g
                );
            break;
            }
            //
            // Rule 204:  ConstantDeclaration ::= ConstantModifiersopt Type VariableDeclarators
            //
            case 204: {
               //#line 531 "GJavaParser.g"
                setResult(
                    //#line 531 GJavaParser.g
                    ConstantDeclaration(getLeftIToken(), getRightIToken(),
                                        //#line 531 GJavaParser.g
                                        getRhsSym(1) as IConstantModifiersopt?,
                                        //#line 531 GJavaParser.g
                                        getRhsSym(2) as IType,
                                        //#line 531 GJavaParser.g
                                        getRhsSym(3) as IVariableDeclarators)
                //#line 531 GJavaParser.g
                );
            break;
            }
            //
            // Rule 205:  ConstantModifiers ::= ConstantModifier
            //
            case 205:
                break;
            //
            // Rule 206:  ConstantModifiers ::= ConstantModifiers ConstantModifier
            //
            case 206: {
               //#line 534 "GJavaParser.g"
                setResult(
                    //#line 534 GJavaParser.g
                    ConstantModifiers(getLeftIToken(), getRightIToken(),
                                      //#line 534 GJavaParser.g
                                      getRhsSym(1) as IConstantModifiers,
                                      //#line 534 GJavaParser.g
                                      getRhsSym(2) as IConstantModifier)
                //#line 534 GJavaParser.g
                );
            break;
            }
            //
            // Rule 207:  ConstantModifier ::= Annotation
            //
            case 207:
                break;
            //
            // Rule 208:  ConstantModifier ::= public
            //
            case 208: {
               //#line 537 "GJavaParser.g"
                setResult(
                    //#line 537 GJavaParser.g
                    ConstantModifier0(getRhsIToken(1))
                //#line 537 GJavaParser.g
                );
            break;
            }
            //
            // Rule 209:  ConstantModifier ::= static
            //
            case 209: {
               //#line 538 "GJavaParser.g"
                setResult(
                    //#line 538 GJavaParser.g
                    ConstantModifier1(getRhsIToken(1))
                //#line 538 GJavaParser.g
                );
            break;
            }
            //
            // Rule 210:  ConstantModifier ::= final
            //
            case 210: {
               //#line 539 "GJavaParser.g"
                setResult(
                    //#line 539 GJavaParser.g
                    ConstantModifier2(getRhsIToken(1))
                //#line 539 GJavaParser.g
                );
            break;
            }
            //
            // Rule 211:  AbstractMethodDeclaration ::= AbstractMethodModifiersopt TypeParametersopt ResultType MethodDeclarator Throwsopt ;
            //
            case 211: {
               //#line 541 "GJavaParser.g"
                setResult(
                    //#line 541 GJavaParser.g
                    AbstractMethodDeclaration(getLeftIToken(), getRightIToken(),
                                              //#line 541 GJavaParser.g
                                              getRhsSym(1) as IAbstractMethodModifiersopt?,
                                              //#line 541 GJavaParser.g
                                              getRhsSym(2) as TypeParameters?,
                                              //#line 541 GJavaParser.g
                                              getRhsSym(3) as IResultType,
                                              //#line 541 GJavaParser.g
                                              getRhsSym(4) as IMethodDeclarator,
                                              //#line 541 GJavaParser.g
                                              getRhsSym(5) as Throws?,
                                              //#line 541 GJavaParser.g
                                              AstToken(getRhsIToken(6)))
                //#line 541 GJavaParser.g
                );
            break;
            }
            //
            // Rule 212:  AbstractMethodModifiers ::= AbstractMethodModifier
            //
            case 212:
                break;
            //
            // Rule 213:  AbstractMethodModifiers ::= AbstractMethodModifiers AbstractMethodModifier
            //
            case 213: {
               //#line 544 "GJavaParser.g"
                setResult(
                    //#line 544 GJavaParser.g
                    AbstractMethodModifiers(getLeftIToken(), getRightIToken(),
                                            //#line 544 GJavaParser.g
                                            getRhsSym(1) as IAbstractMethodModifiers,
                                            //#line 544 GJavaParser.g
                                            getRhsSym(2) as IAbstractMethodModifier)
                //#line 544 GJavaParser.g
                );
            break;
            }
            //
            // Rule 214:  AbstractMethodModifier ::= Annotations
            //
            case 214:
                break;
            //
            // Rule 215:  AbstractMethodModifier ::= public
            //
            case 215: {
               //#line 547 "GJavaParser.g"
                setResult(
                    //#line 547 GJavaParser.g
                    AbstractMethodModifier0(getRhsIToken(1))
                //#line 547 GJavaParser.g
                );
            break;
            }
            //
            // Rule 216:  AbstractMethodModifier ::= abstract
            //
            case 216: {
               //#line 548 "GJavaParser.g"
                setResult(
                    //#line 548 GJavaParser.g
                    AbstractMethodModifier1(getRhsIToken(1))
                //#line 548 GJavaParser.g
                );
            break;
            }
            //
            // Rule 217:  AnnotationTypeDeclaration ::= InterfaceModifiersopt @ interface identifier AnnotationTypeBody
            //
            case 217: {
               //#line 550 "GJavaParser.g"
                setResult(
                    //#line 550 GJavaParser.g
                    AnnotationTypeDeclaration(getLeftIToken(), getRightIToken(),
                                              //#line 550 GJavaParser.g
                                              getRhsSym(1) as IInterfaceModifiersopt?,
                                              //#line 550 GJavaParser.g
                                              AstToken(getRhsIToken(2)),
                                              //#line 550 GJavaParser.g
                                              AstToken(getRhsIToken(3)),
                                              //#line 550 GJavaParser.g
                                              getRhsSym(4) as identifier,
                                              //#line 550 GJavaParser.g
                                              getRhsSym(5) as AnnotationTypeBody)
                //#line 550 GJavaParser.g
                );
            break;
            }
            //
            // Rule 218:  AnnotationTypeBody ::= { AnnotationTypeElementDeclarationsopt }
            //
            case 218: {
               //#line 552 "GJavaParser.g"
                setResult(
                    //#line 552 GJavaParser.g
                    AnnotationTypeBody(getLeftIToken(), getRightIToken(),
                                       //#line 552 GJavaParser.g
                                       AstToken(getRhsIToken(1)),
                                       //#line 552 GJavaParser.g
                                       getRhsSym(2) as IAnnotationTypeElementDeclarationsopt?,
                                       //#line 552 GJavaParser.g
                                       AstToken(getRhsIToken(3)))
                //#line 552 GJavaParser.g
                );
            break;
            }
            //
            // Rule 219:  AnnotationTypeElementDeclarations ::= AnnotationTypeElementDeclaration
            //
            case 219:
                break;
            //
            // Rule 220:  AnnotationTypeElementDeclarations ::= AnnotationTypeElementDeclarations AnnotationTypeElementDeclaration
            //
            case 220: {
               //#line 555 "GJavaParser.g"
                setResult(
                    //#line 555 GJavaParser.g
                    AnnotationTypeElementDeclarations(getLeftIToken(), getRightIToken(),
                                                      //#line 555 GJavaParser.g
                                                      getRhsSym(1) as IAnnotationTypeElementDeclarations,
                                                      //#line 555 GJavaParser.g
                                                      getRhsSym(2) as IAnnotationTypeElementDeclaration)
                //#line 555 GJavaParser.g
                );
            break;
            }
            //
            // Rule 221:  AnnotationTypeElementDeclaration ::= AbstractMethodModifiersopt Type identifier ( ) DefaultValueopt ;
            //
            case 221: {
               //#line 557 "GJavaParser.g"
                setResult(
                    //#line 557 GJavaParser.g
                    AnnotationTypeElementDeclaration0(getLeftIToken(), getRightIToken(),
                                                      //#line 557 GJavaParser.g
                                                      getRhsSym(1) as IAbstractMethodModifiersopt?,
                                                      //#line 557 GJavaParser.g
                                                      getRhsSym(2) as IType,
                                                      //#line 557 GJavaParser.g
                                                      getRhsSym(3) as identifier,
                                                      //#line 557 GJavaParser.g
                                                      AstToken(getRhsIToken(4)),
                                                      //#line 557 GJavaParser.g
                                                      AstToken(getRhsIToken(5)),
                                                      //#line 557 GJavaParser.g
                                                      getRhsSym(6) as DefaultValue?,
                                                      //#line 557 GJavaParser.g
                                                      AstToken(getRhsIToken(7)))
                //#line 557 GJavaParser.g
                );
            break;
            }
            //
            // Rule 222:  AnnotationTypeElementDeclaration ::= ConstantDeclaration
            //
            case 222:
                break;
            //
            // Rule 223:  AnnotationTypeElementDeclaration ::= ClassDeclaration
            //
            case 223:
                break;
            //
            // Rule 224:  AnnotationTypeElementDeclaration ::= InterfaceDeclaration
            //
            case 224:
                break;
            //
            // Rule 225:  AnnotationTypeElementDeclaration ::= EnumDeclaration
            //
            case 225:
                break;
            //
            // Rule 226:  AnnotationTypeElementDeclaration ::= AnnotationTypeDeclaration
            //
            case 226:
                break;
            //
            // Rule 227:  AnnotationTypeElementDeclaration ::= ;
            //
            case 227: {
               //#line 563 "GJavaParser.g"
                setResult(
                    //#line 563 GJavaParser.g
                    AnnotationTypeElementDeclaration1(getRhsIToken(1))
                //#line 563 GJavaParser.g
                );
            break;
            }
            //
            // Rule 228:  DefaultValue ::= default ElementValue
            //
            case 228: {
               //#line 565 "GJavaParser.g"
                setResult(
                    //#line 565 GJavaParser.g
                    DefaultValue(getLeftIToken(), getRightIToken(),
                                 //#line 565 GJavaParser.g
                                 AstToken(getRhsIToken(1)),
                                 //#line 565 GJavaParser.g
                                 getRhsSym(2) as IElementValue)
                //#line 565 GJavaParser.g
                );
            break;
            }
            //
            // Rule 229:  Annotations ::= Annotation
            //
            case 229:
                break;
            //
            // Rule 230:  Annotations ::= Annotations Annotation
            //
            case 230: {
               //#line 568 "GJavaParser.g"
                setResult(
                    //#line 568 GJavaParser.g
                    Annotations(getLeftIToken(), getRightIToken(),
                                //#line 568 GJavaParser.g
                                getRhsSym(1) as IAnnotations,
                                //#line 568 GJavaParser.g
                                getRhsSym(2) as IAnnotation)
                //#line 568 GJavaParser.g
                );
            break;
            }
            //
            // Rule 231:  Annotation ::= NormalAnnotation
            //
            case 231:
                break;
            //
            // Rule 232:  Annotation ::= MarkerAnnotation
            //
            case 232:
                break;
            //
            // Rule 233:  Annotation ::= SingleElementAnnotation
            //
            case 233:
                break;
            //
            // Rule 234:  NormalAnnotation ::= @ TypeName ( ElementValuePairsopt )
            //
            case 234: {
               //#line 574 "GJavaParser.g"
                setResult(
                    //#line 574 GJavaParser.g
                    NormalAnnotation(getLeftIToken(), getRightIToken(),
                                     //#line 574 GJavaParser.g
                                     AstToken(getRhsIToken(1)),
                                     //#line 574 GJavaParser.g
                                     getRhsSym(2) as ITypeName,
                                     //#line 574 GJavaParser.g
                                     AstToken(getRhsIToken(3)),
                                     //#line 574 GJavaParser.g
                                     getRhsSym(4) as IElementValuePairsopt?,
                                     //#line 574 GJavaParser.g
                                     AstToken(getRhsIToken(5)))
                //#line 574 GJavaParser.g
                );
            break;
            }
            //
            // Rule 235:  ElementValuePairs ::= ElementValuePair
            //
            case 235:
                break;
            //
            // Rule 236:  ElementValuePairs ::= ElementValuePairs , ElementValuePair
            //
            case 236: {
               //#line 577 "GJavaParser.g"
                setResult(
                    //#line 577 GJavaParser.g
                    ElementValuePairs(getLeftIToken(), getRightIToken(),
                                      //#line 577 GJavaParser.g
                                      getRhsSym(1) as IElementValuePairs,
                                      //#line 577 GJavaParser.g
                                      AstToken(getRhsIToken(2)),
                                      //#line 577 GJavaParser.g
                                      getRhsSym(3) as ElementValuePair)
                //#line 577 GJavaParser.g
                );
            break;
            }
            //
            // Rule 237:  ElementValuePair ::= SimpleName = ElementValue
            //
            case 237: {
               //#line 579 "GJavaParser.g"
                setResult(
                    //#line 579 GJavaParser.g
                    ElementValuePair(getLeftIToken(), getRightIToken(),
                                     //#line 579 GJavaParser.g
                                     getRhsSym(1) as identifier,
                                     //#line 579 GJavaParser.g
                                     AstToken(getRhsIToken(2)),
                                     //#line 579 GJavaParser.g
                                     getRhsSym(3) as IElementValue)
                //#line 579 GJavaParser.g
                );
            break;
            }
            //
            // Rule 238:  SimpleName ::= identifier
            //
            case 238:
                break;
            //
            // Rule 239:  ElementValue ::= ConditionalExpression
            //
            case 239:
                break;
            //
            // Rule 240:  ElementValue ::= Annotation
            //
            case 240:
                break;
            //
            // Rule 241:  ElementValue ::= ElementValueArrayInitializer
            //
            case 241:
                break;
            //
            // Rule 242:  ElementValueArrayInitializer ::= { ElementValuesopt ,opt }
            //
            case 242: {
               //#line 587 "GJavaParser.g"
                setResult(
                    //#line 587 GJavaParser.g
                    ElementValueArrayInitializer(getLeftIToken(), getRightIToken(),
                                                 //#line 587 GJavaParser.g
                                                 AstToken(getRhsIToken(1)),
                                                 //#line 587 GJavaParser.g
                                                 getRhsSym(2) as IElementValuesopt?,
                                                 //#line 587 GJavaParser.g
                                                 getRhsSym(3) as Commaopt?,
                                                 //#line 587 GJavaParser.g
                                                 AstToken(getRhsIToken(4)))
                //#line 587 GJavaParser.g
                );
            break;
            }
            //
            // Rule 243:  ElementValues ::= ElementValue
            //
            case 243:
                break;
            //
            // Rule 244:  ElementValues ::= ElementValues , ElementValue
            //
            case 244: {
               //#line 590 "GJavaParser.g"
                setResult(
                    //#line 590 GJavaParser.g
                    ElementValues(getLeftIToken(), getRightIToken(),
                                  //#line 590 GJavaParser.g
                                  getRhsSym(1) as IElementValues,
                                  //#line 590 GJavaParser.g
                                  AstToken(getRhsIToken(2)),
                                  //#line 590 GJavaParser.g
                                  getRhsSym(3) as IElementValue)
                //#line 590 GJavaParser.g
                );
            break;
            }
            //
            // Rule 245:  MarkerAnnotation ::= @ TypeName
            //
            case 245: {
               //#line 592 "GJavaParser.g"
                setResult(
                    //#line 592 GJavaParser.g
                    MarkerAnnotation(getLeftIToken(), getRightIToken(),
                                     //#line 592 GJavaParser.g
                                     AstToken(getRhsIToken(1)),
                                     //#line 592 GJavaParser.g
                                     getRhsSym(2) as ITypeName)
                //#line 592 GJavaParser.g
                );
            break;
            }
            //
            // Rule 246:  SingleElementAnnotation ::= @ TypeName ( ElementValue )
            //
            case 246: {
               //#line 594 "GJavaParser.g"
                setResult(
                    //#line 594 GJavaParser.g
                    SingleElementAnnotation(getLeftIToken(), getRightIToken(),
                                            //#line 594 GJavaParser.g
                                            AstToken(getRhsIToken(1)),
                                            //#line 594 GJavaParser.g
                                            getRhsSym(2) as ITypeName,
                                            //#line 594 GJavaParser.g
                                            AstToken(getRhsIToken(3)),
                                            //#line 594 GJavaParser.g
                                            getRhsSym(4) as IElementValue,
                                            //#line 594 GJavaParser.g
                                            AstToken(getRhsIToken(5)))
                //#line 594 GJavaParser.g
                );
            break;
            }
            //
            // Rule 247:  ArrayInitializer ::= { VariableInitializersopt ,opt }
            //
            case 247: {
               //#line 598 "GJavaParser.g"
                setResult(
                    //#line 598 GJavaParser.g
                    ArrayInitializer(getLeftIToken(), getRightIToken(),
                                     //#line 598 GJavaParser.g
                                     AstToken(getRhsIToken(1)),
                                     //#line 598 GJavaParser.g
                                     getRhsSym(2) as IVariableInitializersopt?,
                                     //#line 598 GJavaParser.g
                                     getRhsSym(3) as Commaopt?,
                                     //#line 598 GJavaParser.g
                                     AstToken(getRhsIToken(4)))
                //#line 598 GJavaParser.g
                );
            break;
            }
            //
            // Rule 248:  VariableInitializers ::= VariableInitializer
            //
            case 248:
                break;
            //
            // Rule 249:  VariableInitializers ::= VariableInitializers , VariableInitializer
            //
            case 249: {
               //#line 601 "GJavaParser.g"
                setResult(
                    //#line 601 GJavaParser.g
                    VariableInitializers(getLeftIToken(), getRightIToken(),
                                         //#line 601 GJavaParser.g
                                         getRhsSym(1) as IVariableInitializers,
                                         //#line 601 GJavaParser.g
                                         AstToken(getRhsIToken(2)),
                                         //#line 601 GJavaParser.g
                                         getRhsSym(3) as IVariableInitializer)
                //#line 601 GJavaParser.g
                );
            break;
            }
            //
            // Rule 250:  Block ::= { BlockStatementsopt }
            //
            case 250: {
               //#line 617 "GJavaParser.g"
                setResult(
                    //#line 617 GJavaParser.g
                    Block(getLeftIToken(), getRightIToken(),
                          //#line 617 GJavaParser.g
                          AstToken(getRhsIToken(1)),
                          //#line 617 GJavaParser.g
                          getRhsSym(2) as IBlockStatementsopt?,
                          //#line 617 GJavaParser.g
                          AstToken(getRhsIToken(3)))
                //#line 617 GJavaParser.g
                );
            break;
            }
            //
            // Rule 251:  BlockStatements ::= BlockStatement
            //
            case 251:
                break;
            //
            // Rule 252:  BlockStatements ::= BlockStatements BlockStatement
            //
            case 252: {
               //#line 620 "GJavaParser.g"
                setResult(
                    //#line 620 GJavaParser.g
                    BlockStatements(getLeftIToken(), getRightIToken(),
                                    //#line 620 GJavaParser.g
                                    getRhsSym(1) as IBlockStatements,
                                    //#line 620 GJavaParser.g
                                    getRhsSym(2) as IBlockStatement)
                //#line 620 GJavaParser.g
                );
            break;
            }
            //
            // Rule 253:  BlockStatement ::= LocalVariableDeclarationStatement
            //
            case 253:
                break;
            //
            // Rule 254:  BlockStatement ::= ClassDeclaration
            //
            case 254:
                break;
            //
            // Rule 255:  BlockStatement ::= Statement
            //
            case 255:
                break;
            //
            // Rule 256:  LocalVariableDeclarationStatement ::= LocalVariableDeclaration ;
            //
            case 256: {
               //#line 626 "GJavaParser.g"
                setResult(
                    //#line 626 GJavaParser.g
                    LocalVariableDeclarationStatement(getLeftIToken(), getRightIToken(),
                                                      //#line 626 GJavaParser.g
                                                      getRhsSym(1) as LocalVariableDeclaration,
                                                      //#line 626 GJavaParser.g
                                                      AstToken(getRhsIToken(2)))
                //#line 626 GJavaParser.g
                );
            break;
            }
            //
            // Rule 257:  LocalVariableDeclaration ::= VariableModifiersopt Type VariableDeclarators
            //
            case 257: {
               //#line 628 "GJavaParser.g"
                setResult(
                    //#line 628 GJavaParser.g
                    LocalVariableDeclaration(getLeftIToken(), getRightIToken(),
                                             //#line 628 GJavaParser.g
                                             getRhsSym(1) as IVariableModifiersopt?,
                                             //#line 628 GJavaParser.g
                                             getRhsSym(2) as IType,
                                             //#line 628 GJavaParser.g
                                             getRhsSym(3) as IVariableDeclarators)
                //#line 628 GJavaParser.g
                );
            break;
            }
            //
            // Rule 258:  Statement ::= StatementWithoutTrailingSubstatement
            //
            case 258:
                break;
            //
            // Rule 259:  Statement ::= LabeledStatement
            //
            case 259:
                break;
            //
            // Rule 260:  Statement ::= IfThenStatement
            //
            case 260:
                break;
            //
            // Rule 261:  Statement ::= IfThenElseStatement
            //
            case 261:
                break;
            //
            // Rule 262:  Statement ::= WhileStatement
            //
            case 262:
                break;
            //
            // Rule 263:  Statement ::= ForStatement
            //
            case 263:
                break;
            //
            // Rule 264:  StatementWithoutTrailingSubstatement ::= Block
            //
            case 264:
                break;
            //
            // Rule 265:  StatementWithoutTrailingSubstatement ::= EmptyStatement
            //
            case 265:
                break;
            //
            // Rule 266:  StatementWithoutTrailingSubstatement ::= ExpressionStatement
            //
            case 266:
                break;
            //
            // Rule 267:  StatementWithoutTrailingSubstatement ::= AssertStatement
            //
            case 267:
                break;
            //
            // Rule 268:  StatementWithoutTrailingSubstatement ::= SwitchStatement
            //
            case 268:
                break;
            //
            // Rule 269:  StatementWithoutTrailingSubstatement ::= DoStatement
            //
            case 269:
                break;
            //
            // Rule 270:  StatementWithoutTrailingSubstatement ::= BreakStatement
            //
            case 270:
                break;
            //
            // Rule 271:  StatementWithoutTrailingSubstatement ::= ContinueStatement
            //
            case 271:
                break;
            //
            // Rule 272:  StatementWithoutTrailingSubstatement ::= ReturnStatement
            //
            case 272:
                break;
            //
            // Rule 273:  StatementWithoutTrailingSubstatement ::= SynchronizedStatement
            //
            case 273:
                break;
            //
            // Rule 274:  StatementWithoutTrailingSubstatement ::= ThrowStatement
            //
            case 274:
                break;
            //
            // Rule 275:  StatementWithoutTrailingSubstatement ::= TryStatement
            //
            case 275:
                break;
            //
            // Rule 276:  StatementNoShortIf ::= StatementWithoutTrailingSubstatement
            //
            case 276:
                break;
            //
            // Rule 277:  StatementNoShortIf ::= LabeledStatementNoShortIf
            //
            case 277:
                break;
            //
            // Rule 278:  StatementNoShortIf ::= IfThenElseStatementNoShortIf
            //
            case 278:
                break;
            //
            // Rule 279:  StatementNoShortIf ::= WhileStatementNoShortIf
            //
            case 279:
                break;
            //
            // Rule 280:  StatementNoShortIf ::= ForStatementNoShortIf
            //
            case 280:
                break;
            //
            // Rule 281:  IfThenStatement ::= if ( Expression ) Statement
            //
            case 281: {
               //#line 671 "GJavaParser.g"
                setResult(
                    //#line 671 GJavaParser.g
                    IfThenStatement(getLeftIToken(), getRightIToken(),
                                    //#line 671 GJavaParser.g
                                    AstToken(getRhsIToken(1)),
                                    //#line 671 GJavaParser.g
                                    AstToken(getRhsIToken(2)),
                                    //#line 671 GJavaParser.g
                                    getRhsSym(3) as IExpression,
                                    //#line 671 GJavaParser.g
                                    AstToken(getRhsIToken(4)),
                                    //#line 671 GJavaParser.g
                                    getRhsSym(5) as IStatement)
                //#line 671 GJavaParser.g
                );
            break;
            }
            //
            // Rule 282:  IfThenElseStatement ::= if ( Expression ) StatementNoShortIf else Statement
            //
            case 282: {
               //#line 673 "GJavaParser.g"
                setResult(
                    //#line 673 GJavaParser.g
                    IfThenElseStatement(getLeftIToken(), getRightIToken(),
                                        //#line 673 GJavaParser.g
                                        AstToken(getRhsIToken(1)),
                                        //#line 673 GJavaParser.g
                                        AstToken(getRhsIToken(2)),
                                        //#line 673 GJavaParser.g
                                        getRhsSym(3) as IExpression,
                                        //#line 673 GJavaParser.g
                                        AstToken(getRhsIToken(4)),
                                        //#line 673 GJavaParser.g
                                        getRhsSym(5) as IStatementNoShortIf,
                                        //#line 673 GJavaParser.g
                                        AstToken(getRhsIToken(6)),
                                        //#line 673 GJavaParser.g
                                        getRhsSym(7) as IStatement)
                //#line 673 GJavaParser.g
                );
            break;
            }
            //
            // Rule 283:  IfThenElseStatementNoShortIf ::= if ( Expression ) StatementNoShortIf else StatementNoShortIf
            //
            case 283: {
               //#line 675 "GJavaParser.g"
                setResult(
                    //#line 675 GJavaParser.g
                    IfThenElseStatementNoShortIf(getLeftIToken(), getRightIToken(),
                                                 //#line 675 GJavaParser.g
                                                 AstToken(getRhsIToken(1)),
                                                 //#line 675 GJavaParser.g
                                                 AstToken(getRhsIToken(2)),
                                                 //#line 675 GJavaParser.g
                                                 getRhsSym(3) as IExpression,
                                                 //#line 675 GJavaParser.g
                                                 AstToken(getRhsIToken(4)),
                                                 //#line 675 GJavaParser.g
                                                 getRhsSym(5) as IStatementNoShortIf,
                                                 //#line 675 GJavaParser.g
                                                 AstToken(getRhsIToken(6)),
                                                 //#line 675 GJavaParser.g
                                                 getRhsSym(7) as IStatementNoShortIf)
                //#line 675 GJavaParser.g
                );
            break;
            }
            //
            // Rule 284:  EmptyStatement ::= ;
            //
            case 284: {
               //#line 677 "GJavaParser.g"
                setResult(
                    //#line 677 GJavaParser.g
                    EmptyStatement(getRhsIToken(1))
                //#line 677 GJavaParser.g
                );
            break;
            }
            //
            // Rule 285:  LabeledStatement ::= identifier : Statement
            //
            case 285: {
               //#line 679 "GJavaParser.g"
                setResult(
                    //#line 679 GJavaParser.g
                    LabeledStatement(getLeftIToken(), getRightIToken(),
                                     //#line 679 GJavaParser.g
                                     getRhsSym(1) as identifier,
                                     //#line 679 GJavaParser.g
                                     AstToken(getRhsIToken(2)),
                                     //#line 679 GJavaParser.g
                                     getRhsSym(3) as IStatement)
                //#line 679 GJavaParser.g
                );
            break;
            }
            //
            // Rule 286:  LabeledStatementNoShortIf ::= identifier : StatementNoShortIf
            //
            case 286: {
               //#line 681 "GJavaParser.g"
                setResult(
                    //#line 681 GJavaParser.g
                    LabeledStatementNoShortIf(getLeftIToken(), getRightIToken(),
                                              //#line 681 GJavaParser.g
                                              getRhsSym(1) as identifier,
                                              //#line 681 GJavaParser.g
                                              AstToken(getRhsIToken(2)),
                                              //#line 681 GJavaParser.g
                                              getRhsSym(3) as IStatementNoShortIf)
                //#line 681 GJavaParser.g
                );
            break;
            }
            //
            // Rule 287:  ExpressionStatement ::= StatementExpression ;
            //
            case 287: {
               //#line 683 "GJavaParser.g"
                setResult(
                    //#line 683 GJavaParser.g
                    ExpressionStatement(getLeftIToken(), getRightIToken(),
                                        //#line 683 GJavaParser.g
                                        getRhsSym(1) as IStatementExpression,
                                        //#line 683 GJavaParser.g
                                        AstToken(getRhsIToken(2)))
                //#line 683 GJavaParser.g
                );
            break;
            }
            //
            // Rule 288:  StatementExpression ::= Assignment
            //
            case 288:
                break;
            //
            // Rule 289:  StatementExpression ::= PreIncrementExpression
            //
            case 289:
                break;
            //
            // Rule 290:  StatementExpression ::= PreDecrementExpression
            //
            case 290:
                break;
            //
            // Rule 291:  StatementExpression ::= PostIncrementExpression
            //
            case 291:
                break;
            //
            // Rule 292:  StatementExpression ::= PostDecrementExpression
            //
            case 292:
                break;
            //
            // Rule 293:  StatementExpression ::= MethodInvocation
            //
            case 293:
                break;
            //
            // Rule 294:  StatementExpression ::= ClassInstanceCreationExpression
            //
            case 294:
                break;
            //
            // Rule 295:  AssertStatement ::= assert Expression ;
            //
            case 295: {
               //#line 702 "GJavaParser.g"
                setResult(
                    //#line 702 GJavaParser.g
                    AssertStatement0(getLeftIToken(), getRightIToken(),
                                     //#line 702 GJavaParser.g
                                     AstToken(getRhsIToken(1)),
                                     //#line 702 GJavaParser.g
                                     getRhsSym(2) as IExpression,
                                     //#line 702 GJavaParser.g
                                     AstToken(getRhsIToken(3)))
                //#line 702 GJavaParser.g
                );
            break;
            }
            //
            // Rule 296:  AssertStatement ::= assert Expression : Expression ;
            //
            case 296: {
               //#line 703 "GJavaParser.g"
                setResult(
                    //#line 703 GJavaParser.g
                    AssertStatement1(getLeftIToken(), getRightIToken(),
                                     //#line 703 GJavaParser.g
                                     AstToken(getRhsIToken(1)),
                                     //#line 703 GJavaParser.g
                                     getRhsSym(2) as IExpression,
                                     //#line 703 GJavaParser.g
                                     AstToken(getRhsIToken(3)),
                                     //#line 703 GJavaParser.g
                                     getRhsSym(4) as IExpression,
                                     //#line 703 GJavaParser.g
                                     AstToken(getRhsIToken(5)))
                //#line 703 GJavaParser.g
                );
            break;
            }
            //
            // Rule 297:  SwitchStatement ::= switch ( Expression ) SwitchBlock
            //
            case 297: {
               //#line 705 "GJavaParser.g"
                setResult(
                    //#line 705 GJavaParser.g
                    SwitchStatement(getLeftIToken(), getRightIToken(),
                                    //#line 705 GJavaParser.g
                                    AstToken(getRhsIToken(1)),
                                    //#line 705 GJavaParser.g
                                    AstToken(getRhsIToken(2)),
                                    //#line 705 GJavaParser.g
                                    getRhsSym(3) as IExpression,
                                    //#line 705 GJavaParser.g
                                    AstToken(getRhsIToken(4)),
                                    //#line 705 GJavaParser.g
                                    getRhsSym(5) as SwitchBlock)
                //#line 705 GJavaParser.g
                );
            break;
            }
            //
            // Rule 298:  SwitchBlock ::= { SwitchBlockStatementGroupsopt SwitchLabelsopt }
            //
            case 298: {
               //#line 707 "GJavaParser.g"
                setResult(
                    //#line 707 GJavaParser.g
                    SwitchBlock(getLeftIToken(), getRightIToken(),
                                //#line 707 GJavaParser.g
                                AstToken(getRhsIToken(1)),
                                //#line 707 GJavaParser.g
                                getRhsSym(2) as ISwitchBlockStatementGroupsopt?,
                                //#line 707 GJavaParser.g
                                getRhsSym(3) as ISwitchLabelsopt?,
                                //#line 707 GJavaParser.g
                                AstToken(getRhsIToken(4)))
                //#line 707 GJavaParser.g
                );
            break;
            }
            //
            // Rule 299:  SwitchBlockStatementGroups ::= SwitchBlockStatementGroup
            //
            case 299:
                break;
            //
            // Rule 300:  SwitchBlockStatementGroups ::= SwitchBlockStatementGroups SwitchBlockStatementGroup
            //
            case 300: {
               //#line 710 "GJavaParser.g"
                setResult(
                    //#line 710 GJavaParser.g
                    SwitchBlockStatementGroups(getLeftIToken(), getRightIToken(),
                                               //#line 710 GJavaParser.g
                                               getRhsSym(1) as ISwitchBlockStatementGroups,
                                               //#line 710 GJavaParser.g
                                               getRhsSym(2) as SwitchBlockStatementGroup)
                //#line 710 GJavaParser.g
                );
            break;
            }
            //
            // Rule 301:  SwitchBlockStatementGroup ::= SwitchLabels BlockStatements
            //
            case 301: {
               //#line 712 "GJavaParser.g"
                setResult(
                    //#line 712 GJavaParser.g
                    SwitchBlockStatementGroup(getLeftIToken(), getRightIToken(),
                                              //#line 712 GJavaParser.g
                                              getRhsSym(1) as ISwitchLabels,
                                              //#line 712 GJavaParser.g
                                              getRhsSym(2) as IBlockStatements)
                //#line 712 GJavaParser.g
                );
            break;
            }
            //
            // Rule 302:  SwitchLabels ::= SwitchLabel
            //
            case 302:
                break;
            //
            // Rule 303:  SwitchLabels ::= SwitchLabels SwitchLabel
            //
            case 303: {
               //#line 715 "GJavaParser.g"
                setResult(
                    //#line 715 GJavaParser.g
                    SwitchLabels(getLeftIToken(), getRightIToken(),
                                 //#line 715 GJavaParser.g
                                 getRhsSym(1) as ISwitchLabels,
                                 //#line 715 GJavaParser.g
                                 getRhsSym(2) as ISwitchLabel)
                //#line 715 GJavaParser.g
                );
            break;
            }
            //
            // Rule 304:  SwitchLabel ::= case ConstantExpression :
            //
            case 304: {
               //#line 717 "GJavaParser.g"
                setResult(
                    //#line 717 GJavaParser.g
                    SwitchLabel0(getLeftIToken(), getRightIToken(),
                                 //#line 717 GJavaParser.g
                                 AstToken(getRhsIToken(1)),
                                 //#line 717 GJavaParser.g
                                 getRhsSym(2) as IConstantExpression,
                                 //#line 717 GJavaParser.g
                                 AstToken(getRhsIToken(3)))
                //#line 717 GJavaParser.g
                );
            break;
            }
            //
            // Rule 305:  SwitchLabel ::= case EnumConstant :
            //
            case 305: {
               //#line 718 "GJavaParser.g"
                setResult(
                    //#line 718 GJavaParser.g
                    SwitchLabel1(getLeftIToken(), getRightIToken(),
                                 //#line 718 GJavaParser.g
                                 AstToken(getRhsIToken(1)),
                                 //#line 718 GJavaParser.g
                                 getRhsSym(2) as IEnumConstant,
                                 //#line 718 GJavaParser.g
                                 AstToken(getRhsIToken(3)))
                //#line 718 GJavaParser.g
                );
            break;
            }
            //
            // Rule 306:  SwitchLabel ::= default :
            //
            case 306: {
               //#line 719 "GJavaParser.g"
                setResult(
                    //#line 719 GJavaParser.g
                    SwitchLabel2(getLeftIToken(), getRightIToken(),
                                 //#line 719 GJavaParser.g
                                 AstToken(getRhsIToken(1)),
                                 //#line 719 GJavaParser.g
                                 AstToken(getRhsIToken(2)))
                //#line 719 GJavaParser.g
                );
            break;
            }
            //
            // Rule 307:  EnumConstant ::= identifier
            //
            case 307:
                break;
            //
            // Rule 308:  WhileStatement ::= while ( Expression ) Statement
            //
            case 308: {
               //#line 723 "GJavaParser.g"
                setResult(
                    //#line 723 GJavaParser.g
                    WhileStatement(getLeftIToken(), getRightIToken(),
                                   //#line 723 GJavaParser.g
                                   AstToken(getRhsIToken(1)),
                                   //#line 723 GJavaParser.g
                                   AstToken(getRhsIToken(2)),
                                   //#line 723 GJavaParser.g
                                   getRhsSym(3) as IExpression,
                                   //#line 723 GJavaParser.g
                                   AstToken(getRhsIToken(4)),
                                   //#line 723 GJavaParser.g
                                   getRhsSym(5) as IStatement)
                //#line 723 GJavaParser.g
                );
            break;
            }
            //
            // Rule 309:  WhileStatementNoShortIf ::= while ( Expression ) StatementNoShortIf
            //
            case 309: {
               //#line 725 "GJavaParser.g"
                setResult(
                    //#line 725 GJavaParser.g
                    WhileStatementNoShortIf(getLeftIToken(), getRightIToken(),
                                            //#line 725 GJavaParser.g
                                            AstToken(getRhsIToken(1)),
                                            //#line 725 GJavaParser.g
                                            AstToken(getRhsIToken(2)),
                                            //#line 725 GJavaParser.g
                                            getRhsSym(3) as IExpression,
                                            //#line 725 GJavaParser.g
                                            AstToken(getRhsIToken(4)),
                                            //#line 725 GJavaParser.g
                                            getRhsSym(5) as IStatementNoShortIf)
                //#line 725 GJavaParser.g
                );
            break;
            }
            //
            // Rule 310:  DoStatement ::= do Statement while ( Expression ) ;
            //
            case 310: {
               //#line 727 "GJavaParser.g"
                setResult(
                    //#line 727 GJavaParser.g
                    DoStatement(getLeftIToken(), getRightIToken(),
                                //#line 727 GJavaParser.g
                                AstToken(getRhsIToken(1)),
                                //#line 727 GJavaParser.g
                                getRhsSym(2) as IStatement,
                                //#line 727 GJavaParser.g
                                AstToken(getRhsIToken(3)),
                                //#line 727 GJavaParser.g
                                AstToken(getRhsIToken(4)),
                                //#line 727 GJavaParser.g
                                getRhsSym(5) as IExpression,
                                //#line 727 GJavaParser.g
                                AstToken(getRhsIToken(6)),
                                //#line 727 GJavaParser.g
                                AstToken(getRhsIToken(7)))
                //#line 727 GJavaParser.g
                );
            break;
            }
            //
            // Rule 311:  ForStatement ::= BasicForStatement
            //
            case 311:
                break;
            //
            // Rule 312:  ForStatement ::= EnhancedForStatement
            //
            case 312:
                break;
            //
            // Rule 313:  BasicForStatement ::= for ( ForInitopt ; Expressionopt ; ForUpdateopt ) Statement
            //
            case 313: {
               //#line 732 "GJavaParser.g"
                setResult(
                    //#line 732 GJavaParser.g
                    BasicForStatement(getLeftIToken(), getRightIToken(),
                                      //#line 732 GJavaParser.g
                                      AstToken(getRhsIToken(1)),
                                      //#line 732 GJavaParser.g
                                      AstToken(getRhsIToken(2)),
                                      //#line 732 GJavaParser.g
                                      getRhsSym(3) as IForInitopt?,
                                      //#line 732 GJavaParser.g
                                      AstToken(getRhsIToken(4)),
                                      //#line 732 GJavaParser.g
                                      getRhsSym(5) as IExpressionopt?,
                                      //#line 732 GJavaParser.g
                                      AstToken(getRhsIToken(6)),
                                      //#line 732 GJavaParser.g
                                      getRhsSym(7) as IForUpdateopt?,
                                      //#line 732 GJavaParser.g
                                      AstToken(getRhsIToken(8)),
                                      //#line 732 GJavaParser.g
                                      getRhsSym(9) as IStatement)
                //#line 732 GJavaParser.g
                );
            break;
            }
            //
            // Rule 314:  ForStatementNoShortIf ::= for ( ForInitopt ; Expressionopt ; ForUpdateopt ) StatementNoShortIf
            //
            case 314: {
               //#line 734 "GJavaParser.g"
                setResult(
                    //#line 734 GJavaParser.g
                    ForStatementNoShortIf(getLeftIToken(), getRightIToken(),
                                          //#line 734 GJavaParser.g
                                          AstToken(getRhsIToken(1)),
                                          //#line 734 GJavaParser.g
                                          AstToken(getRhsIToken(2)),
                                          //#line 734 GJavaParser.g
                                          getRhsSym(3) as IForInitopt?,
                                          //#line 734 GJavaParser.g
                                          AstToken(getRhsIToken(4)),
                                          //#line 734 GJavaParser.g
                                          getRhsSym(5) as IExpressionopt?,
                                          //#line 734 GJavaParser.g
                                          AstToken(getRhsIToken(6)),
                                          //#line 734 GJavaParser.g
                                          getRhsSym(7) as IForUpdateopt?,
                                          //#line 734 GJavaParser.g
                                          AstToken(getRhsIToken(8)),
                                          //#line 734 GJavaParser.g
                                          getRhsSym(9) as IStatementNoShortIf)
                //#line 734 GJavaParser.g
                );
            break;
            }
            //
            // Rule 315:  ForInit ::= StatementExpressionList
            //
            case 315:
                break;
            //
            // Rule 316:  ForInit ::= LocalVariableDeclaration
            //
            case 316:
                break;
            //
            // Rule 317:  ForUpdate ::= StatementExpressionList
            //
            case 317:
                break;
            //
            // Rule 318:  StatementExpressionList ::= StatementExpression
            //
            case 318:
                break;
            //
            // Rule 319:  StatementExpressionList ::= StatementExpressionList , StatementExpression
            //
            case 319: {
               //#line 742 "GJavaParser.g"
                setResult(
                    //#line 742 GJavaParser.g
                    StatementExpressionList(getLeftIToken(), getRightIToken(),
                                            //#line 742 GJavaParser.g
                                            getRhsSym(1) as IStatementExpressionList,
                                            //#line 742 GJavaParser.g
                                            AstToken(getRhsIToken(2)),
                                            //#line 742 GJavaParser.g
                                            getRhsSym(3) as IStatementExpression)
                //#line 742 GJavaParser.g
                );
            break;
            }
            //
            // Rule 320:  EnhancedForStatement ::= for ( FormalParameter : Expression ) Statement
            //
            case 320: {
               //#line 744 "GJavaParser.g"
                setResult(
                    //#line 744 GJavaParser.g
                    EnhancedForStatement(getLeftIToken(), getRightIToken(),
                                         //#line 744 GJavaParser.g
                                         AstToken(getRhsIToken(1)),
                                         //#line 744 GJavaParser.g
                                         AstToken(getRhsIToken(2)),
                                         //#line 744 GJavaParser.g
                                         getRhsSym(3) as FormalParameter,
                                         //#line 744 GJavaParser.g
                                         AstToken(getRhsIToken(4)),
                                         //#line 744 GJavaParser.g
                                         getRhsSym(5) as IExpression,
                                         //#line 744 GJavaParser.g
                                         AstToken(getRhsIToken(6)),
                                         //#line 744 GJavaParser.g
                                         getRhsSym(7) as IStatement)
                //#line 744 GJavaParser.g
                );
            break;
            }
            //
            // Rule 321:  BreakStatement ::= break identifieropt ;
            //
            case 321: {
               //#line 746 "GJavaParser.g"
                setResult(
                    //#line 746 GJavaParser.g
                    BreakStatement(getLeftIToken(), getRightIToken(),
                                   //#line 746 GJavaParser.g
                                   AstToken(getRhsIToken(1)),
                                   //#line 746 GJavaParser.g
                                   getRhsSym(2) as identifier?,
                                   //#line 746 GJavaParser.g
                                   AstToken(getRhsIToken(3)))
                //#line 746 GJavaParser.g
                );
            break;
            }
            //
            // Rule 322:  ContinueStatement ::= continue identifieropt ;
            //
            case 322: {
               //#line 748 "GJavaParser.g"
                setResult(
                    //#line 748 GJavaParser.g
                    ContinueStatement(getLeftIToken(), getRightIToken(),
                                      //#line 748 GJavaParser.g
                                      AstToken(getRhsIToken(1)),
                                      //#line 748 GJavaParser.g
                                      getRhsSym(2) as identifier?,
                                      //#line 748 GJavaParser.g
                                      AstToken(getRhsIToken(3)))
                //#line 748 GJavaParser.g
                );
            break;
            }
            //
            // Rule 323:  ReturnStatement ::= return Expressionopt ;
            //
            case 323: {
               //#line 750 "GJavaParser.g"
                setResult(
                    //#line 750 GJavaParser.g
                    ReturnStatement(getLeftIToken(), getRightIToken(),
                                    //#line 750 GJavaParser.g
                                    AstToken(getRhsIToken(1)),
                                    //#line 750 GJavaParser.g
                                    getRhsSym(2) as IExpressionopt?,
                                    //#line 750 GJavaParser.g
                                    AstToken(getRhsIToken(3)))
                //#line 750 GJavaParser.g
                );
            break;
            }
            //
            // Rule 324:  ThrowStatement ::= throw Expression ;
            //
            case 324: {
               //#line 752 "GJavaParser.g"
                setResult(
                    //#line 752 GJavaParser.g
                    ThrowStatement(getLeftIToken(), getRightIToken(),
                                   //#line 752 GJavaParser.g
                                   AstToken(getRhsIToken(1)),
                                   //#line 752 GJavaParser.g
                                   getRhsSym(2) as IExpression,
                                   //#line 752 GJavaParser.g
                                   AstToken(getRhsIToken(3)))
                //#line 752 GJavaParser.g
                );
            break;
            }
            //
            // Rule 325:  SynchronizedStatement ::= synchronized ( Expression ) Block
            //
            case 325: {
               //#line 754 "GJavaParser.g"
                setResult(
                    //#line 754 GJavaParser.g
                    SynchronizedStatement(getLeftIToken(), getRightIToken(),
                                          //#line 754 GJavaParser.g
                                          AstToken(getRhsIToken(1)),
                                          //#line 754 GJavaParser.g
                                          AstToken(getRhsIToken(2)),
                                          //#line 754 GJavaParser.g
                                          getRhsSym(3) as IExpression,
                                          //#line 754 GJavaParser.g
                                          AstToken(getRhsIToken(4)),
                                          //#line 754 GJavaParser.g
                                          getRhsSym(5) as Block)
                //#line 754 GJavaParser.g
                );
            break;
            }
            //
            // Rule 326:  TryStatement ::= try Block Catches
            //
            case 326: {
               //#line 756 "GJavaParser.g"
                setResult(
                    //#line 756 GJavaParser.g
                    TryStatement0(getLeftIToken(), getRightIToken(),
                                  //#line 756 GJavaParser.g
                                  AstToken(getRhsIToken(1)),
                                  //#line 756 GJavaParser.g
                                  getRhsSym(2) as Block,
                                  //#line 756 GJavaParser.g
                                  getRhsSym(3) as ICatches)
                //#line 756 GJavaParser.g
                );
            break;
            }
            //
            // Rule 327:  TryStatement ::= try Block Catchesopt Finally
            //
            case 327: {
               //#line 757 "GJavaParser.g"
                setResult(
                    //#line 757 GJavaParser.g
                    TryStatement1(getLeftIToken(), getRightIToken(),
                                  //#line 757 GJavaParser.g
                                  AstToken(getRhsIToken(1)),
                                  //#line 757 GJavaParser.g
                                  getRhsSym(2) as Block,
                                  //#line 757 GJavaParser.g
                                  getRhsSym(3) as ICatchesopt?,
                                  //#line 757 GJavaParser.g
                                  getRhsSym(4) as Finally)
                //#line 757 GJavaParser.g
                );
            break;
            }
            //
            // Rule 328:  Catches ::= CatchClause
            //
            case 328:
                break;
            //
            // Rule 329:  Catches ::= Catches CatchClause
            //
            case 329: {
               //#line 760 "GJavaParser.g"
                setResult(
                    //#line 760 GJavaParser.g
                    Catches(getLeftIToken(), getRightIToken(),
                            //#line 760 GJavaParser.g
                            getRhsSym(1) as ICatches,
                            //#line 760 GJavaParser.g
                            getRhsSym(2) as CatchClause)
                //#line 760 GJavaParser.g
                );
            break;
            }
            //
            // Rule 330:  CatchClause ::= catch ( FormalParameter ) Block
            //
            case 330: {
               //#line 762 "GJavaParser.g"
                setResult(
                    //#line 762 GJavaParser.g
                    CatchClause(getLeftIToken(), getRightIToken(),
                                //#line 762 GJavaParser.g
                                AstToken(getRhsIToken(1)),
                                //#line 762 GJavaParser.g
                                AstToken(getRhsIToken(2)),
                                //#line 762 GJavaParser.g
                                getRhsSym(3) as FormalParameter,
                                //#line 762 GJavaParser.g
                                AstToken(getRhsIToken(4)),
                                //#line 762 GJavaParser.g
                                getRhsSym(5) as Block)
                //#line 762 GJavaParser.g
                );
            break;
            }
            //
            // Rule 331:  Finally ::= finally Block
            //
            case 331: {
               //#line 764 "GJavaParser.g"
                setResult(
                    //#line 764 GJavaParser.g
                    Finally(getLeftIToken(), getRightIToken(),
                            //#line 764 GJavaParser.g
                            AstToken(getRhsIToken(1)),
                            //#line 764 GJavaParser.g
                            getRhsSym(2) as Block)
                //#line 764 GJavaParser.g
                );
            break;
            }
            //
            // Rule 332:  Primary ::= PrimaryNoNewArray
            //
            case 332:
                break;
            //
            // Rule 333:  Primary ::= ArrayCreationExpression
            //
            case 333:
                break;
            //
            // Rule 334:  PrimaryNoNewArray ::= Literal
            //
            case 334:
                break;
            //
            // Rule 335:  PrimaryNoNewArray ::= Type . class
            //
            case 335: {
               //#line 780 "GJavaParser.g"
                setResult(
                    //#line 780 GJavaParser.g
                    PrimaryNoNewArray0(getLeftIToken(), getRightIToken(),
                                       //#line 780 GJavaParser.g
                                       getRhsSym(1) as IType,
                                       //#line 780 GJavaParser.g
                                       AstToken(getRhsIToken(2)),
                                       //#line 780 GJavaParser.g
                                       AstToken(getRhsIToken(3)))
                //#line 780 GJavaParser.g
                );
            break;
            }
            //
            // Rule 336:  PrimaryNoNewArray ::= void . class
            //
            case 336: {
               //#line 781 "GJavaParser.g"
                setResult(
                    //#line 781 GJavaParser.g
                    PrimaryNoNewArray1(getLeftIToken(), getRightIToken(),
                                       //#line 781 GJavaParser.g
                                       AstToken(getRhsIToken(1)),
                                       //#line 781 GJavaParser.g
                                       AstToken(getRhsIToken(2)),
                                       //#line 781 GJavaParser.g
                                       AstToken(getRhsIToken(3)))
                //#line 781 GJavaParser.g
                );
            break;
            }
            //
            // Rule 337:  PrimaryNoNewArray ::= this
            //
            case 337: {
               //#line 782 "GJavaParser.g"
                setResult(
                    //#line 782 GJavaParser.g
                    PrimaryNoNewArray2(getRhsIToken(1))
                //#line 782 GJavaParser.g
                );
            break;
            }
            //
            // Rule 338:  PrimaryNoNewArray ::= ClassName . this
            //
            case 338: {
               //#line 783 "GJavaParser.g"
                setResult(
                    //#line 783 GJavaParser.g
                    PrimaryNoNewArray3(getLeftIToken(), getRightIToken(),
                                       //#line 783 GJavaParser.g
                                       getRhsSym(1) as IClassName,
                                       //#line 783 GJavaParser.g
                                       AstToken(getRhsIToken(2)),
                                       //#line 783 GJavaParser.g
                                       AstToken(getRhsIToken(3)))
                //#line 783 GJavaParser.g
                );
            break;
            }
            //
            // Rule 339:  PrimaryNoNewArray ::= ( Expression )
            //
            case 339: {
               //#line 784 "GJavaParser.g"
                setResult(
                    //#line 784 GJavaParser.g
                    PrimaryNoNewArray4(getLeftIToken(), getRightIToken(),
                                       //#line 784 GJavaParser.g
                                       AstToken(getRhsIToken(1)),
                                       //#line 784 GJavaParser.g
                                       getRhsSym(2) as IExpression,
                                       //#line 784 GJavaParser.g
                                       AstToken(getRhsIToken(3)))
                //#line 784 GJavaParser.g
                );
            break;
            }
            //
            // Rule 340:  PrimaryNoNewArray ::= ClassInstanceCreationExpression
            //
            case 340:
                break;
            //
            // Rule 341:  PrimaryNoNewArray ::= FieldAccess
            //
            case 341:
                break;
            //
            // Rule 342:  PrimaryNoNewArray ::= MethodInvocation
            //
            case 342:
                break;
            //
            // Rule 343:  PrimaryNoNewArray ::= ArrayAccess
            //
            case 343:
                break;
            //
            // Rule 344:  Literal ::= IntegerLiteral
            //
            case 344: {
               //#line 790 "GJavaParser.g"
                setResult(
                    //#line 790 GJavaParser.g
                    Literal0(getRhsIToken(1))
                //#line 790 GJavaParser.g
                );
            break;
            }
            //
            // Rule 345:  Literal ::= LongLiteral
            //
            case 345: {
               //#line 791 "GJavaParser.g"
                setResult(
                    //#line 791 GJavaParser.g
                    Literal1(getRhsIToken(1))
                //#line 791 GJavaParser.g
                );
            break;
            }
            //
            // Rule 346:  Literal ::= FloatingPointLiteral
            //
            case 346: {
               //#line 792 "GJavaParser.g"
                setResult(
                    //#line 792 GJavaParser.g
                    Literal2(getRhsIToken(1))
                //#line 792 GJavaParser.g
                );
            break;
            }
            //
            // Rule 347:  Literal ::= DoubleLiteral
            //
            case 347: {
               //#line 793 "GJavaParser.g"
                setResult(
                    //#line 793 GJavaParser.g
                    Literal3(getRhsIToken(1))
                //#line 793 GJavaParser.g
                );
            break;
            }
            //
            // Rule 348:  Literal ::= BooleanLiteral
            //
            case 348:
                break;
            //
            // Rule 349:  Literal ::= CharacterLiteral
            //
            case 349: {
               //#line 795 "GJavaParser.g"
                setResult(
                    //#line 795 GJavaParser.g
                    Literal4(getRhsIToken(1))
                //#line 795 GJavaParser.g
                );
            break;
            }
            //
            // Rule 350:  Literal ::= StringLiteral
            //
            case 350: {
               //#line 796 "GJavaParser.g"
                setResult(
                    //#line 796 GJavaParser.g
                    Literal5(getRhsIToken(1))
                //#line 796 GJavaParser.g
                );
            break;
            }
            //
            // Rule 351:  Literal ::= null
            //
            case 351: {
               //#line 797 "GJavaParser.g"
                setResult(
                    //#line 797 GJavaParser.g
                    Literal6(getRhsIToken(1))
                //#line 797 GJavaParser.g
                );
            break;
            }
            //
            // Rule 352:  BooleanLiteral ::= true
            //
            case 352: {
               //#line 799 "GJavaParser.g"
                setResult(
                    //#line 799 GJavaParser.g
                    BooleanLiteral0(getRhsIToken(1))
                //#line 799 GJavaParser.g
                );
            break;
            }
            //
            // Rule 353:  BooleanLiteral ::= false
            //
            case 353: {
               //#line 800 "GJavaParser.g"
                setResult(
                    //#line 800 GJavaParser.g
                    BooleanLiteral1(getRhsIToken(1))
                //#line 800 GJavaParser.g
                );
            break;
            }
            //
            // Rule 354:  ClassInstanceCreationExpression ::= new TypeArgumentsopt ClassOrInterfaceType TypeArgumentsopt ( ArgumentListopt ) ClassBodyopt
            //
            case 354: {
               //#line 807 "GJavaParser.g"
                setResult(
                    //#line 807 GJavaParser.g
                    ClassInstanceCreationExpression0(getLeftIToken(), getRightIToken(),
                                                     //#line 807 GJavaParser.g
                                                     AstToken(getRhsIToken(1)),
                                                     //#line 807 GJavaParser.g
                                                     getRhsSym(2) as TypeArguments?,
                                                     //#line 807 GJavaParser.g
                                                     getRhsSym(3) as ClassType,
                                                     //#line 807 GJavaParser.g
                                                     getRhsSym(4) as TypeArguments?,
                                                     //#line 807 GJavaParser.g
                                                     AstToken(getRhsIToken(5)),
                                                     //#line 807 GJavaParser.g
                                                     getRhsSym(6) as IArgumentListopt?,
                                                     //#line 807 GJavaParser.g
                                                     AstToken(getRhsIToken(7)),
                                                     //#line 807 GJavaParser.g
                                                     getRhsSym(8) as ClassBody?)
                //#line 807 GJavaParser.g
                );
            break;
            }
            //
            // Rule 355:  ClassInstanceCreationExpression ::= Primary . new TypeArgumentsopt identifier TypeArgumentsopt ( ArgumentListopt ) ClassBodyopt
            //
            case 355: {
               //#line 808 "GJavaParser.g"
                setResult(
                    //#line 808 GJavaParser.g
                    ClassInstanceCreationExpression1(getLeftIToken(), getRightIToken(),
                                                     //#line 808 GJavaParser.g
                                                     getRhsSym(1) as IPrimary,
                                                     //#line 808 GJavaParser.g
                                                     AstToken(getRhsIToken(2)),
                                                     //#line 808 GJavaParser.g
                                                     AstToken(getRhsIToken(3)),
                                                     //#line 808 GJavaParser.g
                                                     getRhsSym(4) as TypeArguments?,
                                                     //#line 808 GJavaParser.g
                                                     getRhsSym(5) as identifier,
                                                     //#line 808 GJavaParser.g
                                                     getRhsSym(6) as TypeArguments?,
                                                     //#line 808 GJavaParser.g
                                                     AstToken(getRhsIToken(7)),
                                                     //#line 808 GJavaParser.g
                                                     getRhsSym(8) as IArgumentListopt?,
                                                     //#line 808 GJavaParser.g
                                                     AstToken(getRhsIToken(9)),
                                                     //#line 808 GJavaParser.g
                                                     getRhsSym(10) as ClassBody?)
                //#line 808 GJavaParser.g
                );
            break;
            }
            //
            // Rule 356:  ArgumentList ::= Expression
            //
            case 356:
                break;
            //
            // Rule 357:  ArgumentList ::= ArgumentList , Expression
            //
            case 357: {
               //#line 812 "GJavaParser.g"
                setResult(
                    //#line 812 GJavaParser.g
                    ArgumentList(getLeftIToken(), getRightIToken(),
                                 //#line 812 GJavaParser.g
                                 getRhsSym(1) as IArgumentList,
                                 //#line 812 GJavaParser.g
                                 AstToken(getRhsIToken(2)),
                                 //#line 812 GJavaParser.g
                                 getRhsSym(3) as IExpression)
                //#line 812 GJavaParser.g
                );
            break;
            }
            //
            // Rule 358:  ArrayCreationExpression ::= new PrimitiveType DimExprs Dimsopt
            //
            case 358: {
               //#line 822 "GJavaParser.g"
                setResult(
                    //#line 822 GJavaParser.g
                    ArrayCreationExpression0(getLeftIToken(), getRightIToken(),
                                             //#line 822 GJavaParser.g
                                             AstToken(getRhsIToken(1)),
                                             //#line 822 GJavaParser.g
                                             getRhsSym(2) as IPrimitiveType,
                                             //#line 822 GJavaParser.g
                                             getRhsSym(3) as IDimExprs,
                                             //#line 822 GJavaParser.g
                                             getRhsSym(4) as IDimsopt?)
                //#line 822 GJavaParser.g
                );
            break;
            }
            //
            // Rule 359:  ArrayCreationExpression ::= new ClassOrInterfaceType DimExprs Dimsopt
            //
            case 359: {
               //#line 823 "GJavaParser.g"
                setResult(
                    //#line 823 GJavaParser.g
                    ArrayCreationExpression1(getLeftIToken(), getRightIToken(),
                                             //#line 823 GJavaParser.g
                                             AstToken(getRhsIToken(1)),
                                             //#line 823 GJavaParser.g
                                             getRhsSym(2) as ClassType,
                                             //#line 823 GJavaParser.g
                                             getRhsSym(3) as IDimExprs,
                                             //#line 823 GJavaParser.g
                                             getRhsSym(4) as IDimsopt?)
                //#line 823 GJavaParser.g
                );
            break;
            }
            //
            // Rule 360:  ArrayCreationExpression ::= new PrimitiveType Dims ArrayInitializer
            //
            case 360: {
               //#line 824 "GJavaParser.g"
                setResult(
                    //#line 824 GJavaParser.g
                    ArrayCreationExpression2(getLeftIToken(), getRightIToken(),
                                             //#line 824 GJavaParser.g
                                             AstToken(getRhsIToken(1)),
                                             //#line 824 GJavaParser.g
                                             getRhsSym(2) as IPrimitiveType,
                                             //#line 824 GJavaParser.g
                                             getRhsSym(3) as IDims,
                                             //#line 824 GJavaParser.g
                                             getRhsSym(4) as ArrayInitializer)
                //#line 824 GJavaParser.g
                );
            break;
            }
            //
            // Rule 361:  ArrayCreationExpression ::= new ClassOrInterfaceType Dims ArrayInitializer
            //
            case 361: {
               //#line 825 "GJavaParser.g"
                setResult(
                    //#line 825 GJavaParser.g
                    ArrayCreationExpression3(getLeftIToken(), getRightIToken(),
                                             //#line 825 GJavaParser.g
                                             AstToken(getRhsIToken(1)),
                                             //#line 825 GJavaParser.g
                                             getRhsSym(2) as ClassType,
                                             //#line 825 GJavaParser.g
                                             getRhsSym(3) as IDims,
                                             //#line 825 GJavaParser.g
                                             getRhsSym(4) as ArrayInitializer)
                //#line 825 GJavaParser.g
                );
            break;
            }
            //
            // Rule 362:  DimExprs ::= DimExpr
            //
            case 362:
                break;
            //
            // Rule 363:  DimExprs ::= DimExprs DimExpr
            //
            case 363: {
               //#line 828 "GJavaParser.g"
                setResult(
                    //#line 828 GJavaParser.g
                    DimExprs(getLeftIToken(), getRightIToken(),
                             //#line 828 GJavaParser.g
                             getRhsSym(1) as IDimExprs,
                             //#line 828 GJavaParser.g
                             getRhsSym(2) as DimExpr)
                //#line 828 GJavaParser.g
                );
            break;
            }
            //
            // Rule 364:  DimExpr ::= [ Expression ]
            //
            case 364: {
               //#line 830 "GJavaParser.g"
                setResult(
                    //#line 830 GJavaParser.g
                    DimExpr(getLeftIToken(), getRightIToken(),
                            //#line 830 GJavaParser.g
                            AstToken(getRhsIToken(1)),
                            //#line 830 GJavaParser.g
                            getRhsSym(2) as IExpression,
                            //#line 830 GJavaParser.g
                            AstToken(getRhsIToken(3)))
                //#line 830 GJavaParser.g
                );
            break;
            }
            //
            // Rule 365:  Dims ::= [ ]
            //
            case 365: {
               //#line 832 "GJavaParser.g"
                setResult(
                    //#line 832 GJavaParser.g
                    Dims0(getLeftIToken(), getRightIToken(),
                          //#line 832 GJavaParser.g
                          AstToken(getRhsIToken(1)),
                          //#line 832 GJavaParser.g
                          AstToken(getRhsIToken(2)))
                //#line 832 GJavaParser.g
                );
            break;
            }
            //
            // Rule 366:  Dims ::= Dims [ ]
            //
            case 366: {
               //#line 833 "GJavaParser.g"
                setResult(
                    //#line 833 GJavaParser.g
                    Dims1(getLeftIToken(), getRightIToken(),
                          //#line 833 GJavaParser.g
                          getRhsSym(1) as IDims,
                          //#line 833 GJavaParser.g
                          AstToken(getRhsIToken(2)),
                          //#line 833 GJavaParser.g
                          AstToken(getRhsIToken(3)))
                //#line 833 GJavaParser.g
                );
            break;
            }
            //
            // Rule 367:  FieldAccess ::= Primary . identifier
            //
            case 367: {
               //#line 835 "GJavaParser.g"
                setResult(
                    //#line 835 GJavaParser.g
                    FieldAccess0(getLeftIToken(), getRightIToken(),
                                 //#line 835 GJavaParser.g
                                 getRhsSym(1) as IPrimary,
                                 //#line 835 GJavaParser.g
                                 AstToken(getRhsIToken(2)),
                                 //#line 835 GJavaParser.g
                                 getRhsSym(3) as identifier)
                //#line 835 GJavaParser.g
                );
            break;
            }
            //
            // Rule 368:  FieldAccess ::= super . identifier
            //
            case 368: {
               //#line 836 "GJavaParser.g"
                setResult(
                    //#line 836 GJavaParser.g
                    FieldAccess1(getLeftIToken(), getRightIToken(),
                                 //#line 836 GJavaParser.g
                                 AstToken(getRhsIToken(1)),
                                 //#line 836 GJavaParser.g
                                 AstToken(getRhsIToken(2)),
                                 //#line 836 GJavaParser.g
                                 getRhsSym(3) as identifier)
                //#line 836 GJavaParser.g
                );
            break;
            }
            //
            // Rule 369:  FieldAccess ::= ClassName . super . identifier
            //
            case 369: {
               //#line 837 "GJavaParser.g"
                setResult(
                    //#line 837 GJavaParser.g
                    FieldAccess2(getLeftIToken(), getRightIToken(),
                                 //#line 837 GJavaParser.g
                                 getRhsSym(1) as IClassName,
                                 //#line 837 GJavaParser.g
                                 AstToken(getRhsIToken(2)),
                                 //#line 837 GJavaParser.g
                                 AstToken(getRhsIToken(3)),
                                 //#line 837 GJavaParser.g
                                 AstToken(getRhsIToken(4)),
                                 //#line 837 GJavaParser.g
                                 getRhsSym(5) as identifier)
                //#line 837 GJavaParser.g
                );
            break;
            }
            //
            // Rule 370:  MethodInvocation ::= MethodName ( ArgumentListopt )
            //
            case 370: {
               //#line 839 "GJavaParser.g"
                setResult(
                    //#line 839 GJavaParser.g
                    MethodInvocation0(getLeftIToken(), getRightIToken(),
                                      //#line 839 GJavaParser.g
                                      getRhsSym(1) as IMethodName,
                                      //#line 839 GJavaParser.g
                                      AstToken(getRhsIToken(2)),
                                      //#line 839 GJavaParser.g
                                      getRhsSym(3) as IArgumentListopt?,
                                      //#line 839 GJavaParser.g
                                      AstToken(getRhsIToken(4)))
                //#line 839 GJavaParser.g
                );
            break;
            }
            //
            // Rule 371:  MethodInvocation ::= Primary . TypeArgumentsopt identifier ( ArgumentListopt )
            //
            case 371: {
               //#line 840 "GJavaParser.g"
                setResult(
                    //#line 840 GJavaParser.g
                    MethodInvocation1(getLeftIToken(), getRightIToken(),
                                      //#line 840 GJavaParser.g
                                      getRhsSym(1) as IPrimary,
                                      //#line 840 GJavaParser.g
                                      AstToken(getRhsIToken(2)),
                                      //#line 840 GJavaParser.g
                                      getRhsSym(3) as TypeArguments?,
                                      //#line 840 GJavaParser.g
                                      getRhsSym(4) as identifier,
                                      //#line 840 GJavaParser.g
                                      AstToken(getRhsIToken(5)),
                                      //#line 840 GJavaParser.g
                                      getRhsSym(6) as IArgumentListopt?,
                                      //#line 840 GJavaParser.g
                                      AstToken(getRhsIToken(7)))
                //#line 840 GJavaParser.g
                );
            break;
            }
            //
            // Rule 372:  MethodInvocation ::= super . TypeArgumentsopt identifier ( ArgumentListopt )
            //
            case 372: {
               //#line 841 "GJavaParser.g"
                setResult(
                    //#line 841 GJavaParser.g
                    MethodInvocation2(getLeftIToken(), getRightIToken(),
                                      //#line 841 GJavaParser.g
                                      AstToken(getRhsIToken(1)),
                                      //#line 841 GJavaParser.g
                                      AstToken(getRhsIToken(2)),
                                      //#line 841 GJavaParser.g
                                      getRhsSym(3) as TypeArguments?,
                                      //#line 841 GJavaParser.g
                                      getRhsSym(4) as identifier,
                                      //#line 841 GJavaParser.g
                                      AstToken(getRhsIToken(5)),
                                      //#line 841 GJavaParser.g
                                      getRhsSym(6) as IArgumentListopt?,
                                      //#line 841 GJavaParser.g
                                      AstToken(getRhsIToken(7)))
                //#line 841 GJavaParser.g
                );
            break;
            }
            //
            // Rule 373:  MethodInvocation ::= ClassName . super . TypeArgumentsopt identifier ( ArgumentListopt )
            //
            case 373: {
               //#line 842 "GJavaParser.g"
                setResult(
                    //#line 842 GJavaParser.g
                    MethodInvocation3(getLeftIToken(), getRightIToken(),
                                      //#line 842 GJavaParser.g
                                      getRhsSym(1) as IClassName,
                                      //#line 842 GJavaParser.g
                                      AstToken(getRhsIToken(2)),
                                      //#line 842 GJavaParser.g
                                      AstToken(getRhsIToken(3)),
                                      //#line 842 GJavaParser.g
                                      AstToken(getRhsIToken(4)),
                                      //#line 842 GJavaParser.g
                                      getRhsSym(5) as TypeArguments?,
                                      //#line 842 GJavaParser.g
                                      getRhsSym(6) as identifier,
                                      //#line 842 GJavaParser.g
                                      AstToken(getRhsIToken(7)),
                                      //#line 842 GJavaParser.g
                                      getRhsSym(8) as IArgumentListopt?,
                                      //#line 842 GJavaParser.g
                                      AstToken(getRhsIToken(9)))
                //#line 842 GJavaParser.g
                );
            break;
            }
            //
            // Rule 374:  MethodInvocation ::= TypeName . TypeArguments identifier ( ArgumentListopt )
            //
            case 374: {
               //#line 843 "GJavaParser.g"
                setResult(
                    //#line 843 GJavaParser.g
                    MethodInvocation4(getLeftIToken(), getRightIToken(),
                                      //#line 843 GJavaParser.g
                                      getRhsSym(1) as ITypeName,
                                      //#line 843 GJavaParser.g
                                      AstToken(getRhsIToken(2)),
                                      //#line 843 GJavaParser.g
                                      getRhsSym(3) as TypeArguments,
                                      //#line 843 GJavaParser.g
                                      getRhsSym(4) as identifier,
                                      //#line 843 GJavaParser.g
                                      AstToken(getRhsIToken(5)),
                                      //#line 843 GJavaParser.g
                                      getRhsSym(6) as IArgumentListopt?,
                                      //#line 843 GJavaParser.g
                                      AstToken(getRhsIToken(7)))
                //#line 843 GJavaParser.g
                );
            break;
            }
            //
            // Rule 375:  ArrayAccess ::= ExpressionName [ Expression ]
            //
            case 375: {
               //#line 851 "GJavaParser.g"
                setResult(
                    //#line 851 GJavaParser.g
                    ArrayAccess0(getLeftIToken(), getRightIToken(),
                                 //#line 851 GJavaParser.g
                                 getRhsSym(1) as IExpressionName,
                                 //#line 851 GJavaParser.g
                                 AstToken(getRhsIToken(2)),
                                 //#line 851 GJavaParser.g
                                 getRhsSym(3) as IExpression,
                                 //#line 851 GJavaParser.g
                                 AstToken(getRhsIToken(4)))
                //#line 851 GJavaParser.g
                );
            break;
            }
            //
            // Rule 376:  ArrayAccess ::= PrimaryNoNewArray [ Expression ]
            //
            case 376: {
               //#line 852 "GJavaParser.g"
                setResult(
                    //#line 852 GJavaParser.g
                    ArrayAccess1(getLeftIToken(), getRightIToken(),
                                 //#line 852 GJavaParser.g
                                 getRhsSym(1) as IPrimaryNoNewArray,
                                 //#line 852 GJavaParser.g
                                 AstToken(getRhsIToken(2)),
                                 //#line 852 GJavaParser.g
                                 getRhsSym(3) as IExpression,
                                 //#line 852 GJavaParser.g
                                 AstToken(getRhsIToken(4)))
                //#line 852 GJavaParser.g
                );
            break;
            }
            //
            // Rule 377:  PostfixExpression ::= Primary
            //
            case 377:
                break;
            //
            // Rule 378:  PostfixExpression ::= ExpressionName
            //
            case 378:
                break;
            //
            // Rule 379:  PostfixExpression ::= PostIncrementExpression
            //
            case 379:
                break;
            //
            // Rule 380:  PostfixExpression ::= PostDecrementExpression
            //
            case 380:
                break;
            //
            // Rule 381:  PostIncrementExpression ::= PostfixExpression ++
            //
            case 381: {
               //#line 859 "GJavaParser.g"
                setResult(
                    //#line 859 GJavaParser.g
                    PostIncrementExpression(getLeftIToken(), getRightIToken(),
                                            //#line 859 GJavaParser.g
                                            getRhsSym(1) as IPostfixExpression,
                                            //#line 859 GJavaParser.g
                                            AstToken(getRhsIToken(2)))
                //#line 859 GJavaParser.g
                );
            break;
            }
            //
            // Rule 382:  PostDecrementExpression ::= PostfixExpression --
            //
            case 382: {
               //#line 861 "GJavaParser.g"
                setResult(
                    //#line 861 GJavaParser.g
                    PostDecrementExpression(getLeftIToken(), getRightIToken(),
                                            //#line 861 GJavaParser.g
                                            getRhsSym(1) as IPostfixExpression,
                                            //#line 861 GJavaParser.g
                                            AstToken(getRhsIToken(2)))
                //#line 861 GJavaParser.g
                );
            break;
            }
            //
            // Rule 383:  UnaryExpression ::= PreIncrementExpression
            //
            case 383:
                break;
            //
            // Rule 384:  UnaryExpression ::= PreDecrementExpression
            //
            case 384:
                break;
            //
            // Rule 385:  UnaryExpression ::= + UnaryExpression
            //
            case 385: {
               //#line 865 "GJavaParser.g"
                setResult(
                    //#line 865 GJavaParser.g
                    UnaryExpression0(getLeftIToken(), getRightIToken(),
                                     //#line 865 GJavaParser.g
                                     AstToken(getRhsIToken(1)),
                                     //#line 865 GJavaParser.g
                                     getRhsSym(2) as IUnaryExpression)
                //#line 865 GJavaParser.g
                );
            break;
            }
            //
            // Rule 386:  UnaryExpression ::= - UnaryExpression
            //
            case 386: {
               //#line 866 "GJavaParser.g"
                setResult(
                    //#line 866 GJavaParser.g
                    UnaryExpression1(getLeftIToken(), getRightIToken(),
                                     //#line 866 GJavaParser.g
                                     AstToken(getRhsIToken(1)),
                                     //#line 866 GJavaParser.g
                                     getRhsSym(2) as IUnaryExpression)
                //#line 866 GJavaParser.g
                );
            break;
            }
            //
            // Rule 387:  UnaryExpression ::= UnaryExpressionNotPlusMinus
            //
            case 387:
                break;
            //
            // Rule 388:  PreIncrementExpression ::= ++ UnaryExpression
            //
            case 388: {
               //#line 869 "GJavaParser.g"
                setResult(
                    //#line 869 GJavaParser.g
                    PreIncrementExpression(getLeftIToken(), getRightIToken(),
                                           //#line 869 GJavaParser.g
                                           AstToken(getRhsIToken(1)),
                                           //#line 869 GJavaParser.g
                                           getRhsSym(2) as IUnaryExpression)
                //#line 869 GJavaParser.g
                );
            break;
            }
            //
            // Rule 389:  PreDecrementExpression ::= -- UnaryExpression
            //
            case 389: {
               //#line 871 "GJavaParser.g"
                setResult(
                    //#line 871 GJavaParser.g
                    PreDecrementExpression(getLeftIToken(), getRightIToken(),
                                           //#line 871 GJavaParser.g
                                           AstToken(getRhsIToken(1)),
                                           //#line 871 GJavaParser.g
                                           getRhsSym(2) as IUnaryExpression)
                //#line 871 GJavaParser.g
                );
            break;
            }
            //
            // Rule 390:  UnaryExpressionNotPlusMinus ::= PostfixExpression
            //
            case 390:
                break;
            //
            // Rule 391:  UnaryExpressionNotPlusMinus ::= ~ UnaryExpression
            //
            case 391: {
               //#line 874 "GJavaParser.g"
                setResult(
                    //#line 874 GJavaParser.g
                    UnaryExpressionNotPlusMinus0(getLeftIToken(), getRightIToken(),
                                                 //#line 874 GJavaParser.g
                                                 AstToken(getRhsIToken(1)),
                                                 //#line 874 GJavaParser.g
                                                 getRhsSym(2) as IUnaryExpression)
                //#line 874 GJavaParser.g
                );
            break;
            }
            //
            // Rule 392:  UnaryExpressionNotPlusMinus ::= ! UnaryExpression
            //
            case 392: {
               //#line 875 "GJavaParser.g"
                setResult(
                    //#line 875 GJavaParser.g
                    UnaryExpressionNotPlusMinus1(getLeftIToken(), getRightIToken(),
                                                 //#line 875 GJavaParser.g
                                                 AstToken(getRhsIToken(1)),
                                                 //#line 875 GJavaParser.g
                                                 getRhsSym(2) as IUnaryExpression)
                //#line 875 GJavaParser.g
                );
            break;
            }
            //
            // Rule 393:  UnaryExpressionNotPlusMinus ::= CastExpression
            //
            case 393:
                break;
            //
            // Rule 394:  CastExpression ::= ( PrimitiveType Dimsopt ) UnaryExpression
            //
            case 394: {
               //#line 878 "GJavaParser.g"
                setResult(
                    //#line 878 GJavaParser.g
                    CastExpression0(getLeftIToken(), getRightIToken(),
                                    //#line 878 GJavaParser.g
                                    AstToken(getRhsIToken(1)),
                                    //#line 878 GJavaParser.g
                                    getRhsSym(2) as IPrimitiveType,
                                    //#line 878 GJavaParser.g
                                    getRhsSym(3) as IDimsopt?,
                                    //#line 878 GJavaParser.g
                                    AstToken(getRhsIToken(4)),
                                    //#line 878 GJavaParser.g
                                    getRhsSym(5) as IUnaryExpression)
                //#line 878 GJavaParser.g
                );
            break;
            }
            //
            // Rule 395:  CastExpression ::= ( ReferenceType ) UnaryExpressionNotPlusMinus
            //
            case 395: {
               //#line 879 "GJavaParser.g"
                setResult(
                    //#line 879 GJavaParser.g
                    CastExpression1(getLeftIToken(), getRightIToken(),
                                    //#line 879 GJavaParser.g
                                    AstToken(getRhsIToken(1)),
                                    //#line 879 GJavaParser.g
                                    getRhsSym(2) as IReferenceType,
                                    //#line 879 GJavaParser.g
                                    AstToken(getRhsIToken(3)),
                                    //#line 879 GJavaParser.g
                                    getRhsSym(4) as IUnaryExpressionNotPlusMinus)
                //#line 879 GJavaParser.g
                );
            break;
            }
            //
            // Rule 396:  MultiplicativeExpression ::= UnaryExpression
            //
            case 396:
                break;
            //
            // Rule 397:  MultiplicativeExpression ::= MultiplicativeExpression * UnaryExpression
            //
            case 397: {
               //#line 882 "GJavaParser.g"
                setResult(
                    //#line 882 GJavaParser.g
                    MultiplicativeExpression0(getLeftIToken(), getRightIToken(),
                                              //#line 882 GJavaParser.g
                                              getRhsSym(1) as IMultiplicativeExpression,
                                              //#line 882 GJavaParser.g
                                              AstToken(getRhsIToken(2)),
                                              //#line 882 GJavaParser.g
                                              getRhsSym(3) as IUnaryExpression)
                //#line 882 GJavaParser.g
                );
            break;
            }
            //
            // Rule 398:  MultiplicativeExpression ::= MultiplicativeExpression / UnaryExpression
            //
            case 398: {
               //#line 883 "GJavaParser.g"
                setResult(
                    //#line 883 GJavaParser.g
                    MultiplicativeExpression1(getLeftIToken(), getRightIToken(),
                                              //#line 883 GJavaParser.g
                                              getRhsSym(1) as IMultiplicativeExpression,
                                              //#line 883 GJavaParser.g
                                              AstToken(getRhsIToken(2)),
                                              //#line 883 GJavaParser.g
                                              getRhsSym(3) as IUnaryExpression)
                //#line 883 GJavaParser.g
                );
            break;
            }
            //
            // Rule 399:  MultiplicativeExpression ::= MultiplicativeExpression % UnaryExpression
            //
            case 399: {
               //#line 884 "GJavaParser.g"
                setResult(
                    //#line 884 GJavaParser.g
                    MultiplicativeExpression2(getLeftIToken(), getRightIToken(),
                                              //#line 884 GJavaParser.g
                                              getRhsSym(1) as IMultiplicativeExpression,
                                              //#line 884 GJavaParser.g
                                              AstToken(getRhsIToken(2)),
                                              //#line 884 GJavaParser.g
                                              getRhsSym(3) as IUnaryExpression)
                //#line 884 GJavaParser.g
                );
            break;
            }
            //
            // Rule 400:  AdditiveExpression ::= MultiplicativeExpression
            //
            case 400:
                break;
            //
            // Rule 401:  AdditiveExpression ::= AdditiveExpression + MultiplicativeExpression
            //
            case 401: {
               //#line 887 "GJavaParser.g"
                setResult(
                    //#line 887 GJavaParser.g
                    AdditiveExpression0(getLeftIToken(), getRightIToken(),
                                        //#line 887 GJavaParser.g
                                        getRhsSym(1) as IAdditiveExpression,
                                        //#line 887 GJavaParser.g
                                        AstToken(getRhsIToken(2)),
                                        //#line 887 GJavaParser.g
                                        getRhsSym(3) as IMultiplicativeExpression)
                //#line 887 GJavaParser.g
                );
            break;
            }
            //
            // Rule 402:  AdditiveExpression ::= AdditiveExpression - MultiplicativeExpression
            //
            case 402: {
               //#line 888 "GJavaParser.g"
                setResult(
                    //#line 888 GJavaParser.g
                    AdditiveExpression1(getLeftIToken(), getRightIToken(),
                                        //#line 888 GJavaParser.g
                                        getRhsSym(1) as IAdditiveExpression,
                                        //#line 888 GJavaParser.g
                                        AstToken(getRhsIToken(2)),
                                        //#line 888 GJavaParser.g
                                        getRhsSym(3) as IMultiplicativeExpression)
                //#line 888 GJavaParser.g
                );
            break;
            }
            //
            // Rule 403:  ShiftExpression ::= AdditiveExpression
            //
            case 403:
                break;
            //
            // Rule 404:  ShiftExpression ::= ShiftExpression << AdditiveExpression
            //
            case 404: {
               //#line 891 "GJavaParser.g"
                setResult(
                    //#line 891 GJavaParser.g
                    ShiftExpression0(getLeftIToken(), getRightIToken(),
                                     //#line 891 GJavaParser.g
                                     getRhsSym(1) as IShiftExpression,
                                     //#line 891 GJavaParser.g
                                     AstToken(getRhsIToken(2)),
                                     //#line 891 GJavaParser.g
                                     getRhsSym(3) as IAdditiveExpression)
                //#line 891 GJavaParser.g
                );
            break;
            }
            //
            // Rule 405:  ShiftExpression ::= ShiftExpression > > AdditiveExpression
            //
            case 405: {
               //#line 892 "GJavaParser.g"
                setResult(
                    //#line 892 GJavaParser.g
                    ShiftExpression1(getLeftIToken(), getRightIToken(),
                                     //#line 892 GJavaParser.g
                                     getRhsSym(1) as IShiftExpression,
                                     //#line 892 GJavaParser.g
                                     AstToken(getRhsIToken(2)),
                                     //#line 892 GJavaParser.g
                                     AstToken(getRhsIToken(3)),
                                     //#line 892 GJavaParser.g
                                     getRhsSym(4) as IAdditiveExpression)
                //#line 892 GJavaParser.g
                );
            break;
            }
            //
            // Rule 406:  ShiftExpression ::= ShiftExpression > > > AdditiveExpression
            //
            case 406: {
               //#line 893 "GJavaParser.g"
                setResult(
                    //#line 893 GJavaParser.g
                    ShiftExpression2(getLeftIToken(), getRightIToken(),
                                     //#line 893 GJavaParser.g
                                     getRhsSym(1) as IShiftExpression,
                                     //#line 893 GJavaParser.g
                                     AstToken(getRhsIToken(2)),
                                     //#line 893 GJavaParser.g
                                     AstToken(getRhsIToken(3)),
                                     //#line 893 GJavaParser.g
                                     AstToken(getRhsIToken(4)),
                                     //#line 893 GJavaParser.g
                                     getRhsSym(5) as IAdditiveExpression)
                //#line 893 GJavaParser.g
                );
            break;
            }
            //
            // Rule 407:  RelationalExpression ::= ShiftExpression
            //
            case 407:
                break;
            //
            // Rule 408:  RelationalExpression ::= RelationalExpression < ShiftExpression
            //
            case 408: {
               //#line 896 "GJavaParser.g"
                setResult(
                    //#line 896 GJavaParser.g
                    RelationalExpression0(getLeftIToken(), getRightIToken(),
                                          //#line 896 GJavaParser.g
                                          getRhsSym(1) as IRelationalExpression,
                                          //#line 896 GJavaParser.g
                                          AstToken(getRhsIToken(2)),
                                          //#line 896 GJavaParser.g
                                          getRhsSym(3) as IShiftExpression)
                //#line 896 GJavaParser.g
                );
            break;
            }
            //
            // Rule 409:  RelationalExpression ::= RelationalExpression > ShiftExpression
            //
            case 409: {
               //#line 897 "GJavaParser.g"
                setResult(
                    //#line 897 GJavaParser.g
                    RelationalExpression1(getLeftIToken(), getRightIToken(),
                                          //#line 897 GJavaParser.g
                                          getRhsSym(1) as IRelationalExpression,
                                          //#line 897 GJavaParser.g
                                          AstToken(getRhsIToken(2)),
                                          //#line 897 GJavaParser.g
                                          getRhsSym(3) as IShiftExpression)
                //#line 897 GJavaParser.g
                );
            break;
            }
            //
            // Rule 410:  RelationalExpression ::= RelationalExpression <= ShiftExpression
            //
            case 410: {
               //#line 898 "GJavaParser.g"
                setResult(
                    //#line 898 GJavaParser.g
                    RelationalExpression2(getLeftIToken(), getRightIToken(),
                                          //#line 898 GJavaParser.g
                                          getRhsSym(1) as IRelationalExpression,
                                          //#line 898 GJavaParser.g
                                          AstToken(getRhsIToken(2)),
                                          //#line 898 GJavaParser.g
                                          getRhsSym(3) as IShiftExpression)
                //#line 898 GJavaParser.g
                );
            break;
            }
            //
            // Rule 411:  RelationalExpression ::= RelationalExpression > = ShiftExpression
            //
            case 411: {
               //#line 899 "GJavaParser.g"
                setResult(
                    //#line 899 GJavaParser.g
                    RelationalExpression3(getLeftIToken(), getRightIToken(),
                                          //#line 899 GJavaParser.g
                                          getRhsSym(1) as IRelationalExpression,
                                          //#line 899 GJavaParser.g
                                          AstToken(getRhsIToken(2)),
                                          //#line 899 GJavaParser.g
                                          AstToken(getRhsIToken(3)),
                                          //#line 899 GJavaParser.g
                                          getRhsSym(4) as IShiftExpression)
                //#line 899 GJavaParser.g
                );
            break;
            }
            //
            // Rule 412:  RelationalExpression ::= RelationalExpression instanceof ReferenceType
            //
            case 412: {
               //#line 900 "GJavaParser.g"
                setResult(
                    //#line 900 GJavaParser.g
                    RelationalExpression4(getLeftIToken(), getRightIToken(),
                                          //#line 900 GJavaParser.g
                                          getRhsSym(1) as IRelationalExpression,
                                          //#line 900 GJavaParser.g
                                          AstToken(getRhsIToken(2)),
                                          //#line 900 GJavaParser.g
                                          getRhsSym(3) as IReferenceType)
                //#line 900 GJavaParser.g
                );
            break;
            }
            //
            // Rule 413:  EqualityExpression ::= RelationalExpression
            //
            case 413:
                break;
            //
            // Rule 414:  EqualityExpression ::= EqualityExpression == RelationalExpression
            //
            case 414: {
               //#line 903 "GJavaParser.g"
                setResult(
                    //#line 903 GJavaParser.g
                    EqualityExpression0(getLeftIToken(), getRightIToken(),
                                        //#line 903 GJavaParser.g
                                        getRhsSym(1) as IEqualityExpression,
                                        //#line 903 GJavaParser.g
                                        AstToken(getRhsIToken(2)),
                                        //#line 903 GJavaParser.g
                                        getRhsSym(3) as IRelationalExpression)
                //#line 903 GJavaParser.g
                );
            break;
            }
            //
            // Rule 415:  EqualityExpression ::= EqualityExpression != RelationalExpression
            //
            case 415: {
               //#line 904 "GJavaParser.g"
                setResult(
                    //#line 904 GJavaParser.g
                    EqualityExpression1(getLeftIToken(), getRightIToken(),
                                        //#line 904 GJavaParser.g
                                        getRhsSym(1) as IEqualityExpression,
                                        //#line 904 GJavaParser.g
                                        AstToken(getRhsIToken(2)),
                                        //#line 904 GJavaParser.g
                                        getRhsSym(3) as IRelationalExpression)
                //#line 904 GJavaParser.g
                );
            break;
            }
            //
            // Rule 416:  AndExpression ::= EqualityExpression
            //
            case 416:
                break;
            //
            // Rule 417:  AndExpression ::= AndExpression & EqualityExpression
            //
            case 417: {
               //#line 907 "GJavaParser.g"
                setResult(
                    //#line 907 GJavaParser.g
                    AndExpression(getLeftIToken(), getRightIToken(),
                                  //#line 907 GJavaParser.g
                                  getRhsSym(1) as IAndExpression,
                                  //#line 907 GJavaParser.g
                                  AstToken(getRhsIToken(2)),
                                  //#line 907 GJavaParser.g
                                  getRhsSym(3) as IEqualityExpression)
                //#line 907 GJavaParser.g
                );
            break;
            }
            //
            // Rule 418:  ExclusiveOrExpression ::= AndExpression
            //
            case 418:
                break;
            //
            // Rule 419:  ExclusiveOrExpression ::= ExclusiveOrExpression ^ AndExpression
            //
            case 419: {
               //#line 910 "GJavaParser.g"
                setResult(
                    //#line 910 GJavaParser.g
                    ExclusiveOrExpression(getLeftIToken(), getRightIToken(),
                                          //#line 910 GJavaParser.g
                                          getRhsSym(1) as IExclusiveOrExpression,
                                          //#line 910 GJavaParser.g
                                          AstToken(getRhsIToken(2)),
                                          //#line 910 GJavaParser.g
                                          getRhsSym(3) as IAndExpression)
                //#line 910 GJavaParser.g
                );
            break;
            }
            //
            // Rule 420:  InclusiveOrExpression ::= ExclusiveOrExpression
            //
            case 420:
                break;
            //
            // Rule 421:  InclusiveOrExpression ::= InclusiveOrExpression | ExclusiveOrExpression
            //
            case 421: {
               //#line 913 "GJavaParser.g"
                setResult(
                    //#line 913 GJavaParser.g
                    InclusiveOrExpression(getLeftIToken(), getRightIToken(),
                                          //#line 913 GJavaParser.g
                                          getRhsSym(1) as IInclusiveOrExpression,
                                          //#line 913 GJavaParser.g
                                          AstToken(getRhsIToken(2)),
                                          //#line 913 GJavaParser.g
                                          getRhsSym(3) as IExclusiveOrExpression)
                //#line 913 GJavaParser.g
                );
            break;
            }
            //
            // Rule 422:  ConditionalAndExpression ::= InclusiveOrExpression
            //
            case 422:
                break;
            //
            // Rule 423:  ConditionalAndExpression ::= ConditionalAndExpression && InclusiveOrExpression
            //
            case 423: {
               //#line 916 "GJavaParser.g"
                setResult(
                    //#line 916 GJavaParser.g
                    ConditionalAndExpression(getLeftIToken(), getRightIToken(),
                                             //#line 916 GJavaParser.g
                                             getRhsSym(1) as IConditionalAndExpression,
                                             //#line 916 GJavaParser.g
                                             AstToken(getRhsIToken(2)),
                                             //#line 916 GJavaParser.g
                                             getRhsSym(3) as IInclusiveOrExpression)
                //#line 916 GJavaParser.g
                );
            break;
            }
            //
            // Rule 424:  ConditionalOrExpression ::= ConditionalAndExpression
            //
            case 424:
                break;
            //
            // Rule 425:  ConditionalOrExpression ::= ConditionalOrExpression || ConditionalAndExpression
            //
            case 425: {
               //#line 919 "GJavaParser.g"
                setResult(
                    //#line 919 GJavaParser.g
                    ConditionalOrExpression(getLeftIToken(), getRightIToken(),
                                            //#line 919 GJavaParser.g
                                            getRhsSym(1) as IConditionalOrExpression,
                                            //#line 919 GJavaParser.g
                                            AstToken(getRhsIToken(2)),
                                            //#line 919 GJavaParser.g
                                            getRhsSym(3) as IConditionalAndExpression)
                //#line 919 GJavaParser.g
                );
            break;
            }
            //
            // Rule 426:  ConditionalExpression ::= ConditionalOrExpression
            //
            case 426:
                break;
            //
            // Rule 427:  ConditionalExpression ::= ConditionalOrExpression ? Expression : ConditionalExpression
            //
            case 427: {
               //#line 922 "GJavaParser.g"
                setResult(
                    //#line 922 GJavaParser.g
                    ConditionalExpression(getLeftIToken(), getRightIToken(),
                                          //#line 922 GJavaParser.g
                                          getRhsSym(1) as IConditionalOrExpression,
                                          //#line 922 GJavaParser.g
                                          AstToken(getRhsIToken(2)),
                                          //#line 922 GJavaParser.g
                                          getRhsSym(3) as IExpression,
                                          //#line 922 GJavaParser.g
                                          AstToken(getRhsIToken(4)),
                                          //#line 922 GJavaParser.g
                                          getRhsSym(5) as IConditionalExpression)
                //#line 922 GJavaParser.g
                );
            break;
            }
            //
            // Rule 428:  AssignmentExpression ::= ConditionalExpression
            //
            case 428:
                break;
            //
            // Rule 429:  AssignmentExpression ::= Assignment
            //
            case 429:
                break;
            //
            // Rule 430:  Assignment ::= LeftHandSide AssignmentOperator AssignmentExpression
            //
            case 430: {
               //#line 927 "GJavaParser.g"
                setResult(
                    //#line 927 GJavaParser.g
                    Assignment(getLeftIToken(), getRightIToken(),
                               //#line 927 GJavaParser.g
                               getRhsSym(1) as ILeftHandSide,
                               //#line 927 GJavaParser.g
                               getRhsSym(2) as IAssignmentOperator,
                               //#line 927 GJavaParser.g
                               getRhsSym(3) as IAssignmentExpression)
                //#line 927 GJavaParser.g
                );
            break;
            }
            //
            // Rule 431:  LeftHandSide ::= ExpressionName
            //
            case 431:
                break;
            //
            // Rule 432:  LeftHandSide ::= FieldAccess
            //
            case 432:
                break;
            //
            // Rule 433:  LeftHandSide ::= ArrayAccess
            //
            case 433:
                break;
            //
            // Rule 434:  AssignmentOperator ::= =
            //
            case 434: {
               //#line 933 "GJavaParser.g"
                setResult(
                    //#line 933 GJavaParser.g
                    AssignmentOperator0(getRhsIToken(1))
                //#line 933 GJavaParser.g
                );
            break;
            }
            //
            // Rule 435:  AssignmentOperator ::= *=
            //
            case 435: {
               //#line 934 "GJavaParser.g"
                setResult(
                    //#line 934 GJavaParser.g
                    AssignmentOperator1(getRhsIToken(1))
                //#line 934 GJavaParser.g
                );
            break;
            }
            //
            // Rule 436:  AssignmentOperator ::= /=
            //
            case 436: {
               //#line 935 "GJavaParser.g"
                setResult(
                    //#line 935 GJavaParser.g
                    AssignmentOperator2(getRhsIToken(1))
                //#line 935 GJavaParser.g
                );
            break;
            }
            //
            // Rule 437:  AssignmentOperator ::= %=
            //
            case 437: {
               //#line 936 "GJavaParser.g"
                setResult(
                    //#line 936 GJavaParser.g
                    AssignmentOperator3(getRhsIToken(1))
                //#line 936 GJavaParser.g
                );
            break;
            }
            //
            // Rule 438:  AssignmentOperator ::= +=
            //
            case 438: {
               //#line 937 "GJavaParser.g"
                setResult(
                    //#line 937 GJavaParser.g
                    AssignmentOperator4(getRhsIToken(1))
                //#line 937 GJavaParser.g
                );
            break;
            }
            //
            // Rule 439:  AssignmentOperator ::= -=
            //
            case 439: {
               //#line 938 "GJavaParser.g"
                setResult(
                    //#line 938 GJavaParser.g
                    AssignmentOperator5(getRhsIToken(1))
                //#line 938 GJavaParser.g
                );
            break;
            }
            //
            // Rule 440:  AssignmentOperator ::= <<=
            //
            case 440: {
               //#line 939 "GJavaParser.g"
                setResult(
                    //#line 939 GJavaParser.g
                    AssignmentOperator6(getRhsIToken(1))
                //#line 939 GJavaParser.g
                );
            break;
            }
            //
            // Rule 441:  AssignmentOperator ::= > > =
            //
            case 441: {
               //#line 940 "GJavaParser.g"
                setResult(
                    //#line 940 GJavaParser.g
                    AssignmentOperator7(getLeftIToken(), getRightIToken(),
                                        //#line 940 GJavaParser.g
                                        AstToken(getRhsIToken(1)),
                                        //#line 940 GJavaParser.g
                                        AstToken(getRhsIToken(2)),
                                        //#line 940 GJavaParser.g
                                        AstToken(getRhsIToken(3)))
                //#line 940 GJavaParser.g
                );
            break;
            }
            //
            // Rule 442:  AssignmentOperator ::= > > > =
            //
            case 442: {
               //#line 941 "GJavaParser.g"
                setResult(
                    //#line 941 GJavaParser.g
                    AssignmentOperator8(getLeftIToken(), getRightIToken(),
                                        //#line 941 GJavaParser.g
                                        AstToken(getRhsIToken(1)),
                                        //#line 941 GJavaParser.g
                                        AstToken(getRhsIToken(2)),
                                        //#line 941 GJavaParser.g
                                        AstToken(getRhsIToken(3)),
                                        //#line 941 GJavaParser.g
                                        AstToken(getRhsIToken(4)))
                //#line 941 GJavaParser.g
                );
            break;
            }
            //
            // Rule 443:  AssignmentOperator ::= &=
            //
            case 443: {
               //#line 942 "GJavaParser.g"
                setResult(
                    //#line 942 GJavaParser.g
                    AssignmentOperator9(getRhsIToken(1))
                //#line 942 GJavaParser.g
                );
            break;
            }
            //
            // Rule 444:  AssignmentOperator ::= ^=
            //
            case 444: {
               //#line 943 "GJavaParser.g"
                setResult(
                    //#line 943 GJavaParser.g
                    AssignmentOperator10(getRhsIToken(1))
                //#line 943 GJavaParser.g
                );
            break;
            }
            //
            // Rule 445:  AssignmentOperator ::= |=
            //
            case 445: {
               //#line 944 "GJavaParser.g"
                setResult(
                    //#line 944 GJavaParser.g
                    AssignmentOperator11(getRhsIToken(1))
                //#line 944 GJavaParser.g
                );
            break;
            }
            //
            // Rule 446:  Expression ::= AssignmentExpression
            //
            case 446:
                break;
            //
            // Rule 447:  ConstantExpression ::= Expression
            //
            case 447:
                break;
            //
            // Rule 448:  Dimsopt ::= %Empty
            //
            case 448: {
               //#line 953 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 449:  Dimsopt ::= Dims
            //
            case 449:
                break;
            //
            // Rule 450:  Catchesopt ::= %Empty
            //
            case 450: {
               //#line 956 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 451:  Catchesopt ::= Catches
            //
            case 451:
                break;
            //
            // Rule 452:  identifieropt ::= %Empty
            //
            case 452: {
               //#line 959 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 453:  identifieropt ::= identifier
            //
            case 453:
                break;
            //
            // Rule 454:  ForUpdateopt ::= %Empty
            //
            case 454: {
               //#line 962 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 455:  ForUpdateopt ::= ForUpdate
            //
            case 455:
                break;
            //
            // Rule 456:  Expressionopt ::= %Empty
            //
            case 456: {
               //#line 965 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 457:  Expressionopt ::= Expression
            //
            case 457:
                break;
            //
            // Rule 458:  ForInitopt ::= %Empty
            //
            case 458: {
               //#line 968 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 459:  ForInitopt ::= ForInit
            //
            case 459:
                break;
            //
            // Rule 460:  SwitchLabelsopt ::= %Empty
            //
            case 460: {
               //#line 971 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 461:  SwitchLabelsopt ::= SwitchLabels
            //
            case 461:
                break;
            //
            // Rule 462:  SwitchBlockStatementGroupsopt ::= %Empty
            //
            case 462: {
               //#line 974 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 463:  SwitchBlockStatementGroupsopt ::= SwitchBlockStatementGroups
            //
            case 463:
                break;
            //
            // Rule 464:  VariableModifiersopt ::= %Empty
            //
            case 464: {
               //#line 977 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 465:  VariableModifiersopt ::= VariableModifiers
            //
            case 465:
                break;
            //
            // Rule 466:  VariableInitializersopt ::= %Empty
            //
            case 466: {
               //#line 980 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 467:  VariableInitializersopt ::= VariableInitializers
            //
            case 467:
                break;
            //
            // Rule 468:  ElementValuesopt ::= %Empty
            //
            case 468: {
               //#line 983 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 469:  ElementValuesopt ::= ElementValues
            //
            case 469:
                break;
            //
            // Rule 470:  ElementValuePairsopt ::= %Empty
            //
            case 470: {
               //#line 986 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 471:  ElementValuePairsopt ::= ElementValuePairs
            //
            case 471:
                break;
            //
            // Rule 472:  DefaultValueopt ::= %Empty
            //
            case 472: {
               //#line 989 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 473:  DefaultValueopt ::= DefaultValue
            //
            case 473:
                break;
            //
            // Rule 474:  AnnotationTypeElementDeclarationsopt ::= %Empty
            //
            case 474: {
               //#line 992 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 475:  AnnotationTypeElementDeclarationsopt ::= AnnotationTypeElementDeclarations
            //
            case 475:
                break;
            //
            // Rule 476:  AbstractMethodModifiersopt ::= %Empty
            //
            case 476: {
               //#line 995 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 477:  AbstractMethodModifiersopt ::= AbstractMethodModifiers
            //
            case 477:
                break;
            //
            // Rule 478:  ConstantModifiersopt ::= %Empty
            //
            case 478: {
               //#line 998 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 479:  ConstantModifiersopt ::= ConstantModifiers
            //
            case 479:
                break;
            //
            // Rule 480:  InterfaceMemberDeclarationsopt ::= %Empty
            //
            case 480: {
               //#line 1001 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 481:  InterfaceMemberDeclarationsopt ::= InterfaceMemberDeclarations
            //
            case 481:
                break;
            //
            // Rule 482:  ExtendsInterfacesopt ::= %Empty
            //
            case 482: {
               //#line 1004 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 483:  ExtendsInterfacesopt ::= ExtendsInterfaces
            //
            case 483:
                break;
            //
            // Rule 484:  InterfaceModifiersopt ::= %Empty
            //
            case 484: {
               //#line 1007 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 485:  InterfaceModifiersopt ::= InterfaceModifiers
            //
            case 485:
                break;
            //
            // Rule 486:  ClassBodyopt ::= %Empty
            //
            case 486: {
               //#line 1010 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 487:  ClassBodyopt ::= ClassBody
            //
            case 487:
                break;
            //
            // Rule 488:  Argumentsopt ::= %Empty
            //
            case 488: {
               //#line 1013 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 489:  Argumentsopt ::= Arguments
            //
            case 489:
                break;
            //
            // Rule 490:  EnumBodyDeclarationsopt ::= %Empty
            //
            case 490: {
               //#line 1016 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 491:  EnumBodyDeclarationsopt ::= EnumBodyDeclarations
            //
            case 491:
                break;
            //
            // Rule 492:  ,opt ::= %Empty
            //
            case 492: {
               //#line 1019 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 493:  ,opt ::= ,
            //
            case 493: {
               //#line 1020 "GJavaParser.g"
                setResult(
                    //#line 1020 GJavaParser.g
                    Commaopt(getRhsIToken(1))
                //#line 1020 GJavaParser.g
                );
            break;
            }
            //
            // Rule 494:  EnumConstantsopt ::= %Empty
            //
            case 494: {
               //#line 1022 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 495:  EnumConstantsopt ::= EnumConstants
            //
            case 495:
                break;
            //
            // Rule 496:  ArgumentListopt ::= %Empty
            //
            case 496: {
               //#line 1025 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 497:  ArgumentListopt ::= ArgumentList
            //
            case 497:
                break;
            //
            // Rule 498:  BlockStatementsopt ::= %Empty
            //
            case 498: {
               //#line 1028 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 499:  BlockStatementsopt ::= BlockStatements
            //
            case 499:
                break;
            //
            // Rule 500:  ExplicitConstructorInvocationopt ::= %Empty
            //
            case 500: {
               //#line 1031 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 501:  ExplicitConstructorInvocationopt ::= ExplicitConstructorInvocation
            //
            case 501:
                break;
            //
            // Rule 502:  ConstructorModifiersopt ::= %Empty
            //
            case 502: {
               //#line 1034 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 503:  ConstructorModifiersopt ::= ConstructorModifiers
            //
            case 503:
                break;
            //
            // Rule 504:  ...opt ::= %Empty
            //
            case 504: {
               //#line 1037 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 505:  ...opt ::= ...
            //
            case 505: {
               //#line 1038 "GJavaParser.g"
                setResult(
                    //#line 1038 GJavaParser.g
                    Ellipsisopt(getRhsIToken(1))
                //#line 1038 GJavaParser.g
                );
            break;
            }
            //
            // Rule 506:  FormalParameterListopt ::= %Empty
            //
            case 506: {
               //#line 1040 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 507:  FormalParameterListopt ::= FormalParameterList
            //
            case 507:
                break;
            //
            // Rule 508:  Throwsopt ::= %Empty
            //
            case 508: {
               //#line 1043 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 509:  Throwsopt ::= Throws
            //
            case 509:
                break;
            //
            // Rule 510:  MethodModifiersopt ::= %Empty
            //
            case 510: {
               //#line 1046 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 511:  MethodModifiersopt ::= MethodModifiers
            //
            case 511:
                break;
            //
            // Rule 512:  FieldModifiersopt ::= %Empty
            //
            case 512: {
               //#line 1049 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 513:  FieldModifiersopt ::= FieldModifiers
            //
            case 513:
                break;
            //
            // Rule 514:  ClassBodyDeclarationsopt ::= %Empty
            //
            case 514: {
               //#line 1052 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 515:  ClassBodyDeclarationsopt ::= ClassBodyDeclarations
            //
            case 515:
                break;
            //
            // Rule 516:  Interfacesopt ::= %Empty
            //
            case 516: {
               //#line 1055 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 517:  Interfacesopt ::= Interfaces
            //
            case 517:
                break;
            //
            // Rule 518:  Superopt ::= %Empty
            //
            case 518: {
               //#line 1058 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 519:  Superopt ::= Super
            //
            case 519:
                break;
            //
            // Rule 520:  TypeParametersopt ::= %Empty
            //
            case 520: {
               //#line 1061 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 521:  TypeParametersopt ::= TypeParameters
            //
            case 521:
                break;
            //
            // Rule 522:  ClassModifiersopt ::= %Empty
            //
            case 522: {
               //#line 1064 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 523:  ClassModifiersopt ::= ClassModifiers
            //
            case 523:
                break;
            //
            // Rule 524:  Annotationsopt ::= %Empty
            //
            case 524: {
               //#line 1067 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 525:  Annotationsopt ::= Annotations
            //
            case 525:
                break;
            //
            // Rule 526:  TypeDeclarationsopt ::= %Empty
            //
            case 526: {
               //#line 1070 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 527:  TypeDeclarationsopt ::= TypeDeclarations
            //
            case 527:
                break;
            //
            // Rule 528:  ImportDeclarationsopt ::= %Empty
            //
            case 528: {
               //#line 1073 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 529:  ImportDeclarationsopt ::= ImportDeclarations
            //
            case 529:
                break;
            //
            // Rule 530:  PackageDeclarationopt ::= %Empty
            //
            case 530: {
               //#line 1076 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 531:  PackageDeclarationopt ::= PackageDeclaration
            //
            case 531:
                break;
            //
            // Rule 532:  WildcardBoundsOpt ::= %Empty
            //
            case 532: {
               //#line 1079 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 533:  WildcardBoundsOpt ::= WildcardBounds
            //
            case 533:
                break;
            //
            // Rule 534:  AdditionalBoundListopt ::= %Empty
            //
            case 534: {
               //#line 1082 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 535:  AdditionalBoundListopt ::= AdditionalBoundList
            //
            case 535:
                break;
            //
            // Rule 536:  TypeBoundopt ::= %Empty
            //
            case 536: {
               //#line 1085 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 537:  TypeBoundopt ::= TypeBound
            //
            case 537:
                break;
            //
            // Rule 538:  TypeArgumentsopt ::= %Empty
            //
            case 538: {
               //#line 1088 "GJavaParser.g"
                setResult(null);
            break;
            }
            //
            // Rule 539:  TypeArgumentsopt ::= TypeArguments
            //
            case 539:
                break;
    //#line 289 "btParserTemplateS.gi

    
            default:
                break;
        }
        return;
    }
}
abstract class IRootForJavaParser
    {
         IToken getLeftIToken() ;
        IToken  getRightIToken() ;

        void accept(IAstVisitor v );
    }

    /***
     ** is always implemented by <b>AstToken</b>. It is also implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>PrimitiveType
     **<li>ClassType
     **<li>ArrayType
     **<li>TypeDeclaration
     **<li>NormalClassDeclaration
     **<li>ClassMemberDeclaration
     **<li>FieldDeclaration
     **<li>MethodDeclaration
     **<li>ResultType
     **<li>VariableModifier
     **<li>MethodBody
     **<li>EnumDeclaration
     **<li>NormalInterfaceDeclaration
     **<li>InterfaceMemberDeclaration
     **<li>ConstantDeclaration
     **<li>AbstractMethodDeclaration
     **<li>AnnotationTypeDeclaration
     **<li>Annotations
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>Block
     **<li>BlockStatements
     **<li>LocalVariableDeclarationStatement
     **<li>IfThenStatement
     **<li>IfThenElseStatement
     **<li>EmptyStatement
     **<li>LabeledStatement
     **<li>ExpressionStatement
     **<li>SwitchStatement
     **<li>WhileStatement
     **<li>DoStatement
     **<li>BasicForStatement
     **<li>EnhancedForStatement
     **<li>BreakStatement
     **<li>ContinueStatement
     **<li>ReturnStatement
     **<li>ThrowStatement
     **<li>SynchronizedStatement
     **<li>Commaopt
     **<li>Ellipsisopt
     **<li>LPGUserAction0
     **<li>LPGUserAction1
     **<li>LPGUserAction2
     **<li>LPGUserAction3
     **<li>LPGUserAction4
     **<li>IntegralType0
     **<li>IntegralType1
     **<li>IntegralType2
     **<li>IntegralType3
     **<li>IntegralType4
     **<li>FloatingPointType0
     **<li>FloatingPointType1
     **<li>ClassModifier0
     **<li>ClassModifier1
     **<li>ClassModifier2
     **<li>ClassModifier3
     **<li>ClassModifier4
     **<li>ClassModifier5
     **<li>ClassModifier6
     **<li>FieldModifier0
     **<li>FieldModifier1
     **<li>FieldModifier2
     **<li>FieldModifier3
     **<li>FieldModifier4
     **<li>FieldModifier5
     **<li>FieldModifier6
     **<li>MethodModifier0
     **<li>MethodModifier1
     **<li>MethodModifier2
     **<li>MethodModifier3
     **<li>MethodModifier4
     **<li>MethodModifier5
     **<li>MethodModifier6
     **<li>MethodModifier7
     **<li>MethodModifier8
     **<li>ConstructorModifier0
     **<li>ConstructorModifier1
     **<li>ConstructorModifier2
     **<li>InterfaceModifier0
     **<li>InterfaceModifier1
     **<li>InterfaceModifier2
     **<li>InterfaceModifier3
     **<li>InterfaceModifier4
     **<li>InterfaceModifier5
     **<li>ConstantModifier0
     **<li>ConstantModifier1
     **<li>ConstantModifier2
     **<li>AbstractMethodModifier0
     **<li>AbstractMethodModifier1
     **<li>AnnotationTypeElementDeclaration0
     **<li>AnnotationTypeElementDeclaration1
     **<li>AssertStatement0
     **<li>AssertStatement1
     **<li>TryStatement0
     **<li>TryStatement1
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>AssignmentOperator0
     **<li>AssignmentOperator1
     **<li>AssignmentOperator2
     **<li>AssignmentOperator3
     **<li>AssignmentOperator4
     **<li>AssignmentOperator5
     **<li>AssignmentOperator6
     **<li>AssignmentOperator7
     **<li>AssignmentOperator8
     **<li>AssignmentOperator9
     **<li>AssignmentOperator10
     **<li>AssignmentOperator11
     **</ul>
     **</b>
     **/
abstract class IAstToken implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>CompilationUnit</b>
     **/
abstract class ICompilationUnit implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalClassDeclaration
     **<li>ClassBodyDeclarations
     **<li>ClassMemberDeclaration
     **<li>FieldDeclaration
     **<li>MethodDeclaration
     **<li>StaticInitializer
     **<li>ConstructorDeclaration
     **<li>EnumDeclaration
     **<li>NormalInterfaceDeclaration
     **<li>AnnotationTypeDeclaration
     **<li>Block
     **</ul>
     **</b>
     **/
abstract class IClassBodyDeclarationsopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>TypeArguments</b>
     **/
abstract class ITypeArgumentsopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>TypeName
     **</ul>
     **</b>
     **/
abstract class IClassName implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>TypeBound</b>
     **/
abstract class ITypeBoundopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>AdditionalBoundList
     **<li>AdditionalBound
     **</ul>
     **</b>
     **/
abstract class IAdditionalBoundListopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ClassType
     **<li>ArrayType
     **<li>ActualTypeArgumentList
     **<li>Wildcard
     **</ul>
     **</b>
     **/
abstract class IActualTypeArgumentList implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>WildcardBounds0
     **<li>WildcardBounds1
     **</ul>
     **</b>
     **/
abstract class IWildcardBoundsOpt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>PackageName
     **</ul>
     **</b>
     **/
abstract class IPackageName implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>AmbiguousName
     **</ul>
     **</b>
     **/
abstract class IAmbiguousName implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>MethodName
     **</ul>
     **</b>
     **/
abstract class IMethodName implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>PackageOrTypeName
     **</ul>
     **</b>
     **/
abstract class IPackageOrTypeName implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>PackageDeclaration</b>
     **/
abstract class IPackageDeclarationopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>ImportDeclarations
     **<li>SingleTypeImportDeclaration
     **<li>TypeImportOnDemandDeclaration
     **<li>SingleStaticImportDeclaration
     **<li>StaticImportOnDemandDeclaration
     **</ul>
     **</b>
     **/
abstract class IImportDeclarationsopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>TypeDeclarations
     **<li>TypeDeclaration
     **<li>NormalClassDeclaration
     **<li>EnumDeclaration
     **<li>NormalInterfaceDeclaration
     **<li>AnnotationTypeDeclaration
     **</ul>
     **</b>
     **/
abstract class ITypeDeclarationsopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>Annotations
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **</ul>
     **</b>
     **/
abstract class IAnnotationsopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>ClassModifiers
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>ClassModifier0
     **<li>ClassModifier1
     **<li>ClassModifier2
     **<li>ClassModifier3
     **<li>ClassModifier4
     **<li>ClassModifier5
     **<li>ClassModifier6
     **</ul>
     **</b>
     **/
abstract class IClassModifiersopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>TypeParameters</b>
     **/
abstract class ITypeParametersopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>Super</b>
     **/
abstract class ISuperopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>Interfaces</b>
     **/
abstract class IInterfacesopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>TypeParameter
     **<li>TypeParameterList
     **</ul>
     **</b>
     **/
abstract class ITypeParameterList implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>InterfaceType
     **<li>InterfaceTypeList
     **</ul>
     **</b>
     **/
abstract class IInterfaceTypeList implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>FieldModifiers
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>FieldModifier0
     **<li>FieldModifier1
     **<li>FieldModifier2
     **<li>FieldModifier3
     **<li>FieldModifier4
     **<li>FieldModifier5
     **<li>FieldModifier6
     **</ul>
     **</b>
     **/
abstract class IFieldModifiersopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>VariableDeclarators
     **<li>VariableDeclarator
     **<li>VariableDeclaratorId
     **</ul>
     **</b>
     **/
abstract class IVariableDeclarators implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>MethodHeader</b>
     **/
abstract class IMethodHeader implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>MethodModifiers
     **<li>Annotations
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>MethodModifier0
     **<li>MethodModifier1
     **<li>MethodModifier2
     **<li>MethodModifier3
     **<li>MethodModifier4
     **<li>MethodModifier5
     **<li>MethodModifier6
     **<li>MethodModifier7
     **<li>MethodModifier8
     **</ul>
     **</b>
     **/
abstract class IMethodModifiersopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>MethodDeclarator0
     **<li>MethodDeclarator1
     **</ul>
     **</b>
     **/
abstract class IMethodDeclarator implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>Throws</b>
     **/
abstract class IThrowsopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>FormalParameterList
     **<li>LastFormalParameter
     **</ul>
     **</b>
     **/
abstract class IFormalParameterListopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>FormalParameters
     **<li>FormalParameter
     **</ul>
     **</b>
     **/
abstract class IFormalParameters implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>VariableModifiers
     **<li>VariableModifier
     **<li>Annotations
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **</ul>
     **</b>
     **/
abstract class IVariableModifiersopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ClassType
     **<li>ExceptionTypeList
     **</ul>
     **</b>
     **/
abstract class IExceptionTypeList implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>ConstructorModifiers
     **<li>Annotations
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>ConstructorModifier0
     **<li>ConstructorModifier1
     **<li>ConstructorModifier2
     **</ul>
     **</b>
     **/
abstract class IConstructorModifiersopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>ConstructorDeclarator</b>
     **/
abstract class IConstructorDeclarator implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>ConstructorBody</b>
     **/
abstract class IConstructorBody implements IRootForJavaParser    {
    }

    /***
     ** is always implemented by <b>AstToken</b>. It is also implemented by <b>identifier</b>
     **/
abstract class ISimpleTypeName implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>ExplicitConstructorInvocation0
     **<li>ExplicitConstructorInvocation1
     **<li>ExplicitConstructorInvocation2
     **</ul>
     **</b>
     **/
abstract class IExplicitConstructorInvocationopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>ArgumentList
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>AndExpression
     **<li>ExclusiveOrExpression
     **<li>InclusiveOrExpression
     **<li>ConditionalAndExpression
     **<li>ConditionalOrExpression
     **<li>ConditionalExpression
     **<li>Assignment
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **<li>EqualityExpression0
     **<li>EqualityExpression1
     **</ul>
     **</b>
     **/
abstract class IArgumentListopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>EnumBody</b>
     **/
abstract class IEnumBody implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>EnumConstants
     **<li>EnumConstant
     **</ul>
     **</b>
     **/
abstract class IEnumConstantsopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>EnumBodyDeclarations</b>
     **/
abstract class IEnumBodyDeclarationsopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>Arguments</b>
     **/
abstract class IArgumentsopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>ClassBody</b>
     **/
abstract class IClassBodyopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>InterfaceModifiers
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>InterfaceModifier0
     **<li>InterfaceModifier1
     **<li>InterfaceModifier2
     **<li>InterfaceModifier3
     **<li>InterfaceModifier4
     **<li>InterfaceModifier5
     **</ul>
     **</b>
     **/
abstract class IInterfaceModifiersopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>ExtendsInterfaces0
     **<li>ExtendsInterfaces1
     **</ul>
     **</b>
     **/
abstract class IExtendsInterfacesopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>InterfaceBody</b>
     **/
abstract class IInterfaceBody implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalClassDeclaration
     **<li>EnumDeclaration
     **<li>NormalInterfaceDeclaration
     **<li>InterfaceMemberDeclarations
     **<li>InterfaceMemberDeclaration
     **<li>ConstantDeclaration
     **<li>AbstractMethodDeclaration
     **<li>AnnotationTypeDeclaration
     **</ul>
     **</b>
     **/
abstract class IInterfaceMemberDeclarationsopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>ConstantModifiers
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>ConstantModifier0
     **<li>ConstantModifier1
     **<li>ConstantModifier2
     **</ul>
     **</b>
     **/
abstract class IConstantModifiersopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>AbstractMethodModifiers
     **<li>Annotations
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>AbstractMethodModifier0
     **<li>AbstractMethodModifier1
     **</ul>
     **</b>
     **/
abstract class IAbstractMethodModifiersopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>AnnotationTypeBody</b>
     **/
abstract class IAnnotationTypeBody implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalClassDeclaration
     **<li>EnumDeclaration
     **<li>NormalInterfaceDeclaration
     **<li>ConstantDeclaration
     **<li>AnnotationTypeDeclaration
     **<li>AnnotationTypeElementDeclarations
     **<li>AnnotationTypeElementDeclaration0
     **<li>AnnotationTypeElementDeclaration1
     **</ul>
     **</b>
     **/
abstract class IAnnotationTypeElementDeclarationsopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>DefaultValue</b>
     **/
abstract class IDefaultValueopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>ElementValuePairs
     **<li>ElementValuePair
     **</ul>
     **</b>
     **/
abstract class IElementValuePairsopt implements IRootForJavaParser    {
    }

    /***
     ** is always implemented by <b>AstToken</b>. It is also implemented by <b>identifier</b>
     **/
abstract class ISimpleName implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>NormalAnnotation
     **<li>ElementValueArrayInitializer
     **<li>ElementValues
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>AndExpression
     **<li>ExclusiveOrExpression
     **<li>InclusiveOrExpression
     **<li>ConditionalAndExpression
     **<li>ConditionalOrExpression
     **<li>ConditionalExpression
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **<li>EqualityExpression0
     **<li>EqualityExpression1
     **</ul>
     **</b>
     **/
abstract class IElementValuesopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>ArrayInitializer
     **<li>VariableInitializers
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>AndExpression
     **<li>ExclusiveOrExpression
     **<li>InclusiveOrExpression
     **<li>ConditionalAndExpression
     **<li>ConditionalOrExpression
     **<li>ConditionalExpression
     **<li>Assignment
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **<li>EqualityExpression0
     **<li>EqualityExpression1
     **</ul>
     **</b>
     **/
abstract class IVariableInitializersopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>Block
     **<li>IfThenElseStatementNoShortIf
     **<li>EmptyStatement
     **<li>LabeledStatementNoShortIf
     **<li>ExpressionStatement
     **<li>SwitchStatement
     **<li>WhileStatementNoShortIf
     **<li>DoStatement
     **<li>ForStatementNoShortIf
     **<li>BreakStatement
     **<li>ContinueStatement
     **<li>ReturnStatement
     **<li>ThrowStatement
     **<li>SynchronizedStatement
     **<li>AssertStatement0
     **<li>AssertStatement1
     **<li>TryStatement0
     **<li>TryStatement1
     **</ul>
     **</b>
     **/
abstract class IStatementNoShortIf implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>SwitchBlock</b>
     **/
abstract class ISwitchBlock implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>SwitchBlockStatementGroups
     **<li>SwitchBlockStatementGroup
     **</ul>
     **</b>
     **/
abstract class ISwitchBlockStatementGroupsopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>SwitchLabels
     **<li>SwitchLabel0
     **<li>SwitchLabel1
     **<li>SwitchLabel2
     **</ul>
     **</b>
     **/
abstract class ISwitchLabelsopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>AndExpression
     **<li>ExclusiveOrExpression
     **<li>InclusiveOrExpression
     **<li>ConditionalAndExpression
     **<li>ConditionalOrExpression
     **<li>ConditionalExpression
     **<li>Assignment
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **<li>EqualityExpression0
     **<li>EqualityExpression1
     **</ul>
     **</b>
     **/
abstract class IConstantExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>LocalVariableDeclaration
     **<li>StatementExpressionList
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>Assignment
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **</ul>
     **</b>
     **/
abstract class IForInitopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>AndExpression
     **<li>ExclusiveOrExpression
     **<li>InclusiveOrExpression
     **<li>ConditionalAndExpression
     **<li>ConditionalOrExpression
     **<li>ConditionalExpression
     **<li>Assignment
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **<li>EqualityExpression0
     **<li>EqualityExpression1
     **</ul>
     **</b>
     **/
abstract class IExpressionopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>StatementExpressionList
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>Assignment
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **</ul>
     **</b>
     **/
abstract class IForUpdateopt implements IRootForJavaParser    {
    }

    /***
     ** is always implemented by <b>AstToken</b>. It is also implemented by <b>identifier</b>
     **/
abstract class Iidentifieropt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>Catches
     **<li>CatchClause
     **</ul>
     **</b>
     **/
abstract class ICatchesopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>Finally</b>
     **/
abstract class IFinally implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>DimExprs
     **<li>DimExpr
     **</ul>
     **</b>
     **/
abstract class IDimExprs implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>Dims0
     **<li>Dims1
     **</ul>
     **</b>
     **/
abstract class IDimsopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **</ul>
     **</b>
     **/
abstract class ILeftHandSide implements IRootForJavaParser    {
    }

    /***
     ** is always implemented by <b>AstToken</b>. It is also implemented by <b>Commaopt</b>
     **/
abstract class ICommaopt implements IRootForJavaParser    {
    }

    /***
     ** is always implemented by <b>AstToken</b>. It is also implemented by <b>Ellipsisopt</b>
     **/
abstract class IEllipsisopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalClassDeclaration
     **<li>EnumDeclaration
     **<li>Block
     **<li>BlockStatements
     **<li>LocalVariableDeclarationStatement
     **<li>IfThenStatement
     **<li>IfThenElseStatement
     **<li>EmptyStatement
     **<li>LabeledStatement
     **<li>ExpressionStatement
     **<li>SwitchStatement
     **<li>WhileStatement
     **<li>DoStatement
     **<li>BasicForStatement
     **<li>EnhancedForStatement
     **<li>BreakStatement
     **<li>ContinueStatement
     **<li>ReturnStatement
     **<li>ThrowStatement
     **<li>SynchronizedStatement
     **<li>LPGUserAction0
     **<li>LPGUserAction1
     **<li>LPGUserAction2
     **<li>LPGUserAction3
     **<li>LPGUserAction4
     **<li>AssertStatement0
     **<li>AssertStatement1
     **<li>TryStatement0
     **<li>TryStatement1
     **</ul>
     **</b>
     **/
abstract class ILPGUserAction implements IRootForJavaParser    {
    }

    /***
     ** is always implemented by <b>AstToken</b>. It is also implemented by <b>identifier</b>
     **/
abstract class Iidentifier implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalClassDeclaration
     **<li>EnumDeclaration
     **<li>Block
     **<li>BlockStatements
     **<li>LocalVariableDeclarationStatement
     **<li>IfThenStatement
     **<li>IfThenElseStatement
     **<li>EmptyStatement
     **<li>LabeledStatement
     **<li>ExpressionStatement
     **<li>SwitchStatement
     **<li>WhileStatement
     **<li>DoStatement
     **<li>BasicForStatement
     **<li>EnhancedForStatement
     **<li>BreakStatement
     **<li>ContinueStatement
     **<li>ReturnStatement
     **<li>ThrowStatement
     **<li>SynchronizedStatement
     **<li>AssertStatement0
     **<li>AssertStatement1
     **<li>TryStatement0
     **<li>TryStatement1
     **</ul>
     **</b>
     **/
abstract class IBlockStatementsopt implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>PrimitiveType
     **<li>ClassType
     **<li>ArrayType
     **<li>IntegralType0
     **<li>IntegralType1
     **<li>IntegralType2
     **<li>IntegralType3
     **<li>IntegralType4
     **<li>FloatingPointType0
     **<li>FloatingPointType1
     **</ul>
     **</b>
     **/
abstract class IType implements IRootForJavaParser    {
    }

    /***
     ** is always implemented by <b>AstToken</b>. It is also implemented by:
     **<b>
     **<ul>
     **<li>PrimitiveType
     **<li>IntegralType0
     **<li>IntegralType1
     **<li>IntegralType2
     **<li>IntegralType3
     **<li>IntegralType4
     **<li>FloatingPointType0
     **<li>FloatingPointType1
     **</ul>
     **</b>
     **/
abstract class IPrimitiveType implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ClassType
     **<li>ArrayType
     **</ul>
     **</b>
     **/
abstract class IReferenceType implements IRootForJavaParser    {
    }

    /***
     ** is always implemented by <b>AstToken</b>. It is also implemented by:
     **<b>
     **<ul>
     **<li>IntegralType0
     **<li>IntegralType1
     **<li>IntegralType2
     **<li>IntegralType3
     **<li>IntegralType4
     **<li>FloatingPointType0
     **<li>FloatingPointType1
     **</ul>
     **</b>
     **/
abstract class INumericType implements IRootForJavaParser    {
    }

    /***
     ** is always implemented by <b>AstToken</b>. It is also implemented by:
     **<b>
     **<ul>
     **<li>IntegralType0
     **<li>IntegralType1
     **<li>IntegralType2
     **<li>IntegralType3
     **<li>IntegralType4
     **</ul>
     **</b>
     **/
abstract class IIntegralType implements IRootForJavaParser    {
    }

    /***
     ** is always implemented by <b>AstToken</b>. It is also implemented by:
     **<b>
     **<ul>
     **<li>FloatingPointType0
     **<li>FloatingPointType1
     **</ul>
     **</b>
     **/
abstract class IFloatingPointType implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>ClassType</b>
     **/
abstract class IClassOrInterfaceType implements IRootForJavaParser    {
    }

    /***
     ** is always implemented by <b>AstToken</b>. It is also implemented by <b>identifier</b>
     **/
abstract class ITypeVariable implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>ArrayType</b>
     **/
abstract class IArrayType implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>ClassType</b>
     **/
abstract class IClassType implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>TypeName
     **</ul>
     **</b>
     **/
abstract class ITypeName implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>InterfaceType</b>
     **/
abstract class IInterfaceType implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>TypeParameter</b>
     **/
abstract class ITypeParameter implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>TypeBound</b>
     **/
abstract class ITypeBound implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>AdditionalBoundList
     **<li>AdditionalBound
     **</ul>
     **</b>
     **/
abstract class IAdditionalBoundList implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>AdditionalBound</b>
     **/
abstract class IAdditionalBound implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>TypeArguments</b>
     **/
abstract class ITypeArguments implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ClassType
     **<li>ArrayType
     **<li>Wildcard
     **</ul>
     **</b>
     **/
abstract class IActualTypeArgument implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>Wildcard</b>
     **/
abstract class IWildcard implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>WildcardBounds0
     **<li>WildcardBounds1
     **</ul>
     **</b>
     **/
abstract class IWildcardBounds implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **</ul>
     **</b>
     **/
abstract class IExpressionName implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>ImportDeclarations
     **<li>SingleTypeImportDeclaration
     **<li>TypeImportOnDemandDeclaration
     **<li>SingleStaticImportDeclaration
     **<li>StaticImportOnDemandDeclaration
     **</ul>
     **</b>
     **/
abstract class IImportDeclarations implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>SingleTypeImportDeclaration
     **<li>TypeImportOnDemandDeclaration
     **<li>SingleStaticImportDeclaration
     **<li>StaticImportOnDemandDeclaration
     **</ul>
     **</b>
     **/
abstract class IImportDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>TypeDeclarations
     **<li>TypeDeclaration
     **<li>NormalClassDeclaration
     **<li>EnumDeclaration
     **<li>NormalInterfaceDeclaration
     **<li>AnnotationTypeDeclaration
     **</ul>
     **</b>
     **/
abstract class ITypeDeclarations implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>TypeDeclaration
     **<li>NormalClassDeclaration
     **<li>EnumDeclaration
     **<li>NormalInterfaceDeclaration
     **<li>AnnotationTypeDeclaration
     **</ul>
     **</b>
     **/
abstract class ITypeDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>PackageDeclaration</b>
     **/
abstract class IPackageDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>SingleTypeImportDeclaration</b>
     **/
abstract class ISingleTypeImportDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>TypeImportOnDemandDeclaration</b>
     **/
abstract class ITypeImportOnDemandDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>SingleStaticImportDeclaration</b>
     **/
abstract class ISingleStaticImportDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>StaticImportOnDemandDeclaration</b>
     **/
abstract class IStaticImportOnDemandDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalClassDeclaration
     **<li>EnumDeclaration
     **</ul>
     **</b>
     **/
abstract class IClassDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalInterfaceDeclaration
     **<li>AnnotationTypeDeclaration
     **</ul>
     **</b>
     **/
abstract class IInterfaceDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>NormalClassDeclaration</b>
     **/
abstract class INormalClassDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>EnumDeclaration</b>
     **/
abstract class IEnumDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>ClassBody</b>
     **/
abstract class IClassBody implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>ClassModifiers
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>ClassModifier0
     **<li>ClassModifier1
     **<li>ClassModifier2
     **<li>ClassModifier3
     **<li>ClassModifier4
     **<li>ClassModifier5
     **<li>ClassModifier6
     **</ul>
     **</b>
     **/
abstract class IClassModifiers implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>ClassModifier0
     **<li>ClassModifier1
     **<li>ClassModifier2
     **<li>ClassModifier3
     **<li>ClassModifier4
     **<li>ClassModifier5
     **<li>ClassModifier6
     **</ul>
     **</b>
     **/
abstract class IClassModifier implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **</ul>
     **</b>
     **/
abstract class IAnnotation implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>TypeParameters</b>
     **/
abstract class ITypeParameters implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>Super</b>
     **/
abstract class ISuper implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>Interfaces</b>
     **/
abstract class IInterfaces implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalClassDeclaration
     **<li>ClassBodyDeclarations
     **<li>ClassMemberDeclaration
     **<li>FieldDeclaration
     **<li>MethodDeclaration
     **<li>StaticInitializer
     **<li>ConstructorDeclaration
     **<li>EnumDeclaration
     **<li>NormalInterfaceDeclaration
     **<li>AnnotationTypeDeclaration
     **<li>Block
     **</ul>
     **</b>
     **/
abstract class IClassBodyDeclarations implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalClassDeclaration
     **<li>ClassMemberDeclaration
     **<li>FieldDeclaration
     **<li>MethodDeclaration
     **<li>StaticInitializer
     **<li>ConstructorDeclaration
     **<li>EnumDeclaration
     **<li>NormalInterfaceDeclaration
     **<li>AnnotationTypeDeclaration
     **<li>Block
     **</ul>
     **</b>
     **/
abstract class IClassBodyDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalClassDeclaration
     **<li>ClassMemberDeclaration
     **<li>FieldDeclaration
     **<li>MethodDeclaration
     **<li>EnumDeclaration
     **<li>NormalInterfaceDeclaration
     **<li>AnnotationTypeDeclaration
     **</ul>
     **</b>
     **/
abstract class IClassMemberDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>Block</b>
     **/
abstract class IInstanceInitializer implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>StaticInitializer</b>
     **/
abstract class IStaticInitializer implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>ConstructorDeclaration</b>
     **/
abstract class IConstructorDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>FieldDeclaration</b>
     **/
abstract class IFieldDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>MethodDeclaration</b>
     **/
abstract class IMethodDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>VariableDeclarator
     **<li>VariableDeclaratorId
     **</ul>
     **</b>
     **/
abstract class IVariableDeclarator implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>VariableDeclaratorId
     **</ul>
     **</b>
     **/
abstract class IVariableDeclaratorId implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>ArrayInitializer
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>AndExpression
     **<li>ExclusiveOrExpression
     **<li>InclusiveOrExpression
     **<li>ConditionalAndExpression
     **<li>ConditionalOrExpression
     **<li>ConditionalExpression
     **<li>Assignment
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **<li>EqualityExpression0
     **<li>EqualityExpression1
     **</ul>
     **</b>
     **/
abstract class IVariableInitializer implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>AndExpression
     **<li>ExclusiveOrExpression
     **<li>InclusiveOrExpression
     **<li>ConditionalAndExpression
     **<li>ConditionalOrExpression
     **<li>ConditionalExpression
     **<li>Assignment
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **<li>EqualityExpression0
     **<li>EqualityExpression1
     **</ul>
     **</b>
     **/
abstract class IExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>ArrayInitializer</b>
     **/
abstract class IArrayInitializer implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>FieldModifiers
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>FieldModifier0
     **<li>FieldModifier1
     **<li>FieldModifier2
     **<li>FieldModifier3
     **<li>FieldModifier4
     **<li>FieldModifier5
     **<li>FieldModifier6
     **</ul>
     **</b>
     **/
abstract class IFieldModifiers implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>FieldModifier0
     **<li>FieldModifier1
     **<li>FieldModifier2
     **<li>FieldModifier3
     **<li>FieldModifier4
     **<li>FieldModifier5
     **<li>FieldModifier6
     **</ul>
     **</b>
     **/
abstract class IFieldModifier implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>MethodBody
     **<li>Block
     **</ul>
     **</b>
     **/
abstract class IMethodBody implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>PrimitiveType
     **<li>ClassType
     **<li>ArrayType
     **<li>ResultType
     **<li>IntegralType0
     **<li>IntegralType1
     **<li>IntegralType2
     **<li>IntegralType3
     **<li>IntegralType4
     **<li>FloatingPointType0
     **<li>FloatingPointType1
     **</ul>
     **</b>
     **/
abstract class IResultType implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>FormalParameterList
     **<li>LastFormalParameter
     **</ul>
     **</b>
     **/
abstract class IFormalParameterList implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>LastFormalParameter</b>
     **/
abstract class ILastFormalParameter implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>FormalParameter</b>
     **/
abstract class IFormalParameter implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>VariableModifiers
     **<li>VariableModifier
     **<li>Annotations
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **</ul>
     **</b>
     **/
abstract class IVariableModifiers implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>VariableModifier
     **<li>Annotations
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **</ul>
     **</b>
     **/
abstract class IVariableModifier implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>Annotations
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **</ul>
     **</b>
     **/
abstract class IAnnotations implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>MethodModifiers
     **<li>Annotations
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>MethodModifier0
     **<li>MethodModifier1
     **<li>MethodModifier2
     **<li>MethodModifier3
     **<li>MethodModifier4
     **<li>MethodModifier5
     **<li>MethodModifier6
     **<li>MethodModifier7
     **<li>MethodModifier8
     **</ul>
     **</b>
     **/
abstract class IMethodModifiers implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>Annotations
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>MethodModifier0
     **<li>MethodModifier1
     **<li>MethodModifier2
     **<li>MethodModifier3
     **<li>MethodModifier4
     **<li>MethodModifier5
     **<li>MethodModifier6
     **<li>MethodModifier7
     **<li>MethodModifier8
     **</ul>
     **</b>
     **/
abstract class IMethodModifier implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>Throws</b>
     **/
abstract class IThrows implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ClassType
     **</ul>
     **</b>
     **/
abstract class IExceptionType implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>Block</b>
     **/
abstract class IBlock implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>ConstructorModifiers
     **<li>Annotations
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>ConstructorModifier0
     **<li>ConstructorModifier1
     **<li>ConstructorModifier2
     **</ul>
     **</b>
     **/
abstract class IConstructorModifiers implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>Annotations
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>ConstructorModifier0
     **<li>ConstructorModifier1
     **<li>ConstructorModifier2
     **</ul>
     **</b>
     **/
abstract class IConstructorModifier implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>ExplicitConstructorInvocation0
     **<li>ExplicitConstructorInvocation1
     **<li>ExplicitConstructorInvocation2
     **</ul>
     **</b>
     **/
abstract class IExplicitConstructorInvocation implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **</ul>
     **</b>
     **/
abstract class IPrimary implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>EnumConstants
     **<li>EnumConstant
     **</ul>
     **</b>
     **/
abstract class IEnumConstants implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>EnumConstant
     **</ul>
     **</b>
     **/
abstract class IEnumConstant implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>Arguments</b>
     **/
abstract class IArguments implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>EnumBodyDeclarations</b>
     **/
abstract class IEnumBodyDeclarations implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>NormalInterfaceDeclaration</b>
     **/
abstract class INormalInterfaceDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>AnnotationTypeDeclaration</b>
     **/
abstract class IAnnotationTypeDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>InterfaceModifiers
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>InterfaceModifier0
     **<li>InterfaceModifier1
     **<li>InterfaceModifier2
     **<li>InterfaceModifier3
     **<li>InterfaceModifier4
     **<li>InterfaceModifier5
     **</ul>
     **</b>
     **/
abstract class IInterfaceModifiers implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>InterfaceModifier0
     **<li>InterfaceModifier1
     **<li>InterfaceModifier2
     **<li>InterfaceModifier3
     **<li>InterfaceModifier4
     **<li>InterfaceModifier5
     **</ul>
     **</b>
     **/
abstract class IInterfaceModifier implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>ExtendsInterfaces0
     **<li>ExtendsInterfaces1
     **</ul>
     **</b>
     **/
abstract class IExtendsInterfaces implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalClassDeclaration
     **<li>EnumDeclaration
     **<li>NormalInterfaceDeclaration
     **<li>InterfaceMemberDeclarations
     **<li>InterfaceMemberDeclaration
     **<li>ConstantDeclaration
     **<li>AbstractMethodDeclaration
     **<li>AnnotationTypeDeclaration
     **</ul>
     **</b>
     **/
abstract class IInterfaceMemberDeclarations implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalClassDeclaration
     **<li>EnumDeclaration
     **<li>NormalInterfaceDeclaration
     **<li>InterfaceMemberDeclaration
     **<li>ConstantDeclaration
     **<li>AbstractMethodDeclaration
     **<li>AnnotationTypeDeclaration
     **</ul>
     **</b>
     **/
abstract class IInterfaceMemberDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>ConstantDeclaration</b>
     **/
abstract class IConstantDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>AbstractMethodDeclaration</b>
     **/
abstract class IAbstractMethodDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>ConstantModifiers
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>ConstantModifier0
     **<li>ConstantModifier1
     **<li>ConstantModifier2
     **</ul>
     **</b>
     **/
abstract class IConstantModifiers implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>ConstantModifier0
     **<li>ConstantModifier1
     **<li>ConstantModifier2
     **</ul>
     **</b>
     **/
abstract class IConstantModifier implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>AbstractMethodModifiers
     **<li>Annotations
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>AbstractMethodModifier0
     **<li>AbstractMethodModifier1
     **</ul>
     **</b>
     **/
abstract class IAbstractMethodModifiers implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>Annotations
     **<li>NormalAnnotation
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>AbstractMethodModifier0
     **<li>AbstractMethodModifier1
     **</ul>
     **</b>
     **/
abstract class IAbstractMethodModifier implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalClassDeclaration
     **<li>EnumDeclaration
     **<li>NormalInterfaceDeclaration
     **<li>ConstantDeclaration
     **<li>AnnotationTypeDeclaration
     **<li>AnnotationTypeElementDeclarations
     **<li>AnnotationTypeElementDeclaration0
     **<li>AnnotationTypeElementDeclaration1
     **</ul>
     **</b>
     **/
abstract class IAnnotationTypeElementDeclarations implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalClassDeclaration
     **<li>EnumDeclaration
     **<li>NormalInterfaceDeclaration
     **<li>ConstantDeclaration
     **<li>AnnotationTypeDeclaration
     **<li>AnnotationTypeElementDeclaration0
     **<li>AnnotationTypeElementDeclaration1
     **</ul>
     **</b>
     **/
abstract class IAnnotationTypeElementDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>DefaultValue</b>
     **/
abstract class IDefaultValue implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>NormalAnnotation
     **<li>ElementValueArrayInitializer
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>AndExpression
     **<li>ExclusiveOrExpression
     **<li>InclusiveOrExpression
     **<li>ConditionalAndExpression
     **<li>ConditionalOrExpression
     **<li>ConditionalExpression
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **<li>EqualityExpression0
     **<li>EqualityExpression1
     **</ul>
     **</b>
     **/
abstract class IElementValue implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>NormalAnnotation</b>
     **/
abstract class INormalAnnotation implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>MarkerAnnotation</b>
     **/
abstract class IMarkerAnnotation implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>SingleElementAnnotation</b>
     **/
abstract class ISingleElementAnnotation implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>ElementValuePairs
     **<li>ElementValuePair
     **</ul>
     **</b>
     **/
abstract class IElementValuePairs implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>ElementValuePair</b>
     **/
abstract class IElementValuePair implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>AndExpression
     **<li>ExclusiveOrExpression
     **<li>InclusiveOrExpression
     **<li>ConditionalAndExpression
     **<li>ConditionalOrExpression
     **<li>ConditionalExpression
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **<li>EqualityExpression0
     **<li>EqualityExpression1
     **</ul>
     **</b>
     **/
abstract class IConditionalExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>ElementValueArrayInitializer</b>
     **/
abstract class IElementValueArrayInitializer implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>NormalAnnotation
     **<li>ElementValueArrayInitializer
     **<li>ElementValues
     **<li>MarkerAnnotation
     **<li>SingleElementAnnotation
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>AndExpression
     **<li>ExclusiveOrExpression
     **<li>InclusiveOrExpression
     **<li>ConditionalAndExpression
     **<li>ConditionalOrExpression
     **<li>ConditionalExpression
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **<li>EqualityExpression0
     **<li>EqualityExpression1
     **</ul>
     **</b>
     **/
abstract class IElementValues implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>ArrayInitializer
     **<li>VariableInitializers
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>AndExpression
     **<li>ExclusiveOrExpression
     **<li>InclusiveOrExpression
     **<li>ConditionalAndExpression
     **<li>ConditionalOrExpression
     **<li>ConditionalExpression
     **<li>Assignment
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **<li>EqualityExpression0
     **<li>EqualityExpression1
     **</ul>
     **</b>
     **/
abstract class IVariableInitializers implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalClassDeclaration
     **<li>EnumDeclaration
     **<li>Block
     **<li>BlockStatements
     **<li>LocalVariableDeclarationStatement
     **<li>IfThenStatement
     **<li>IfThenElseStatement
     **<li>EmptyStatement
     **<li>LabeledStatement
     **<li>ExpressionStatement
     **<li>SwitchStatement
     **<li>WhileStatement
     **<li>DoStatement
     **<li>BasicForStatement
     **<li>EnhancedForStatement
     **<li>BreakStatement
     **<li>ContinueStatement
     **<li>ReturnStatement
     **<li>ThrowStatement
     **<li>SynchronizedStatement
     **<li>AssertStatement0
     **<li>AssertStatement1
     **<li>TryStatement0
     **<li>TryStatement1
     **</ul>
     **</b>
     **/
abstract class IBlockStatements implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>NormalClassDeclaration
     **<li>EnumDeclaration
     **<li>Block
     **<li>LocalVariableDeclarationStatement
     **<li>IfThenStatement
     **<li>IfThenElseStatement
     **<li>EmptyStatement
     **<li>LabeledStatement
     **<li>ExpressionStatement
     **<li>SwitchStatement
     **<li>WhileStatement
     **<li>DoStatement
     **<li>BasicForStatement
     **<li>EnhancedForStatement
     **<li>BreakStatement
     **<li>ContinueStatement
     **<li>ReturnStatement
     **<li>ThrowStatement
     **<li>SynchronizedStatement
     **<li>AssertStatement0
     **<li>AssertStatement1
     **<li>TryStatement0
     **<li>TryStatement1
     **</ul>
     **</b>
     **/
abstract class IBlockStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>LocalVariableDeclarationStatement</b>
     **/
abstract class ILocalVariableDeclarationStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>Block
     **<li>IfThenStatement
     **<li>IfThenElseStatement
     **<li>EmptyStatement
     **<li>LabeledStatement
     **<li>ExpressionStatement
     **<li>SwitchStatement
     **<li>WhileStatement
     **<li>DoStatement
     **<li>BasicForStatement
     **<li>EnhancedForStatement
     **<li>BreakStatement
     **<li>ContinueStatement
     **<li>ReturnStatement
     **<li>ThrowStatement
     **<li>SynchronizedStatement
     **<li>AssertStatement0
     **<li>AssertStatement1
     **<li>TryStatement0
     **<li>TryStatement1
     **</ul>
     **</b>
     **/
abstract class IStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>LocalVariableDeclaration</b>
     **/
abstract class ILocalVariableDeclaration implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>Block
     **<li>EmptyStatement
     **<li>ExpressionStatement
     **<li>SwitchStatement
     **<li>DoStatement
     **<li>BreakStatement
     **<li>ContinueStatement
     **<li>ReturnStatement
     **<li>ThrowStatement
     **<li>SynchronizedStatement
     **<li>AssertStatement0
     **<li>AssertStatement1
     **<li>TryStatement0
     **<li>TryStatement1
     **</ul>
     **</b>
     **/
abstract class IStatementWithoutTrailingSubstatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>LabeledStatement</b>
     **/
abstract class ILabeledStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>IfThenStatement</b>
     **/
abstract class IIfThenStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>IfThenElseStatement</b>
     **/
abstract class IIfThenElseStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>WhileStatement</b>
     **/
abstract class IWhileStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>BasicForStatement
     **<li>EnhancedForStatement
     **</ul>
     **</b>
     **/
abstract class IForStatement implements IRootForJavaParser    {
    }

    /***
     ** is always implemented by <b>AstToken</b>. It is also implemented by <b>EmptyStatement</b>
     **/
abstract class IEmptyStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>ExpressionStatement</b>
     **/
abstract class IExpressionStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>AssertStatement0
     **<li>AssertStatement1
     **</ul>
     **</b>
     **/
abstract class IAssertStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>SwitchStatement</b>
     **/
abstract class ISwitchStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>DoStatement</b>
     **/
abstract class IDoStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>BreakStatement</b>
     **/
abstract class IBreakStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>ContinueStatement</b>
     **/
abstract class IContinueStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>ReturnStatement</b>
     **/
abstract class IReturnStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>SynchronizedStatement</b>
     **/
abstract class ISynchronizedStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>ThrowStatement</b>
     **/
abstract class IThrowStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>TryStatement0
     **<li>TryStatement1
     **</ul>
     **</b>
     **/
abstract class ITryStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>LabeledStatementNoShortIf</b>
     **/
abstract class ILabeledStatementNoShortIf implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>IfThenElseStatementNoShortIf</b>
     **/
abstract class IIfThenElseStatementNoShortIf implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>WhileStatementNoShortIf</b>
     **/
abstract class IWhileStatementNoShortIf implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>ForStatementNoShortIf</b>
     **/
abstract class IForStatementNoShortIf implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>Assignment
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **</ul>
     **</b>
     **/
abstract class IStatementExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>Assignment</b>
     **/
abstract class IAssignment implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>PreIncrementExpression</b>
     **/
abstract class IPreIncrementExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>PreDecrementExpression</b>
     **/
abstract class IPreDecrementExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>PostIncrementExpression</b>
     **/
abstract class IPostIncrementExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>PostDecrementExpression</b>
     **/
abstract class IPostDecrementExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **</ul>
     **</b>
     **/
abstract class IMethodInvocation implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **</ul>
     **</b>
     **/
abstract class IClassInstanceCreationExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>SwitchBlockStatementGroups
     **<li>SwitchBlockStatementGroup
     **</ul>
     **</b>
     **/
abstract class ISwitchBlockStatementGroups implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>SwitchBlockStatementGroup</b>
     **/
abstract class ISwitchBlockStatementGroup implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>SwitchLabels
     **<li>SwitchLabel0
     **<li>SwitchLabel1
     **<li>SwitchLabel2
     **</ul>
     **</b>
     **/
abstract class ISwitchLabels implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>SwitchLabel0
     **<li>SwitchLabel1
     **<li>SwitchLabel2
     **</ul>
     **</b>
     **/
abstract class ISwitchLabel implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>BasicForStatement</b>
     **/
abstract class IBasicForStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>EnhancedForStatement</b>
     **/
abstract class IEnhancedForStatement implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>LocalVariableDeclaration
     **<li>StatementExpressionList
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>Assignment
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **</ul>
     **</b>
     **/
abstract class IForInit implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>StatementExpressionList
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>Assignment
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **</ul>
     **</b>
     **/
abstract class IStatementExpressionList implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>StatementExpressionList
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>Assignment
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **</ul>
     **</b>
     **/
abstract class IForUpdate implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>Catches
     **<li>CatchClause
     **</ul>
     **</b>
     **/
abstract class ICatches implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>CatchClause</b>
     **/
abstract class ICatchClause implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **</ul>
     **</b>
     **/
abstract class IPrimaryNoNewArray implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **</ul>
     **</b>
     **/
abstract class IArrayCreationExpression implements IRootForJavaParser    {
    }

    /***
     ** is always implemented by <b>AstToken</b>. It is also implemented by:
     **<b>
     **<ul>
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **</ul>
     **</b>
     **/
abstract class ILiteral implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **</ul>
     **</b>
     **/
abstract class IFieldAccess implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **</ul>
     **</b>
     **/
abstract class IArrayAccess implements IRootForJavaParser    {
    }

    /***
     ** is always implemented by <b>AstToken</b>. It is also implemented by:
     **<b>
     **<ul>
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **</ul>
     **</b>
     **/
abstract class IBooleanLiteral implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>ArgumentList
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>AndExpression
     **<li>ExclusiveOrExpression
     **<li>InclusiveOrExpression
     **<li>ConditionalAndExpression
     **<li>ConditionalOrExpression
     **<li>ConditionalExpression
     **<li>Assignment
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **<li>EqualityExpression0
     **<li>EqualityExpression1
     **</ul>
     **</b>
     **/
abstract class IArgumentList implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>Dims0
     **<li>Dims1
     **</ul>
     **</b>
     **/
abstract class IDims implements IRootForJavaParser    {
    }

    /***
     ** is implemented by <b>DimExpr</b>
     **/
abstract class IDimExpr implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **</ul>
     **</b>
     **/
abstract class IPostfixExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **</ul>
     **</b>
     **/
abstract class IUnaryExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **</ul>
     **</b>
     **/
abstract class IUnaryExpressionNotPlusMinus implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>CastExpression0
     **<li>CastExpression1
     **</ul>
     **</b>
     **/
abstract class ICastExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **</ul>
     **</b>
     **/
abstract class IMultiplicativeExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **</ul>
     **</b>
     **/
abstract class IAdditiveExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **</ul>
     **</b>
     **/
abstract class IShiftExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **</ul>
     **</b>
     **/
abstract class IRelationalExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **<li>EqualityExpression0
     **<li>EqualityExpression1
     **</ul>
     **</b>
     **/
abstract class IEqualityExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>AndExpression
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **<li>EqualityExpression0
     **<li>EqualityExpression1
     **</ul>
     **</b>
     **/
abstract class IAndExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>AndExpression
     **<li>ExclusiveOrExpression
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **<li>EqualityExpression0
     **<li>EqualityExpression1
     **</ul>
     **</b>
     **/
abstract class IExclusiveOrExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>AndExpression
     **<li>ExclusiveOrExpression
     **<li>InclusiveOrExpression
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **<li>EqualityExpression0
     **<li>EqualityExpression1
     **</ul>
     **</b>
     **/
abstract class IInclusiveOrExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>AndExpression
     **<li>ExclusiveOrExpression
     **<li>InclusiveOrExpression
     **<li>ConditionalAndExpression
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **<li>EqualityExpression0
     **<li>EqualityExpression1
     **</ul>
     **</b>
     **/
abstract class IConditionalAndExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>AndExpression
     **<li>ExclusiveOrExpression
     **<li>InclusiveOrExpression
     **<li>ConditionalAndExpression
     **<li>ConditionalOrExpression
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **<li>EqualityExpression0
     **<li>EqualityExpression1
     **</ul>
     **</b>
     **/
abstract class IConditionalOrExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>identifier
     **<li>ExpressionName
     **<li>PostIncrementExpression
     **<li>PostDecrementExpression
     **<li>PreIncrementExpression
     **<li>PreDecrementExpression
     **<li>AndExpression
     **<li>ExclusiveOrExpression
     **<li>InclusiveOrExpression
     **<li>ConditionalAndExpression
     **<li>ConditionalOrExpression
     **<li>ConditionalExpression
     **<li>Assignment
     **<li>PrimaryNoNewArray0
     **<li>PrimaryNoNewArray1
     **<li>PrimaryNoNewArray2
     **<li>PrimaryNoNewArray3
     **<li>PrimaryNoNewArray4
     **<li>Literal0
     **<li>Literal1
     **<li>Literal2
     **<li>Literal3
     **<li>Literal4
     **<li>Literal5
     **<li>Literal6
     **<li>BooleanLiteral0
     **<li>BooleanLiteral1
     **<li>ClassInstanceCreationExpression0
     **<li>ClassInstanceCreationExpression1
     **<li>ArrayCreationExpression0
     **<li>ArrayCreationExpression1
     **<li>ArrayCreationExpression2
     **<li>ArrayCreationExpression3
     **<li>FieldAccess0
     **<li>FieldAccess1
     **<li>FieldAccess2
     **<li>MethodInvocation0
     **<li>MethodInvocation1
     **<li>MethodInvocation2
     **<li>MethodInvocation3
     **<li>MethodInvocation4
     **<li>ArrayAccess0
     **<li>ArrayAccess1
     **<li>UnaryExpression0
     **<li>UnaryExpression1
     **<li>UnaryExpressionNotPlusMinus0
     **<li>UnaryExpressionNotPlusMinus1
     **<li>CastExpression0
     **<li>CastExpression1
     **<li>MultiplicativeExpression0
     **<li>MultiplicativeExpression1
     **<li>MultiplicativeExpression2
     **<li>AdditiveExpression0
     **<li>AdditiveExpression1
     **<li>ShiftExpression0
     **<li>ShiftExpression1
     **<li>ShiftExpression2
     **<li>RelationalExpression0
     **<li>RelationalExpression1
     **<li>RelationalExpression2
     **<li>RelationalExpression3
     **<li>RelationalExpression4
     **<li>EqualityExpression0
     **<li>EqualityExpression1
     **</ul>
     **</b>
     **/
abstract class IAssignmentExpression implements IRootForJavaParser    {
    }

    /***
     ** is implemented by:
     **<b>
     **<ul>
     **<li>AssignmentOperator0
     **<li>AssignmentOperator1
     **<li>AssignmentOperator2
     **<li>AssignmentOperator3
     **<li>AssignmentOperator4
     **<li>AssignmentOperator5
     **<li>AssignmentOperator6
     **<li>AssignmentOperator7
     **<li>AssignmentOperator8
     **<li>AssignmentOperator9
     **<li>AssignmentOperator10
     **<li>AssignmentOperator11
     **</ul>
     **</b>
     **/
abstract class IAssignmentOperator implements IRootForJavaParser    {
    }

abstract class Ast implements IAst
    {
        IAst? getNextAst(){ return null; }
         late IToken leftIToken ;
         late IToken rightIToken ;
         IAst? parent;
         void setParent(IAst p){ parent = p; }
         IAst? getParent(){ return parent; }

         IToken getLeftIToken()  { return leftIToken; }
         IToken getRightIToken()  { return rightIToken; }
          List<IToken> getPrecedingAdjuncts() { return leftIToken.getPrecedingAdjuncts(); }
          List<IToken> getFollowingAdjuncts() { return rightIToken.getFollowingAdjuncts(); }

        String  toString()  
        {
          var  lex = leftIToken.getILexStream();
          if( lex != null)
            return lex.toStringWithOffset(leftIToken.getStartOffset(), rightIToken.getEndOffset());
          return  '';
        }

    Ast(IToken leftIToken ,[ IToken? rightIToken ])
        {
            this.leftIToken = leftIToken;
            if(rightIToken != null) this.rightIToken = rightIToken;
            else            this.rightIToken = leftIToken;
        }

        void initialize(){}

        /**
         * A list of all children of this node, excluding the null ones.
         */
          ArrayList getChildren() 
        {
             var list = getAllChildren() ;
            var k = -1;
            for (var i = 0; i < list.size(); i++)
            {
                var element = list.get(i);
                if (null==element)
                {
                    if (++k != i)
                        list.set(k, element);
                }
            }
            for (var i = list.size() - 1; i > k; i--) // remove extraneous elements
                list.remove(i);
            return list;
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
         ArrayList getAllChildren() ;

         void accept(IAstVisitor v );
    }

abstract class AbstractAstList extends Ast implements IAbstractArrayList<Ast>
    {
         late bool leftRecursive  ;
          var list  =  ArrayList();
         int size()   { return list.size(); }
         ArrayList getList(){ return list; }
         Ast getElementAt(int i) { return list.get(leftRecursive ? i : list.size() - 1 - i); }
         ArrayList getArrayList()
        {
            if (! leftRecursive) // reverse the list 
            {
                for (var i = 0, n = list.size() - 1; i < n; i++, n--)
                {
                    var ith = list.get(i),
                           nth = list.get(n);
                    list.set(i, nth);
                    list.set(n, ith);
                }
                leftRecursive = true;
            }
            return list;
        }
        /**
         * @deprecated replaced by {@link #addElement()}
         *
         */
         bool add(Ast element)
        {
            addElement(element);
            return true;
        }

         void addElement(Ast element)
        {
            list.add(element);
            if (leftRecursive)
                 rightIToken = element.getRightIToken();
            else leftIToken = element.getLeftIToken();
        }

          AbstractAstList(IToken leftToken, IToken rightToken , bool leftRecursive  ):super(leftToken, rightToken){
              this.leftRecursive = leftRecursive;
        }

        /**
         * Make a copy of the list and return it. Note that we obtain the local list by
         * invoking getArrayList so as to make sure that the list we return is in proper order.
         */
            ArrayList getAllChildren() 
        {
            return getArrayList().clone();
        }

    }

class AstToken extends Ast implements IAstToken
    {
        AstToken(IToken token   ):super(token){  }
         IToken getIToken()  { return leftIToken; }
         String toString(){ return leftIToken.toString(); }

        /**
         * A token class has no children. So, we return the empty list.
         */
            ArrayList getAllChildren()  { return  ArrayList(); }


         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitAstToken(this);
            v.endVisitAstToken(this);
        }
    }

/**
 *<b>
*<li>Rule 3:  identifier ::= IDENTIFIER
 *</b>
 */
class identifier extends AstToken implements Iidentifier
    {
         late JavaParser environment;
         JavaParser getEnvironment() { return environment; }

         IToken getIDENTIFIER(){ return leftIToken; }

    identifier(JavaParser environment, IToken token):super(token)        {
            this.environment = environment;
            initialize();
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitidentifier(this);
            v.endVisitidentifier(this);
        }
    }

/**
 *<em>
*<li>Rule 12:  PrimitiveType ::= NumericType
 *</em>
 *<p>
 *<b>
*<li>Rule 13:  PrimitiveType ::= boolean
 *</b>
 */
class PrimitiveType extends AstToken implements IPrimitiveType
    {
         IToken getboolean(){ return leftIToken; }

    PrimitiveType(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitPrimitiveType(this);
            v.endVisitPrimitiveType(this);
        }
    }

/**
 *<b>
*<li>Rule 27:  ClassType ::= TypeName TypeArgumentsopt
 *</b>
 */
class ClassType extends Ast implements IClassType
    {
         late ITypeName _TypeName;
         late TypeArguments? _TypeArgumentsopt;

         ITypeName getTypeName(){ return _TypeName; }
         void setTypeName(ITypeName _TypeName){ this._TypeName = _TypeName; }
        /**
         * The value returned by <b>getTypeArgumentsopt</b> may be <b>null</b>
         */
         TypeArguments ?  getTypeArgumentsopt(){ return _TypeArgumentsopt; }
         void setTypeArgumentsopt(TypeArguments _TypeArgumentsopt){ this._TypeArgumentsopt = _TypeArgumentsopt; }

        ClassType(IToken leftIToken, IToken rightIToken,
                  ITypeName _TypeName,
                  TypeArguments? _TypeArgumentsopt)
            :super(leftIToken, rightIToken)

        {
            this._TypeName = _TypeName;
            (_TypeName as Ast).setParent(this);
            this._TypeArgumentsopt = _TypeArgumentsopt;
            if (null != _TypeArgumentsopt) (_TypeArgumentsopt as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _TypeName)  list.add(_TypeName);
            if(null != _TypeArgumentsopt)  list.add(_TypeArgumentsopt);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitClassType(this);
            if (checkChildren)
            {
                _TypeName.accept(v);
                if (null != _TypeArgumentsopt) _TypeArgumentsopt!.accept(v);
            }
            v.endVisitClassType(this);
        }
    }

/**
 *<b>
*<li>Rule 28:  InterfaceType ::= TypeName TypeArgumentsopt
 *</b>
 */
class InterfaceType extends Ast implements IInterfaceType
    {
         late ITypeName _TypeName;
         late TypeArguments? _TypeArgumentsopt;

         ITypeName getTypeName(){ return _TypeName; }
         void setTypeName(ITypeName _TypeName){ this._TypeName = _TypeName; }
        /**
         * The value returned by <b>getTypeArgumentsopt</b> may be <b>null</b>
         */
         TypeArguments ?  getTypeArgumentsopt(){ return _TypeArgumentsopt; }
         void setTypeArgumentsopt(TypeArguments _TypeArgumentsopt){ this._TypeArgumentsopt = _TypeArgumentsopt; }

        InterfaceType(IToken leftIToken, IToken rightIToken,
                      ITypeName _TypeName,
                      TypeArguments? _TypeArgumentsopt)
            :super(leftIToken, rightIToken)

        {
            this._TypeName = _TypeName;
            (_TypeName as Ast).setParent(this);
            this._TypeArgumentsopt = _TypeArgumentsopt;
            if (null != _TypeArgumentsopt) (_TypeArgumentsopt as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _TypeName)  list.add(_TypeName);
            if(null != _TypeArgumentsopt)  list.add(_TypeArgumentsopt);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitInterfaceType(this);
            if (checkChildren)
            {
                _TypeName.accept(v);
                if (null != _TypeArgumentsopt) _TypeArgumentsopt!.accept(v);
            }
            v.endVisitInterfaceType(this);
        }
    }

/**
 *<em>
*<li>Rule 29:  TypeName ::= identifier
 *</em>
 *<p>
 *<b>
*<li>Rule 30:  TypeName ::= TypeName . identifier
 *</b>
 */
class TypeName extends Ast implements ITypeName
    {
         late ITypeName _TypeName;
         late AstToken _DOT;
         late identifier _identifier;

         ITypeName getTypeName(){ return _TypeName; }
         void setTypeName(ITypeName _TypeName){ this._TypeName = _TypeName; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }

        TypeName(IToken leftIToken, IToken rightIToken,
                 ITypeName _TypeName,
                 AstToken _DOT,
                 identifier _identifier)
            :super(leftIToken, rightIToken)

        {
            this._TypeName = _TypeName;
            (_TypeName as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _TypeName)  list.add(_TypeName);
            if(null != _DOT)  list.add(_DOT);
            if(null != _identifier)  list.add(_identifier);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitTypeName(this);
            if (checkChildren)
            {
                _TypeName.accept(v);
                _DOT.accept(v);
                _identifier.accept(v);
            }
            v.endVisitTypeName(this);
        }
    }

/**
 *<b>
*<li>Rule 33:  ArrayType ::= Type [ ]
 *</b>
 */
class ArrayType extends Ast implements IArrayType
    {
         late IType _Type;
         late AstToken _LBRACKET;
         late AstToken _RBRACKET;

         IType getType(){ return _Type; }
         void setType(IType _Type){ this._Type = _Type; }
         AstToken getLBRACKET(){ return _LBRACKET; }
         void setLBRACKET(AstToken _LBRACKET){ this._LBRACKET = _LBRACKET; }
         AstToken getRBRACKET(){ return _RBRACKET; }
         void setRBRACKET(AstToken _RBRACKET){ this._RBRACKET = _RBRACKET; }

        ArrayType(IToken leftIToken, IToken rightIToken,
                  IType _Type,
                  AstToken _LBRACKET,
                  AstToken _RBRACKET)
            :super(leftIToken, rightIToken)

        {
            this._Type = _Type;
            (_Type as Ast).setParent(this);
            this._LBRACKET = _LBRACKET;
            (_LBRACKET as Ast).setParent(this);
            this._RBRACKET = _RBRACKET;
            (_RBRACKET as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _Type)  list.add(_Type);
            if(null != _LBRACKET)  list.add(_LBRACKET);
            if(null != _RBRACKET)  list.add(_RBRACKET);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitArrayType(this);
            if (checkChildren)
            {
                _Type.accept(v);
                _LBRACKET.accept(v);
                _RBRACKET.accept(v);
            }
            v.endVisitArrayType(this);
        }
    }

/**
 *<b>
*<li>Rule 34:  TypeParameter ::= TypeVariable TypeBoundopt
 *</b>
 */
class TypeParameter extends Ast implements ITypeParameter
    {
         late identifier _TypeVariable;
         late TypeBound? _TypeBoundopt;

         identifier getTypeVariable(){ return _TypeVariable; }
         void setTypeVariable(identifier _TypeVariable){ this._TypeVariable = _TypeVariable; }
        /**
         * The value returned by <b>getTypeBoundopt</b> may be <b>null</b>
         */
         TypeBound ?  getTypeBoundopt(){ return _TypeBoundopt; }
         void setTypeBoundopt(TypeBound _TypeBoundopt){ this._TypeBoundopt = _TypeBoundopt; }

        TypeParameter(IToken leftIToken, IToken rightIToken,
                      identifier _TypeVariable,
                      TypeBound? _TypeBoundopt)
            :super(leftIToken, rightIToken)

        {
            this._TypeVariable = _TypeVariable;
            (_TypeVariable as Ast).setParent(this);
            this._TypeBoundopt = _TypeBoundopt;
            if (null != _TypeBoundopt) (_TypeBoundopt as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _TypeVariable)  list.add(_TypeVariable);
            if(null != _TypeBoundopt)  list.add(_TypeBoundopt);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitTypeParameter(this);
            if (checkChildren)
            {
                _TypeVariable.accept(v);
                if (null != _TypeBoundopt) _TypeBoundopt!.accept(v);
            }
            v.endVisitTypeParameter(this);
        }
    }

/**
 *<b>
*<li>Rule 35:  TypeBound ::= extends ClassOrInterfaceType AdditionalBoundListopt
 *</b>
 */
class TypeBound extends Ast implements ITypeBound
    {
         late AstToken _extends;
         late ClassType _ClassOrInterfaceType;
         late IAdditionalBoundListopt? _AdditionalBoundListopt;

         AstToken getextends(){ return _extends; }
         void setextends(AstToken _extends){ this._extends = _extends; }
         ClassType getClassOrInterfaceType(){ return _ClassOrInterfaceType; }
         void setClassOrInterfaceType(ClassType _ClassOrInterfaceType){ this._ClassOrInterfaceType = _ClassOrInterfaceType; }
        /**
         * The value returned by <b>getAdditionalBoundListopt</b> may be <b>null</b>
         */
         IAdditionalBoundListopt ?  getAdditionalBoundListopt(){ return _AdditionalBoundListopt; }
         void setAdditionalBoundListopt(IAdditionalBoundListopt _AdditionalBoundListopt){ this._AdditionalBoundListopt = _AdditionalBoundListopt; }

        TypeBound(IToken leftIToken, IToken rightIToken,
                  AstToken _extends,
                  ClassType _ClassOrInterfaceType,
                  IAdditionalBoundListopt? _AdditionalBoundListopt)
            :super(leftIToken, rightIToken)

        {
            this._extends = _extends;
            (_extends as Ast).setParent(this);
            this._ClassOrInterfaceType = _ClassOrInterfaceType;
            (_ClassOrInterfaceType as Ast).setParent(this);
            this._AdditionalBoundListopt = _AdditionalBoundListopt;
            if (null != _AdditionalBoundListopt) (_AdditionalBoundListopt as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _extends)  list.add(_extends);
            if(null != _ClassOrInterfaceType)  list.add(_ClassOrInterfaceType);
            if(null != _AdditionalBoundListopt)  list.add(_AdditionalBoundListopt);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitTypeBound(this);
            if (checkChildren)
            {
                _extends.accept(v);
                _ClassOrInterfaceType.accept(v);
                if (null != _AdditionalBoundListopt) _AdditionalBoundListopt!.accept(v);
            }
            v.endVisitTypeBound(this);
        }
    }

/**
 *<em>
*<li>Rule 36:  AdditionalBoundList ::= AdditionalBound
 *</em>
 *<p>
 *<b>
*<li>Rule 37:  AdditionalBoundList ::= AdditionalBoundList AdditionalBound
 *</b>
 */
class AdditionalBoundList extends Ast implements IAdditionalBoundList
    {
         late IAdditionalBoundList _AdditionalBoundList;
         late AdditionalBound _AdditionalBound;

         IAdditionalBoundList getAdditionalBoundList(){ return _AdditionalBoundList; }
         void setAdditionalBoundList(IAdditionalBoundList _AdditionalBoundList){ this._AdditionalBoundList = _AdditionalBoundList; }
         AdditionalBound getAdditionalBound(){ return _AdditionalBound; }
         void setAdditionalBound(AdditionalBound _AdditionalBound){ this._AdditionalBound = _AdditionalBound; }

        AdditionalBoundList(IToken leftIToken, IToken rightIToken,
                            IAdditionalBoundList _AdditionalBoundList,
                            AdditionalBound _AdditionalBound)
            :super(leftIToken, rightIToken)

        {
            this._AdditionalBoundList = _AdditionalBoundList;
            (_AdditionalBoundList as Ast).setParent(this);
            this._AdditionalBound = _AdditionalBound;
            (_AdditionalBound as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _AdditionalBoundList)  list.add(_AdditionalBoundList);
            if(null != _AdditionalBound)  list.add(_AdditionalBound);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitAdditionalBoundList(this);
            if (checkChildren)
            {
                _AdditionalBoundList.accept(v);
                _AdditionalBound.accept(v);
            }
            v.endVisitAdditionalBoundList(this);
        }
    }

/**
 *<b>
*<li>Rule 38:  AdditionalBound ::= & InterfaceType
 *</b>
 */
class AdditionalBound extends Ast implements IAdditionalBound
    {
         late AstToken _AND;
         late InterfaceType _InterfaceType;

         AstToken getAND(){ return _AND; }
         void setAND(AstToken _AND){ this._AND = _AND; }
         InterfaceType getInterfaceType(){ return _InterfaceType; }
         void setInterfaceType(InterfaceType _InterfaceType){ this._InterfaceType = _InterfaceType; }

        AdditionalBound(IToken leftIToken, IToken rightIToken,
                        AstToken _AND,
                        InterfaceType _InterfaceType)
            :super(leftIToken, rightIToken)

        {
            this._AND = _AND;
            (_AND as Ast).setParent(this);
            this._InterfaceType = _InterfaceType;
            (_InterfaceType as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _AND)  list.add(_AND);
            if(null != _InterfaceType)  list.add(_InterfaceType);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitAdditionalBound(this);
            if (checkChildren)
            {
                _AND.accept(v);
                _InterfaceType.accept(v);
            }
            v.endVisitAdditionalBound(this);
        }
    }

/**
 *<b>
*<li>Rule 39:  TypeArguments ::= < ActualTypeArgumentList >
 *</b>
 */
class TypeArguments extends Ast implements ITypeArguments
    {
         late AstToken _LESS;
         late IActualTypeArgumentList _ActualTypeArgumentList;
         late AstToken _GREATER;

         AstToken getLESS(){ return _LESS; }
         void setLESS(AstToken _LESS){ this._LESS = _LESS; }
         IActualTypeArgumentList getActualTypeArgumentList(){ return _ActualTypeArgumentList; }
         void setActualTypeArgumentList(IActualTypeArgumentList _ActualTypeArgumentList){ this._ActualTypeArgumentList = _ActualTypeArgumentList; }
         AstToken getGREATER(){ return _GREATER; }
         void setGREATER(AstToken _GREATER){ this._GREATER = _GREATER; }

        TypeArguments(IToken leftIToken, IToken rightIToken,
                      AstToken _LESS,
                      IActualTypeArgumentList _ActualTypeArgumentList,
                      AstToken _GREATER)
            :super(leftIToken, rightIToken)

        {
            this._LESS = _LESS;
            (_LESS as Ast).setParent(this);
            this._ActualTypeArgumentList = _ActualTypeArgumentList;
            (_ActualTypeArgumentList as Ast).setParent(this);
            this._GREATER = _GREATER;
            (_GREATER as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _LESS)  list.add(_LESS);
            if(null != _ActualTypeArgumentList)  list.add(_ActualTypeArgumentList);
            if(null != _GREATER)  list.add(_GREATER);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitTypeArguments(this);
            if (checkChildren)
            {
                _LESS.accept(v);
                _ActualTypeArgumentList.accept(v);
                _GREATER.accept(v);
            }
            v.endVisitTypeArguments(this);
        }
    }

/**
 *<em>
*<li>Rule 40:  ActualTypeArgumentList ::= ActualTypeArgument
 *</em>
 *<p>
 *<b>
*<li>Rule 41:  ActualTypeArgumentList ::= ActualTypeArgumentList , ActualTypeArgument
 *</b>
 */
class ActualTypeArgumentList extends Ast implements IActualTypeArgumentList
    {
         late IActualTypeArgumentList _ActualTypeArgumentList;
         late AstToken _COMMA;
         late IActualTypeArgument _ActualTypeArgument;

         IActualTypeArgumentList getActualTypeArgumentList(){ return _ActualTypeArgumentList; }
         void setActualTypeArgumentList(IActualTypeArgumentList _ActualTypeArgumentList){ this._ActualTypeArgumentList = _ActualTypeArgumentList; }
         AstToken getCOMMA(){ return _COMMA; }
         void setCOMMA(AstToken _COMMA){ this._COMMA = _COMMA; }
         IActualTypeArgument getActualTypeArgument(){ return _ActualTypeArgument; }
         void setActualTypeArgument(IActualTypeArgument _ActualTypeArgument){ this._ActualTypeArgument = _ActualTypeArgument; }

        ActualTypeArgumentList(IToken leftIToken, IToken rightIToken,
                               IActualTypeArgumentList _ActualTypeArgumentList,
                               AstToken _COMMA,
                               IActualTypeArgument _ActualTypeArgument)
            :super(leftIToken, rightIToken)

        {
            this._ActualTypeArgumentList = _ActualTypeArgumentList;
            (_ActualTypeArgumentList as Ast).setParent(this);
            this._COMMA = _COMMA;
            (_COMMA as Ast).setParent(this);
            this._ActualTypeArgument = _ActualTypeArgument;
            (_ActualTypeArgument as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ActualTypeArgumentList)  list.add(_ActualTypeArgumentList);
            if(null != _COMMA)  list.add(_COMMA);
            if(null != _ActualTypeArgument)  list.add(_ActualTypeArgument);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitActualTypeArgumentList(this);
            if (checkChildren)
            {
                _ActualTypeArgumentList.accept(v);
                _COMMA.accept(v);
                _ActualTypeArgument.accept(v);
            }
            v.endVisitActualTypeArgumentList(this);
        }
    }

/**
 *<b>
*<li>Rule 44:  Wildcard ::= ? WildcardBoundsOpt
 *</b>
 */
class Wildcard extends Ast implements IWildcard
    {
         late AstToken _QUESTION;
         late IWildcardBoundsOpt? _WildcardBoundsOpt;

         AstToken getQUESTION(){ return _QUESTION; }
         void setQUESTION(AstToken _QUESTION){ this._QUESTION = _QUESTION; }
        /**
         * The value returned by <b>getWildcardBoundsOpt</b> may be <b>null</b>
         */
         IWildcardBoundsOpt ?  getWildcardBoundsOpt(){ return _WildcardBoundsOpt; }
         void setWildcardBoundsOpt(IWildcardBoundsOpt _WildcardBoundsOpt){ this._WildcardBoundsOpt = _WildcardBoundsOpt; }

        Wildcard(IToken leftIToken, IToken rightIToken,
                 AstToken _QUESTION,
                 IWildcardBoundsOpt? _WildcardBoundsOpt)
            :super(leftIToken, rightIToken)

        {
            this._QUESTION = _QUESTION;
            (_QUESTION as Ast).setParent(this);
            this._WildcardBoundsOpt = _WildcardBoundsOpt;
            if (null != _WildcardBoundsOpt) (_WildcardBoundsOpt as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _QUESTION)  list.add(_QUESTION);
            if(null != _WildcardBoundsOpt)  list.add(_WildcardBoundsOpt);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitWildcard(this);
            if (checkChildren)
            {
                _QUESTION.accept(v);
                if (null != _WildcardBoundsOpt) _WildcardBoundsOpt!.accept(v);
            }
            v.endVisitWildcard(this);
        }
    }

/**
 *<em>
*<li>Rule 47:  PackageName ::= identifier
 *</em>
 *<p>
 *<b>
*<li>Rule 48:  PackageName ::= PackageName . identifier
 *</b>
 */
class PackageName extends Ast implements IPackageName
    {
         late IPackageName _PackageName;
         late AstToken _DOT;
         late identifier _identifier;

         IPackageName getPackageName(){ return _PackageName; }
         void setPackageName(IPackageName _PackageName){ this._PackageName = _PackageName; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }

        PackageName(IToken leftIToken, IToken rightIToken,
                    IPackageName _PackageName,
                    AstToken _DOT,
                    identifier _identifier)
            :super(leftIToken, rightIToken)

        {
            this._PackageName = _PackageName;
            (_PackageName as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _PackageName)  list.add(_PackageName);
            if(null != _DOT)  list.add(_DOT);
            if(null != _identifier)  list.add(_identifier);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitPackageName(this);
            if (checkChildren)
            {
                _PackageName.accept(v);
                _DOT.accept(v);
                _identifier.accept(v);
            }
            v.endVisitPackageName(this);
        }
    }

/**
 *<em>
*<li>Rule 49:  ExpressionName ::= identifier
 *</em>
 *<p>
 *<b>
*<li>Rule 50:  ExpressionName ::= AmbiguousName . identifier
 *</b>
 */
class ExpressionName extends Ast implements IExpressionName
    {
         late IAmbiguousName _AmbiguousName;
         late AstToken _DOT;
         late identifier _identifier;

         IAmbiguousName getAmbiguousName(){ return _AmbiguousName; }
         void setAmbiguousName(IAmbiguousName _AmbiguousName){ this._AmbiguousName = _AmbiguousName; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }

        ExpressionName(IToken leftIToken, IToken rightIToken,
                       IAmbiguousName _AmbiguousName,
                       AstToken _DOT,
                       identifier _identifier)
            :super(leftIToken, rightIToken)

        {
            this._AmbiguousName = _AmbiguousName;
            (_AmbiguousName as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _AmbiguousName)  list.add(_AmbiguousName);
            if(null != _DOT)  list.add(_DOT);
            if(null != _identifier)  list.add(_identifier);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitExpressionName(this);
            if (checkChildren)
            {
                _AmbiguousName.accept(v);
                _DOT.accept(v);
                _identifier.accept(v);
            }
            v.endVisitExpressionName(this);
        }
    }

/**
 *<em>
*<li>Rule 51:  MethodName ::= identifier
 *</em>
 *<p>
 *<b>
*<li>Rule 52:  MethodName ::= AmbiguousName . identifier
 *</b>
 */
class MethodName extends Ast implements IMethodName
    {
         late IAmbiguousName _AmbiguousName;
         late AstToken _DOT;
         late identifier _identifier;

         IAmbiguousName getAmbiguousName(){ return _AmbiguousName; }
         void setAmbiguousName(IAmbiguousName _AmbiguousName){ this._AmbiguousName = _AmbiguousName; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }

        MethodName(IToken leftIToken, IToken rightIToken,
                   IAmbiguousName _AmbiguousName,
                   AstToken _DOT,
                   identifier _identifier)
            :super(leftIToken, rightIToken)

        {
            this._AmbiguousName = _AmbiguousName;
            (_AmbiguousName as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _AmbiguousName)  list.add(_AmbiguousName);
            if(null != _DOT)  list.add(_DOT);
            if(null != _identifier)  list.add(_identifier);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitMethodName(this);
            if (checkChildren)
            {
                _AmbiguousName.accept(v);
                _DOT.accept(v);
                _identifier.accept(v);
            }
            v.endVisitMethodName(this);
        }
    }

/**
 *<em>
*<li>Rule 53:  PackageOrTypeName ::= identifier
 *</em>
 *<p>
 *<b>
*<li>Rule 54:  PackageOrTypeName ::= PackageOrTypeName . identifier
 *</b>
 */
class PackageOrTypeName extends Ast implements IPackageOrTypeName
    {
         late IPackageOrTypeName _PackageOrTypeName;
         late AstToken _DOT;
         late identifier _identifier;

         IPackageOrTypeName getPackageOrTypeName(){ return _PackageOrTypeName; }
         void setPackageOrTypeName(IPackageOrTypeName _PackageOrTypeName){ this._PackageOrTypeName = _PackageOrTypeName; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }

        PackageOrTypeName(IToken leftIToken, IToken rightIToken,
                          IPackageOrTypeName _PackageOrTypeName,
                          AstToken _DOT,
                          identifier _identifier)
            :super(leftIToken, rightIToken)

        {
            this._PackageOrTypeName = _PackageOrTypeName;
            (_PackageOrTypeName as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _PackageOrTypeName)  list.add(_PackageOrTypeName);
            if(null != _DOT)  list.add(_DOT);
            if(null != _identifier)  list.add(_identifier);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitPackageOrTypeName(this);
            if (checkChildren)
            {
                _PackageOrTypeName.accept(v);
                _DOT.accept(v);
                _identifier.accept(v);
            }
            v.endVisitPackageOrTypeName(this);
        }
    }

/**
 *<em>
*<li>Rule 55:  AmbiguousName ::= identifier
 *</em>
 *<p>
 *<b>
*<li>Rule 56:  AmbiguousName ::= AmbiguousName . identifier
 *</b>
 */
class AmbiguousName extends Ast implements IAmbiguousName
    {
         late IAmbiguousName _AmbiguousName;
         late AstToken _DOT;
         late identifier _identifier;

         IAmbiguousName getAmbiguousName(){ return _AmbiguousName; }
         void setAmbiguousName(IAmbiguousName _AmbiguousName){ this._AmbiguousName = _AmbiguousName; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }

        AmbiguousName(IToken leftIToken, IToken rightIToken,
                      IAmbiguousName _AmbiguousName,
                      AstToken _DOT,
                      identifier _identifier)
            :super(leftIToken, rightIToken)

        {
            this._AmbiguousName = _AmbiguousName;
            (_AmbiguousName as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _AmbiguousName)  list.add(_AmbiguousName);
            if(null != _DOT)  list.add(_DOT);
            if(null != _identifier)  list.add(_identifier);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitAmbiguousName(this);
            if (checkChildren)
            {
                _AmbiguousName.accept(v);
                _DOT.accept(v);
                _identifier.accept(v);
            }
            v.endVisitAmbiguousName(this);
        }
    }

/**
 *<b>
*<li>Rule 57:  CompilationUnit ::= PackageDeclarationopt ImportDeclarationsopt TypeDeclarationsopt
 *</b>
 */
class CompilationUnit extends Ast implements ICompilationUnit
    {
         late PackageDeclaration? _PackageDeclarationopt;
         late IImportDeclarationsopt? _ImportDeclarationsopt;
         late ITypeDeclarationsopt? _TypeDeclarationsopt;

        /**
         * The value returned by <b>getPackageDeclarationopt</b> may be <b>null</b>
         */
         PackageDeclaration ?  getPackageDeclarationopt(){ return _PackageDeclarationopt; }
         void setPackageDeclarationopt(PackageDeclaration _PackageDeclarationopt){ this._PackageDeclarationopt = _PackageDeclarationopt; }
        /**
         * The value returned by <b>getImportDeclarationsopt</b> may be <b>null</b>
         */
         IImportDeclarationsopt ?  getImportDeclarationsopt(){ return _ImportDeclarationsopt; }
         void setImportDeclarationsopt(IImportDeclarationsopt _ImportDeclarationsopt){ this._ImportDeclarationsopt = _ImportDeclarationsopt; }
        /**
         * The value returned by <b>getTypeDeclarationsopt</b> may be <b>null</b>
         */
         ITypeDeclarationsopt ?  getTypeDeclarationsopt(){ return _TypeDeclarationsopt; }
         void setTypeDeclarationsopt(ITypeDeclarationsopt _TypeDeclarationsopt){ this._TypeDeclarationsopt = _TypeDeclarationsopt; }

        CompilationUnit(IToken leftIToken, IToken rightIToken,
                        PackageDeclaration? _PackageDeclarationopt,
                        IImportDeclarationsopt? _ImportDeclarationsopt,
                        ITypeDeclarationsopt? _TypeDeclarationsopt)
            :super(leftIToken, rightIToken)

        {
            this._PackageDeclarationopt = _PackageDeclarationopt;
            if (null != _PackageDeclarationopt) (_PackageDeclarationopt as Ast).setParent(this);
            this._ImportDeclarationsopt = _ImportDeclarationsopt;
            if (null != _ImportDeclarationsopt) (_ImportDeclarationsopt as Ast).setParent(this);
            this._TypeDeclarationsopt = _TypeDeclarationsopt;
            if (null != _TypeDeclarationsopt) (_TypeDeclarationsopt as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _PackageDeclarationopt)  list.add(_PackageDeclarationopt);
            if(null != _ImportDeclarationsopt)  list.add(_ImportDeclarationsopt);
            if(null != _TypeDeclarationsopt)  list.add(_TypeDeclarationsopt);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitCompilationUnit(this);
            if (checkChildren)
            {
                if (null != _PackageDeclarationopt) _PackageDeclarationopt!.accept(v);
                if (null != _ImportDeclarationsopt) _ImportDeclarationsopt!.accept(v);
                if (null != _TypeDeclarationsopt) _TypeDeclarationsopt!.accept(v);
            }
            v.endVisitCompilationUnit(this);
        }
    }

/**
 *<em>
*<li>Rule 58:  ImportDeclarations ::= ImportDeclaration
 *</em>
 *<p>
 *<b>
*<li>Rule 59:  ImportDeclarations ::= ImportDeclarations ImportDeclaration
 *</b>
 */
class ImportDeclarations extends Ast implements IImportDeclarations
    {
         late IImportDeclarations _ImportDeclarations;
         late IImportDeclaration _ImportDeclaration;

         IImportDeclarations getImportDeclarations(){ return _ImportDeclarations; }
         void setImportDeclarations(IImportDeclarations _ImportDeclarations){ this._ImportDeclarations = _ImportDeclarations; }
         IImportDeclaration getImportDeclaration(){ return _ImportDeclaration; }
         void setImportDeclaration(IImportDeclaration _ImportDeclaration){ this._ImportDeclaration = _ImportDeclaration; }

        ImportDeclarations(IToken leftIToken, IToken rightIToken,
                           IImportDeclarations _ImportDeclarations,
                           IImportDeclaration _ImportDeclaration)
            :super(leftIToken, rightIToken)

        {
            this._ImportDeclarations = _ImportDeclarations;
            (_ImportDeclarations as Ast).setParent(this);
            this._ImportDeclaration = _ImportDeclaration;
            (_ImportDeclaration as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ImportDeclarations)  list.add(_ImportDeclarations);
            if(null != _ImportDeclaration)  list.add(_ImportDeclaration);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitImportDeclarations(this);
            if (checkChildren)
            {
                _ImportDeclarations.accept(v);
                _ImportDeclaration.accept(v);
            }
            v.endVisitImportDeclarations(this);
        }
    }

/**
 *<em>
*<li>Rule 60:  TypeDeclarations ::= TypeDeclaration
 *</em>
 *<p>
 *<b>
*<li>Rule 61:  TypeDeclarations ::= TypeDeclarations TypeDeclaration
 *</b>
 */
class TypeDeclarations extends Ast implements ITypeDeclarations
    {
         late ITypeDeclarations _TypeDeclarations;
         late ITypeDeclaration _TypeDeclaration;

         ITypeDeclarations getTypeDeclarations(){ return _TypeDeclarations; }
         void setTypeDeclarations(ITypeDeclarations _TypeDeclarations){ this._TypeDeclarations = _TypeDeclarations; }
         ITypeDeclaration getTypeDeclaration(){ return _TypeDeclaration; }
         void setTypeDeclaration(ITypeDeclaration _TypeDeclaration){ this._TypeDeclaration = _TypeDeclaration; }

        TypeDeclarations(IToken leftIToken, IToken rightIToken,
                         ITypeDeclarations _TypeDeclarations,
                         ITypeDeclaration _TypeDeclaration)
            :super(leftIToken, rightIToken)

        {
            this._TypeDeclarations = _TypeDeclarations;
            (_TypeDeclarations as Ast).setParent(this);
            this._TypeDeclaration = _TypeDeclaration;
            (_TypeDeclaration as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _TypeDeclarations)  list.add(_TypeDeclarations);
            if(null != _TypeDeclaration)  list.add(_TypeDeclaration);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitTypeDeclarations(this);
            if (checkChildren)
            {
                _TypeDeclarations.accept(v);
                _TypeDeclaration.accept(v);
            }
            v.endVisitTypeDeclarations(this);
        }
    }

/**
 *<b>
*<li>Rule 62:  PackageDeclaration ::= Annotationsopt package PackageName ;
 *</b>
 */
class PackageDeclaration extends Ast implements IPackageDeclaration
    {
         late IAnnotationsopt? _Annotationsopt;
         late AstToken _package;
         late IPackageName _PackageName;
         late AstToken _SEMICOLON;

        /**
         * The value returned by <b>getAnnotationsopt</b> may be <b>null</b>
         */
         IAnnotationsopt ?  getAnnotationsopt(){ return _Annotationsopt; }
         void setAnnotationsopt(IAnnotationsopt _Annotationsopt){ this._Annotationsopt = _Annotationsopt; }
         AstToken getpackage(){ return _package; }
         void setpackage(AstToken _package){ this._package = _package; }
         IPackageName getPackageName(){ return _PackageName; }
         void setPackageName(IPackageName _PackageName){ this._PackageName = _PackageName; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        PackageDeclaration(IToken leftIToken, IToken rightIToken,
                           IAnnotationsopt? _Annotationsopt,
                           AstToken _package,
                           IPackageName _PackageName,
                           AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._Annotationsopt = _Annotationsopt;
            if (null != _Annotationsopt) (_Annotationsopt as Ast).setParent(this);
            this._package = _package;
            (_package as Ast).setParent(this);
            this._PackageName = _PackageName;
            (_PackageName as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _Annotationsopt)  list.add(_Annotationsopt);
            if(null != _package)  list.add(_package);
            if(null != _PackageName)  list.add(_PackageName);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitPackageDeclaration(this);
            if (checkChildren)
            {
                if (null != _Annotationsopt) _Annotationsopt!.accept(v);
                _package.accept(v);
                _PackageName.accept(v);
                _SEMICOLON.accept(v);
            }
            v.endVisitPackageDeclaration(this);
        }
    }

/**
 *<b>
*<li>Rule 67:  SingleTypeImportDeclaration ::= import TypeName ;
 *</b>
 */
class SingleTypeImportDeclaration extends Ast implements ISingleTypeImportDeclaration
    {
         late AstToken _import;
         late ITypeName _TypeName;
         late AstToken _SEMICOLON;

         AstToken getimport(){ return _import; }
         void setimport(AstToken _import){ this._import = _import; }
         ITypeName getTypeName(){ return _TypeName; }
         void setTypeName(ITypeName _TypeName){ this._TypeName = _TypeName; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        SingleTypeImportDeclaration(IToken leftIToken, IToken rightIToken,
                                    AstToken _import,
                                    ITypeName _TypeName,
                                    AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._import = _import;
            (_import as Ast).setParent(this);
            this._TypeName = _TypeName;
            (_TypeName as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _import)  list.add(_import);
            if(null != _TypeName)  list.add(_TypeName);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitSingleTypeImportDeclaration(this);
            if (checkChildren)
            {
                _import.accept(v);
                _TypeName.accept(v);
                _SEMICOLON.accept(v);
            }
            v.endVisitSingleTypeImportDeclaration(this);
        }
    }

/**
 *<b>
*<li>Rule 68:  TypeImportOnDemandDeclaration ::= import PackageOrTypeName . * ;
 *</b>
 */
class TypeImportOnDemandDeclaration extends Ast implements ITypeImportOnDemandDeclaration
    {
         late AstToken _import;
         late IPackageOrTypeName _PackageOrTypeName;
         late AstToken _DOT;
         late AstToken _MULTIPLY;
         late AstToken _SEMICOLON;

         AstToken getimport(){ return _import; }
         void setimport(AstToken _import){ this._import = _import; }
         IPackageOrTypeName getPackageOrTypeName(){ return _PackageOrTypeName; }
         void setPackageOrTypeName(IPackageOrTypeName _PackageOrTypeName){ this._PackageOrTypeName = _PackageOrTypeName; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
         AstToken getMULTIPLY(){ return _MULTIPLY; }
         void setMULTIPLY(AstToken _MULTIPLY){ this._MULTIPLY = _MULTIPLY; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        TypeImportOnDemandDeclaration(IToken leftIToken, IToken rightIToken,
                                      AstToken _import,
                                      IPackageOrTypeName _PackageOrTypeName,
                                      AstToken _DOT,
                                      AstToken _MULTIPLY,
                                      AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._import = _import;
            (_import as Ast).setParent(this);
            this._PackageOrTypeName = _PackageOrTypeName;
            (_PackageOrTypeName as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._MULTIPLY = _MULTIPLY;
            (_MULTIPLY as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _import)  list.add(_import);
            if(null != _PackageOrTypeName)  list.add(_PackageOrTypeName);
            if(null != _DOT)  list.add(_DOT);
            if(null != _MULTIPLY)  list.add(_MULTIPLY);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitTypeImportOnDemandDeclaration(this);
            if (checkChildren)
            {
                _import.accept(v);
                _PackageOrTypeName.accept(v);
                _DOT.accept(v);
                _MULTIPLY.accept(v);
                _SEMICOLON.accept(v);
            }
            v.endVisitTypeImportOnDemandDeclaration(this);
        }
    }

/**
 *<b>
*<li>Rule 69:  SingleStaticImportDeclaration ::= import static TypeName . identifier ;
 *</b>
 */
class SingleStaticImportDeclaration extends Ast implements ISingleStaticImportDeclaration
    {
         late AstToken _import;
         late AstToken _static;
         late ITypeName _TypeName;
         late AstToken _DOT;
         late identifier _identifier;
         late AstToken _SEMICOLON;

         AstToken getimport(){ return _import; }
         void setimport(AstToken _import){ this._import = _import; }
         AstToken getstatic(){ return _static; }
         void setstatic(AstToken _static){ this._static = _static; }
         ITypeName getTypeName(){ return _TypeName; }
         void setTypeName(ITypeName _TypeName){ this._TypeName = _TypeName; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        SingleStaticImportDeclaration(IToken leftIToken, IToken rightIToken,
                                      AstToken _import,
                                      AstToken _static,
                                      ITypeName _TypeName,
                                      AstToken _DOT,
                                      identifier _identifier,
                                      AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._import = _import;
            (_import as Ast).setParent(this);
            this._static = _static;
            (_static as Ast).setParent(this);
            this._TypeName = _TypeName;
            (_TypeName as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _import)  list.add(_import);
            if(null != _static)  list.add(_static);
            if(null != _TypeName)  list.add(_TypeName);
            if(null != _DOT)  list.add(_DOT);
            if(null != _identifier)  list.add(_identifier);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitSingleStaticImportDeclaration(this);
            if (checkChildren)
            {
                _import.accept(v);
                _static.accept(v);
                _TypeName.accept(v);
                _DOT.accept(v);
                _identifier.accept(v);
                _SEMICOLON.accept(v);
            }
            v.endVisitSingleStaticImportDeclaration(this);
        }
    }

/**
 *<b>
*<li>Rule 70:  StaticImportOnDemandDeclaration ::= import static TypeName . * ;
 *</b>
 */
class StaticImportOnDemandDeclaration extends Ast implements IStaticImportOnDemandDeclaration
    {
         late AstToken _import;
         late AstToken _static;
         late ITypeName _TypeName;
         late AstToken _DOT;
         late AstToken _MULTIPLY;
         late AstToken _SEMICOLON;

         AstToken getimport(){ return _import; }
         void setimport(AstToken _import){ this._import = _import; }
         AstToken getstatic(){ return _static; }
         void setstatic(AstToken _static){ this._static = _static; }
         ITypeName getTypeName(){ return _TypeName; }
         void setTypeName(ITypeName _TypeName){ this._TypeName = _TypeName; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
         AstToken getMULTIPLY(){ return _MULTIPLY; }
         void setMULTIPLY(AstToken _MULTIPLY){ this._MULTIPLY = _MULTIPLY; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        StaticImportOnDemandDeclaration(IToken leftIToken, IToken rightIToken,
                                        AstToken _import,
                                        AstToken _static,
                                        ITypeName _TypeName,
                                        AstToken _DOT,
                                        AstToken _MULTIPLY,
                                        AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._import = _import;
            (_import as Ast).setParent(this);
            this._static = _static;
            (_static as Ast).setParent(this);
            this._TypeName = _TypeName;
            (_TypeName as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._MULTIPLY = _MULTIPLY;
            (_MULTIPLY as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _import)  list.add(_import);
            if(null != _static)  list.add(_static);
            if(null != _TypeName)  list.add(_TypeName);
            if(null != _DOT)  list.add(_DOT);
            if(null != _MULTIPLY)  list.add(_MULTIPLY);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitStaticImportOnDemandDeclaration(this);
            if (checkChildren)
            {
                _import.accept(v);
                _static.accept(v);
                _TypeName.accept(v);
                _DOT.accept(v);
                _MULTIPLY.accept(v);
                _SEMICOLON.accept(v);
            }
            v.endVisitStaticImportOnDemandDeclaration(this);
        }
    }

/**
 *<em>
*<li>Rule 71:  TypeDeclaration ::= ClassDeclaration
*<li>Rule 72:  TypeDeclaration ::= InterfaceDeclaration
 *</em>
 *<p>
 *<b>
*<li>Rule 73:  TypeDeclaration ::= ;
 *</b>
 */
class TypeDeclaration extends AstToken implements ITypeDeclaration
    {
         IToken getSEMICOLON(){ return leftIToken; }

    TypeDeclaration(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitTypeDeclaration(this);
            v.endVisitTypeDeclaration(this);
        }
    }

/**
 *<b>
*<li>Rule 76:  NormalClassDeclaration ::= ClassModifiersopt class identifier TypeParametersopt Superopt Interfacesopt ClassBody
 *</b>
 */
class NormalClassDeclaration extends Ast implements INormalClassDeclaration
    {
         late IClassModifiersopt? _ClassModifiersopt;
         late AstToken _class;
         late identifier _identifier;
         late TypeParameters? _TypeParametersopt;
         late Super? _Superopt;
         late Interfaces? _Interfacesopt;
         late ClassBody _ClassBody;

        /**
         * The value returned by <b>getClassModifiersopt</b> may be <b>null</b>
         */
         IClassModifiersopt ?  getClassModifiersopt(){ return _ClassModifiersopt; }
         void setClassModifiersopt(IClassModifiersopt _ClassModifiersopt){ this._ClassModifiersopt = _ClassModifiersopt; }
         AstToken getclass(){ return _class; }
         void setclass(AstToken _class){ this._class = _class; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }
        /**
         * The value returned by <b>getTypeParametersopt</b> may be <b>null</b>
         */
         TypeParameters ?  getTypeParametersopt(){ return _TypeParametersopt; }
         void setTypeParametersopt(TypeParameters _TypeParametersopt){ this._TypeParametersopt = _TypeParametersopt; }
        /**
         * The value returned by <b>getSuperopt</b> may be <b>null</b>
         */
         Super ?  getSuperopt(){ return _Superopt; }
         void setSuperopt(Super _Superopt){ this._Superopt = _Superopt; }
        /**
         * The value returned by <b>getInterfacesopt</b> may be <b>null</b>
         */
         Interfaces ?  getInterfacesopt(){ return _Interfacesopt; }
         void setInterfacesopt(Interfaces _Interfacesopt){ this._Interfacesopt = _Interfacesopt; }
         ClassBody getClassBody(){ return _ClassBody; }
         void setClassBody(ClassBody _ClassBody){ this._ClassBody = _ClassBody; }

        NormalClassDeclaration(IToken leftIToken, IToken rightIToken,
                               IClassModifiersopt? _ClassModifiersopt,
                               AstToken _class,
                               identifier _identifier,
                               TypeParameters? _TypeParametersopt,
                               Super? _Superopt,
                               Interfaces? _Interfacesopt,
                               ClassBody _ClassBody)
            :super(leftIToken, rightIToken)

        {
            this._ClassModifiersopt = _ClassModifiersopt;
            if (null != _ClassModifiersopt) (_ClassModifiersopt as Ast).setParent(this);
            this._class = _class;
            (_class as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            this._TypeParametersopt = _TypeParametersopt;
            if (null != _TypeParametersopt) (_TypeParametersopt as Ast).setParent(this);
            this._Superopt = _Superopt;
            if (null != _Superopt) (_Superopt as Ast).setParent(this);
            this._Interfacesopt = _Interfacesopt;
            if (null != _Interfacesopt) (_Interfacesopt as Ast).setParent(this);
            this._ClassBody = _ClassBody;
            (_ClassBody as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ClassModifiersopt)  list.add(_ClassModifiersopt);
            if(null != _class)  list.add(_class);
            if(null != _identifier)  list.add(_identifier);
            if(null != _TypeParametersopt)  list.add(_TypeParametersopt);
            if(null != _Superopt)  list.add(_Superopt);
            if(null != _Interfacesopt)  list.add(_Interfacesopt);
            if(null != _ClassBody)  list.add(_ClassBody);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitNormalClassDeclaration(this);
            if (checkChildren)
            {
                if (null != _ClassModifiersopt) _ClassModifiersopt!.accept(v);
                _class.accept(v);
                _identifier.accept(v);
                if (null != _TypeParametersopt) _TypeParametersopt!.accept(v);
                if (null != _Superopt) _Superopt!.accept(v);
                if (null != _Interfacesopt) _Interfacesopt!.accept(v);
                _ClassBody.accept(v);
            }
            v.endVisitNormalClassDeclaration(this);
        }
    }

/**
 *<em>
*<li>Rule 77:  ClassModifiers ::= ClassModifier
 *</em>
 *<p>
 *<b>
*<li>Rule 78:  ClassModifiers ::= ClassModifiers ClassModifier
 *</b>
 */
class ClassModifiers extends Ast implements IClassModifiers
    {
         late IClassModifiers _ClassModifiers;
         late IClassModifier _ClassModifier;

         IClassModifiers getClassModifiers(){ return _ClassModifiers; }
         void setClassModifiers(IClassModifiers _ClassModifiers){ this._ClassModifiers = _ClassModifiers; }
         IClassModifier getClassModifier(){ return _ClassModifier; }
         void setClassModifier(IClassModifier _ClassModifier){ this._ClassModifier = _ClassModifier; }

        ClassModifiers(IToken leftIToken, IToken rightIToken,
                       IClassModifiers _ClassModifiers,
                       IClassModifier _ClassModifier)
            :super(leftIToken, rightIToken)

        {
            this._ClassModifiers = _ClassModifiers;
            (_ClassModifiers as Ast).setParent(this);
            this._ClassModifier = _ClassModifier;
            (_ClassModifier as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ClassModifiers)  list.add(_ClassModifiers);
            if(null != _ClassModifier)  list.add(_ClassModifier);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitClassModifiers(this);
            if (checkChildren)
            {
                _ClassModifiers.accept(v);
                _ClassModifier.accept(v);
            }
            v.endVisitClassModifiers(this);
        }
    }

/**
 *<b>
*<li>Rule 87:  TypeParameters ::= < TypeParameterList >
 *</b>
 */
class TypeParameters extends Ast implements ITypeParameters
    {
         late AstToken _LESS;
         late ITypeParameterList _TypeParameterList;
         late AstToken _GREATER;

         AstToken getLESS(){ return _LESS; }
         void setLESS(AstToken _LESS){ this._LESS = _LESS; }
         ITypeParameterList getTypeParameterList(){ return _TypeParameterList; }
         void setTypeParameterList(ITypeParameterList _TypeParameterList){ this._TypeParameterList = _TypeParameterList; }
         AstToken getGREATER(){ return _GREATER; }
         void setGREATER(AstToken _GREATER){ this._GREATER = _GREATER; }

        TypeParameters(IToken leftIToken, IToken rightIToken,
                       AstToken _LESS,
                       ITypeParameterList _TypeParameterList,
                       AstToken _GREATER)
            :super(leftIToken, rightIToken)

        {
            this._LESS = _LESS;
            (_LESS as Ast).setParent(this);
            this._TypeParameterList = _TypeParameterList;
            (_TypeParameterList as Ast).setParent(this);
            this._GREATER = _GREATER;
            (_GREATER as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _LESS)  list.add(_LESS);
            if(null != _TypeParameterList)  list.add(_TypeParameterList);
            if(null != _GREATER)  list.add(_GREATER);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitTypeParameters(this);
            if (checkChildren)
            {
                _LESS.accept(v);
                _TypeParameterList.accept(v);
                _GREATER.accept(v);
            }
            v.endVisitTypeParameters(this);
        }
    }

/**
 *<em>
*<li>Rule 88:  TypeParameterList ::= TypeParameter
 *</em>
 *<p>
 *<b>
*<li>Rule 89:  TypeParameterList ::= TypeParameterList , TypeParameter
 *</b>
 */
class TypeParameterList extends Ast implements ITypeParameterList
    {
         late ITypeParameterList _TypeParameterList;
         late AstToken _COMMA;
         late TypeParameter _TypeParameter;

         ITypeParameterList getTypeParameterList(){ return _TypeParameterList; }
         void setTypeParameterList(ITypeParameterList _TypeParameterList){ this._TypeParameterList = _TypeParameterList; }
         AstToken getCOMMA(){ return _COMMA; }
         void setCOMMA(AstToken _COMMA){ this._COMMA = _COMMA; }
         TypeParameter getTypeParameter(){ return _TypeParameter; }
         void setTypeParameter(TypeParameter _TypeParameter){ this._TypeParameter = _TypeParameter; }

        TypeParameterList(IToken leftIToken, IToken rightIToken,
                          ITypeParameterList _TypeParameterList,
                          AstToken _COMMA,
                          TypeParameter _TypeParameter)
            :super(leftIToken, rightIToken)

        {
            this._TypeParameterList = _TypeParameterList;
            (_TypeParameterList as Ast).setParent(this);
            this._COMMA = _COMMA;
            (_COMMA as Ast).setParent(this);
            this._TypeParameter = _TypeParameter;
            (_TypeParameter as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _TypeParameterList)  list.add(_TypeParameterList);
            if(null != _COMMA)  list.add(_COMMA);
            if(null != _TypeParameter)  list.add(_TypeParameter);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitTypeParameterList(this);
            if (checkChildren)
            {
                _TypeParameterList.accept(v);
                _COMMA.accept(v);
                _TypeParameter.accept(v);
            }
            v.endVisitTypeParameterList(this);
        }
    }

/**
 *<b>
*<li>Rule 90:  Super ::= extends ClassType
 *</b>
 */
class Super extends Ast implements ISuper
    {
         late AstToken _extends;
         late ClassType _ClassType;

         AstToken getextends(){ return _extends; }
         void setextends(AstToken _extends){ this._extends = _extends; }
         ClassType getClassType(){ return _ClassType; }
         void setClassType(ClassType _ClassType){ this._ClassType = _ClassType; }

        Super(IToken leftIToken, IToken rightIToken,
              AstToken _extends,
              ClassType _ClassType)
            :super(leftIToken, rightIToken)

        {
            this._extends = _extends;
            (_extends as Ast).setParent(this);
            this._ClassType = _ClassType;
            (_ClassType as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _extends)  list.add(_extends);
            if(null != _ClassType)  list.add(_ClassType);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitSuper(this);
            if (checkChildren)
            {
                _extends.accept(v);
                _ClassType.accept(v);
            }
            v.endVisitSuper(this);
        }
    }

/**
 *<b>
*<li>Rule 91:  Interfaces ::= implements InterfaceTypeList
 *</b>
 */
class Interfaces extends Ast implements IInterfaces
    {
         late AstToken _implements;
         late IInterfaceTypeList _InterfaceTypeList;

         AstToken getimplements(){ return _implements; }
         void setimplements(AstToken _implements){ this._implements = _implements; }
         IInterfaceTypeList getInterfaceTypeList(){ return _InterfaceTypeList; }
         void setInterfaceTypeList(IInterfaceTypeList _InterfaceTypeList){ this._InterfaceTypeList = _InterfaceTypeList; }

        Interfaces(IToken leftIToken, IToken rightIToken,
                   AstToken _implements,
                   IInterfaceTypeList _InterfaceTypeList)
            :super(leftIToken, rightIToken)

        {
            this._implements = _implements;
            (_implements as Ast).setParent(this);
            this._InterfaceTypeList = _InterfaceTypeList;
            (_InterfaceTypeList as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _implements)  list.add(_implements);
            if(null != _InterfaceTypeList)  list.add(_InterfaceTypeList);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitInterfaces(this);
            if (checkChildren)
            {
                _implements.accept(v);
                _InterfaceTypeList.accept(v);
            }
            v.endVisitInterfaces(this);
        }
    }

/**
 *<em>
*<li>Rule 92:  InterfaceTypeList ::= InterfaceType
 *</em>
 *<p>
 *<b>
*<li>Rule 93:  InterfaceTypeList ::= InterfaceTypeList , InterfaceType
 *</b>
 */
class InterfaceTypeList extends Ast implements IInterfaceTypeList
    {
         late IInterfaceTypeList _InterfaceTypeList;
         late AstToken _COMMA;
         late InterfaceType _InterfaceType;

         IInterfaceTypeList getInterfaceTypeList(){ return _InterfaceTypeList; }
         void setInterfaceTypeList(IInterfaceTypeList _InterfaceTypeList){ this._InterfaceTypeList = _InterfaceTypeList; }
         AstToken getCOMMA(){ return _COMMA; }
         void setCOMMA(AstToken _COMMA){ this._COMMA = _COMMA; }
         InterfaceType getInterfaceType(){ return _InterfaceType; }
         void setInterfaceType(InterfaceType _InterfaceType){ this._InterfaceType = _InterfaceType; }

        InterfaceTypeList(IToken leftIToken, IToken rightIToken,
                          IInterfaceTypeList _InterfaceTypeList,
                          AstToken _COMMA,
                          InterfaceType _InterfaceType)
            :super(leftIToken, rightIToken)

        {
            this._InterfaceTypeList = _InterfaceTypeList;
            (_InterfaceTypeList as Ast).setParent(this);
            this._COMMA = _COMMA;
            (_COMMA as Ast).setParent(this);
            this._InterfaceType = _InterfaceType;
            (_InterfaceType as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _InterfaceTypeList)  list.add(_InterfaceTypeList);
            if(null != _COMMA)  list.add(_COMMA);
            if(null != _InterfaceType)  list.add(_InterfaceType);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitInterfaceTypeList(this);
            if (checkChildren)
            {
                _InterfaceTypeList.accept(v);
                _COMMA.accept(v);
                _InterfaceType.accept(v);
            }
            v.endVisitInterfaceTypeList(this);
        }
    }

/**
 *<b>
*<li>Rule 94:  ClassBody ::= { ClassBodyDeclarationsopt }
 *</b>
 */
class ClassBody extends Ast implements IClassBody
    {
         late AstToken _LBRACE;
         late IClassBodyDeclarationsopt? _ClassBodyDeclarationsopt;
         late AstToken _RBRACE;

         AstToken getLBRACE(){ return _LBRACE; }
         void setLBRACE(AstToken _LBRACE){ this._LBRACE = _LBRACE; }
        /**
         * The value returned by <b>getClassBodyDeclarationsopt</b> may be <b>null</b>
         */
         IClassBodyDeclarationsopt ?  getClassBodyDeclarationsopt(){ return _ClassBodyDeclarationsopt; }
         void setClassBodyDeclarationsopt(IClassBodyDeclarationsopt _ClassBodyDeclarationsopt){ this._ClassBodyDeclarationsopt = _ClassBodyDeclarationsopt; }
         AstToken getRBRACE(){ return _RBRACE; }
         void setRBRACE(AstToken _RBRACE){ this._RBRACE = _RBRACE; }

        ClassBody(IToken leftIToken, IToken rightIToken,
                  AstToken _LBRACE,
                  IClassBodyDeclarationsopt? _ClassBodyDeclarationsopt,
                  AstToken _RBRACE)
            :super(leftIToken, rightIToken)

        {
            this._LBRACE = _LBRACE;
            (_LBRACE as Ast).setParent(this);
            this._ClassBodyDeclarationsopt = _ClassBodyDeclarationsopt;
            if (null != _ClassBodyDeclarationsopt) (_ClassBodyDeclarationsopt as Ast).setParent(this);
            this._RBRACE = _RBRACE;
            (_RBRACE as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _LBRACE)  list.add(_LBRACE);
            if(null != _ClassBodyDeclarationsopt)  list.add(_ClassBodyDeclarationsopt);
            if(null != _RBRACE)  list.add(_RBRACE);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitClassBody(this);
            if (checkChildren)
            {
                _LBRACE.accept(v);
                if (null != _ClassBodyDeclarationsopt) _ClassBodyDeclarationsopt!.accept(v);
                _RBRACE.accept(v);
            }
            v.endVisitClassBody(this);
        }
    }

/**
 *<em>
*<li>Rule 95:  ClassBodyDeclarations ::= ClassBodyDeclaration
 *</em>
 *<p>
 *<b>
*<li>Rule 96:  ClassBodyDeclarations ::= ClassBodyDeclarations ClassBodyDeclaration
 *</b>
 */
class ClassBodyDeclarations extends Ast implements IClassBodyDeclarations
    {
         late IClassBodyDeclarations _ClassBodyDeclarations;
         late IClassBodyDeclaration _ClassBodyDeclaration;

         IClassBodyDeclarations getClassBodyDeclarations(){ return _ClassBodyDeclarations; }
         void setClassBodyDeclarations(IClassBodyDeclarations _ClassBodyDeclarations){ this._ClassBodyDeclarations = _ClassBodyDeclarations; }
         IClassBodyDeclaration getClassBodyDeclaration(){ return _ClassBodyDeclaration; }
         void setClassBodyDeclaration(IClassBodyDeclaration _ClassBodyDeclaration){ this._ClassBodyDeclaration = _ClassBodyDeclaration; }

        ClassBodyDeclarations(IToken leftIToken, IToken rightIToken,
                              IClassBodyDeclarations _ClassBodyDeclarations,
                              IClassBodyDeclaration _ClassBodyDeclaration)
            :super(leftIToken, rightIToken)

        {
            this._ClassBodyDeclarations = _ClassBodyDeclarations;
            (_ClassBodyDeclarations as Ast).setParent(this);
            this._ClassBodyDeclaration = _ClassBodyDeclaration;
            (_ClassBodyDeclaration as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ClassBodyDeclarations)  list.add(_ClassBodyDeclarations);
            if(null != _ClassBodyDeclaration)  list.add(_ClassBodyDeclaration);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitClassBodyDeclarations(this);
            if (checkChildren)
            {
                _ClassBodyDeclarations.accept(v);
                _ClassBodyDeclaration.accept(v);
            }
            v.endVisitClassBodyDeclarations(this);
        }
    }

/**
 *<em>
*<li>Rule 101:  ClassMemberDeclaration ::= FieldDeclaration
*<li>Rule 102:  ClassMemberDeclaration ::= MethodDeclaration
*<li>Rule 103:  ClassMemberDeclaration ::= ClassDeclaration
*<li>Rule 104:  ClassMemberDeclaration ::= InterfaceDeclaration
 *</em>
 *<p>
 *<b>
*<li>Rule 105:  ClassMemberDeclaration ::= ;
 *</b>
 */
class ClassMemberDeclaration extends AstToken implements IClassMemberDeclaration
    {
         IToken getSEMICOLON(){ return leftIToken; }

    ClassMemberDeclaration(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitClassMemberDeclaration(this);
            v.endVisitClassMemberDeclaration(this);
        }
    }

/**
 *<b>
*<li>Rule 106:  FieldDeclaration ::= FieldModifiersopt Type VariableDeclarators ;
 *</b>
 */
class FieldDeclaration extends Ast implements IFieldDeclaration
    {
         late IFieldModifiersopt? _FieldModifiersopt;
         late IType _Type;
         late IVariableDeclarators _VariableDeclarators;
         late AstToken _SEMICOLON;

        /**
         * The value returned by <b>getFieldModifiersopt</b> may be <b>null</b>
         */
         IFieldModifiersopt ?  getFieldModifiersopt(){ return _FieldModifiersopt; }
         void setFieldModifiersopt(IFieldModifiersopt _FieldModifiersopt){ this._FieldModifiersopt = _FieldModifiersopt; }
         IType getType(){ return _Type; }
         void setType(IType _Type){ this._Type = _Type; }
         IVariableDeclarators getVariableDeclarators(){ return _VariableDeclarators; }
         void setVariableDeclarators(IVariableDeclarators _VariableDeclarators){ this._VariableDeclarators = _VariableDeclarators; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        FieldDeclaration(IToken leftIToken, IToken rightIToken,
                         IFieldModifiersopt? _FieldModifiersopt,
                         IType _Type,
                         IVariableDeclarators _VariableDeclarators,
                         AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._FieldModifiersopt = _FieldModifiersopt;
            if (null != _FieldModifiersopt) (_FieldModifiersopt as Ast).setParent(this);
            this._Type = _Type;
            (_Type as Ast).setParent(this);
            this._VariableDeclarators = _VariableDeclarators;
            (_VariableDeclarators as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _FieldModifiersopt)  list.add(_FieldModifiersopt);
            if(null != _Type)  list.add(_Type);
            if(null != _VariableDeclarators)  list.add(_VariableDeclarators);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitFieldDeclaration(this);
            if (checkChildren)
            {
                if (null != _FieldModifiersopt) _FieldModifiersopt!.accept(v);
                _Type.accept(v);
                _VariableDeclarators.accept(v);
                _SEMICOLON.accept(v);
            }
            v.endVisitFieldDeclaration(this);
        }
    }

/**
 *<em>
*<li>Rule 107:  VariableDeclarators ::= VariableDeclarator
 *</em>
 *<p>
 *<b>
*<li>Rule 108:  VariableDeclarators ::= VariableDeclarators , VariableDeclarator
 *</b>
 */
class VariableDeclarators extends Ast implements IVariableDeclarators
    {
         late IVariableDeclarators _VariableDeclarators;
         late AstToken _COMMA;
         late IVariableDeclarator _VariableDeclarator;

         IVariableDeclarators getVariableDeclarators(){ return _VariableDeclarators; }
         void setVariableDeclarators(IVariableDeclarators _VariableDeclarators){ this._VariableDeclarators = _VariableDeclarators; }
         AstToken getCOMMA(){ return _COMMA; }
         void setCOMMA(AstToken _COMMA){ this._COMMA = _COMMA; }
         IVariableDeclarator getVariableDeclarator(){ return _VariableDeclarator; }
         void setVariableDeclarator(IVariableDeclarator _VariableDeclarator){ this._VariableDeclarator = _VariableDeclarator; }

        VariableDeclarators(IToken leftIToken, IToken rightIToken,
                            IVariableDeclarators _VariableDeclarators,
                            AstToken _COMMA,
                            IVariableDeclarator _VariableDeclarator)
            :super(leftIToken, rightIToken)

        {
            this._VariableDeclarators = _VariableDeclarators;
            (_VariableDeclarators as Ast).setParent(this);
            this._COMMA = _COMMA;
            (_COMMA as Ast).setParent(this);
            this._VariableDeclarator = _VariableDeclarator;
            (_VariableDeclarator as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _VariableDeclarators)  list.add(_VariableDeclarators);
            if(null != _COMMA)  list.add(_COMMA);
            if(null != _VariableDeclarator)  list.add(_VariableDeclarator);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitVariableDeclarators(this);
            if (checkChildren)
            {
                _VariableDeclarators.accept(v);
                _COMMA.accept(v);
                _VariableDeclarator.accept(v);
            }
            v.endVisitVariableDeclarators(this);
        }
    }

/**
 *<em>
*<li>Rule 109:  VariableDeclarator ::= VariableDeclaratorId
 *</em>
 *<p>
 *<b>
*<li>Rule 110:  VariableDeclarator ::= VariableDeclaratorId = VariableInitializer
 *</b>
 */
class VariableDeclarator extends Ast implements IVariableDeclarator
    {
         late IVariableDeclaratorId _VariableDeclaratorId;
         late AstToken _EQUAL;
         late IVariableInitializer _VariableInitializer;

         IVariableDeclaratorId getVariableDeclaratorId(){ return _VariableDeclaratorId; }
         void setVariableDeclaratorId(IVariableDeclaratorId _VariableDeclaratorId){ this._VariableDeclaratorId = _VariableDeclaratorId; }
         AstToken getEQUAL(){ return _EQUAL; }
         void setEQUAL(AstToken _EQUAL){ this._EQUAL = _EQUAL; }
         IVariableInitializer getVariableInitializer(){ return _VariableInitializer; }
         void setVariableInitializer(IVariableInitializer _VariableInitializer){ this._VariableInitializer = _VariableInitializer; }

        VariableDeclarator(IToken leftIToken, IToken rightIToken,
                           IVariableDeclaratorId _VariableDeclaratorId,
                           AstToken _EQUAL,
                           IVariableInitializer _VariableInitializer)
            :super(leftIToken, rightIToken)

        {
            this._VariableDeclaratorId = _VariableDeclaratorId;
            (_VariableDeclaratorId as Ast).setParent(this);
            this._EQUAL = _EQUAL;
            (_EQUAL as Ast).setParent(this);
            this._VariableInitializer = _VariableInitializer;
            (_VariableInitializer as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _VariableDeclaratorId)  list.add(_VariableDeclaratorId);
            if(null != _EQUAL)  list.add(_EQUAL);
            if(null != _VariableInitializer)  list.add(_VariableInitializer);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitVariableDeclarator(this);
            if (checkChildren)
            {
                _VariableDeclaratorId.accept(v);
                _EQUAL.accept(v);
                _VariableInitializer.accept(v);
            }
            v.endVisitVariableDeclarator(this);
        }
    }

/**
 *<em>
*<li>Rule 111:  VariableDeclaratorId ::= identifier
 *</em>
 *<p>
 *<b>
*<li>Rule 112:  VariableDeclaratorId ::= VariableDeclaratorId [ ]
 *</b>
 */
class VariableDeclaratorId extends Ast implements IVariableDeclaratorId
    {
         late IVariableDeclaratorId _VariableDeclaratorId;
         late AstToken _LBRACKET;
         late AstToken _RBRACKET;

         IVariableDeclaratorId getVariableDeclaratorId(){ return _VariableDeclaratorId; }
         void setVariableDeclaratorId(IVariableDeclaratorId _VariableDeclaratorId){ this._VariableDeclaratorId = _VariableDeclaratorId; }
         AstToken getLBRACKET(){ return _LBRACKET; }
         void setLBRACKET(AstToken _LBRACKET){ this._LBRACKET = _LBRACKET; }
         AstToken getRBRACKET(){ return _RBRACKET; }
         void setRBRACKET(AstToken _RBRACKET){ this._RBRACKET = _RBRACKET; }

        VariableDeclaratorId(IToken leftIToken, IToken rightIToken,
                             IVariableDeclaratorId _VariableDeclaratorId,
                             AstToken _LBRACKET,
                             AstToken _RBRACKET)
            :super(leftIToken, rightIToken)

        {
            this._VariableDeclaratorId = _VariableDeclaratorId;
            (_VariableDeclaratorId as Ast).setParent(this);
            this._LBRACKET = _LBRACKET;
            (_LBRACKET as Ast).setParent(this);
            this._RBRACKET = _RBRACKET;
            (_RBRACKET as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _VariableDeclaratorId)  list.add(_VariableDeclaratorId);
            if(null != _LBRACKET)  list.add(_LBRACKET);
            if(null != _RBRACKET)  list.add(_RBRACKET);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitVariableDeclaratorId(this);
            if (checkChildren)
            {
                _VariableDeclaratorId.accept(v);
                _LBRACKET.accept(v);
                _RBRACKET.accept(v);
            }
            v.endVisitVariableDeclaratorId(this);
        }
    }

/**
 *<em>
*<li>Rule 115:  FieldModifiers ::= FieldModifier
 *</em>
 *<p>
 *<b>
*<li>Rule 116:  FieldModifiers ::= FieldModifiers FieldModifier
 *</b>
 */
class FieldModifiers extends Ast implements IFieldModifiers
    {
         late IFieldModifiers _FieldModifiers;
         late IFieldModifier _FieldModifier;

         IFieldModifiers getFieldModifiers(){ return _FieldModifiers; }
         void setFieldModifiers(IFieldModifiers _FieldModifiers){ this._FieldModifiers = _FieldModifiers; }
         IFieldModifier getFieldModifier(){ return _FieldModifier; }
         void setFieldModifier(IFieldModifier _FieldModifier){ this._FieldModifier = _FieldModifier; }

        FieldModifiers(IToken leftIToken, IToken rightIToken,
                       IFieldModifiers _FieldModifiers,
                       IFieldModifier _FieldModifier)
            :super(leftIToken, rightIToken)

        {
            this._FieldModifiers = _FieldModifiers;
            (_FieldModifiers as Ast).setParent(this);
            this._FieldModifier = _FieldModifier;
            (_FieldModifier as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _FieldModifiers)  list.add(_FieldModifiers);
            if(null != _FieldModifier)  list.add(_FieldModifier);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitFieldModifiers(this);
            if (checkChildren)
            {
                _FieldModifiers.accept(v);
                _FieldModifier.accept(v);
            }
            v.endVisitFieldModifiers(this);
        }
    }

/**
 *<b>
*<li>Rule 125:  MethodDeclaration ::= MethodHeader MethodBody
 *</b>
 */
class MethodDeclaration extends Ast implements IMethodDeclaration
    {
         late MethodHeader _MethodHeader;
         late IMethodBody _MethodBody;

         MethodHeader getMethodHeader(){ return _MethodHeader; }
         void setMethodHeader(MethodHeader _MethodHeader){ this._MethodHeader = _MethodHeader; }
         IMethodBody getMethodBody(){ return _MethodBody; }
         void setMethodBody(IMethodBody _MethodBody){ this._MethodBody = _MethodBody; }

        MethodDeclaration(IToken leftIToken, IToken rightIToken,
                          MethodHeader _MethodHeader,
                          IMethodBody _MethodBody)
            :super(leftIToken, rightIToken)

        {
            this._MethodHeader = _MethodHeader;
            (_MethodHeader as Ast).setParent(this);
            this._MethodBody = _MethodBody;
            (_MethodBody as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _MethodHeader)  list.add(_MethodHeader);
            if(null != _MethodBody)  list.add(_MethodBody);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitMethodDeclaration(this);
            if (checkChildren)
            {
                _MethodHeader.accept(v);
                _MethodBody.accept(v);
            }
            v.endVisitMethodDeclaration(this);
        }
    }

/**
 *<b>
*<li>Rule 126:  MethodHeader ::= MethodModifiersopt TypeParametersopt ResultType MethodDeclarator Throwsopt
 *</b>
 */
class MethodHeader extends Ast implements IMethodHeader
    {
         late IMethodModifiersopt? _MethodModifiersopt;
         late TypeParameters? _TypeParametersopt;
         late IResultType _ResultType;
         late IMethodDeclarator _MethodDeclarator;
         late Throws? _Throwsopt;

        /**
         * The value returned by <b>getMethodModifiersopt</b> may be <b>null</b>
         */
         IMethodModifiersopt ?  getMethodModifiersopt(){ return _MethodModifiersopt; }
         void setMethodModifiersopt(IMethodModifiersopt _MethodModifiersopt){ this._MethodModifiersopt = _MethodModifiersopt; }
        /**
         * The value returned by <b>getTypeParametersopt</b> may be <b>null</b>
         */
         TypeParameters ?  getTypeParametersopt(){ return _TypeParametersopt; }
         void setTypeParametersopt(TypeParameters _TypeParametersopt){ this._TypeParametersopt = _TypeParametersopt; }
         IResultType getResultType(){ return _ResultType; }
         void setResultType(IResultType _ResultType){ this._ResultType = _ResultType; }
         IMethodDeclarator getMethodDeclarator(){ return _MethodDeclarator; }
         void setMethodDeclarator(IMethodDeclarator _MethodDeclarator){ this._MethodDeclarator = _MethodDeclarator; }
        /**
         * The value returned by <b>getThrowsopt</b> may be <b>null</b>
         */
         Throws ?  getThrowsopt(){ return _Throwsopt; }
         void setThrowsopt(Throws _Throwsopt){ this._Throwsopt = _Throwsopt; }

        MethodHeader(IToken leftIToken, IToken rightIToken,
                     IMethodModifiersopt? _MethodModifiersopt,
                     TypeParameters? _TypeParametersopt,
                     IResultType _ResultType,
                     IMethodDeclarator _MethodDeclarator,
                     Throws? _Throwsopt)
            :super(leftIToken, rightIToken)

        {
            this._MethodModifiersopt = _MethodModifiersopt;
            if (null != _MethodModifiersopt) (_MethodModifiersopt as Ast).setParent(this);
            this._TypeParametersopt = _TypeParametersopt;
            if (null != _TypeParametersopt) (_TypeParametersopt as Ast).setParent(this);
            this._ResultType = _ResultType;
            (_ResultType as Ast).setParent(this);
            this._MethodDeclarator = _MethodDeclarator;
            (_MethodDeclarator as Ast).setParent(this);
            this._Throwsopt = _Throwsopt;
            if (null != _Throwsopt) (_Throwsopt as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _MethodModifiersopt)  list.add(_MethodModifiersopt);
            if(null != _TypeParametersopt)  list.add(_TypeParametersopt);
            if(null != _ResultType)  list.add(_ResultType);
            if(null != _MethodDeclarator)  list.add(_MethodDeclarator);
            if(null != _Throwsopt)  list.add(_Throwsopt);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitMethodHeader(this);
            if (checkChildren)
            {
                if (null != _MethodModifiersopt) _MethodModifiersopt!.accept(v);
                if (null != _TypeParametersopt) _TypeParametersopt!.accept(v);
                _ResultType.accept(v);
                _MethodDeclarator.accept(v);
                if (null != _Throwsopt) _Throwsopt!.accept(v);
            }
            v.endVisitMethodHeader(this);
        }
    }

/**
 *<em>
*<li>Rule 127:  ResultType ::= Type
 *</em>
 *<p>
 *<b>
*<li>Rule 128:  ResultType ::= void
 *</b>
 */
class ResultType extends AstToken implements IResultType
    {
         IToken getvoid(){ return leftIToken; }

    ResultType(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitResultType(this);
            v.endVisitResultType(this);
        }
    }

/**
 *<em>
*<li>Rule 131:  FormalParameterList ::= LastFormalParameter
 *</em>
 *<p>
 *<b>
*<li>Rule 132:  FormalParameterList ::= FormalParameters , LastFormalParameter
 *</b>
 */
class FormalParameterList extends Ast implements IFormalParameterList
    {
         late IFormalParameters _FormalParameters;
         late AstToken _COMMA;
         late LastFormalParameter _LastFormalParameter;

         IFormalParameters getFormalParameters(){ return _FormalParameters; }
         void setFormalParameters(IFormalParameters _FormalParameters){ this._FormalParameters = _FormalParameters; }
         AstToken getCOMMA(){ return _COMMA; }
         void setCOMMA(AstToken _COMMA){ this._COMMA = _COMMA; }
         LastFormalParameter getLastFormalParameter(){ return _LastFormalParameter; }
         void setLastFormalParameter(LastFormalParameter _LastFormalParameter){ this._LastFormalParameter = _LastFormalParameter; }

        FormalParameterList(IToken leftIToken, IToken rightIToken,
                            IFormalParameters _FormalParameters,
                            AstToken _COMMA,
                            LastFormalParameter _LastFormalParameter)
            :super(leftIToken, rightIToken)

        {
            this._FormalParameters = _FormalParameters;
            (_FormalParameters as Ast).setParent(this);
            this._COMMA = _COMMA;
            (_COMMA as Ast).setParent(this);
            this._LastFormalParameter = _LastFormalParameter;
            (_LastFormalParameter as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _FormalParameters)  list.add(_FormalParameters);
            if(null != _COMMA)  list.add(_COMMA);
            if(null != _LastFormalParameter)  list.add(_LastFormalParameter);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitFormalParameterList(this);
            if (checkChildren)
            {
                _FormalParameters.accept(v);
                _COMMA.accept(v);
                _LastFormalParameter.accept(v);
            }
            v.endVisitFormalParameterList(this);
        }
    }

/**
 *<em>
*<li>Rule 133:  FormalParameters ::= FormalParameter
 *</em>
 *<p>
 *<b>
*<li>Rule 134:  FormalParameters ::= FormalParameters , FormalParameter
 *</b>
 */
class FormalParameters extends Ast implements IFormalParameters
    {
         late IFormalParameters _FormalParameters;
         late AstToken _COMMA;
         late FormalParameter _FormalParameter;

         IFormalParameters getFormalParameters(){ return _FormalParameters; }
         void setFormalParameters(IFormalParameters _FormalParameters){ this._FormalParameters = _FormalParameters; }
         AstToken getCOMMA(){ return _COMMA; }
         void setCOMMA(AstToken _COMMA){ this._COMMA = _COMMA; }
         FormalParameter getFormalParameter(){ return _FormalParameter; }
         void setFormalParameter(FormalParameter _FormalParameter){ this._FormalParameter = _FormalParameter; }

        FormalParameters(IToken leftIToken, IToken rightIToken,
                         IFormalParameters _FormalParameters,
                         AstToken _COMMA,
                         FormalParameter _FormalParameter)
            :super(leftIToken, rightIToken)

        {
            this._FormalParameters = _FormalParameters;
            (_FormalParameters as Ast).setParent(this);
            this._COMMA = _COMMA;
            (_COMMA as Ast).setParent(this);
            this._FormalParameter = _FormalParameter;
            (_FormalParameter as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _FormalParameters)  list.add(_FormalParameters);
            if(null != _COMMA)  list.add(_COMMA);
            if(null != _FormalParameter)  list.add(_FormalParameter);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitFormalParameters(this);
            if (checkChildren)
            {
                _FormalParameters.accept(v);
                _COMMA.accept(v);
                _FormalParameter.accept(v);
            }
            v.endVisitFormalParameters(this);
        }
    }

/**
 *<b>
*<li>Rule 135:  FormalParameter ::= VariableModifiersopt Type VariableDeclaratorId
 *</b>
 */
class FormalParameter extends Ast implements IFormalParameter
    {
         late IVariableModifiersopt? _VariableModifiersopt;
         late IType _Type;
         late IVariableDeclaratorId _VariableDeclaratorId;

        /**
         * The value returned by <b>getVariableModifiersopt</b> may be <b>null</b>
         */
         IVariableModifiersopt ?  getVariableModifiersopt(){ return _VariableModifiersopt; }
         void setVariableModifiersopt(IVariableModifiersopt _VariableModifiersopt){ this._VariableModifiersopt = _VariableModifiersopt; }
         IType getType(){ return _Type; }
         void setType(IType _Type){ this._Type = _Type; }
         IVariableDeclaratorId getVariableDeclaratorId(){ return _VariableDeclaratorId; }
         void setVariableDeclaratorId(IVariableDeclaratorId _VariableDeclaratorId){ this._VariableDeclaratorId = _VariableDeclaratorId; }

        FormalParameter(IToken leftIToken, IToken rightIToken,
                        IVariableModifiersopt? _VariableModifiersopt,
                        IType _Type,
                        IVariableDeclaratorId _VariableDeclaratorId)
            :super(leftIToken, rightIToken)

        {
            this._VariableModifiersopt = _VariableModifiersopt;
            if (null != _VariableModifiersopt) (_VariableModifiersopt as Ast).setParent(this);
            this._Type = _Type;
            (_Type as Ast).setParent(this);
            this._VariableDeclaratorId = _VariableDeclaratorId;
            (_VariableDeclaratorId as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _VariableModifiersopt)  list.add(_VariableModifiersopt);
            if(null != _Type)  list.add(_Type);
            if(null != _VariableDeclaratorId)  list.add(_VariableDeclaratorId);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitFormalParameter(this);
            if (checkChildren)
            {
                if (null != _VariableModifiersopt) _VariableModifiersopt!.accept(v);
                _Type.accept(v);
                _VariableDeclaratorId.accept(v);
            }
            v.endVisitFormalParameter(this);
        }
    }

/**
 *<em>
*<li>Rule 136:  VariableModifiers ::= VariableModifier
 *</em>
 *<p>
 *<b>
*<li>Rule 137:  VariableModifiers ::= VariableModifiers VariableModifier
 *</b>
 */
class VariableModifiers extends Ast implements IVariableModifiers
    {
         late IVariableModifiers _VariableModifiers;
         late IVariableModifier _VariableModifier;

         IVariableModifiers getVariableModifiers(){ return _VariableModifiers; }
         void setVariableModifiers(IVariableModifiers _VariableModifiers){ this._VariableModifiers = _VariableModifiers; }
         IVariableModifier getVariableModifier(){ return _VariableModifier; }
         void setVariableModifier(IVariableModifier _VariableModifier){ this._VariableModifier = _VariableModifier; }

        VariableModifiers(IToken leftIToken, IToken rightIToken,
                          IVariableModifiers _VariableModifiers,
                          IVariableModifier _VariableModifier)
            :super(leftIToken, rightIToken)

        {
            this._VariableModifiers = _VariableModifiers;
            (_VariableModifiers as Ast).setParent(this);
            this._VariableModifier = _VariableModifier;
            (_VariableModifier as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _VariableModifiers)  list.add(_VariableModifiers);
            if(null != _VariableModifier)  list.add(_VariableModifier);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitVariableModifiers(this);
            if (checkChildren)
            {
                _VariableModifiers.accept(v);
                _VariableModifier.accept(v);
            }
            v.endVisitVariableModifiers(this);
        }
    }

/**
 *<em>
*<li>Rule 139:  VariableModifier ::= Annotations
 *</em>
 *<p>
 *<b>
*<li>Rule 138:  VariableModifier ::= final
 *</b>
 */
class VariableModifier extends AstToken implements IVariableModifier
    {
         IToken getfinal(){ return leftIToken; }

    VariableModifier(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitVariableModifier(this);
            v.endVisitVariableModifier(this);
        }
    }

/**
 *<b>
*<li>Rule 140:  LastFormalParameter ::= VariableModifiersopt Type ...opt VariableDeclaratorId
 *</b>
 */
class LastFormalParameter extends Ast implements ILastFormalParameter
    {
         late IVariableModifiersopt? _VariableModifiersopt;
         late IType _Type;
         late Ellipsisopt? _Ellipsisopt;
         late IVariableDeclaratorId _VariableDeclaratorId;

        /**
         * The value returned by <b>getVariableModifiersopt</b> may be <b>null</b>
         */
         IVariableModifiersopt ?  getVariableModifiersopt(){ return _VariableModifiersopt; }
         void setVariableModifiersopt(IVariableModifiersopt _VariableModifiersopt){ this._VariableModifiersopt = _VariableModifiersopt; }
         IType getType(){ return _Type; }
         void setType(IType _Type){ this._Type = _Type; }
        /**
         * The value returned by <b>getEllipsisopt</b> may be <b>null</b>
         */
         Ellipsisopt ?  getEllipsisopt(){ return _Ellipsisopt; }
         void setEllipsisopt(Ellipsisopt _Ellipsisopt){ this._Ellipsisopt = _Ellipsisopt; }
         IVariableDeclaratorId getVariableDeclaratorId(){ return _VariableDeclaratorId; }
         void setVariableDeclaratorId(IVariableDeclaratorId _VariableDeclaratorId){ this._VariableDeclaratorId = _VariableDeclaratorId; }

        LastFormalParameter(IToken leftIToken, IToken rightIToken,
                            IVariableModifiersopt? _VariableModifiersopt,
                            IType _Type,
                            Ellipsisopt? _Ellipsisopt,
                            IVariableDeclaratorId _VariableDeclaratorId)
            :super(leftIToken, rightIToken)

        {
            this._VariableModifiersopt = _VariableModifiersopt;
            if (null != _VariableModifiersopt) (_VariableModifiersopt as Ast).setParent(this);
            this._Type = _Type;
            (_Type as Ast).setParent(this);
            this._Ellipsisopt = _Ellipsisopt;
            if (null != _Ellipsisopt) (_Ellipsisopt as Ast).setParent(this);
            this._VariableDeclaratorId = _VariableDeclaratorId;
            (_VariableDeclaratorId as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _VariableModifiersopt)  list.add(_VariableModifiersopt);
            if(null != _Type)  list.add(_Type);
            if(null != _Ellipsisopt)  list.add(_Ellipsisopt);
            if(null != _VariableDeclaratorId)  list.add(_VariableDeclaratorId);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitLastFormalParameter(this);
            if (checkChildren)
            {
                if (null != _VariableModifiersopt) _VariableModifiersopt!.accept(v);
                _Type.accept(v);
                if (null != _Ellipsisopt) _Ellipsisopt!.accept(v);
                _VariableDeclaratorId.accept(v);
            }
            v.endVisitLastFormalParameter(this);
        }
    }

/**
 *<em>
*<li>Rule 141:  MethodModifiers ::= MethodModifier
 *</em>
 *<p>
 *<b>
*<li>Rule 142:  MethodModifiers ::= MethodModifiers MethodModifier
 *</b>
 */
class MethodModifiers extends Ast implements IMethodModifiers
    {
         late IMethodModifiers _MethodModifiers;
         late IMethodModifier _MethodModifier;

         IMethodModifiers getMethodModifiers(){ return _MethodModifiers; }
         void setMethodModifiers(IMethodModifiers _MethodModifiers){ this._MethodModifiers = _MethodModifiers; }
         IMethodModifier getMethodModifier(){ return _MethodModifier; }
         void setMethodModifier(IMethodModifier _MethodModifier){ this._MethodModifier = _MethodModifier; }

        MethodModifiers(IToken leftIToken, IToken rightIToken,
                        IMethodModifiers _MethodModifiers,
                        IMethodModifier _MethodModifier)
            :super(leftIToken, rightIToken)

        {
            this._MethodModifiers = _MethodModifiers;
            (_MethodModifiers as Ast).setParent(this);
            this._MethodModifier = _MethodModifier;
            (_MethodModifier as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _MethodModifiers)  list.add(_MethodModifiers);
            if(null != _MethodModifier)  list.add(_MethodModifier);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitMethodModifiers(this);
            if (checkChildren)
            {
                _MethodModifiers.accept(v);
                _MethodModifier.accept(v);
            }
            v.endVisitMethodModifiers(this);
        }
    }

/**
 *<b>
*<li>Rule 153:  Throws ::= throws ExceptionTypeList
 *</b>
 */
class Throws extends Ast implements IThrows
    {
         late AstToken _throws;
         late IExceptionTypeList _ExceptionTypeList;

         AstToken getthrows(){ return _throws; }
         void setthrows(AstToken _throws){ this._throws = _throws; }
         IExceptionTypeList getExceptionTypeList(){ return _ExceptionTypeList; }
         void setExceptionTypeList(IExceptionTypeList _ExceptionTypeList){ this._ExceptionTypeList = _ExceptionTypeList; }

        Throws(IToken leftIToken, IToken rightIToken,
               AstToken _throws,
               IExceptionTypeList _ExceptionTypeList)
            :super(leftIToken, rightIToken)

        {
            this._throws = _throws;
            (_throws as Ast).setParent(this);
            this._ExceptionTypeList = _ExceptionTypeList;
            (_ExceptionTypeList as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _throws)  list.add(_throws);
            if(null != _ExceptionTypeList)  list.add(_ExceptionTypeList);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitThrows(this);
            if (checkChildren)
            {
                _throws.accept(v);
                _ExceptionTypeList.accept(v);
            }
            v.endVisitThrows(this);
        }
    }

/**
 *<em>
*<li>Rule 154:  ExceptionTypeList ::= ExceptionType
 *</em>
 *<p>
 *<b>
*<li>Rule 155:  ExceptionTypeList ::= ExceptionTypeList , ExceptionType
 *</b>
 */
class ExceptionTypeList extends Ast implements IExceptionTypeList
    {
         late IExceptionTypeList _ExceptionTypeList;
         late AstToken _COMMA;
         late IExceptionType _ExceptionType;

         IExceptionTypeList getExceptionTypeList(){ return _ExceptionTypeList; }
         void setExceptionTypeList(IExceptionTypeList _ExceptionTypeList){ this._ExceptionTypeList = _ExceptionTypeList; }
         AstToken getCOMMA(){ return _COMMA; }
         void setCOMMA(AstToken _COMMA){ this._COMMA = _COMMA; }
         IExceptionType getExceptionType(){ return _ExceptionType; }
         void setExceptionType(IExceptionType _ExceptionType){ this._ExceptionType = _ExceptionType; }

        ExceptionTypeList(IToken leftIToken, IToken rightIToken,
                          IExceptionTypeList _ExceptionTypeList,
                          AstToken _COMMA,
                          IExceptionType _ExceptionType)
            :super(leftIToken, rightIToken)

        {
            this._ExceptionTypeList = _ExceptionTypeList;
            (_ExceptionTypeList as Ast).setParent(this);
            this._COMMA = _COMMA;
            (_COMMA as Ast).setParent(this);
            this._ExceptionType = _ExceptionType;
            (_ExceptionType as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ExceptionTypeList)  list.add(_ExceptionTypeList);
            if(null != _COMMA)  list.add(_COMMA);
            if(null != _ExceptionType)  list.add(_ExceptionType);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitExceptionTypeList(this);
            if (checkChildren)
            {
                _ExceptionTypeList.accept(v);
                _COMMA.accept(v);
                _ExceptionType.accept(v);
            }
            v.endVisitExceptionTypeList(this);
        }
    }

/**
 *<em>
*<li>Rule 158:  MethodBody ::= Block
 *</em>
 *<p>
 *<b>
*<li>Rule 159:  MethodBody ::= ;
 *</b>
 */
class MethodBody extends AstToken implements IMethodBody
    {
         IToken getSEMICOLON(){ return leftIToken; }

    MethodBody(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitMethodBody(this);
            v.endVisitMethodBody(this);
        }
    }

/**
 *<b>
*<li>Rule 161:  StaticInitializer ::= static Block
 *</b>
 */
class StaticInitializer extends Ast implements IStaticInitializer
    {
         late AstToken _static;
         late Block _Block;

         AstToken getstatic(){ return _static; }
         void setstatic(AstToken _static){ this._static = _static; }
         Block getBlock(){ return _Block; }
         void setBlock(Block _Block){ this._Block = _Block; }

        StaticInitializer(IToken leftIToken, IToken rightIToken,
                          AstToken _static,
                          Block _Block)
            :super(leftIToken, rightIToken)

        {
            this._static = _static;
            (_static as Ast).setParent(this);
            this._Block = _Block;
            (_Block as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _static)  list.add(_static);
            if(null != _Block)  list.add(_Block);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitStaticInitializer(this);
            if (checkChildren)
            {
                _static.accept(v);
                _Block.accept(v);
            }
            v.endVisitStaticInitializer(this);
        }
    }

/**
 *<b>
*<li>Rule 162:  ConstructorDeclaration ::= ConstructorModifiersopt ConstructorDeclarator Throwsopt ConstructorBody
 *</b>
 */
class ConstructorDeclaration extends Ast implements IConstructorDeclaration
    {
         late IConstructorModifiersopt? _ConstructorModifiersopt;
         late ConstructorDeclarator _ConstructorDeclarator;
         late Throws? _Throwsopt;
         late ConstructorBody _ConstructorBody;

        /**
         * The value returned by <b>getConstructorModifiersopt</b> may be <b>null</b>
         */
         IConstructorModifiersopt ?  getConstructorModifiersopt(){ return _ConstructorModifiersopt; }
         void setConstructorModifiersopt(IConstructorModifiersopt _ConstructorModifiersopt){ this._ConstructorModifiersopt = _ConstructorModifiersopt; }
         ConstructorDeclarator getConstructorDeclarator(){ return _ConstructorDeclarator; }
         void setConstructorDeclarator(ConstructorDeclarator _ConstructorDeclarator){ this._ConstructorDeclarator = _ConstructorDeclarator; }
        /**
         * The value returned by <b>getThrowsopt</b> may be <b>null</b>
         */
         Throws ?  getThrowsopt(){ return _Throwsopt; }
         void setThrowsopt(Throws _Throwsopt){ this._Throwsopt = _Throwsopt; }
         ConstructorBody getConstructorBody(){ return _ConstructorBody; }
         void setConstructorBody(ConstructorBody _ConstructorBody){ this._ConstructorBody = _ConstructorBody; }

        ConstructorDeclaration(IToken leftIToken, IToken rightIToken,
                               IConstructorModifiersopt? _ConstructorModifiersopt,
                               ConstructorDeclarator _ConstructorDeclarator,
                               Throws? _Throwsopt,
                               ConstructorBody _ConstructorBody)
            :super(leftIToken, rightIToken)

        {
            this._ConstructorModifiersopt = _ConstructorModifiersopt;
            if (null != _ConstructorModifiersopt) (_ConstructorModifiersopt as Ast).setParent(this);
            this._ConstructorDeclarator = _ConstructorDeclarator;
            (_ConstructorDeclarator as Ast).setParent(this);
            this._Throwsopt = _Throwsopt;
            if (null != _Throwsopt) (_Throwsopt as Ast).setParent(this);
            this._ConstructorBody = _ConstructorBody;
            (_ConstructorBody as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ConstructorModifiersopt)  list.add(_ConstructorModifiersopt);
            if(null != _ConstructorDeclarator)  list.add(_ConstructorDeclarator);
            if(null != _Throwsopt)  list.add(_Throwsopt);
            if(null != _ConstructorBody)  list.add(_ConstructorBody);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitConstructorDeclaration(this);
            if (checkChildren)
            {
                if (null != _ConstructorModifiersopt) _ConstructorModifiersopt!.accept(v);
                _ConstructorDeclarator.accept(v);
                if (null != _Throwsopt) _Throwsopt!.accept(v);
                _ConstructorBody.accept(v);
            }
            v.endVisitConstructorDeclaration(this);
        }
    }

/**
 *<b>
*<li>Rule 163:  ConstructorDeclarator ::= TypeParametersopt SimpleTypeName ( FormalParameterListopt )
 *</b>
 */
class ConstructorDeclarator extends Ast implements IConstructorDeclarator
    {
         late TypeParameters? _TypeParametersopt;
         late identifier _SimpleTypeName;
         late AstToken _LPAREN;
         late IFormalParameterListopt? _FormalParameterListopt;
         late AstToken _RPAREN;

        /**
         * The value returned by <b>getTypeParametersopt</b> may be <b>null</b>
         */
         TypeParameters ?  getTypeParametersopt(){ return _TypeParametersopt; }
         void setTypeParametersopt(TypeParameters _TypeParametersopt){ this._TypeParametersopt = _TypeParametersopt; }
         identifier getSimpleTypeName(){ return _SimpleTypeName; }
         void setSimpleTypeName(identifier _SimpleTypeName){ this._SimpleTypeName = _SimpleTypeName; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
        /**
         * The value returned by <b>getFormalParameterListopt</b> may be <b>null</b>
         */
         IFormalParameterListopt ?  getFormalParameterListopt(){ return _FormalParameterListopt; }
         void setFormalParameterListopt(IFormalParameterListopt _FormalParameterListopt){ this._FormalParameterListopt = _FormalParameterListopt; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }

        ConstructorDeclarator(IToken leftIToken, IToken rightIToken,
                              TypeParameters? _TypeParametersopt,
                              identifier _SimpleTypeName,
                              AstToken _LPAREN,
                              IFormalParameterListopt? _FormalParameterListopt,
                              AstToken _RPAREN)
            :super(leftIToken, rightIToken)

        {
            this._TypeParametersopt = _TypeParametersopt;
            if (null != _TypeParametersopt) (_TypeParametersopt as Ast).setParent(this);
            this._SimpleTypeName = _SimpleTypeName;
            (_SimpleTypeName as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._FormalParameterListopt = _FormalParameterListopt;
            if (null != _FormalParameterListopt) (_FormalParameterListopt as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _TypeParametersopt)  list.add(_TypeParametersopt);
            if(null != _SimpleTypeName)  list.add(_SimpleTypeName);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _FormalParameterListopt)  list.add(_FormalParameterListopt);
            if(null != _RPAREN)  list.add(_RPAREN);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitConstructorDeclarator(this);
            if (checkChildren)
            {
                if (null != _TypeParametersopt) _TypeParametersopt!.accept(v);
                _SimpleTypeName.accept(v);
                _LPAREN.accept(v);
                if (null != _FormalParameterListopt) _FormalParameterListopt!.accept(v);
                _RPAREN.accept(v);
            }
            v.endVisitConstructorDeclarator(this);
        }
    }

/**
 *<em>
*<li>Rule 165:  ConstructorModifiers ::= ConstructorModifier
 *</em>
 *<p>
 *<b>
*<li>Rule 166:  ConstructorModifiers ::= ConstructorModifiers ConstructorModifier
 *</b>
 */
class ConstructorModifiers extends Ast implements IConstructorModifiers
    {
         late IConstructorModifiers _ConstructorModifiers;
         late IConstructorModifier _ConstructorModifier;

         IConstructorModifiers getConstructorModifiers(){ return _ConstructorModifiers; }
         void setConstructorModifiers(IConstructorModifiers _ConstructorModifiers){ this._ConstructorModifiers = _ConstructorModifiers; }
         IConstructorModifier getConstructorModifier(){ return _ConstructorModifier; }
         void setConstructorModifier(IConstructorModifier _ConstructorModifier){ this._ConstructorModifier = _ConstructorModifier; }

        ConstructorModifiers(IToken leftIToken, IToken rightIToken,
                             IConstructorModifiers _ConstructorModifiers,
                             IConstructorModifier _ConstructorModifier)
            :super(leftIToken, rightIToken)

        {
            this._ConstructorModifiers = _ConstructorModifiers;
            (_ConstructorModifiers as Ast).setParent(this);
            this._ConstructorModifier = _ConstructorModifier;
            (_ConstructorModifier as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ConstructorModifiers)  list.add(_ConstructorModifiers);
            if(null != _ConstructorModifier)  list.add(_ConstructorModifier);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitConstructorModifiers(this);
            if (checkChildren)
            {
                _ConstructorModifiers.accept(v);
                _ConstructorModifier.accept(v);
            }
            v.endVisitConstructorModifiers(this);
        }
    }

/**
 *<b>
*<li>Rule 171:  ConstructorBody ::= { ExplicitConstructorInvocationopt BlockStatementsopt }
 *</b>
 */
class ConstructorBody extends Ast implements IConstructorBody
    {
         late AstToken _LBRACE;
         late IExplicitConstructorInvocationopt? _ExplicitConstructorInvocationopt;
         late IBlockStatementsopt? _BlockStatementsopt;
         late AstToken _RBRACE;

         AstToken getLBRACE(){ return _LBRACE; }
         void setLBRACE(AstToken _LBRACE){ this._LBRACE = _LBRACE; }
        /**
         * The value returned by <b>getExplicitConstructorInvocationopt</b> may be <b>null</b>
         */
         IExplicitConstructorInvocationopt ?  getExplicitConstructorInvocationopt(){ return _ExplicitConstructorInvocationopt; }
         void setExplicitConstructorInvocationopt(IExplicitConstructorInvocationopt _ExplicitConstructorInvocationopt){ this._ExplicitConstructorInvocationopt = _ExplicitConstructorInvocationopt; }
        /**
         * The value returned by <b>getBlockStatementsopt</b> may be <b>null</b>
         */
         IBlockStatementsopt ?  getBlockStatementsopt(){ return _BlockStatementsopt; }
         void setBlockStatementsopt(IBlockStatementsopt _BlockStatementsopt){ this._BlockStatementsopt = _BlockStatementsopt; }
         AstToken getRBRACE(){ return _RBRACE; }
         void setRBRACE(AstToken _RBRACE){ this._RBRACE = _RBRACE; }

        ConstructorBody(IToken leftIToken, IToken rightIToken,
                        AstToken _LBRACE,
                        IExplicitConstructorInvocationopt? _ExplicitConstructorInvocationopt,
                        IBlockStatementsopt? _BlockStatementsopt,
                        AstToken _RBRACE)
            :super(leftIToken, rightIToken)

        {
            this._LBRACE = _LBRACE;
            (_LBRACE as Ast).setParent(this);
            this._ExplicitConstructorInvocationopt = _ExplicitConstructorInvocationopt;
            if (null != _ExplicitConstructorInvocationopt) (_ExplicitConstructorInvocationopt as Ast).setParent(this);
            this._BlockStatementsopt = _BlockStatementsopt;
            if (null != _BlockStatementsopt) (_BlockStatementsopt as Ast).setParent(this);
            this._RBRACE = _RBRACE;
            (_RBRACE as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _LBRACE)  list.add(_LBRACE);
            if(null != _ExplicitConstructorInvocationopt)  list.add(_ExplicitConstructorInvocationopt);
            if(null != _BlockStatementsopt)  list.add(_BlockStatementsopt);
            if(null != _RBRACE)  list.add(_RBRACE);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitConstructorBody(this);
            if (checkChildren)
            {
                _LBRACE.accept(v);
                if (null != _ExplicitConstructorInvocationopt) _ExplicitConstructorInvocationopt!.accept(v);
                if (null != _BlockStatementsopt) _BlockStatementsopt!.accept(v);
                _RBRACE.accept(v);
            }
            v.endVisitConstructorBody(this);
        }
    }

/**
 *<b>
*<li>Rule 175:  EnumDeclaration ::= ClassModifiersopt enum identifier Interfacesopt EnumBody
 *</b>
 */
class EnumDeclaration extends Ast implements IEnumDeclaration
    {
         late IClassModifiersopt? _ClassModifiersopt;
         late AstToken _enum;
         late identifier _identifier;
         late Interfaces? _Interfacesopt;
         late EnumBody _EnumBody;

        /**
         * The value returned by <b>getClassModifiersopt</b> may be <b>null</b>
         */
         IClassModifiersopt ?  getClassModifiersopt(){ return _ClassModifiersopt; }
         void setClassModifiersopt(IClassModifiersopt _ClassModifiersopt){ this._ClassModifiersopt = _ClassModifiersopt; }
         AstToken getenum(){ return _enum; }
         void setenum(AstToken _enum){ this._enum = _enum; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }
        /**
         * The value returned by <b>getInterfacesopt</b> may be <b>null</b>
         */
         Interfaces ?  getInterfacesopt(){ return _Interfacesopt; }
         void setInterfacesopt(Interfaces _Interfacesopt){ this._Interfacesopt = _Interfacesopt; }
         EnumBody getEnumBody(){ return _EnumBody; }
         void setEnumBody(EnumBody _EnumBody){ this._EnumBody = _EnumBody; }

        EnumDeclaration(IToken leftIToken, IToken rightIToken,
                        IClassModifiersopt? _ClassModifiersopt,
                        AstToken _enum,
                        identifier _identifier,
                        Interfaces? _Interfacesopt,
                        EnumBody _EnumBody)
            :super(leftIToken, rightIToken)

        {
            this._ClassModifiersopt = _ClassModifiersopt;
            if (null != _ClassModifiersopt) (_ClassModifiersopt as Ast).setParent(this);
            this._enum = _enum;
            (_enum as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            this._Interfacesopt = _Interfacesopt;
            if (null != _Interfacesopt) (_Interfacesopt as Ast).setParent(this);
            this._EnumBody = _EnumBody;
            (_EnumBody as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ClassModifiersopt)  list.add(_ClassModifiersopt);
            if(null != _enum)  list.add(_enum);
            if(null != _identifier)  list.add(_identifier);
            if(null != _Interfacesopt)  list.add(_Interfacesopt);
            if(null != _EnumBody)  list.add(_EnumBody);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitEnumDeclaration(this);
            if (checkChildren)
            {
                if (null != _ClassModifiersopt) _ClassModifiersopt!.accept(v);
                _enum.accept(v);
                _identifier.accept(v);
                if (null != _Interfacesopt) _Interfacesopt!.accept(v);
                _EnumBody.accept(v);
            }
            v.endVisitEnumDeclaration(this);
        }
    }

/**
 *<b>
*<li>Rule 176:  EnumBody ::= { EnumConstantsopt ,opt EnumBodyDeclarationsopt }
 *</b>
 */
class EnumBody extends Ast implements IEnumBody
    {
         late AstToken _LBRACE;
         late IEnumConstantsopt? _EnumConstantsopt;
         late Commaopt? _Commaopt;
         late EnumBodyDeclarations? _EnumBodyDeclarationsopt;
         late AstToken _RBRACE;

         AstToken getLBRACE(){ return _LBRACE; }
         void setLBRACE(AstToken _LBRACE){ this._LBRACE = _LBRACE; }
        /**
         * The value returned by <b>getEnumConstantsopt</b> may be <b>null</b>
         */
         IEnumConstantsopt ?  getEnumConstantsopt(){ return _EnumConstantsopt; }
         void setEnumConstantsopt(IEnumConstantsopt _EnumConstantsopt){ this._EnumConstantsopt = _EnumConstantsopt; }
        /**
         * The value returned by <b>getCommaopt</b> may be <b>null</b>
         */
         Commaopt ?  getCommaopt(){ return _Commaopt; }
         void setCommaopt(Commaopt _Commaopt){ this._Commaopt = _Commaopt; }
        /**
         * The value returned by <b>getEnumBodyDeclarationsopt</b> may be <b>null</b>
         */
         EnumBodyDeclarations ?  getEnumBodyDeclarationsopt(){ return _EnumBodyDeclarationsopt; }
         void setEnumBodyDeclarationsopt(EnumBodyDeclarations _EnumBodyDeclarationsopt){ this._EnumBodyDeclarationsopt = _EnumBodyDeclarationsopt; }
         AstToken getRBRACE(){ return _RBRACE; }
         void setRBRACE(AstToken _RBRACE){ this._RBRACE = _RBRACE; }

        EnumBody(IToken leftIToken, IToken rightIToken,
                 AstToken _LBRACE,
                 IEnumConstantsopt? _EnumConstantsopt,
                 Commaopt? _Commaopt,
                 EnumBodyDeclarations? _EnumBodyDeclarationsopt,
                 AstToken _RBRACE)
            :super(leftIToken, rightIToken)

        {
            this._LBRACE = _LBRACE;
            (_LBRACE as Ast).setParent(this);
            this._EnumConstantsopt = _EnumConstantsopt;
            if (null != _EnumConstantsopt) (_EnumConstantsopt as Ast).setParent(this);
            this._Commaopt = _Commaopt;
            if (null != _Commaopt) (_Commaopt as Ast).setParent(this);
            this._EnumBodyDeclarationsopt = _EnumBodyDeclarationsopt;
            if (null != _EnumBodyDeclarationsopt) (_EnumBodyDeclarationsopt as Ast).setParent(this);
            this._RBRACE = _RBRACE;
            (_RBRACE as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _LBRACE)  list.add(_LBRACE);
            if(null != _EnumConstantsopt)  list.add(_EnumConstantsopt);
            if(null != _Commaopt)  list.add(_Commaopt);
            if(null != _EnumBodyDeclarationsopt)  list.add(_EnumBodyDeclarationsopt);
            if(null != _RBRACE)  list.add(_RBRACE);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitEnumBody(this);
            if (checkChildren)
            {
                _LBRACE.accept(v);
                if (null != _EnumConstantsopt) _EnumConstantsopt!.accept(v);
                if (null != _Commaopt) _Commaopt!.accept(v);
                if (null != _EnumBodyDeclarationsopt) _EnumBodyDeclarationsopt!.accept(v);
                _RBRACE.accept(v);
            }
            v.endVisitEnumBody(this);
        }
    }

/**
 *<em>
*<li>Rule 177:  EnumConstants ::= EnumConstant
 *</em>
 *<p>
 *<b>
*<li>Rule 178:  EnumConstants ::= EnumConstants , EnumConstant
 *</b>
 */
class EnumConstants extends Ast implements IEnumConstants
    {
         late IEnumConstants _EnumConstants;
         late AstToken _COMMA;
         late IEnumConstant _EnumConstant;

         IEnumConstants getEnumConstants(){ return _EnumConstants; }
         void setEnumConstants(IEnumConstants _EnumConstants){ this._EnumConstants = _EnumConstants; }
         AstToken getCOMMA(){ return _COMMA; }
         void setCOMMA(AstToken _COMMA){ this._COMMA = _COMMA; }
         IEnumConstant getEnumConstant(){ return _EnumConstant; }
         void setEnumConstant(IEnumConstant _EnumConstant){ this._EnumConstant = _EnumConstant; }

        EnumConstants(IToken leftIToken, IToken rightIToken,
                      IEnumConstants _EnumConstants,
                      AstToken _COMMA,
                      IEnumConstant _EnumConstant)
            :super(leftIToken, rightIToken)

        {
            this._EnumConstants = _EnumConstants;
            (_EnumConstants as Ast).setParent(this);
            this._COMMA = _COMMA;
            (_COMMA as Ast).setParent(this);
            this._EnumConstant = _EnumConstant;
            (_EnumConstant as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _EnumConstants)  list.add(_EnumConstants);
            if(null != _COMMA)  list.add(_COMMA);
            if(null != _EnumConstant)  list.add(_EnumConstant);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitEnumConstants(this);
            if (checkChildren)
            {
                _EnumConstants.accept(v);
                _COMMA.accept(v);
                _EnumConstant.accept(v);
            }
            v.endVisitEnumConstants(this);
        }
    }

/**
 *<em>
*<li>Rule 307:  EnumConstant ::= identifier
 *</em>
 *<p>
 *<b>
*<li>Rule 179:  EnumConstant ::= Annotationsopt identifier Argumentsopt ClassBodyopt
 *</b>
 */
class EnumConstant extends Ast implements IEnumConstant
    {
         late IAnnotationsopt? _Annotationsopt;
         late identifier _identifier;
         late Arguments? _Argumentsopt;
         late ClassBody? _ClassBodyopt;

        /**
         * The value returned by <b>getAnnotationsopt</b> may be <b>null</b>
         */
         IAnnotationsopt ?  getAnnotationsopt(){ return _Annotationsopt; }
         void setAnnotationsopt(IAnnotationsopt _Annotationsopt){ this._Annotationsopt = _Annotationsopt; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }
        /**
         * The value returned by <b>getArgumentsopt</b> may be <b>null</b>
         */
         Arguments ?  getArgumentsopt(){ return _Argumentsopt; }
         void setArgumentsopt(Arguments _Argumentsopt){ this._Argumentsopt = _Argumentsopt; }
        /**
         * The value returned by <b>getClassBodyopt</b> may be <b>null</b>
         */
         ClassBody ?  getClassBodyopt(){ return _ClassBodyopt; }
         void setClassBodyopt(ClassBody _ClassBodyopt){ this._ClassBodyopt = _ClassBodyopt; }

        EnumConstant(IToken leftIToken, IToken rightIToken,
                     IAnnotationsopt? _Annotationsopt,
                     identifier _identifier,
                     Arguments? _Argumentsopt,
                     ClassBody? _ClassBodyopt)
            :super(leftIToken, rightIToken)

        {
            this._Annotationsopt = _Annotationsopt;
            if (null != _Annotationsopt) (_Annotationsopt as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            this._Argumentsopt = _Argumentsopt;
            if (null != _Argumentsopt) (_Argumentsopt as Ast).setParent(this);
            this._ClassBodyopt = _ClassBodyopt;
            if (null != _ClassBodyopt) (_ClassBodyopt as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _Annotationsopt)  list.add(_Annotationsopt);
            if(null != _identifier)  list.add(_identifier);
            if(null != _Argumentsopt)  list.add(_Argumentsopt);
            if(null != _ClassBodyopt)  list.add(_ClassBodyopt);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitEnumConstant(this);
            if (checkChildren)
            {
                if (null != _Annotationsopt) _Annotationsopt!.accept(v);
                _identifier.accept(v);
                if (null != _Argumentsopt) _Argumentsopt!.accept(v);
                if (null != _ClassBodyopt) _ClassBodyopt!.accept(v);
            }
            v.endVisitEnumConstant(this);
        }
    }

/**
 *<b>
*<li>Rule 180:  Arguments ::= ( ArgumentListopt )
 *</b>
 */
class Arguments extends Ast implements IArguments
    {
         late AstToken _LPAREN;
         late IArgumentListopt? _ArgumentListopt;
         late AstToken _RPAREN;

         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
        /**
         * The value returned by <b>getArgumentListopt</b> may be <b>null</b>
         */
         IArgumentListopt ?  getArgumentListopt(){ return _ArgumentListopt; }
         void setArgumentListopt(IArgumentListopt _ArgumentListopt){ this._ArgumentListopt = _ArgumentListopt; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }

        Arguments(IToken leftIToken, IToken rightIToken,
                  AstToken _LPAREN,
                  IArgumentListopt? _ArgumentListopt,
                  AstToken _RPAREN)
            :super(leftIToken, rightIToken)

        {
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._ArgumentListopt = _ArgumentListopt;
            if (null != _ArgumentListopt) (_ArgumentListopt as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _ArgumentListopt)  list.add(_ArgumentListopt);
            if(null != _RPAREN)  list.add(_RPAREN);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitArguments(this);
            if (checkChildren)
            {
                _LPAREN.accept(v);
                if (null != _ArgumentListopt) _ArgumentListopt!.accept(v);
                _RPAREN.accept(v);
            }
            v.endVisitArguments(this);
        }
    }

/**
 *<b>
*<li>Rule 181:  EnumBodyDeclarations ::= ; ClassBodyDeclarationsopt
 *</b>
 */
class EnumBodyDeclarations extends Ast implements IEnumBodyDeclarations
    {
         late AstToken _SEMICOLON;
         late IClassBodyDeclarationsopt? _ClassBodyDeclarationsopt;

         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }
        /**
         * The value returned by <b>getClassBodyDeclarationsopt</b> may be <b>null</b>
         */
         IClassBodyDeclarationsopt ?  getClassBodyDeclarationsopt(){ return _ClassBodyDeclarationsopt; }
         void setClassBodyDeclarationsopt(IClassBodyDeclarationsopt _ClassBodyDeclarationsopt){ this._ClassBodyDeclarationsopt = _ClassBodyDeclarationsopt; }

        EnumBodyDeclarations(IToken leftIToken, IToken rightIToken,
                             AstToken _SEMICOLON,
                             IClassBodyDeclarationsopt? _ClassBodyDeclarationsopt)
            :super(leftIToken, rightIToken)

        {
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            this._ClassBodyDeclarationsopt = _ClassBodyDeclarationsopt;
            if (null != _ClassBodyDeclarationsopt) (_ClassBodyDeclarationsopt as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            if(null != _ClassBodyDeclarationsopt)  list.add(_ClassBodyDeclarationsopt);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitEnumBodyDeclarations(this);
            if (checkChildren)
            {
                _SEMICOLON.accept(v);
                if (null != _ClassBodyDeclarationsopt) _ClassBodyDeclarationsopt!.accept(v);
            }
            v.endVisitEnumBodyDeclarations(this);
        }
    }

/**
 *<b>
*<li>Rule 184:  NormalInterfaceDeclaration ::= InterfaceModifiersopt interface identifier TypeParametersopt ExtendsInterfacesopt InterfaceBody
 *</b>
 */
class NormalInterfaceDeclaration extends Ast implements INormalInterfaceDeclaration
    {
         late IInterfaceModifiersopt? _InterfaceModifiersopt;
         late AstToken _interface;
         late identifier _identifier;
         late TypeParameters? _TypeParametersopt;
         late IExtendsInterfacesopt? _ExtendsInterfacesopt;
         late InterfaceBody _InterfaceBody;

        /**
         * The value returned by <b>getInterfaceModifiersopt</b> may be <b>null</b>
         */
         IInterfaceModifiersopt ?  getInterfaceModifiersopt(){ return _InterfaceModifiersopt; }
         void setInterfaceModifiersopt(IInterfaceModifiersopt _InterfaceModifiersopt){ this._InterfaceModifiersopt = _InterfaceModifiersopt; }
         AstToken getinterface(){ return _interface; }
         void setinterface(AstToken _interface){ this._interface = _interface; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }
        /**
         * The value returned by <b>getTypeParametersopt</b> may be <b>null</b>
         */
         TypeParameters ?  getTypeParametersopt(){ return _TypeParametersopt; }
         void setTypeParametersopt(TypeParameters _TypeParametersopt){ this._TypeParametersopt = _TypeParametersopt; }
        /**
         * The value returned by <b>getExtendsInterfacesopt</b> may be <b>null</b>
         */
         IExtendsInterfacesopt ?  getExtendsInterfacesopt(){ return _ExtendsInterfacesopt; }
         void setExtendsInterfacesopt(IExtendsInterfacesopt _ExtendsInterfacesopt){ this._ExtendsInterfacesopt = _ExtendsInterfacesopt; }
         InterfaceBody getInterfaceBody(){ return _InterfaceBody; }
         void setInterfaceBody(InterfaceBody _InterfaceBody){ this._InterfaceBody = _InterfaceBody; }

        NormalInterfaceDeclaration(IToken leftIToken, IToken rightIToken,
                                   IInterfaceModifiersopt? _InterfaceModifiersopt,
                                   AstToken _interface,
                                   identifier _identifier,
                                   TypeParameters? _TypeParametersopt,
                                   IExtendsInterfacesopt? _ExtendsInterfacesopt,
                                   InterfaceBody _InterfaceBody)
            :super(leftIToken, rightIToken)

        {
            this._InterfaceModifiersopt = _InterfaceModifiersopt;
            if (null != _InterfaceModifiersopt) (_InterfaceModifiersopt as Ast).setParent(this);
            this._interface = _interface;
            (_interface as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            this._TypeParametersopt = _TypeParametersopt;
            if (null != _TypeParametersopt) (_TypeParametersopt as Ast).setParent(this);
            this._ExtendsInterfacesopt = _ExtendsInterfacesopt;
            if (null != _ExtendsInterfacesopt) (_ExtendsInterfacesopt as Ast).setParent(this);
            this._InterfaceBody = _InterfaceBody;
            (_InterfaceBody as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _InterfaceModifiersopt)  list.add(_InterfaceModifiersopt);
            if(null != _interface)  list.add(_interface);
            if(null != _identifier)  list.add(_identifier);
            if(null != _TypeParametersopt)  list.add(_TypeParametersopt);
            if(null != _ExtendsInterfacesopt)  list.add(_ExtendsInterfacesopt);
            if(null != _InterfaceBody)  list.add(_InterfaceBody);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitNormalInterfaceDeclaration(this);
            if (checkChildren)
            {
                if (null != _InterfaceModifiersopt) _InterfaceModifiersopt!.accept(v);
                _interface.accept(v);
                _identifier.accept(v);
                if (null != _TypeParametersopt) _TypeParametersopt!.accept(v);
                if (null != _ExtendsInterfacesopt) _ExtendsInterfacesopt!.accept(v);
                _InterfaceBody.accept(v);
            }
            v.endVisitNormalInterfaceDeclaration(this);
        }
    }

/**
 *<em>
*<li>Rule 185:  InterfaceModifiers ::= InterfaceModifier
 *</em>
 *<p>
 *<b>
*<li>Rule 186:  InterfaceModifiers ::= InterfaceModifiers InterfaceModifier
 *</b>
 */
class InterfaceModifiers extends Ast implements IInterfaceModifiers
    {
         late IInterfaceModifiers _InterfaceModifiers;
         late IInterfaceModifier _InterfaceModifier;

         IInterfaceModifiers getInterfaceModifiers(){ return _InterfaceModifiers; }
         void setInterfaceModifiers(IInterfaceModifiers _InterfaceModifiers){ this._InterfaceModifiers = _InterfaceModifiers; }
         IInterfaceModifier getInterfaceModifier(){ return _InterfaceModifier; }
         void setInterfaceModifier(IInterfaceModifier _InterfaceModifier){ this._InterfaceModifier = _InterfaceModifier; }

        InterfaceModifiers(IToken leftIToken, IToken rightIToken,
                           IInterfaceModifiers _InterfaceModifiers,
                           IInterfaceModifier _InterfaceModifier)
            :super(leftIToken, rightIToken)

        {
            this._InterfaceModifiers = _InterfaceModifiers;
            (_InterfaceModifiers as Ast).setParent(this);
            this._InterfaceModifier = _InterfaceModifier;
            (_InterfaceModifier as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _InterfaceModifiers)  list.add(_InterfaceModifiers);
            if(null != _InterfaceModifier)  list.add(_InterfaceModifier);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitInterfaceModifiers(this);
            if (checkChildren)
            {
                _InterfaceModifiers.accept(v);
                _InterfaceModifier.accept(v);
            }
            v.endVisitInterfaceModifiers(this);
        }
    }

/**
 *<b>
*<li>Rule 196:  InterfaceBody ::= { InterfaceMemberDeclarationsopt }
 *</b>
 */
class InterfaceBody extends Ast implements IInterfaceBody
    {
         late AstToken _LBRACE;
         late IInterfaceMemberDeclarationsopt? _InterfaceMemberDeclarationsopt;
         late AstToken _RBRACE;

         AstToken getLBRACE(){ return _LBRACE; }
         void setLBRACE(AstToken _LBRACE){ this._LBRACE = _LBRACE; }
        /**
         * The value returned by <b>getInterfaceMemberDeclarationsopt</b> may be <b>null</b>
         */
         IInterfaceMemberDeclarationsopt ?  getInterfaceMemberDeclarationsopt(){ return _InterfaceMemberDeclarationsopt; }
         void setInterfaceMemberDeclarationsopt(IInterfaceMemberDeclarationsopt _InterfaceMemberDeclarationsopt){ this._InterfaceMemberDeclarationsopt = _InterfaceMemberDeclarationsopt; }
         AstToken getRBRACE(){ return _RBRACE; }
         void setRBRACE(AstToken _RBRACE){ this._RBRACE = _RBRACE; }

        InterfaceBody(IToken leftIToken, IToken rightIToken,
                      AstToken _LBRACE,
                      IInterfaceMemberDeclarationsopt? _InterfaceMemberDeclarationsopt,
                      AstToken _RBRACE)
            :super(leftIToken, rightIToken)

        {
            this._LBRACE = _LBRACE;
            (_LBRACE as Ast).setParent(this);
            this._InterfaceMemberDeclarationsopt = _InterfaceMemberDeclarationsopt;
            if (null != _InterfaceMemberDeclarationsopt) (_InterfaceMemberDeclarationsopt as Ast).setParent(this);
            this._RBRACE = _RBRACE;
            (_RBRACE as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _LBRACE)  list.add(_LBRACE);
            if(null != _InterfaceMemberDeclarationsopt)  list.add(_InterfaceMemberDeclarationsopt);
            if(null != _RBRACE)  list.add(_RBRACE);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitInterfaceBody(this);
            if (checkChildren)
            {
                _LBRACE.accept(v);
                if (null != _InterfaceMemberDeclarationsopt) _InterfaceMemberDeclarationsopt!.accept(v);
                _RBRACE.accept(v);
            }
            v.endVisitInterfaceBody(this);
        }
    }

/**
 *<em>
*<li>Rule 197:  InterfaceMemberDeclarations ::= InterfaceMemberDeclaration
 *</em>
 *<p>
 *<b>
*<li>Rule 198:  InterfaceMemberDeclarations ::= InterfaceMemberDeclarations InterfaceMemberDeclaration
 *</b>
 */
class InterfaceMemberDeclarations extends Ast implements IInterfaceMemberDeclarations
    {
         late IInterfaceMemberDeclarations _InterfaceMemberDeclarations;
         late IInterfaceMemberDeclaration _InterfaceMemberDeclaration;

         IInterfaceMemberDeclarations getInterfaceMemberDeclarations(){ return _InterfaceMemberDeclarations; }
         void setInterfaceMemberDeclarations(IInterfaceMemberDeclarations _InterfaceMemberDeclarations){ this._InterfaceMemberDeclarations = _InterfaceMemberDeclarations; }
         IInterfaceMemberDeclaration getInterfaceMemberDeclaration(){ return _InterfaceMemberDeclaration; }
         void setInterfaceMemberDeclaration(IInterfaceMemberDeclaration _InterfaceMemberDeclaration){ this._InterfaceMemberDeclaration = _InterfaceMemberDeclaration; }

        InterfaceMemberDeclarations(IToken leftIToken, IToken rightIToken,
                                    IInterfaceMemberDeclarations _InterfaceMemberDeclarations,
                                    IInterfaceMemberDeclaration _InterfaceMemberDeclaration)
            :super(leftIToken, rightIToken)

        {
            this._InterfaceMemberDeclarations = _InterfaceMemberDeclarations;
            (_InterfaceMemberDeclarations as Ast).setParent(this);
            this._InterfaceMemberDeclaration = _InterfaceMemberDeclaration;
            (_InterfaceMemberDeclaration as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _InterfaceMemberDeclarations)  list.add(_InterfaceMemberDeclarations);
            if(null != _InterfaceMemberDeclaration)  list.add(_InterfaceMemberDeclaration);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitInterfaceMemberDeclarations(this);
            if (checkChildren)
            {
                _InterfaceMemberDeclarations.accept(v);
                _InterfaceMemberDeclaration.accept(v);
            }
            v.endVisitInterfaceMemberDeclarations(this);
        }
    }

/**
 *<em>
*<li>Rule 199:  InterfaceMemberDeclaration ::= ConstantDeclaration
*<li>Rule 200:  InterfaceMemberDeclaration ::= AbstractMethodDeclaration
*<li>Rule 201:  InterfaceMemberDeclaration ::= ClassDeclaration
*<li>Rule 202:  InterfaceMemberDeclaration ::= InterfaceDeclaration
 *</em>
 *<p>
 *<b>
*<li>Rule 203:  InterfaceMemberDeclaration ::= ;
 *</b>
 */
class InterfaceMemberDeclaration extends AstToken implements IInterfaceMemberDeclaration
    {
         IToken getSEMICOLON(){ return leftIToken; }

    InterfaceMemberDeclaration(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitInterfaceMemberDeclaration(this);
            v.endVisitInterfaceMemberDeclaration(this);
        }
    }

/**
 *<b>
*<li>Rule 204:  ConstantDeclaration ::= ConstantModifiersopt Type VariableDeclarators
 *</b>
 */
class ConstantDeclaration extends Ast implements IConstantDeclaration
    {
         late IConstantModifiersopt? _ConstantModifiersopt;
         late IType _Type;
         late IVariableDeclarators _VariableDeclarators;

        /**
         * The value returned by <b>getConstantModifiersopt</b> may be <b>null</b>
         */
         IConstantModifiersopt ?  getConstantModifiersopt(){ return _ConstantModifiersopt; }
         void setConstantModifiersopt(IConstantModifiersopt _ConstantModifiersopt){ this._ConstantModifiersopt = _ConstantModifiersopt; }
         IType getType(){ return _Type; }
         void setType(IType _Type){ this._Type = _Type; }
         IVariableDeclarators getVariableDeclarators(){ return _VariableDeclarators; }
         void setVariableDeclarators(IVariableDeclarators _VariableDeclarators){ this._VariableDeclarators = _VariableDeclarators; }

        ConstantDeclaration(IToken leftIToken, IToken rightIToken,
                            IConstantModifiersopt? _ConstantModifiersopt,
                            IType _Type,
                            IVariableDeclarators _VariableDeclarators)
            :super(leftIToken, rightIToken)

        {
            this._ConstantModifiersopt = _ConstantModifiersopt;
            if (null != _ConstantModifiersopt) (_ConstantModifiersopt as Ast).setParent(this);
            this._Type = _Type;
            (_Type as Ast).setParent(this);
            this._VariableDeclarators = _VariableDeclarators;
            (_VariableDeclarators as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ConstantModifiersopt)  list.add(_ConstantModifiersopt);
            if(null != _Type)  list.add(_Type);
            if(null != _VariableDeclarators)  list.add(_VariableDeclarators);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitConstantDeclaration(this);
            if (checkChildren)
            {
                if (null != _ConstantModifiersopt) _ConstantModifiersopt!.accept(v);
                _Type.accept(v);
                _VariableDeclarators.accept(v);
            }
            v.endVisitConstantDeclaration(this);
        }
    }

/**
 *<em>
*<li>Rule 205:  ConstantModifiers ::= ConstantModifier
 *</em>
 *<p>
 *<b>
*<li>Rule 206:  ConstantModifiers ::= ConstantModifiers ConstantModifier
 *</b>
 */
class ConstantModifiers extends Ast implements IConstantModifiers
    {
         late IConstantModifiers _ConstantModifiers;
         late IConstantModifier _ConstantModifier;

         IConstantModifiers getConstantModifiers(){ return _ConstantModifiers; }
         void setConstantModifiers(IConstantModifiers _ConstantModifiers){ this._ConstantModifiers = _ConstantModifiers; }
         IConstantModifier getConstantModifier(){ return _ConstantModifier; }
         void setConstantModifier(IConstantModifier _ConstantModifier){ this._ConstantModifier = _ConstantModifier; }

        ConstantModifiers(IToken leftIToken, IToken rightIToken,
                          IConstantModifiers _ConstantModifiers,
                          IConstantModifier _ConstantModifier)
            :super(leftIToken, rightIToken)

        {
            this._ConstantModifiers = _ConstantModifiers;
            (_ConstantModifiers as Ast).setParent(this);
            this._ConstantModifier = _ConstantModifier;
            (_ConstantModifier as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ConstantModifiers)  list.add(_ConstantModifiers);
            if(null != _ConstantModifier)  list.add(_ConstantModifier);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitConstantModifiers(this);
            if (checkChildren)
            {
                _ConstantModifiers.accept(v);
                _ConstantModifier.accept(v);
            }
            v.endVisitConstantModifiers(this);
        }
    }

/**
 *<b>
*<li>Rule 211:  AbstractMethodDeclaration ::= AbstractMethodModifiersopt TypeParametersopt ResultType MethodDeclarator Throwsopt ;
 *</b>
 */
class AbstractMethodDeclaration extends Ast implements IAbstractMethodDeclaration
    {
         late IAbstractMethodModifiersopt? _AbstractMethodModifiersopt;
         late TypeParameters? _TypeParametersopt;
         late IResultType _ResultType;
         late IMethodDeclarator _MethodDeclarator;
         late Throws? _Throwsopt;
         late AstToken _SEMICOLON;

        /**
         * The value returned by <b>getAbstractMethodModifiersopt</b> may be <b>null</b>
         */
         IAbstractMethodModifiersopt ?  getAbstractMethodModifiersopt(){ return _AbstractMethodModifiersopt; }
         void setAbstractMethodModifiersopt(IAbstractMethodModifiersopt _AbstractMethodModifiersopt){ this._AbstractMethodModifiersopt = _AbstractMethodModifiersopt; }
        /**
         * The value returned by <b>getTypeParametersopt</b> may be <b>null</b>
         */
         TypeParameters ?  getTypeParametersopt(){ return _TypeParametersopt; }
         void setTypeParametersopt(TypeParameters _TypeParametersopt){ this._TypeParametersopt = _TypeParametersopt; }
         IResultType getResultType(){ return _ResultType; }
         void setResultType(IResultType _ResultType){ this._ResultType = _ResultType; }
         IMethodDeclarator getMethodDeclarator(){ return _MethodDeclarator; }
         void setMethodDeclarator(IMethodDeclarator _MethodDeclarator){ this._MethodDeclarator = _MethodDeclarator; }
        /**
         * The value returned by <b>getThrowsopt</b> may be <b>null</b>
         */
         Throws ?  getThrowsopt(){ return _Throwsopt; }
         void setThrowsopt(Throws _Throwsopt){ this._Throwsopt = _Throwsopt; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        AbstractMethodDeclaration(IToken leftIToken, IToken rightIToken,
                                  IAbstractMethodModifiersopt? _AbstractMethodModifiersopt,
                                  TypeParameters? _TypeParametersopt,
                                  IResultType _ResultType,
                                  IMethodDeclarator _MethodDeclarator,
                                  Throws? _Throwsopt,
                                  AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._AbstractMethodModifiersopt = _AbstractMethodModifiersopt;
            if (null != _AbstractMethodModifiersopt) (_AbstractMethodModifiersopt as Ast).setParent(this);
            this._TypeParametersopt = _TypeParametersopt;
            if (null != _TypeParametersopt) (_TypeParametersopt as Ast).setParent(this);
            this._ResultType = _ResultType;
            (_ResultType as Ast).setParent(this);
            this._MethodDeclarator = _MethodDeclarator;
            (_MethodDeclarator as Ast).setParent(this);
            this._Throwsopt = _Throwsopt;
            if (null != _Throwsopt) (_Throwsopt as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _AbstractMethodModifiersopt)  list.add(_AbstractMethodModifiersopt);
            if(null != _TypeParametersopt)  list.add(_TypeParametersopt);
            if(null != _ResultType)  list.add(_ResultType);
            if(null != _MethodDeclarator)  list.add(_MethodDeclarator);
            if(null != _Throwsopt)  list.add(_Throwsopt);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitAbstractMethodDeclaration(this);
            if (checkChildren)
            {
                if (null != _AbstractMethodModifiersopt) _AbstractMethodModifiersopt!.accept(v);
                if (null != _TypeParametersopt) _TypeParametersopt!.accept(v);
                _ResultType.accept(v);
                _MethodDeclarator.accept(v);
                if (null != _Throwsopt) _Throwsopt!.accept(v);
                _SEMICOLON.accept(v);
            }
            v.endVisitAbstractMethodDeclaration(this);
        }
    }

/**
 *<em>
*<li>Rule 212:  AbstractMethodModifiers ::= AbstractMethodModifier
 *</em>
 *<p>
 *<b>
*<li>Rule 213:  AbstractMethodModifiers ::= AbstractMethodModifiers AbstractMethodModifier
 *</b>
 */
class AbstractMethodModifiers extends Ast implements IAbstractMethodModifiers
    {
         late IAbstractMethodModifiers _AbstractMethodModifiers;
         late IAbstractMethodModifier _AbstractMethodModifier;

         IAbstractMethodModifiers getAbstractMethodModifiers(){ return _AbstractMethodModifiers; }
         void setAbstractMethodModifiers(IAbstractMethodModifiers _AbstractMethodModifiers){ this._AbstractMethodModifiers = _AbstractMethodModifiers; }
         IAbstractMethodModifier getAbstractMethodModifier(){ return _AbstractMethodModifier; }
         void setAbstractMethodModifier(IAbstractMethodModifier _AbstractMethodModifier){ this._AbstractMethodModifier = _AbstractMethodModifier; }

        AbstractMethodModifiers(IToken leftIToken, IToken rightIToken,
                                IAbstractMethodModifiers _AbstractMethodModifiers,
                                IAbstractMethodModifier _AbstractMethodModifier)
            :super(leftIToken, rightIToken)

        {
            this._AbstractMethodModifiers = _AbstractMethodModifiers;
            (_AbstractMethodModifiers as Ast).setParent(this);
            this._AbstractMethodModifier = _AbstractMethodModifier;
            (_AbstractMethodModifier as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _AbstractMethodModifiers)  list.add(_AbstractMethodModifiers);
            if(null != _AbstractMethodModifier)  list.add(_AbstractMethodModifier);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitAbstractMethodModifiers(this);
            if (checkChildren)
            {
                _AbstractMethodModifiers.accept(v);
                _AbstractMethodModifier.accept(v);
            }
            v.endVisitAbstractMethodModifiers(this);
        }
    }

/**
 *<b>
*<li>Rule 217:  AnnotationTypeDeclaration ::= InterfaceModifiersopt @ interface identifier AnnotationTypeBody
 *</b>
 */
class AnnotationTypeDeclaration extends Ast implements IAnnotationTypeDeclaration
    {
         late IInterfaceModifiersopt? _InterfaceModifiersopt;
         late AstToken _AT;
         late AstToken _interface;
         late identifier _identifier;
         late AnnotationTypeBody _AnnotationTypeBody;

        /**
         * The value returned by <b>getInterfaceModifiersopt</b> may be <b>null</b>
         */
         IInterfaceModifiersopt ?  getInterfaceModifiersopt(){ return _InterfaceModifiersopt; }
         void setInterfaceModifiersopt(IInterfaceModifiersopt _InterfaceModifiersopt){ this._InterfaceModifiersopt = _InterfaceModifiersopt; }
         AstToken getAT(){ return _AT; }
         void setAT(AstToken _AT){ this._AT = _AT; }
         AstToken getinterface(){ return _interface; }
         void setinterface(AstToken _interface){ this._interface = _interface; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }
         AnnotationTypeBody getAnnotationTypeBody(){ return _AnnotationTypeBody; }
         void setAnnotationTypeBody(AnnotationTypeBody _AnnotationTypeBody){ this._AnnotationTypeBody = _AnnotationTypeBody; }

        AnnotationTypeDeclaration(IToken leftIToken, IToken rightIToken,
                                  IInterfaceModifiersopt? _InterfaceModifiersopt,
                                  AstToken _AT,
                                  AstToken _interface,
                                  identifier _identifier,
                                  AnnotationTypeBody _AnnotationTypeBody)
            :super(leftIToken, rightIToken)

        {
            this._InterfaceModifiersopt = _InterfaceModifiersopt;
            if (null != _InterfaceModifiersopt) (_InterfaceModifiersopt as Ast).setParent(this);
            this._AT = _AT;
            (_AT as Ast).setParent(this);
            this._interface = _interface;
            (_interface as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            this._AnnotationTypeBody = _AnnotationTypeBody;
            (_AnnotationTypeBody as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _InterfaceModifiersopt)  list.add(_InterfaceModifiersopt);
            if(null != _AT)  list.add(_AT);
            if(null != _interface)  list.add(_interface);
            if(null != _identifier)  list.add(_identifier);
            if(null != _AnnotationTypeBody)  list.add(_AnnotationTypeBody);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitAnnotationTypeDeclaration(this);
            if (checkChildren)
            {
                if (null != _InterfaceModifiersopt) _InterfaceModifiersopt!.accept(v);
                _AT.accept(v);
                _interface.accept(v);
                _identifier.accept(v);
                _AnnotationTypeBody.accept(v);
            }
            v.endVisitAnnotationTypeDeclaration(this);
        }
    }

/**
 *<b>
*<li>Rule 218:  AnnotationTypeBody ::= { AnnotationTypeElementDeclarationsopt }
 *</b>
 */
class AnnotationTypeBody extends Ast implements IAnnotationTypeBody
    {
         late AstToken _LBRACE;
         late IAnnotationTypeElementDeclarationsopt? _AnnotationTypeElementDeclarationsopt;
         late AstToken _RBRACE;

         AstToken getLBRACE(){ return _LBRACE; }
         void setLBRACE(AstToken _LBRACE){ this._LBRACE = _LBRACE; }
        /**
         * The value returned by <b>getAnnotationTypeElementDeclarationsopt</b> may be <b>null</b>
         */
         IAnnotationTypeElementDeclarationsopt ?  getAnnotationTypeElementDeclarationsopt(){ return _AnnotationTypeElementDeclarationsopt; }
         void setAnnotationTypeElementDeclarationsopt(IAnnotationTypeElementDeclarationsopt _AnnotationTypeElementDeclarationsopt){ this._AnnotationTypeElementDeclarationsopt = _AnnotationTypeElementDeclarationsopt; }
         AstToken getRBRACE(){ return _RBRACE; }
         void setRBRACE(AstToken _RBRACE){ this._RBRACE = _RBRACE; }

        AnnotationTypeBody(IToken leftIToken, IToken rightIToken,
                           AstToken _LBRACE,
                           IAnnotationTypeElementDeclarationsopt? _AnnotationTypeElementDeclarationsopt,
                           AstToken _RBRACE)
            :super(leftIToken, rightIToken)

        {
            this._LBRACE = _LBRACE;
            (_LBRACE as Ast).setParent(this);
            this._AnnotationTypeElementDeclarationsopt = _AnnotationTypeElementDeclarationsopt;
            if (null != _AnnotationTypeElementDeclarationsopt) (_AnnotationTypeElementDeclarationsopt as Ast).setParent(this);
            this._RBRACE = _RBRACE;
            (_RBRACE as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _LBRACE)  list.add(_LBRACE);
            if(null != _AnnotationTypeElementDeclarationsopt)  list.add(_AnnotationTypeElementDeclarationsopt);
            if(null != _RBRACE)  list.add(_RBRACE);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitAnnotationTypeBody(this);
            if (checkChildren)
            {
                _LBRACE.accept(v);
                if (null != _AnnotationTypeElementDeclarationsopt) _AnnotationTypeElementDeclarationsopt!.accept(v);
                _RBRACE.accept(v);
            }
            v.endVisitAnnotationTypeBody(this);
        }
    }

/**
 *<em>
*<li>Rule 219:  AnnotationTypeElementDeclarations ::= AnnotationTypeElementDeclaration
 *</em>
 *<p>
 *<b>
*<li>Rule 220:  AnnotationTypeElementDeclarations ::= AnnotationTypeElementDeclarations AnnotationTypeElementDeclaration
 *</b>
 */
class AnnotationTypeElementDeclarations extends Ast implements IAnnotationTypeElementDeclarations
    {
         late IAnnotationTypeElementDeclarations _AnnotationTypeElementDeclarations;
         late IAnnotationTypeElementDeclaration _AnnotationTypeElementDeclaration;

         IAnnotationTypeElementDeclarations getAnnotationTypeElementDeclarations(){ return _AnnotationTypeElementDeclarations; }
         void setAnnotationTypeElementDeclarations(IAnnotationTypeElementDeclarations _AnnotationTypeElementDeclarations){ this._AnnotationTypeElementDeclarations = _AnnotationTypeElementDeclarations; }
         IAnnotationTypeElementDeclaration getAnnotationTypeElementDeclaration(){ return _AnnotationTypeElementDeclaration; }
         void setAnnotationTypeElementDeclaration(IAnnotationTypeElementDeclaration _AnnotationTypeElementDeclaration){ this._AnnotationTypeElementDeclaration = _AnnotationTypeElementDeclaration; }

        AnnotationTypeElementDeclarations(IToken leftIToken, IToken rightIToken,
                                          IAnnotationTypeElementDeclarations _AnnotationTypeElementDeclarations,
                                          IAnnotationTypeElementDeclaration _AnnotationTypeElementDeclaration)
            :super(leftIToken, rightIToken)

        {
            this._AnnotationTypeElementDeclarations = _AnnotationTypeElementDeclarations;
            (_AnnotationTypeElementDeclarations as Ast).setParent(this);
            this._AnnotationTypeElementDeclaration = _AnnotationTypeElementDeclaration;
            (_AnnotationTypeElementDeclaration as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _AnnotationTypeElementDeclarations)  list.add(_AnnotationTypeElementDeclarations);
            if(null != _AnnotationTypeElementDeclaration)  list.add(_AnnotationTypeElementDeclaration);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitAnnotationTypeElementDeclarations(this);
            if (checkChildren)
            {
                _AnnotationTypeElementDeclarations.accept(v);
                _AnnotationTypeElementDeclaration.accept(v);
            }
            v.endVisitAnnotationTypeElementDeclarations(this);
        }
    }

/**
 *<b>
*<li>Rule 228:  DefaultValue ::= default ElementValue
 *</b>
 */
class DefaultValue extends Ast implements IDefaultValue
    {
         late AstToken _default;
         late IElementValue _ElementValue;

         AstToken getdefault(){ return _default; }
         void setdefault(AstToken _default){ this._default = _default; }
         IElementValue getElementValue(){ return _ElementValue; }
         void setElementValue(IElementValue _ElementValue){ this._ElementValue = _ElementValue; }

        DefaultValue(IToken leftIToken, IToken rightIToken,
                     AstToken _default,
                     IElementValue _ElementValue)
            :super(leftIToken, rightIToken)

        {
            this._default = _default;
            (_default as Ast).setParent(this);
            this._ElementValue = _ElementValue;
            (_ElementValue as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _default)  list.add(_default);
            if(null != _ElementValue)  list.add(_ElementValue);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitDefaultValue(this);
            if (checkChildren)
            {
                _default.accept(v);
                _ElementValue.accept(v);
            }
            v.endVisitDefaultValue(this);
        }
    }

/**
 *<em>
*<li>Rule 229:  Annotations ::= Annotation
 *</em>
 *<p>
 *<b>
*<li>Rule 230:  Annotations ::= Annotations Annotation
 *</b>
 */
class Annotations extends Ast implements IAnnotations
    {
         late IAnnotations _Annotations;
         late IAnnotation _Annotation;

         IAnnotations getAnnotations(){ return _Annotations; }
         void setAnnotations(IAnnotations _Annotations){ this._Annotations = _Annotations; }
         IAnnotation getAnnotation(){ return _Annotation; }
         void setAnnotation(IAnnotation _Annotation){ this._Annotation = _Annotation; }

        Annotations(IToken leftIToken, IToken rightIToken,
                    IAnnotations _Annotations,
                    IAnnotation _Annotation)
            :super(leftIToken, rightIToken)

        {
            this._Annotations = _Annotations;
            (_Annotations as Ast).setParent(this);
            this._Annotation = _Annotation;
            (_Annotation as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _Annotations)  list.add(_Annotations);
            if(null != _Annotation)  list.add(_Annotation);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitAnnotations(this);
            if (checkChildren)
            {
                _Annotations.accept(v);
                _Annotation.accept(v);
            }
            v.endVisitAnnotations(this);
        }
    }

/**
 *<b>
*<li>Rule 234:  NormalAnnotation ::= @ TypeName ( ElementValuePairsopt )
 *</b>
 */
class NormalAnnotation extends Ast implements INormalAnnotation
    {
         late AstToken _AT;
         late ITypeName _TypeName;
         late AstToken _LPAREN;
         late IElementValuePairsopt? _ElementValuePairsopt;
         late AstToken _RPAREN;

         AstToken getAT(){ return _AT; }
         void setAT(AstToken _AT){ this._AT = _AT; }
         ITypeName getTypeName(){ return _TypeName; }
         void setTypeName(ITypeName _TypeName){ this._TypeName = _TypeName; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
        /**
         * The value returned by <b>getElementValuePairsopt</b> may be <b>null</b>
         */
         IElementValuePairsopt ?  getElementValuePairsopt(){ return _ElementValuePairsopt; }
         void setElementValuePairsopt(IElementValuePairsopt _ElementValuePairsopt){ this._ElementValuePairsopt = _ElementValuePairsopt; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }

        NormalAnnotation(IToken leftIToken, IToken rightIToken,
                         AstToken _AT,
                         ITypeName _TypeName,
                         AstToken _LPAREN,
                         IElementValuePairsopt? _ElementValuePairsopt,
                         AstToken _RPAREN)
            :super(leftIToken, rightIToken)

        {
            this._AT = _AT;
            (_AT as Ast).setParent(this);
            this._TypeName = _TypeName;
            (_TypeName as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._ElementValuePairsopt = _ElementValuePairsopt;
            if (null != _ElementValuePairsopt) (_ElementValuePairsopt as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _AT)  list.add(_AT);
            if(null != _TypeName)  list.add(_TypeName);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _ElementValuePairsopt)  list.add(_ElementValuePairsopt);
            if(null != _RPAREN)  list.add(_RPAREN);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitNormalAnnotation(this);
            if (checkChildren)
            {
                _AT.accept(v);
                _TypeName.accept(v);
                _LPAREN.accept(v);
                if (null != _ElementValuePairsopt) _ElementValuePairsopt!.accept(v);
                _RPAREN.accept(v);
            }
            v.endVisitNormalAnnotation(this);
        }
    }

/**
 *<em>
*<li>Rule 235:  ElementValuePairs ::= ElementValuePair
 *</em>
 *<p>
 *<b>
*<li>Rule 236:  ElementValuePairs ::= ElementValuePairs , ElementValuePair
 *</b>
 */
class ElementValuePairs extends Ast implements IElementValuePairs
    {
         late IElementValuePairs _ElementValuePairs;
         late AstToken _COMMA;
         late ElementValuePair _ElementValuePair;

         IElementValuePairs getElementValuePairs(){ return _ElementValuePairs; }
         void setElementValuePairs(IElementValuePairs _ElementValuePairs){ this._ElementValuePairs = _ElementValuePairs; }
         AstToken getCOMMA(){ return _COMMA; }
         void setCOMMA(AstToken _COMMA){ this._COMMA = _COMMA; }
         ElementValuePair getElementValuePair(){ return _ElementValuePair; }
         void setElementValuePair(ElementValuePair _ElementValuePair){ this._ElementValuePair = _ElementValuePair; }

        ElementValuePairs(IToken leftIToken, IToken rightIToken,
                          IElementValuePairs _ElementValuePairs,
                          AstToken _COMMA,
                          ElementValuePair _ElementValuePair)
            :super(leftIToken, rightIToken)

        {
            this._ElementValuePairs = _ElementValuePairs;
            (_ElementValuePairs as Ast).setParent(this);
            this._COMMA = _COMMA;
            (_COMMA as Ast).setParent(this);
            this._ElementValuePair = _ElementValuePair;
            (_ElementValuePair as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ElementValuePairs)  list.add(_ElementValuePairs);
            if(null != _COMMA)  list.add(_COMMA);
            if(null != _ElementValuePair)  list.add(_ElementValuePair);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitElementValuePairs(this);
            if (checkChildren)
            {
                _ElementValuePairs.accept(v);
                _COMMA.accept(v);
                _ElementValuePair.accept(v);
            }
            v.endVisitElementValuePairs(this);
        }
    }

/**
 *<b>
*<li>Rule 237:  ElementValuePair ::= SimpleName = ElementValue
 *</b>
 */
class ElementValuePair extends Ast implements IElementValuePair
    {
         late identifier _SimpleName;
         late AstToken _EQUAL;
         late IElementValue _ElementValue;

         identifier getSimpleName(){ return _SimpleName; }
         void setSimpleName(identifier _SimpleName){ this._SimpleName = _SimpleName; }
         AstToken getEQUAL(){ return _EQUAL; }
         void setEQUAL(AstToken _EQUAL){ this._EQUAL = _EQUAL; }
         IElementValue getElementValue(){ return _ElementValue; }
         void setElementValue(IElementValue _ElementValue){ this._ElementValue = _ElementValue; }

        ElementValuePair(IToken leftIToken, IToken rightIToken,
                         identifier _SimpleName,
                         AstToken _EQUAL,
                         IElementValue _ElementValue)
            :super(leftIToken, rightIToken)

        {
            this._SimpleName = _SimpleName;
            (_SimpleName as Ast).setParent(this);
            this._EQUAL = _EQUAL;
            (_EQUAL as Ast).setParent(this);
            this._ElementValue = _ElementValue;
            (_ElementValue as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _SimpleName)  list.add(_SimpleName);
            if(null != _EQUAL)  list.add(_EQUAL);
            if(null != _ElementValue)  list.add(_ElementValue);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitElementValuePair(this);
            if (checkChildren)
            {
                _SimpleName.accept(v);
                _EQUAL.accept(v);
                _ElementValue.accept(v);
            }
            v.endVisitElementValuePair(this);
        }
    }

/**
 *<b>
*<li>Rule 242:  ElementValueArrayInitializer ::= { ElementValuesopt ,opt }
 *</b>
 */
class ElementValueArrayInitializer extends Ast implements IElementValueArrayInitializer
    {
         late AstToken _LBRACE;
         late IElementValuesopt? _ElementValuesopt;
         late Commaopt? _Commaopt;
         late AstToken _RBRACE;

         AstToken getLBRACE(){ return _LBRACE; }
         void setLBRACE(AstToken _LBRACE){ this._LBRACE = _LBRACE; }
        /**
         * The value returned by <b>getElementValuesopt</b> may be <b>null</b>
         */
         IElementValuesopt ?  getElementValuesopt(){ return _ElementValuesopt; }
         void setElementValuesopt(IElementValuesopt _ElementValuesopt){ this._ElementValuesopt = _ElementValuesopt; }
        /**
         * The value returned by <b>getCommaopt</b> may be <b>null</b>
         */
         Commaopt ?  getCommaopt(){ return _Commaopt; }
         void setCommaopt(Commaopt _Commaopt){ this._Commaopt = _Commaopt; }
         AstToken getRBRACE(){ return _RBRACE; }
         void setRBRACE(AstToken _RBRACE){ this._RBRACE = _RBRACE; }

        ElementValueArrayInitializer(IToken leftIToken, IToken rightIToken,
                                     AstToken _LBRACE,
                                     IElementValuesopt? _ElementValuesopt,
                                     Commaopt? _Commaopt,
                                     AstToken _RBRACE)
            :super(leftIToken, rightIToken)

        {
            this._LBRACE = _LBRACE;
            (_LBRACE as Ast).setParent(this);
            this._ElementValuesopt = _ElementValuesopt;
            if (null != _ElementValuesopt) (_ElementValuesopt as Ast).setParent(this);
            this._Commaopt = _Commaopt;
            if (null != _Commaopt) (_Commaopt as Ast).setParent(this);
            this._RBRACE = _RBRACE;
            (_RBRACE as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _LBRACE)  list.add(_LBRACE);
            if(null != _ElementValuesopt)  list.add(_ElementValuesopt);
            if(null != _Commaopt)  list.add(_Commaopt);
            if(null != _RBRACE)  list.add(_RBRACE);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitElementValueArrayInitializer(this);
            if (checkChildren)
            {
                _LBRACE.accept(v);
                if (null != _ElementValuesopt) _ElementValuesopt!.accept(v);
                if (null != _Commaopt) _Commaopt!.accept(v);
                _RBRACE.accept(v);
            }
            v.endVisitElementValueArrayInitializer(this);
        }
    }

/**
 *<em>
*<li>Rule 243:  ElementValues ::= ElementValue
 *</em>
 *<p>
 *<b>
*<li>Rule 244:  ElementValues ::= ElementValues , ElementValue
 *</b>
 */
class ElementValues extends Ast implements IElementValues
    {
         late IElementValues _ElementValues;
         late AstToken _COMMA;
         late IElementValue _ElementValue;

         IElementValues getElementValues(){ return _ElementValues; }
         void setElementValues(IElementValues _ElementValues){ this._ElementValues = _ElementValues; }
         AstToken getCOMMA(){ return _COMMA; }
         void setCOMMA(AstToken _COMMA){ this._COMMA = _COMMA; }
         IElementValue getElementValue(){ return _ElementValue; }
         void setElementValue(IElementValue _ElementValue){ this._ElementValue = _ElementValue; }

        ElementValues(IToken leftIToken, IToken rightIToken,
                      IElementValues _ElementValues,
                      AstToken _COMMA,
                      IElementValue _ElementValue)
            :super(leftIToken, rightIToken)

        {
            this._ElementValues = _ElementValues;
            (_ElementValues as Ast).setParent(this);
            this._COMMA = _COMMA;
            (_COMMA as Ast).setParent(this);
            this._ElementValue = _ElementValue;
            (_ElementValue as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ElementValues)  list.add(_ElementValues);
            if(null != _COMMA)  list.add(_COMMA);
            if(null != _ElementValue)  list.add(_ElementValue);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitElementValues(this);
            if (checkChildren)
            {
                _ElementValues.accept(v);
                _COMMA.accept(v);
                _ElementValue.accept(v);
            }
            v.endVisitElementValues(this);
        }
    }

/**
 *<b>
*<li>Rule 245:  MarkerAnnotation ::= @ TypeName
 *</b>
 */
class MarkerAnnotation extends Ast implements IMarkerAnnotation
    {
         late AstToken _AT;
         late ITypeName _TypeName;

         AstToken getAT(){ return _AT; }
         void setAT(AstToken _AT){ this._AT = _AT; }
         ITypeName getTypeName(){ return _TypeName; }
         void setTypeName(ITypeName _TypeName){ this._TypeName = _TypeName; }

        MarkerAnnotation(IToken leftIToken, IToken rightIToken,
                         AstToken _AT,
                         ITypeName _TypeName)
            :super(leftIToken, rightIToken)

        {
            this._AT = _AT;
            (_AT as Ast).setParent(this);
            this._TypeName = _TypeName;
            (_TypeName as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _AT)  list.add(_AT);
            if(null != _TypeName)  list.add(_TypeName);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitMarkerAnnotation(this);
            if (checkChildren)
            {
                _AT.accept(v);
                _TypeName.accept(v);
            }
            v.endVisitMarkerAnnotation(this);
        }
    }

/**
 *<b>
*<li>Rule 246:  SingleElementAnnotation ::= @ TypeName ( ElementValue )
 *</b>
 */
class SingleElementAnnotation extends Ast implements ISingleElementAnnotation
    {
         late AstToken _AT;
         late ITypeName _TypeName;
         late AstToken _LPAREN;
         late IElementValue _ElementValue;
         late AstToken _RPAREN;

         AstToken getAT(){ return _AT; }
         void setAT(AstToken _AT){ this._AT = _AT; }
         ITypeName getTypeName(){ return _TypeName; }
         void setTypeName(ITypeName _TypeName){ this._TypeName = _TypeName; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
         IElementValue getElementValue(){ return _ElementValue; }
         void setElementValue(IElementValue _ElementValue){ this._ElementValue = _ElementValue; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }

        SingleElementAnnotation(IToken leftIToken, IToken rightIToken,
                                AstToken _AT,
                                ITypeName _TypeName,
                                AstToken _LPAREN,
                                IElementValue _ElementValue,
                                AstToken _RPAREN)
            :super(leftIToken, rightIToken)

        {
            this._AT = _AT;
            (_AT as Ast).setParent(this);
            this._TypeName = _TypeName;
            (_TypeName as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._ElementValue = _ElementValue;
            (_ElementValue as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _AT)  list.add(_AT);
            if(null != _TypeName)  list.add(_TypeName);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _ElementValue)  list.add(_ElementValue);
            if(null != _RPAREN)  list.add(_RPAREN);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitSingleElementAnnotation(this);
            if (checkChildren)
            {
                _AT.accept(v);
                _TypeName.accept(v);
                _LPAREN.accept(v);
                _ElementValue.accept(v);
                _RPAREN.accept(v);
            }
            v.endVisitSingleElementAnnotation(this);
        }
    }

/**
 *<b>
*<li>Rule 247:  ArrayInitializer ::= { VariableInitializersopt ,opt }
 *</b>
 */
class ArrayInitializer extends Ast implements IArrayInitializer
    {
         late AstToken _LBRACE;
         late IVariableInitializersopt? _VariableInitializersopt;
         late Commaopt? _Commaopt;
         late AstToken _RBRACE;

         AstToken getLBRACE(){ return _LBRACE; }
         void setLBRACE(AstToken _LBRACE){ this._LBRACE = _LBRACE; }
        /**
         * The value returned by <b>getVariableInitializersopt</b> may be <b>null</b>
         */
         IVariableInitializersopt ?  getVariableInitializersopt(){ return _VariableInitializersopt; }
         void setVariableInitializersopt(IVariableInitializersopt _VariableInitializersopt){ this._VariableInitializersopt = _VariableInitializersopt; }
        /**
         * The value returned by <b>getCommaopt</b> may be <b>null</b>
         */
         Commaopt ?  getCommaopt(){ return _Commaopt; }
         void setCommaopt(Commaopt _Commaopt){ this._Commaopt = _Commaopt; }
         AstToken getRBRACE(){ return _RBRACE; }
         void setRBRACE(AstToken _RBRACE){ this._RBRACE = _RBRACE; }

        ArrayInitializer(IToken leftIToken, IToken rightIToken,
                         AstToken _LBRACE,
                         IVariableInitializersopt? _VariableInitializersopt,
                         Commaopt? _Commaopt,
                         AstToken _RBRACE)
            :super(leftIToken, rightIToken)

        {
            this._LBRACE = _LBRACE;
            (_LBRACE as Ast).setParent(this);
            this._VariableInitializersopt = _VariableInitializersopt;
            if (null != _VariableInitializersopt) (_VariableInitializersopt as Ast).setParent(this);
            this._Commaopt = _Commaopt;
            if (null != _Commaopt) (_Commaopt as Ast).setParent(this);
            this._RBRACE = _RBRACE;
            (_RBRACE as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _LBRACE)  list.add(_LBRACE);
            if(null != _VariableInitializersopt)  list.add(_VariableInitializersopt);
            if(null != _Commaopt)  list.add(_Commaopt);
            if(null != _RBRACE)  list.add(_RBRACE);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitArrayInitializer(this);
            if (checkChildren)
            {
                _LBRACE.accept(v);
                if (null != _VariableInitializersopt) _VariableInitializersopt!.accept(v);
                if (null != _Commaopt) _Commaopt!.accept(v);
                _RBRACE.accept(v);
            }
            v.endVisitArrayInitializer(this);
        }
    }

/**
 *<em>
*<li>Rule 248:  VariableInitializers ::= VariableInitializer
 *</em>
 *<p>
 *<b>
*<li>Rule 249:  VariableInitializers ::= VariableInitializers , VariableInitializer
 *</b>
 */
class VariableInitializers extends Ast implements IVariableInitializers
    {
         late IVariableInitializers _VariableInitializers;
         late AstToken _COMMA;
         late IVariableInitializer _VariableInitializer;

         IVariableInitializers getVariableInitializers(){ return _VariableInitializers; }
         void setVariableInitializers(IVariableInitializers _VariableInitializers){ this._VariableInitializers = _VariableInitializers; }
         AstToken getCOMMA(){ return _COMMA; }
         void setCOMMA(AstToken _COMMA){ this._COMMA = _COMMA; }
         IVariableInitializer getVariableInitializer(){ return _VariableInitializer; }
         void setVariableInitializer(IVariableInitializer _VariableInitializer){ this._VariableInitializer = _VariableInitializer; }

        VariableInitializers(IToken leftIToken, IToken rightIToken,
                             IVariableInitializers _VariableInitializers,
                             AstToken _COMMA,
                             IVariableInitializer _VariableInitializer)
            :super(leftIToken, rightIToken)

        {
            this._VariableInitializers = _VariableInitializers;
            (_VariableInitializers as Ast).setParent(this);
            this._COMMA = _COMMA;
            (_COMMA as Ast).setParent(this);
            this._VariableInitializer = _VariableInitializer;
            (_VariableInitializer as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _VariableInitializers)  list.add(_VariableInitializers);
            if(null != _COMMA)  list.add(_COMMA);
            if(null != _VariableInitializer)  list.add(_VariableInitializer);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitVariableInitializers(this);
            if (checkChildren)
            {
                _VariableInitializers.accept(v);
                _COMMA.accept(v);
                _VariableInitializer.accept(v);
            }
            v.endVisitVariableInitializers(this);
        }
    }

/**
 *<b>
*<li>Rule 250:  Block ::= { BlockStatementsopt }
 *</b>
 */
class Block extends Ast implements IBlock
    {
         late AstToken _LBRACE;
         late IBlockStatementsopt? _BlockStatementsopt;
         late AstToken _RBRACE;

         AstToken getLBRACE(){ return _LBRACE; }
         void setLBRACE(AstToken _LBRACE){ this._LBRACE = _LBRACE; }
        /**
         * The value returned by <b>getBlockStatementsopt</b> may be <b>null</b>
         */
         IBlockStatementsopt ?  getBlockStatementsopt(){ return _BlockStatementsopt; }
         void setBlockStatementsopt(IBlockStatementsopt _BlockStatementsopt){ this._BlockStatementsopt = _BlockStatementsopt; }
         AstToken getRBRACE(){ return _RBRACE; }
         void setRBRACE(AstToken _RBRACE){ this._RBRACE = _RBRACE; }

        Block(IToken leftIToken, IToken rightIToken,
              AstToken _LBRACE,
              IBlockStatementsopt? _BlockStatementsopt,
              AstToken _RBRACE)
            :super(leftIToken, rightIToken)

        {
            this._LBRACE = _LBRACE;
            (_LBRACE as Ast).setParent(this);
            this._BlockStatementsopt = _BlockStatementsopt;
            if (null != _BlockStatementsopt) (_BlockStatementsopt as Ast).setParent(this);
            this._RBRACE = _RBRACE;
            (_RBRACE as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _LBRACE)  list.add(_LBRACE);
            if(null != _BlockStatementsopt)  list.add(_BlockStatementsopt);
            if(null != _RBRACE)  list.add(_RBRACE);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitBlock(this);
            if (checkChildren)
            {
                _LBRACE.accept(v);
                if (null != _BlockStatementsopt) _BlockStatementsopt!.accept(v);
                _RBRACE.accept(v);
            }
            v.endVisitBlock(this);
        }
    }

/**
 *<em>
*<li>Rule 251:  BlockStatements ::= BlockStatement
 *</em>
 *<p>
 *<b>
*<li>Rule 252:  BlockStatements ::= BlockStatements BlockStatement
 *</b>
 */
class BlockStatements extends Ast implements IBlockStatements
    {
         late IBlockStatements _BlockStatements;
         late IBlockStatement _BlockStatement;

         IBlockStatements getBlockStatements(){ return _BlockStatements; }
         void setBlockStatements(IBlockStatements _BlockStatements){ this._BlockStatements = _BlockStatements; }
         IBlockStatement getBlockStatement(){ return _BlockStatement; }
         void setBlockStatement(IBlockStatement _BlockStatement){ this._BlockStatement = _BlockStatement; }

        BlockStatements(IToken leftIToken, IToken rightIToken,
                        IBlockStatements _BlockStatements,
                        IBlockStatement _BlockStatement)
            :super(leftIToken, rightIToken)

        {
            this._BlockStatements = _BlockStatements;
            (_BlockStatements as Ast).setParent(this);
            this._BlockStatement = _BlockStatement;
            (_BlockStatement as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _BlockStatements)  list.add(_BlockStatements);
            if(null != _BlockStatement)  list.add(_BlockStatement);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitBlockStatements(this);
            if (checkChildren)
            {
                _BlockStatements.accept(v);
                _BlockStatement.accept(v);
            }
            v.endVisitBlockStatements(this);
        }
    }

/**
 *<b>
*<li>Rule 256:  LocalVariableDeclarationStatement ::= LocalVariableDeclaration ;
 *</b>
 */
class LocalVariableDeclarationStatement extends Ast implements ILocalVariableDeclarationStatement
    {
         late LocalVariableDeclaration _LocalVariableDeclaration;
         late AstToken _SEMICOLON;

         LocalVariableDeclaration getLocalVariableDeclaration(){ return _LocalVariableDeclaration; }
         void setLocalVariableDeclaration(LocalVariableDeclaration _LocalVariableDeclaration){ this._LocalVariableDeclaration = _LocalVariableDeclaration; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        LocalVariableDeclarationStatement(IToken leftIToken, IToken rightIToken,
                                          LocalVariableDeclaration _LocalVariableDeclaration,
                                          AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._LocalVariableDeclaration = _LocalVariableDeclaration;
            (_LocalVariableDeclaration as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _LocalVariableDeclaration)  list.add(_LocalVariableDeclaration);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitLocalVariableDeclarationStatement(this);
            if (checkChildren)
            {
                _LocalVariableDeclaration.accept(v);
                _SEMICOLON.accept(v);
            }
            v.endVisitLocalVariableDeclarationStatement(this);
        }
    }

/**
 *<b>
*<li>Rule 257:  LocalVariableDeclaration ::= VariableModifiersopt Type VariableDeclarators
 *</b>
 */
class LocalVariableDeclaration extends Ast implements ILocalVariableDeclaration
    {
         late IVariableModifiersopt? _VariableModifiersopt;
         late IType _Type;
         late IVariableDeclarators _VariableDeclarators;

        /**
         * The value returned by <b>getVariableModifiersopt</b> may be <b>null</b>
         */
         IVariableModifiersopt ?  getVariableModifiersopt(){ return _VariableModifiersopt; }
         void setVariableModifiersopt(IVariableModifiersopt _VariableModifiersopt){ this._VariableModifiersopt = _VariableModifiersopt; }
         IType getType(){ return _Type; }
         void setType(IType _Type){ this._Type = _Type; }
         IVariableDeclarators getVariableDeclarators(){ return _VariableDeclarators; }
         void setVariableDeclarators(IVariableDeclarators _VariableDeclarators){ this._VariableDeclarators = _VariableDeclarators; }

        LocalVariableDeclaration(IToken leftIToken, IToken rightIToken,
                                 IVariableModifiersopt? _VariableModifiersopt,
                                 IType _Type,
                                 IVariableDeclarators _VariableDeclarators)
            :super(leftIToken, rightIToken)

        {
            this._VariableModifiersopt = _VariableModifiersopt;
            if (null != _VariableModifiersopt) (_VariableModifiersopt as Ast).setParent(this);
            this._Type = _Type;
            (_Type as Ast).setParent(this);
            this._VariableDeclarators = _VariableDeclarators;
            (_VariableDeclarators as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _VariableModifiersopt)  list.add(_VariableModifiersopt);
            if(null != _Type)  list.add(_Type);
            if(null != _VariableDeclarators)  list.add(_VariableDeclarators);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitLocalVariableDeclaration(this);
            if (checkChildren)
            {
                if (null != _VariableModifiersopt) _VariableModifiersopt!.accept(v);
                _Type.accept(v);
                _VariableDeclarators.accept(v);
            }
            v.endVisitLocalVariableDeclaration(this);
        }
    }

/**
 *<b>
*<li>Rule 281:  IfThenStatement ::= if ( Expression ) Statement
 *</b>
 */
class IfThenStatement extends Ast implements IIfThenStatement
    {
         late AstToken _if;
         late AstToken _LPAREN;
         late IExpression _Expression;
         late AstToken _RPAREN;
         late IStatement _Statement;

         AstToken getif(){ return _if; }
         void setif(AstToken _if){ this._if = _if; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
         IExpression getExpression(){ return _Expression; }
         void setExpression(IExpression _Expression){ this._Expression = _Expression; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
         IStatement getStatement(){ return _Statement; }
         void setStatement(IStatement _Statement){ this._Statement = _Statement; }

        IfThenStatement(IToken leftIToken, IToken rightIToken,
                        AstToken _if,
                        AstToken _LPAREN,
                        IExpression _Expression,
                        AstToken _RPAREN,
                        IStatement _Statement)
            :super(leftIToken, rightIToken)

        {
            this._if = _if;
            (_if as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._Expression = _Expression;
            (_Expression as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._Statement = _Statement;
            (_Statement as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _if)  list.add(_if);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _Expression)  list.add(_Expression);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _Statement)  list.add(_Statement);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitIfThenStatement(this);
            if (checkChildren)
            {
                _if.accept(v);
                _LPAREN.accept(v);
                _Expression.accept(v);
                _RPAREN.accept(v);
                _Statement.accept(v);
            }
            v.endVisitIfThenStatement(this);
        }
    }

/**
 *<b>
*<li>Rule 282:  IfThenElseStatement ::= if ( Expression ) StatementNoShortIf else Statement
 *</b>
 */
class IfThenElseStatement extends Ast implements IIfThenElseStatement
    {
         late AstToken _if;
         late AstToken _LPAREN;
         late IExpression _Expression;
         late AstToken _RPAREN;
         late IStatementNoShortIf _StatementNoShortIf;
         late AstToken _else;
         late IStatement _Statement;

         AstToken getif(){ return _if; }
         void setif(AstToken _if){ this._if = _if; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
         IExpression getExpression(){ return _Expression; }
         void setExpression(IExpression _Expression){ this._Expression = _Expression; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
         IStatementNoShortIf getStatementNoShortIf(){ return _StatementNoShortIf; }
         void setStatementNoShortIf(IStatementNoShortIf _StatementNoShortIf){ this._StatementNoShortIf = _StatementNoShortIf; }
         AstToken getelse(){ return _else; }
         void setelse(AstToken _else){ this._else = _else; }
         IStatement getStatement(){ return _Statement; }
         void setStatement(IStatement _Statement){ this._Statement = _Statement; }

        IfThenElseStatement(IToken leftIToken, IToken rightIToken,
                            AstToken _if,
                            AstToken _LPAREN,
                            IExpression _Expression,
                            AstToken _RPAREN,
                            IStatementNoShortIf _StatementNoShortIf,
                            AstToken _else,
                            IStatement _Statement)
            :super(leftIToken, rightIToken)

        {
            this._if = _if;
            (_if as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._Expression = _Expression;
            (_Expression as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._StatementNoShortIf = _StatementNoShortIf;
            (_StatementNoShortIf as Ast).setParent(this);
            this._else = _else;
            (_else as Ast).setParent(this);
            this._Statement = _Statement;
            (_Statement as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _if)  list.add(_if);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _Expression)  list.add(_Expression);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _StatementNoShortIf)  list.add(_StatementNoShortIf);
            if(null != _else)  list.add(_else);
            if(null != _Statement)  list.add(_Statement);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitIfThenElseStatement(this);
            if (checkChildren)
            {
                _if.accept(v);
                _LPAREN.accept(v);
                _Expression.accept(v);
                _RPAREN.accept(v);
                _StatementNoShortIf.accept(v);
                _else.accept(v);
                _Statement.accept(v);
            }
            v.endVisitIfThenElseStatement(this);
        }
    }

/**
 *<b>
*<li>Rule 283:  IfThenElseStatementNoShortIf ::= if ( Expression ) StatementNoShortIf else StatementNoShortIf
 *</b>
 */
class IfThenElseStatementNoShortIf extends Ast implements IIfThenElseStatementNoShortIf
    {
         late AstToken _if;
         late AstToken _LPAREN;
         late IExpression _Expression;
         late AstToken _RPAREN;
         late IStatementNoShortIf _StatementNoShortIf;
         late AstToken _else;
         late IStatementNoShortIf _StatementNoShortIf7;

         AstToken getif(){ return _if; }
         void setif(AstToken _if){ this._if = _if; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
         IExpression getExpression(){ return _Expression; }
         void setExpression(IExpression _Expression){ this._Expression = _Expression; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
         IStatementNoShortIf getStatementNoShortIf(){ return _StatementNoShortIf; }
         void setStatementNoShortIf(IStatementNoShortIf _StatementNoShortIf){ this._StatementNoShortIf = _StatementNoShortIf; }
         AstToken getelse(){ return _else; }
         void setelse(AstToken _else){ this._else = _else; }
         IStatementNoShortIf getStatementNoShortIf7(){ return _StatementNoShortIf7; }
         void setStatementNoShortIf7(IStatementNoShortIf _StatementNoShortIf7){ this._StatementNoShortIf7 = _StatementNoShortIf7; }

        IfThenElseStatementNoShortIf(IToken leftIToken, IToken rightIToken,
                                     AstToken _if,
                                     AstToken _LPAREN,
                                     IExpression _Expression,
                                     AstToken _RPAREN,
                                     IStatementNoShortIf _StatementNoShortIf,
                                     AstToken _else,
                                     IStatementNoShortIf _StatementNoShortIf7)
            :super(leftIToken, rightIToken)

        {
            this._if = _if;
            (_if as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._Expression = _Expression;
            (_Expression as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._StatementNoShortIf = _StatementNoShortIf;
            (_StatementNoShortIf as Ast).setParent(this);
            this._else = _else;
            (_else as Ast).setParent(this);
            this._StatementNoShortIf7 = _StatementNoShortIf7;
            (_StatementNoShortIf7 as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _if)  list.add(_if);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _Expression)  list.add(_Expression);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _StatementNoShortIf)  list.add(_StatementNoShortIf);
            if(null != _else)  list.add(_else);
            if(null != _StatementNoShortIf7)  list.add(_StatementNoShortIf7);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitIfThenElseStatementNoShortIf(this);
            if (checkChildren)
            {
                _if.accept(v);
                _LPAREN.accept(v);
                _Expression.accept(v);
                _RPAREN.accept(v);
                _StatementNoShortIf.accept(v);
                _else.accept(v);
                _StatementNoShortIf7.accept(v);
            }
            v.endVisitIfThenElseStatementNoShortIf(this);
        }
    }

/**
 *<b>
*<li>Rule 284:  EmptyStatement ::= ;
 *</b>
 */
class EmptyStatement extends AstToken implements IEmptyStatement
    {
         IToken getSEMICOLON(){ return leftIToken; }

    EmptyStatement(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitEmptyStatement(this);
            v.endVisitEmptyStatement(this);
        }
    }

/**
 *<b>
*<li>Rule 285:  LabeledStatement ::= identifier : Statement
 *</b>
 */
class LabeledStatement extends Ast implements ILabeledStatement
    {
         late identifier _identifier;
         late AstToken _COLON;
         late IStatement _Statement;

         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }
         AstToken getCOLON(){ return _COLON; }
         void setCOLON(AstToken _COLON){ this._COLON = _COLON; }
         IStatement getStatement(){ return _Statement; }
         void setStatement(IStatement _Statement){ this._Statement = _Statement; }

        LabeledStatement(IToken leftIToken, IToken rightIToken,
                         identifier _identifier,
                         AstToken _COLON,
                         IStatement _Statement)
            :super(leftIToken, rightIToken)

        {
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            this._COLON = _COLON;
            (_COLON as Ast).setParent(this);
            this._Statement = _Statement;
            (_Statement as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _identifier)  list.add(_identifier);
            if(null != _COLON)  list.add(_COLON);
            if(null != _Statement)  list.add(_Statement);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitLabeledStatement(this);
            if (checkChildren)
            {
                _identifier.accept(v);
                _COLON.accept(v);
                _Statement.accept(v);
            }
            v.endVisitLabeledStatement(this);
        }
    }

/**
 *<b>
*<li>Rule 286:  LabeledStatementNoShortIf ::= identifier : StatementNoShortIf
 *</b>
 */
class LabeledStatementNoShortIf extends Ast implements ILabeledStatementNoShortIf
    {
         late identifier _identifier;
         late AstToken _COLON;
         late IStatementNoShortIf _StatementNoShortIf;

         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }
         AstToken getCOLON(){ return _COLON; }
         void setCOLON(AstToken _COLON){ this._COLON = _COLON; }
         IStatementNoShortIf getStatementNoShortIf(){ return _StatementNoShortIf; }
         void setStatementNoShortIf(IStatementNoShortIf _StatementNoShortIf){ this._StatementNoShortIf = _StatementNoShortIf; }

        LabeledStatementNoShortIf(IToken leftIToken, IToken rightIToken,
                                  identifier _identifier,
                                  AstToken _COLON,
                                  IStatementNoShortIf _StatementNoShortIf)
            :super(leftIToken, rightIToken)

        {
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            this._COLON = _COLON;
            (_COLON as Ast).setParent(this);
            this._StatementNoShortIf = _StatementNoShortIf;
            (_StatementNoShortIf as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _identifier)  list.add(_identifier);
            if(null != _COLON)  list.add(_COLON);
            if(null != _StatementNoShortIf)  list.add(_StatementNoShortIf);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitLabeledStatementNoShortIf(this);
            if (checkChildren)
            {
                _identifier.accept(v);
                _COLON.accept(v);
                _StatementNoShortIf.accept(v);
            }
            v.endVisitLabeledStatementNoShortIf(this);
        }
    }

/**
 *<b>
*<li>Rule 287:  ExpressionStatement ::= StatementExpression ;
 *</b>
 */
class ExpressionStatement extends Ast implements IExpressionStatement
    {
         late IStatementExpression _StatementExpression;
         late AstToken _SEMICOLON;

         IStatementExpression getStatementExpression(){ return _StatementExpression; }
         void setStatementExpression(IStatementExpression _StatementExpression){ this._StatementExpression = _StatementExpression; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        ExpressionStatement(IToken leftIToken, IToken rightIToken,
                            IStatementExpression _StatementExpression,
                            AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._StatementExpression = _StatementExpression;
            (_StatementExpression as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _StatementExpression)  list.add(_StatementExpression);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitExpressionStatement(this);
            if (checkChildren)
            {
                _StatementExpression.accept(v);
                _SEMICOLON.accept(v);
            }
            v.endVisitExpressionStatement(this);
        }
    }

/**
 *<b>
*<li>Rule 297:  SwitchStatement ::= switch ( Expression ) SwitchBlock
 *</b>
 */
class SwitchStatement extends Ast implements ISwitchStatement
    {
         late AstToken _switch;
         late AstToken _LPAREN;
         late IExpression _Expression;
         late AstToken _RPAREN;
         late SwitchBlock _SwitchBlock;

         AstToken getswitch(){ return _switch; }
         void setswitch(AstToken _switch){ this._switch = _switch; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
         IExpression getExpression(){ return _Expression; }
         void setExpression(IExpression _Expression){ this._Expression = _Expression; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
         SwitchBlock getSwitchBlock(){ return _SwitchBlock; }
         void setSwitchBlock(SwitchBlock _SwitchBlock){ this._SwitchBlock = _SwitchBlock; }

        SwitchStatement(IToken leftIToken, IToken rightIToken,
                        AstToken _switch,
                        AstToken _LPAREN,
                        IExpression _Expression,
                        AstToken _RPAREN,
                        SwitchBlock _SwitchBlock)
            :super(leftIToken, rightIToken)

        {
            this._switch = _switch;
            (_switch as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._Expression = _Expression;
            (_Expression as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._SwitchBlock = _SwitchBlock;
            (_SwitchBlock as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _switch)  list.add(_switch);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _Expression)  list.add(_Expression);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _SwitchBlock)  list.add(_SwitchBlock);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitSwitchStatement(this);
            if (checkChildren)
            {
                _switch.accept(v);
                _LPAREN.accept(v);
                _Expression.accept(v);
                _RPAREN.accept(v);
                _SwitchBlock.accept(v);
            }
            v.endVisitSwitchStatement(this);
        }
    }

/**
 *<b>
*<li>Rule 298:  SwitchBlock ::= { SwitchBlockStatementGroupsopt SwitchLabelsopt }
 *</b>
 */
class SwitchBlock extends Ast implements ISwitchBlock
    {
         late AstToken _LBRACE;
         late ISwitchBlockStatementGroupsopt? _SwitchBlockStatementGroupsopt;
         late ISwitchLabelsopt? _SwitchLabelsopt;
         late AstToken _RBRACE;

         AstToken getLBRACE(){ return _LBRACE; }
         void setLBRACE(AstToken _LBRACE){ this._LBRACE = _LBRACE; }
        /**
         * The value returned by <b>getSwitchBlockStatementGroupsopt</b> may be <b>null</b>
         */
         ISwitchBlockStatementGroupsopt ?  getSwitchBlockStatementGroupsopt(){ return _SwitchBlockStatementGroupsopt; }
         void setSwitchBlockStatementGroupsopt(ISwitchBlockStatementGroupsopt _SwitchBlockStatementGroupsopt){ this._SwitchBlockStatementGroupsopt = _SwitchBlockStatementGroupsopt; }
        /**
         * The value returned by <b>getSwitchLabelsopt</b> may be <b>null</b>
         */
         ISwitchLabelsopt ?  getSwitchLabelsopt(){ return _SwitchLabelsopt; }
         void setSwitchLabelsopt(ISwitchLabelsopt _SwitchLabelsopt){ this._SwitchLabelsopt = _SwitchLabelsopt; }
         AstToken getRBRACE(){ return _RBRACE; }
         void setRBRACE(AstToken _RBRACE){ this._RBRACE = _RBRACE; }

        SwitchBlock(IToken leftIToken, IToken rightIToken,
                    AstToken _LBRACE,
                    ISwitchBlockStatementGroupsopt? _SwitchBlockStatementGroupsopt,
                    ISwitchLabelsopt? _SwitchLabelsopt,
                    AstToken _RBRACE)
            :super(leftIToken, rightIToken)

        {
            this._LBRACE = _LBRACE;
            (_LBRACE as Ast).setParent(this);
            this._SwitchBlockStatementGroupsopt = _SwitchBlockStatementGroupsopt;
            if (null != _SwitchBlockStatementGroupsopt) (_SwitchBlockStatementGroupsopt as Ast).setParent(this);
            this._SwitchLabelsopt = _SwitchLabelsopt;
            if (null != _SwitchLabelsopt) (_SwitchLabelsopt as Ast).setParent(this);
            this._RBRACE = _RBRACE;
            (_RBRACE as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _LBRACE)  list.add(_LBRACE);
            if(null != _SwitchBlockStatementGroupsopt)  list.add(_SwitchBlockStatementGroupsopt);
            if(null != _SwitchLabelsopt)  list.add(_SwitchLabelsopt);
            if(null != _RBRACE)  list.add(_RBRACE);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitSwitchBlock(this);
            if (checkChildren)
            {
                _LBRACE.accept(v);
                if (null != _SwitchBlockStatementGroupsopt) _SwitchBlockStatementGroupsopt!.accept(v);
                if (null != _SwitchLabelsopt) _SwitchLabelsopt!.accept(v);
                _RBRACE.accept(v);
            }
            v.endVisitSwitchBlock(this);
        }
    }

/**
 *<em>
*<li>Rule 299:  SwitchBlockStatementGroups ::= SwitchBlockStatementGroup
 *</em>
 *<p>
 *<b>
*<li>Rule 300:  SwitchBlockStatementGroups ::= SwitchBlockStatementGroups SwitchBlockStatementGroup
 *</b>
 */
class SwitchBlockStatementGroups extends Ast implements ISwitchBlockStatementGroups
    {
         late ISwitchBlockStatementGroups _SwitchBlockStatementGroups;
         late SwitchBlockStatementGroup _SwitchBlockStatementGroup;

         ISwitchBlockStatementGroups getSwitchBlockStatementGroups(){ return _SwitchBlockStatementGroups; }
         void setSwitchBlockStatementGroups(ISwitchBlockStatementGroups _SwitchBlockStatementGroups){ this._SwitchBlockStatementGroups = _SwitchBlockStatementGroups; }
         SwitchBlockStatementGroup getSwitchBlockStatementGroup(){ return _SwitchBlockStatementGroup; }
         void setSwitchBlockStatementGroup(SwitchBlockStatementGroup _SwitchBlockStatementGroup){ this._SwitchBlockStatementGroup = _SwitchBlockStatementGroup; }

        SwitchBlockStatementGroups(IToken leftIToken, IToken rightIToken,
                                   ISwitchBlockStatementGroups _SwitchBlockStatementGroups,
                                   SwitchBlockStatementGroup _SwitchBlockStatementGroup)
            :super(leftIToken, rightIToken)

        {
            this._SwitchBlockStatementGroups = _SwitchBlockStatementGroups;
            (_SwitchBlockStatementGroups as Ast).setParent(this);
            this._SwitchBlockStatementGroup = _SwitchBlockStatementGroup;
            (_SwitchBlockStatementGroup as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _SwitchBlockStatementGroups)  list.add(_SwitchBlockStatementGroups);
            if(null != _SwitchBlockStatementGroup)  list.add(_SwitchBlockStatementGroup);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitSwitchBlockStatementGroups(this);
            if (checkChildren)
            {
                _SwitchBlockStatementGroups.accept(v);
                _SwitchBlockStatementGroup.accept(v);
            }
            v.endVisitSwitchBlockStatementGroups(this);
        }
    }

/**
 *<b>
*<li>Rule 301:  SwitchBlockStatementGroup ::= SwitchLabels BlockStatements
 *</b>
 */
class SwitchBlockStatementGroup extends Ast implements ISwitchBlockStatementGroup
    {
         late ISwitchLabels _SwitchLabels;
         late IBlockStatements _BlockStatements;

         ISwitchLabels getSwitchLabels(){ return _SwitchLabels; }
         void setSwitchLabels(ISwitchLabels _SwitchLabels){ this._SwitchLabels = _SwitchLabels; }
         IBlockStatements getBlockStatements(){ return _BlockStatements; }
         void setBlockStatements(IBlockStatements _BlockStatements){ this._BlockStatements = _BlockStatements; }

        SwitchBlockStatementGroup(IToken leftIToken, IToken rightIToken,
                                  ISwitchLabels _SwitchLabels,
                                  IBlockStatements _BlockStatements)
            :super(leftIToken, rightIToken)

        {
            this._SwitchLabels = _SwitchLabels;
            (_SwitchLabels as Ast).setParent(this);
            this._BlockStatements = _BlockStatements;
            (_BlockStatements as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _SwitchLabels)  list.add(_SwitchLabels);
            if(null != _BlockStatements)  list.add(_BlockStatements);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitSwitchBlockStatementGroup(this);
            if (checkChildren)
            {
                _SwitchLabels.accept(v);
                _BlockStatements.accept(v);
            }
            v.endVisitSwitchBlockStatementGroup(this);
        }
    }

/**
 *<em>
*<li>Rule 302:  SwitchLabels ::= SwitchLabel
 *</em>
 *<p>
 *<b>
*<li>Rule 303:  SwitchLabels ::= SwitchLabels SwitchLabel
 *</b>
 */
class SwitchLabels extends Ast implements ISwitchLabels
    {
         late ISwitchLabels _SwitchLabels;
         late ISwitchLabel _SwitchLabel;

         ISwitchLabels getSwitchLabels(){ return _SwitchLabels; }
         void setSwitchLabels(ISwitchLabels _SwitchLabels){ this._SwitchLabels = _SwitchLabels; }
         ISwitchLabel getSwitchLabel(){ return _SwitchLabel; }
         void setSwitchLabel(ISwitchLabel _SwitchLabel){ this._SwitchLabel = _SwitchLabel; }

        SwitchLabels(IToken leftIToken, IToken rightIToken,
                     ISwitchLabels _SwitchLabels,
                     ISwitchLabel _SwitchLabel)
            :super(leftIToken, rightIToken)

        {
            this._SwitchLabels = _SwitchLabels;
            (_SwitchLabels as Ast).setParent(this);
            this._SwitchLabel = _SwitchLabel;
            (_SwitchLabel as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _SwitchLabels)  list.add(_SwitchLabels);
            if(null != _SwitchLabel)  list.add(_SwitchLabel);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitSwitchLabels(this);
            if (checkChildren)
            {
                _SwitchLabels.accept(v);
                _SwitchLabel.accept(v);
            }
            v.endVisitSwitchLabels(this);
        }
    }

/**
 *<b>
*<li>Rule 308:  WhileStatement ::= while ( Expression ) Statement
 *</b>
 */
class WhileStatement extends Ast implements IWhileStatement
    {
         late AstToken _while;
         late AstToken _LPAREN;
         late IExpression _Expression;
         late AstToken _RPAREN;
         late IStatement _Statement;

         AstToken getwhile(){ return _while; }
         void setwhile(AstToken _while){ this._while = _while; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
         IExpression getExpression(){ return _Expression; }
         void setExpression(IExpression _Expression){ this._Expression = _Expression; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
         IStatement getStatement(){ return _Statement; }
         void setStatement(IStatement _Statement){ this._Statement = _Statement; }

        WhileStatement(IToken leftIToken, IToken rightIToken,
                       AstToken _while,
                       AstToken _LPAREN,
                       IExpression _Expression,
                       AstToken _RPAREN,
                       IStatement _Statement)
            :super(leftIToken, rightIToken)

        {
            this._while = _while;
            (_while as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._Expression = _Expression;
            (_Expression as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._Statement = _Statement;
            (_Statement as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _while)  list.add(_while);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _Expression)  list.add(_Expression);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _Statement)  list.add(_Statement);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitWhileStatement(this);
            if (checkChildren)
            {
                _while.accept(v);
                _LPAREN.accept(v);
                _Expression.accept(v);
                _RPAREN.accept(v);
                _Statement.accept(v);
            }
            v.endVisitWhileStatement(this);
        }
    }

/**
 *<b>
*<li>Rule 309:  WhileStatementNoShortIf ::= while ( Expression ) StatementNoShortIf
 *</b>
 */
class WhileStatementNoShortIf extends Ast implements IWhileStatementNoShortIf
    {
         late AstToken _while;
         late AstToken _LPAREN;
         late IExpression _Expression;
         late AstToken _RPAREN;
         late IStatementNoShortIf _StatementNoShortIf;

         AstToken getwhile(){ return _while; }
         void setwhile(AstToken _while){ this._while = _while; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
         IExpression getExpression(){ return _Expression; }
         void setExpression(IExpression _Expression){ this._Expression = _Expression; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
         IStatementNoShortIf getStatementNoShortIf(){ return _StatementNoShortIf; }
         void setStatementNoShortIf(IStatementNoShortIf _StatementNoShortIf){ this._StatementNoShortIf = _StatementNoShortIf; }

        WhileStatementNoShortIf(IToken leftIToken, IToken rightIToken,
                                AstToken _while,
                                AstToken _LPAREN,
                                IExpression _Expression,
                                AstToken _RPAREN,
                                IStatementNoShortIf _StatementNoShortIf)
            :super(leftIToken, rightIToken)

        {
            this._while = _while;
            (_while as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._Expression = _Expression;
            (_Expression as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._StatementNoShortIf = _StatementNoShortIf;
            (_StatementNoShortIf as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _while)  list.add(_while);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _Expression)  list.add(_Expression);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _StatementNoShortIf)  list.add(_StatementNoShortIf);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitWhileStatementNoShortIf(this);
            if (checkChildren)
            {
                _while.accept(v);
                _LPAREN.accept(v);
                _Expression.accept(v);
                _RPAREN.accept(v);
                _StatementNoShortIf.accept(v);
            }
            v.endVisitWhileStatementNoShortIf(this);
        }
    }

/**
 *<b>
*<li>Rule 310:  DoStatement ::= do Statement while ( Expression ) ;
 *</b>
 */
class DoStatement extends Ast implements IDoStatement
    {
         late AstToken _do;
         late IStatement _Statement;
         late AstToken _while;
         late AstToken _LPAREN;
         late IExpression _Expression;
         late AstToken _RPAREN;
         late AstToken _SEMICOLON;

         AstToken getdo(){ return _do; }
         void setdo(AstToken _do){ this._do = _do; }
         IStatement getStatement(){ return _Statement; }
         void setStatement(IStatement _Statement){ this._Statement = _Statement; }
         AstToken getwhile(){ return _while; }
         void setwhile(AstToken _while){ this._while = _while; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
         IExpression getExpression(){ return _Expression; }
         void setExpression(IExpression _Expression){ this._Expression = _Expression; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        DoStatement(IToken leftIToken, IToken rightIToken,
                    AstToken _do,
                    IStatement _Statement,
                    AstToken _while,
                    AstToken _LPAREN,
                    IExpression _Expression,
                    AstToken _RPAREN,
                    AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._do = _do;
            (_do as Ast).setParent(this);
            this._Statement = _Statement;
            (_Statement as Ast).setParent(this);
            this._while = _while;
            (_while as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._Expression = _Expression;
            (_Expression as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _do)  list.add(_do);
            if(null != _Statement)  list.add(_Statement);
            if(null != _while)  list.add(_while);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _Expression)  list.add(_Expression);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitDoStatement(this);
            if (checkChildren)
            {
                _do.accept(v);
                _Statement.accept(v);
                _while.accept(v);
                _LPAREN.accept(v);
                _Expression.accept(v);
                _RPAREN.accept(v);
                _SEMICOLON.accept(v);
            }
            v.endVisitDoStatement(this);
        }
    }

/**
 *<b>
*<li>Rule 313:  BasicForStatement ::= for ( ForInitopt ; Expressionopt ; ForUpdateopt ) Statement
 *</b>
 */
class BasicForStatement extends Ast implements IBasicForStatement
    {
         late AstToken _for;
         late AstToken _LPAREN;
         late IForInitopt? _ForInitopt;
         late AstToken _SEMICOLON;
         late IExpressionopt? _Expressionopt;
         late AstToken _SEMICOLON6;
         late IForUpdateopt? _ForUpdateopt;
         late AstToken _RPAREN;
         late IStatement _Statement;

         AstToken getfor(){ return _for; }
         void setfor(AstToken _for){ this._for = _for; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
        /**
         * The value returned by <b>getForInitopt</b> may be <b>null</b>
         */
         IForInitopt ?  getForInitopt(){ return _ForInitopt; }
         void setForInitopt(IForInitopt _ForInitopt){ this._ForInitopt = _ForInitopt; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }
        /**
         * The value returned by <b>getExpressionopt</b> may be <b>null</b>
         */
         IExpressionopt ?  getExpressionopt(){ return _Expressionopt; }
         void setExpressionopt(IExpressionopt _Expressionopt){ this._Expressionopt = _Expressionopt; }
         AstToken getSEMICOLON6(){ return _SEMICOLON6; }
         void setSEMICOLON6(AstToken _SEMICOLON6){ this._SEMICOLON6 = _SEMICOLON6; }
        /**
         * The value returned by <b>getForUpdateopt</b> may be <b>null</b>
         */
         IForUpdateopt ?  getForUpdateopt(){ return _ForUpdateopt; }
         void setForUpdateopt(IForUpdateopt _ForUpdateopt){ this._ForUpdateopt = _ForUpdateopt; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
         IStatement getStatement(){ return _Statement; }
         void setStatement(IStatement _Statement){ this._Statement = _Statement; }

        BasicForStatement(IToken leftIToken, IToken rightIToken,
                          AstToken _for,
                          AstToken _LPAREN,
                          IForInitopt? _ForInitopt,
                          AstToken _SEMICOLON,
                          IExpressionopt? _Expressionopt,
                          AstToken _SEMICOLON6,
                          IForUpdateopt? _ForUpdateopt,
                          AstToken _RPAREN,
                          IStatement _Statement)
            :super(leftIToken, rightIToken)

        {
            this._for = _for;
            (_for as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._ForInitopt = _ForInitopt;
            if (null != _ForInitopt) (_ForInitopt as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            this._Expressionopt = _Expressionopt;
            if (null != _Expressionopt) (_Expressionopt as Ast).setParent(this);
            this._SEMICOLON6 = _SEMICOLON6;
            (_SEMICOLON6 as Ast).setParent(this);
            this._ForUpdateopt = _ForUpdateopt;
            if (null != _ForUpdateopt) (_ForUpdateopt as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._Statement = _Statement;
            (_Statement as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _for)  list.add(_for);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _ForInitopt)  list.add(_ForInitopt);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            if(null != _Expressionopt)  list.add(_Expressionopt);
            if(null != _SEMICOLON6)  list.add(_SEMICOLON6);
            if(null != _ForUpdateopt)  list.add(_ForUpdateopt);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _Statement)  list.add(_Statement);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitBasicForStatement(this);
            if (checkChildren)
            {
                _for.accept(v);
                _LPAREN.accept(v);
                if (null != _ForInitopt) _ForInitopt!.accept(v);
                _SEMICOLON.accept(v);
                if (null != _Expressionopt) _Expressionopt!.accept(v);
                _SEMICOLON6.accept(v);
                if (null != _ForUpdateopt) _ForUpdateopt!.accept(v);
                _RPAREN.accept(v);
                _Statement.accept(v);
            }
            v.endVisitBasicForStatement(this);
        }
    }

/**
 *<b>
*<li>Rule 314:  ForStatementNoShortIf ::= for ( ForInitopt ; Expressionopt ; ForUpdateopt ) StatementNoShortIf
 *</b>
 */
class ForStatementNoShortIf extends Ast implements IForStatementNoShortIf
    {
         late AstToken _for;
         late AstToken _LPAREN;
         late IForInitopt? _ForInitopt;
         late AstToken _SEMICOLON;
         late IExpressionopt? _Expressionopt;
         late AstToken _SEMICOLON6;
         late IForUpdateopt? _ForUpdateopt;
         late AstToken _RPAREN;
         late IStatementNoShortIf _StatementNoShortIf;

         AstToken getfor(){ return _for; }
         void setfor(AstToken _for){ this._for = _for; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
        /**
         * The value returned by <b>getForInitopt</b> may be <b>null</b>
         */
         IForInitopt ?  getForInitopt(){ return _ForInitopt; }
         void setForInitopt(IForInitopt _ForInitopt){ this._ForInitopt = _ForInitopt; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }
        /**
         * The value returned by <b>getExpressionopt</b> may be <b>null</b>
         */
         IExpressionopt ?  getExpressionopt(){ return _Expressionopt; }
         void setExpressionopt(IExpressionopt _Expressionopt){ this._Expressionopt = _Expressionopt; }
         AstToken getSEMICOLON6(){ return _SEMICOLON6; }
         void setSEMICOLON6(AstToken _SEMICOLON6){ this._SEMICOLON6 = _SEMICOLON6; }
        /**
         * The value returned by <b>getForUpdateopt</b> may be <b>null</b>
         */
         IForUpdateopt ?  getForUpdateopt(){ return _ForUpdateopt; }
         void setForUpdateopt(IForUpdateopt _ForUpdateopt){ this._ForUpdateopt = _ForUpdateopt; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
         IStatementNoShortIf getStatementNoShortIf(){ return _StatementNoShortIf; }
         void setStatementNoShortIf(IStatementNoShortIf _StatementNoShortIf){ this._StatementNoShortIf = _StatementNoShortIf; }

        ForStatementNoShortIf(IToken leftIToken, IToken rightIToken,
                              AstToken _for,
                              AstToken _LPAREN,
                              IForInitopt? _ForInitopt,
                              AstToken _SEMICOLON,
                              IExpressionopt? _Expressionopt,
                              AstToken _SEMICOLON6,
                              IForUpdateopt? _ForUpdateopt,
                              AstToken _RPAREN,
                              IStatementNoShortIf _StatementNoShortIf)
            :super(leftIToken, rightIToken)

        {
            this._for = _for;
            (_for as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._ForInitopt = _ForInitopt;
            if (null != _ForInitopt) (_ForInitopt as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            this._Expressionopt = _Expressionopt;
            if (null != _Expressionopt) (_Expressionopt as Ast).setParent(this);
            this._SEMICOLON6 = _SEMICOLON6;
            (_SEMICOLON6 as Ast).setParent(this);
            this._ForUpdateopt = _ForUpdateopt;
            if (null != _ForUpdateopt) (_ForUpdateopt as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._StatementNoShortIf = _StatementNoShortIf;
            (_StatementNoShortIf as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _for)  list.add(_for);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _ForInitopt)  list.add(_ForInitopt);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            if(null != _Expressionopt)  list.add(_Expressionopt);
            if(null != _SEMICOLON6)  list.add(_SEMICOLON6);
            if(null != _ForUpdateopt)  list.add(_ForUpdateopt);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _StatementNoShortIf)  list.add(_StatementNoShortIf);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitForStatementNoShortIf(this);
            if (checkChildren)
            {
                _for.accept(v);
                _LPAREN.accept(v);
                if (null != _ForInitopt) _ForInitopt!.accept(v);
                _SEMICOLON.accept(v);
                if (null != _Expressionopt) _Expressionopt!.accept(v);
                _SEMICOLON6.accept(v);
                if (null != _ForUpdateopt) _ForUpdateopt!.accept(v);
                _RPAREN.accept(v);
                _StatementNoShortIf.accept(v);
            }
            v.endVisitForStatementNoShortIf(this);
        }
    }

/**
 *<em>
*<li>Rule 318:  StatementExpressionList ::= StatementExpression
 *</em>
 *<p>
 *<b>
*<li>Rule 319:  StatementExpressionList ::= StatementExpressionList , StatementExpression
 *</b>
 */
class StatementExpressionList extends Ast implements IStatementExpressionList
    {
         late IStatementExpressionList _StatementExpressionList;
         late AstToken _COMMA;
         late IStatementExpression _StatementExpression;

         IStatementExpressionList getStatementExpressionList(){ return _StatementExpressionList; }
         void setStatementExpressionList(IStatementExpressionList _StatementExpressionList){ this._StatementExpressionList = _StatementExpressionList; }
         AstToken getCOMMA(){ return _COMMA; }
         void setCOMMA(AstToken _COMMA){ this._COMMA = _COMMA; }
         IStatementExpression getStatementExpression(){ return _StatementExpression; }
         void setStatementExpression(IStatementExpression _StatementExpression){ this._StatementExpression = _StatementExpression; }

        StatementExpressionList(IToken leftIToken, IToken rightIToken,
                                IStatementExpressionList _StatementExpressionList,
                                AstToken _COMMA,
                                IStatementExpression _StatementExpression)
            :super(leftIToken, rightIToken)

        {
            this._StatementExpressionList = _StatementExpressionList;
            (_StatementExpressionList as Ast).setParent(this);
            this._COMMA = _COMMA;
            (_COMMA as Ast).setParent(this);
            this._StatementExpression = _StatementExpression;
            (_StatementExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _StatementExpressionList)  list.add(_StatementExpressionList);
            if(null != _COMMA)  list.add(_COMMA);
            if(null != _StatementExpression)  list.add(_StatementExpression);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitStatementExpressionList(this);
            if (checkChildren)
            {
                _StatementExpressionList.accept(v);
                _COMMA.accept(v);
                _StatementExpression.accept(v);
            }
            v.endVisitStatementExpressionList(this);
        }
    }

/**
 *<b>
*<li>Rule 320:  EnhancedForStatement ::= for ( FormalParameter : Expression ) Statement
 *</b>
 */
class EnhancedForStatement extends Ast implements IEnhancedForStatement
    {
         late AstToken _for;
         late AstToken _LPAREN;
         late FormalParameter _FormalParameter;
         late AstToken _COLON;
         late IExpression _Expression;
         late AstToken _RPAREN;
         late IStatement _Statement;

         AstToken getfor(){ return _for; }
         void setfor(AstToken _for){ this._for = _for; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
         FormalParameter getFormalParameter(){ return _FormalParameter; }
         void setFormalParameter(FormalParameter _FormalParameter){ this._FormalParameter = _FormalParameter; }
         AstToken getCOLON(){ return _COLON; }
         void setCOLON(AstToken _COLON){ this._COLON = _COLON; }
         IExpression getExpression(){ return _Expression; }
         void setExpression(IExpression _Expression){ this._Expression = _Expression; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
         IStatement getStatement(){ return _Statement; }
         void setStatement(IStatement _Statement){ this._Statement = _Statement; }

        EnhancedForStatement(IToken leftIToken, IToken rightIToken,
                             AstToken _for,
                             AstToken _LPAREN,
                             FormalParameter _FormalParameter,
                             AstToken _COLON,
                             IExpression _Expression,
                             AstToken _RPAREN,
                             IStatement _Statement)
            :super(leftIToken, rightIToken)

        {
            this._for = _for;
            (_for as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._FormalParameter = _FormalParameter;
            (_FormalParameter as Ast).setParent(this);
            this._COLON = _COLON;
            (_COLON as Ast).setParent(this);
            this._Expression = _Expression;
            (_Expression as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._Statement = _Statement;
            (_Statement as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _for)  list.add(_for);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _FormalParameter)  list.add(_FormalParameter);
            if(null != _COLON)  list.add(_COLON);
            if(null != _Expression)  list.add(_Expression);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _Statement)  list.add(_Statement);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitEnhancedForStatement(this);
            if (checkChildren)
            {
                _for.accept(v);
                _LPAREN.accept(v);
                _FormalParameter.accept(v);
                _COLON.accept(v);
                _Expression.accept(v);
                _RPAREN.accept(v);
                _Statement.accept(v);
            }
            v.endVisitEnhancedForStatement(this);
        }
    }

/**
 *<b>
*<li>Rule 321:  BreakStatement ::= break identifieropt ;
 *</b>
 */
class BreakStatement extends Ast implements IBreakStatement
    {
         late AstToken _break;
         late identifier? _identifieropt;
         late AstToken _SEMICOLON;

         AstToken getbreak(){ return _break; }
         void setbreak(AstToken _break){ this._break = _break; }
        /**
         * The value returned by <b>getidentifieropt</b> may be <b>null</b>
         */
         identifier ?  getidentifieropt(){ return _identifieropt; }
         void setidentifieropt(identifier _identifieropt){ this._identifieropt = _identifieropt; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        BreakStatement(IToken leftIToken, IToken rightIToken,
                       AstToken _break,
                       identifier? _identifieropt,
                       AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._break = _break;
            (_break as Ast).setParent(this);
            this._identifieropt = _identifieropt;
            if (null != _identifieropt) (_identifieropt as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _break)  list.add(_break);
            if(null != _identifieropt)  list.add(_identifieropt);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitBreakStatement(this);
            if (checkChildren)
            {
                _break.accept(v);
                if (null != _identifieropt) _identifieropt!.accept(v);
                _SEMICOLON.accept(v);
            }
            v.endVisitBreakStatement(this);
        }
    }

/**
 *<b>
*<li>Rule 322:  ContinueStatement ::= continue identifieropt ;
 *</b>
 */
class ContinueStatement extends Ast implements IContinueStatement
    {
         late AstToken _continue;
         late identifier? _identifieropt;
         late AstToken _SEMICOLON;

         AstToken getcontinue(){ return _continue; }
         void setcontinue(AstToken _continue){ this._continue = _continue; }
        /**
         * The value returned by <b>getidentifieropt</b> may be <b>null</b>
         */
         identifier ?  getidentifieropt(){ return _identifieropt; }
         void setidentifieropt(identifier _identifieropt){ this._identifieropt = _identifieropt; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        ContinueStatement(IToken leftIToken, IToken rightIToken,
                          AstToken _continue,
                          identifier? _identifieropt,
                          AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._continue = _continue;
            (_continue as Ast).setParent(this);
            this._identifieropt = _identifieropt;
            if (null != _identifieropt) (_identifieropt as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _continue)  list.add(_continue);
            if(null != _identifieropt)  list.add(_identifieropt);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitContinueStatement(this);
            if (checkChildren)
            {
                _continue.accept(v);
                if (null != _identifieropt) _identifieropt!.accept(v);
                _SEMICOLON.accept(v);
            }
            v.endVisitContinueStatement(this);
        }
    }

/**
 *<b>
*<li>Rule 323:  ReturnStatement ::= return Expressionopt ;
 *</b>
 */
class ReturnStatement extends Ast implements IReturnStatement
    {
         late AstToken _return;
         late IExpressionopt? _Expressionopt;
         late AstToken _SEMICOLON;

         AstToken getreturn(){ return _return; }
         void setreturn(AstToken _return){ this._return = _return; }
        /**
         * The value returned by <b>getExpressionopt</b> may be <b>null</b>
         */
         IExpressionopt ?  getExpressionopt(){ return _Expressionopt; }
         void setExpressionopt(IExpressionopt _Expressionopt){ this._Expressionopt = _Expressionopt; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        ReturnStatement(IToken leftIToken, IToken rightIToken,
                        AstToken _return,
                        IExpressionopt? _Expressionopt,
                        AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._return = _return;
            (_return as Ast).setParent(this);
            this._Expressionopt = _Expressionopt;
            if (null != _Expressionopt) (_Expressionopt as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _return)  list.add(_return);
            if(null != _Expressionopt)  list.add(_Expressionopt);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitReturnStatement(this);
            if (checkChildren)
            {
                _return.accept(v);
                if (null != _Expressionopt) _Expressionopt!.accept(v);
                _SEMICOLON.accept(v);
            }
            v.endVisitReturnStatement(this);
        }
    }

/**
 *<b>
*<li>Rule 324:  ThrowStatement ::= throw Expression ;
 *</b>
 */
class ThrowStatement extends Ast implements IThrowStatement
    {
         late AstToken _throw;
         late IExpression _Expression;
         late AstToken _SEMICOLON;

         AstToken getthrow(){ return _throw; }
         void setthrow(AstToken _throw){ this._throw = _throw; }
         IExpression getExpression(){ return _Expression; }
         void setExpression(IExpression _Expression){ this._Expression = _Expression; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        ThrowStatement(IToken leftIToken, IToken rightIToken,
                       AstToken _throw,
                       IExpression _Expression,
                       AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._throw = _throw;
            (_throw as Ast).setParent(this);
            this._Expression = _Expression;
            (_Expression as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _throw)  list.add(_throw);
            if(null != _Expression)  list.add(_Expression);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitThrowStatement(this);
            if (checkChildren)
            {
                _throw.accept(v);
                _Expression.accept(v);
                _SEMICOLON.accept(v);
            }
            v.endVisitThrowStatement(this);
        }
    }

/**
 *<b>
*<li>Rule 325:  SynchronizedStatement ::= synchronized ( Expression ) Block
 *</b>
 */
class SynchronizedStatement extends Ast implements ISynchronizedStatement
    {
         late AstToken _synchronized;
         late AstToken _LPAREN;
         late IExpression _Expression;
         late AstToken _RPAREN;
         late Block _Block;

         AstToken getsynchronized(){ return _synchronized; }
         void setsynchronized(AstToken _synchronized){ this._synchronized = _synchronized; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
         IExpression getExpression(){ return _Expression; }
         void setExpression(IExpression _Expression){ this._Expression = _Expression; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
         Block getBlock(){ return _Block; }
         void setBlock(Block _Block){ this._Block = _Block; }

        SynchronizedStatement(IToken leftIToken, IToken rightIToken,
                              AstToken _synchronized,
                              AstToken _LPAREN,
                              IExpression _Expression,
                              AstToken _RPAREN,
                              Block _Block)
            :super(leftIToken, rightIToken)

        {
            this._synchronized = _synchronized;
            (_synchronized as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._Expression = _Expression;
            (_Expression as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._Block = _Block;
            (_Block as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _synchronized)  list.add(_synchronized);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _Expression)  list.add(_Expression);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _Block)  list.add(_Block);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitSynchronizedStatement(this);
            if (checkChildren)
            {
                _synchronized.accept(v);
                _LPAREN.accept(v);
                _Expression.accept(v);
                _RPAREN.accept(v);
                _Block.accept(v);
            }
            v.endVisitSynchronizedStatement(this);
        }
    }

/**
 *<em>
*<li>Rule 328:  Catches ::= CatchClause
 *</em>
 *<p>
 *<b>
*<li>Rule 329:  Catches ::= Catches CatchClause
 *</b>
 */
class Catches extends Ast implements ICatches
    {
         late ICatches _Catches;
         late CatchClause _CatchClause;

         ICatches getCatches(){ return _Catches; }
         void setCatches(ICatches _Catches){ this._Catches = _Catches; }
         CatchClause getCatchClause(){ return _CatchClause; }
         void setCatchClause(CatchClause _CatchClause){ this._CatchClause = _CatchClause; }

        Catches(IToken leftIToken, IToken rightIToken,
                ICatches _Catches,
                CatchClause _CatchClause)
            :super(leftIToken, rightIToken)

        {
            this._Catches = _Catches;
            (_Catches as Ast).setParent(this);
            this._CatchClause = _CatchClause;
            (_CatchClause as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _Catches)  list.add(_Catches);
            if(null != _CatchClause)  list.add(_CatchClause);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitCatches(this);
            if (checkChildren)
            {
                _Catches.accept(v);
                _CatchClause.accept(v);
            }
            v.endVisitCatches(this);
        }
    }

/**
 *<b>
*<li>Rule 330:  CatchClause ::= catch ( FormalParameter ) Block
 *</b>
 */
class CatchClause extends Ast implements ICatchClause
    {
         late AstToken _catch;
         late AstToken _LPAREN;
         late FormalParameter _FormalParameter;
         late AstToken _RPAREN;
         late Block _Block;

         AstToken getcatch(){ return _catch; }
         void setcatch(AstToken _catch){ this._catch = _catch; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
         FormalParameter getFormalParameter(){ return _FormalParameter; }
         void setFormalParameter(FormalParameter _FormalParameter){ this._FormalParameter = _FormalParameter; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
         Block getBlock(){ return _Block; }
         void setBlock(Block _Block){ this._Block = _Block; }

        CatchClause(IToken leftIToken, IToken rightIToken,
                    AstToken _catch,
                    AstToken _LPAREN,
                    FormalParameter _FormalParameter,
                    AstToken _RPAREN,
                    Block _Block)
            :super(leftIToken, rightIToken)

        {
            this._catch = _catch;
            (_catch as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._FormalParameter = _FormalParameter;
            (_FormalParameter as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._Block = _Block;
            (_Block as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _catch)  list.add(_catch);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _FormalParameter)  list.add(_FormalParameter);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _Block)  list.add(_Block);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitCatchClause(this);
            if (checkChildren)
            {
                _catch.accept(v);
                _LPAREN.accept(v);
                _FormalParameter.accept(v);
                _RPAREN.accept(v);
                _Block.accept(v);
            }
            v.endVisitCatchClause(this);
        }
    }

/**
 *<b>
*<li>Rule 331:  Finally ::= finally Block
 *</b>
 */
class Finally extends Ast implements IFinally
    {
         late AstToken _finally;
         late Block _Block;

         AstToken getfinally(){ return _finally; }
         void setfinally(AstToken _finally){ this._finally = _finally; }
         Block getBlock(){ return _Block; }
         void setBlock(Block _Block){ this._Block = _Block; }

        Finally(IToken leftIToken, IToken rightIToken,
                AstToken _finally,
                Block _Block)
            :super(leftIToken, rightIToken)

        {
            this._finally = _finally;
            (_finally as Ast).setParent(this);
            this._Block = _Block;
            (_Block as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _finally)  list.add(_finally);
            if(null != _Block)  list.add(_Block);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitFinally(this);
            if (checkChildren)
            {
                _finally.accept(v);
                _Block.accept(v);
            }
            v.endVisitFinally(this);
        }
    }

/**
 *<em>
*<li>Rule 356:  ArgumentList ::= Expression
 *</em>
 *<p>
 *<b>
*<li>Rule 357:  ArgumentList ::= ArgumentList , Expression
 *</b>
 */
class ArgumentList extends Ast implements IArgumentList
    {
         late IArgumentList _ArgumentList;
         late AstToken _COMMA;
         late IExpression _Expression;

         IArgumentList getArgumentList(){ return _ArgumentList; }
         void setArgumentList(IArgumentList _ArgumentList){ this._ArgumentList = _ArgumentList; }
         AstToken getCOMMA(){ return _COMMA; }
         void setCOMMA(AstToken _COMMA){ this._COMMA = _COMMA; }
         IExpression getExpression(){ return _Expression; }
         void setExpression(IExpression _Expression){ this._Expression = _Expression; }

        ArgumentList(IToken leftIToken, IToken rightIToken,
                     IArgumentList _ArgumentList,
                     AstToken _COMMA,
                     IExpression _Expression)
            :super(leftIToken, rightIToken)

        {
            this._ArgumentList = _ArgumentList;
            (_ArgumentList as Ast).setParent(this);
            this._COMMA = _COMMA;
            (_COMMA as Ast).setParent(this);
            this._Expression = _Expression;
            (_Expression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ArgumentList)  list.add(_ArgumentList);
            if(null != _COMMA)  list.add(_COMMA);
            if(null != _Expression)  list.add(_Expression);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitArgumentList(this);
            if (checkChildren)
            {
                _ArgumentList.accept(v);
                _COMMA.accept(v);
                _Expression.accept(v);
            }
            v.endVisitArgumentList(this);
        }
    }

/**
 *<em>
*<li>Rule 362:  DimExprs ::= DimExpr
 *</em>
 *<p>
 *<b>
*<li>Rule 363:  DimExprs ::= DimExprs DimExpr
 *</b>
 */
class DimExprs extends Ast implements IDimExprs
    {
         late IDimExprs _DimExprs;
         late DimExpr _DimExpr;

         IDimExprs getDimExprs(){ return _DimExprs; }
         void setDimExprs(IDimExprs _DimExprs){ this._DimExprs = _DimExprs; }
         DimExpr getDimExpr(){ return _DimExpr; }
         void setDimExpr(DimExpr _DimExpr){ this._DimExpr = _DimExpr; }

        DimExprs(IToken leftIToken, IToken rightIToken,
                 IDimExprs _DimExprs,
                 DimExpr _DimExpr)
            :super(leftIToken, rightIToken)

        {
            this._DimExprs = _DimExprs;
            (_DimExprs as Ast).setParent(this);
            this._DimExpr = _DimExpr;
            (_DimExpr as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _DimExprs)  list.add(_DimExprs);
            if(null != _DimExpr)  list.add(_DimExpr);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitDimExprs(this);
            if (checkChildren)
            {
                _DimExprs.accept(v);
                _DimExpr.accept(v);
            }
            v.endVisitDimExprs(this);
        }
    }

/**
 *<b>
*<li>Rule 364:  DimExpr ::= [ Expression ]
 *</b>
 */
class DimExpr extends Ast implements IDimExpr
    {
         late AstToken _LBRACKET;
         late IExpression _Expression;
         late AstToken _RBRACKET;

         AstToken getLBRACKET(){ return _LBRACKET; }
         void setLBRACKET(AstToken _LBRACKET){ this._LBRACKET = _LBRACKET; }
         IExpression getExpression(){ return _Expression; }
         void setExpression(IExpression _Expression){ this._Expression = _Expression; }
         AstToken getRBRACKET(){ return _RBRACKET; }
         void setRBRACKET(AstToken _RBRACKET){ this._RBRACKET = _RBRACKET; }

        DimExpr(IToken leftIToken, IToken rightIToken,
                AstToken _LBRACKET,
                IExpression _Expression,
                AstToken _RBRACKET)
            :super(leftIToken, rightIToken)

        {
            this._LBRACKET = _LBRACKET;
            (_LBRACKET as Ast).setParent(this);
            this._Expression = _Expression;
            (_Expression as Ast).setParent(this);
            this._RBRACKET = _RBRACKET;
            (_RBRACKET as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _LBRACKET)  list.add(_LBRACKET);
            if(null != _Expression)  list.add(_Expression);
            if(null != _RBRACKET)  list.add(_RBRACKET);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitDimExpr(this);
            if (checkChildren)
            {
                _LBRACKET.accept(v);
                _Expression.accept(v);
                _RBRACKET.accept(v);
            }
            v.endVisitDimExpr(this);
        }
    }

/**
 *<b>
*<li>Rule 381:  PostIncrementExpression ::= PostfixExpression ++
 *</b>
 */
class PostIncrementExpression extends Ast implements IPostIncrementExpression
    {
         late IPostfixExpression _PostfixExpression;
         late AstToken _PLUS_PLUS;

         IPostfixExpression getPostfixExpression(){ return _PostfixExpression; }
         void setPostfixExpression(IPostfixExpression _PostfixExpression){ this._PostfixExpression = _PostfixExpression; }
         AstToken getPLUS_PLUS(){ return _PLUS_PLUS; }
         void setPLUS_PLUS(AstToken _PLUS_PLUS){ this._PLUS_PLUS = _PLUS_PLUS; }

        PostIncrementExpression(IToken leftIToken, IToken rightIToken,
                                IPostfixExpression _PostfixExpression,
                                AstToken _PLUS_PLUS)
            :super(leftIToken, rightIToken)

        {
            this._PostfixExpression = _PostfixExpression;
            (_PostfixExpression as Ast).setParent(this);
            this._PLUS_PLUS = _PLUS_PLUS;
            (_PLUS_PLUS as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _PostfixExpression)  list.add(_PostfixExpression);
            if(null != _PLUS_PLUS)  list.add(_PLUS_PLUS);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitPostIncrementExpression(this);
            if (checkChildren)
            {
                _PostfixExpression.accept(v);
                _PLUS_PLUS.accept(v);
            }
            v.endVisitPostIncrementExpression(this);
        }
    }

/**
 *<b>
*<li>Rule 382:  PostDecrementExpression ::= PostfixExpression --
 *</b>
 */
class PostDecrementExpression extends Ast implements IPostDecrementExpression
    {
         late IPostfixExpression _PostfixExpression;
         late AstToken _MINUS_MINUS;

         IPostfixExpression getPostfixExpression(){ return _PostfixExpression; }
         void setPostfixExpression(IPostfixExpression _PostfixExpression){ this._PostfixExpression = _PostfixExpression; }
         AstToken getMINUS_MINUS(){ return _MINUS_MINUS; }
         void setMINUS_MINUS(AstToken _MINUS_MINUS){ this._MINUS_MINUS = _MINUS_MINUS; }

        PostDecrementExpression(IToken leftIToken, IToken rightIToken,
                                IPostfixExpression _PostfixExpression,
                                AstToken _MINUS_MINUS)
            :super(leftIToken, rightIToken)

        {
            this._PostfixExpression = _PostfixExpression;
            (_PostfixExpression as Ast).setParent(this);
            this._MINUS_MINUS = _MINUS_MINUS;
            (_MINUS_MINUS as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _PostfixExpression)  list.add(_PostfixExpression);
            if(null != _MINUS_MINUS)  list.add(_MINUS_MINUS);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitPostDecrementExpression(this);
            if (checkChildren)
            {
                _PostfixExpression.accept(v);
                _MINUS_MINUS.accept(v);
            }
            v.endVisitPostDecrementExpression(this);
        }
    }

/**
 *<b>
*<li>Rule 388:  PreIncrementExpression ::= ++ UnaryExpression
 *</b>
 */
class PreIncrementExpression extends Ast implements IPreIncrementExpression
    {
         late AstToken _PLUS_PLUS;
         late IUnaryExpression _UnaryExpression;

         AstToken getPLUS_PLUS(){ return _PLUS_PLUS; }
         void setPLUS_PLUS(AstToken _PLUS_PLUS){ this._PLUS_PLUS = _PLUS_PLUS; }
         IUnaryExpression getUnaryExpression(){ return _UnaryExpression; }
         void setUnaryExpression(IUnaryExpression _UnaryExpression){ this._UnaryExpression = _UnaryExpression; }

        PreIncrementExpression(IToken leftIToken, IToken rightIToken,
                               AstToken _PLUS_PLUS,
                               IUnaryExpression _UnaryExpression)
            :super(leftIToken, rightIToken)

        {
            this._PLUS_PLUS = _PLUS_PLUS;
            (_PLUS_PLUS as Ast).setParent(this);
            this._UnaryExpression = _UnaryExpression;
            (_UnaryExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _PLUS_PLUS)  list.add(_PLUS_PLUS);
            if(null != _UnaryExpression)  list.add(_UnaryExpression);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitPreIncrementExpression(this);
            if (checkChildren)
            {
                _PLUS_PLUS.accept(v);
                _UnaryExpression.accept(v);
            }
            v.endVisitPreIncrementExpression(this);
        }
    }

/**
 *<b>
*<li>Rule 389:  PreDecrementExpression ::= -- UnaryExpression
 *</b>
 */
class PreDecrementExpression extends Ast implements IPreDecrementExpression
    {
         late AstToken _MINUS_MINUS;
         late IUnaryExpression _UnaryExpression;

         AstToken getMINUS_MINUS(){ return _MINUS_MINUS; }
         void setMINUS_MINUS(AstToken _MINUS_MINUS){ this._MINUS_MINUS = _MINUS_MINUS; }
         IUnaryExpression getUnaryExpression(){ return _UnaryExpression; }
         void setUnaryExpression(IUnaryExpression _UnaryExpression){ this._UnaryExpression = _UnaryExpression; }

        PreDecrementExpression(IToken leftIToken, IToken rightIToken,
                               AstToken _MINUS_MINUS,
                               IUnaryExpression _UnaryExpression)
            :super(leftIToken, rightIToken)

        {
            this._MINUS_MINUS = _MINUS_MINUS;
            (_MINUS_MINUS as Ast).setParent(this);
            this._UnaryExpression = _UnaryExpression;
            (_UnaryExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _MINUS_MINUS)  list.add(_MINUS_MINUS);
            if(null != _UnaryExpression)  list.add(_UnaryExpression);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitPreDecrementExpression(this);
            if (checkChildren)
            {
                _MINUS_MINUS.accept(v);
                _UnaryExpression.accept(v);
            }
            v.endVisitPreDecrementExpression(this);
        }
    }

/**
 *<em>
*<li>Rule 416:  AndExpression ::= EqualityExpression
 *</em>
 *<p>
 *<b>
*<li>Rule 417:  AndExpression ::= AndExpression & EqualityExpression
 *</b>
 */
class AndExpression extends Ast implements IAndExpression
    {
         late IAndExpression _AndExpression;
         late AstToken _AND;
         late IEqualityExpression _EqualityExpression;

         IAndExpression getAndExpression(){ return _AndExpression; }
         void setAndExpression(IAndExpression _AndExpression){ this._AndExpression = _AndExpression; }
         AstToken getAND(){ return _AND; }
         void setAND(AstToken _AND){ this._AND = _AND; }
         IEqualityExpression getEqualityExpression(){ return _EqualityExpression; }
         void setEqualityExpression(IEqualityExpression _EqualityExpression){ this._EqualityExpression = _EqualityExpression; }

        AndExpression(IToken leftIToken, IToken rightIToken,
                      IAndExpression _AndExpression,
                      AstToken _AND,
                      IEqualityExpression _EqualityExpression)
            :super(leftIToken, rightIToken)

        {
            this._AndExpression = _AndExpression;
            (_AndExpression as Ast).setParent(this);
            this._AND = _AND;
            (_AND as Ast).setParent(this);
            this._EqualityExpression = _EqualityExpression;
            (_EqualityExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _AndExpression)  list.add(_AndExpression);
            if(null != _AND)  list.add(_AND);
            if(null != _EqualityExpression)  list.add(_EqualityExpression);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitAndExpression(this);
            if (checkChildren)
            {
                _AndExpression.accept(v);
                _AND.accept(v);
                _EqualityExpression.accept(v);
            }
            v.endVisitAndExpression(this);
        }
    }

/**
 *<em>
*<li>Rule 418:  ExclusiveOrExpression ::= AndExpression
 *</em>
 *<p>
 *<b>
*<li>Rule 419:  ExclusiveOrExpression ::= ExclusiveOrExpression ^ AndExpression
 *</b>
 */
class ExclusiveOrExpression extends Ast implements IExclusiveOrExpression
    {
         late IExclusiveOrExpression _ExclusiveOrExpression;
         late AstToken _XOR;
         late IAndExpression _AndExpression;

         IExclusiveOrExpression getExclusiveOrExpression(){ return _ExclusiveOrExpression; }
         void setExclusiveOrExpression(IExclusiveOrExpression _ExclusiveOrExpression){ this._ExclusiveOrExpression = _ExclusiveOrExpression; }
         AstToken getXOR(){ return _XOR; }
         void setXOR(AstToken _XOR){ this._XOR = _XOR; }
         IAndExpression getAndExpression(){ return _AndExpression; }
         void setAndExpression(IAndExpression _AndExpression){ this._AndExpression = _AndExpression; }

        ExclusiveOrExpression(IToken leftIToken, IToken rightIToken,
                              IExclusiveOrExpression _ExclusiveOrExpression,
                              AstToken _XOR,
                              IAndExpression _AndExpression)
            :super(leftIToken, rightIToken)

        {
            this._ExclusiveOrExpression = _ExclusiveOrExpression;
            (_ExclusiveOrExpression as Ast).setParent(this);
            this._XOR = _XOR;
            (_XOR as Ast).setParent(this);
            this._AndExpression = _AndExpression;
            (_AndExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ExclusiveOrExpression)  list.add(_ExclusiveOrExpression);
            if(null != _XOR)  list.add(_XOR);
            if(null != _AndExpression)  list.add(_AndExpression);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitExclusiveOrExpression(this);
            if (checkChildren)
            {
                _ExclusiveOrExpression.accept(v);
                _XOR.accept(v);
                _AndExpression.accept(v);
            }
            v.endVisitExclusiveOrExpression(this);
        }
    }

/**
 *<em>
*<li>Rule 420:  InclusiveOrExpression ::= ExclusiveOrExpression
 *</em>
 *<p>
 *<b>
*<li>Rule 421:  InclusiveOrExpression ::= InclusiveOrExpression | ExclusiveOrExpression
 *</b>
 */
class InclusiveOrExpression extends Ast implements IInclusiveOrExpression
    {
         late IInclusiveOrExpression _InclusiveOrExpression;
         late AstToken _OR;
         late IExclusiveOrExpression _ExclusiveOrExpression;

         IInclusiveOrExpression getInclusiveOrExpression(){ return _InclusiveOrExpression; }
         void setInclusiveOrExpression(IInclusiveOrExpression _InclusiveOrExpression){ this._InclusiveOrExpression = _InclusiveOrExpression; }
         AstToken getOR(){ return _OR; }
         void setOR(AstToken _OR){ this._OR = _OR; }
         IExclusiveOrExpression getExclusiveOrExpression(){ return _ExclusiveOrExpression; }
         void setExclusiveOrExpression(IExclusiveOrExpression _ExclusiveOrExpression){ this._ExclusiveOrExpression = _ExclusiveOrExpression; }

        InclusiveOrExpression(IToken leftIToken, IToken rightIToken,
                              IInclusiveOrExpression _InclusiveOrExpression,
                              AstToken _OR,
                              IExclusiveOrExpression _ExclusiveOrExpression)
            :super(leftIToken, rightIToken)

        {
            this._InclusiveOrExpression = _InclusiveOrExpression;
            (_InclusiveOrExpression as Ast).setParent(this);
            this._OR = _OR;
            (_OR as Ast).setParent(this);
            this._ExclusiveOrExpression = _ExclusiveOrExpression;
            (_ExclusiveOrExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _InclusiveOrExpression)  list.add(_InclusiveOrExpression);
            if(null != _OR)  list.add(_OR);
            if(null != _ExclusiveOrExpression)  list.add(_ExclusiveOrExpression);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitInclusiveOrExpression(this);
            if (checkChildren)
            {
                _InclusiveOrExpression.accept(v);
                _OR.accept(v);
                _ExclusiveOrExpression.accept(v);
            }
            v.endVisitInclusiveOrExpression(this);
        }
    }

/**
 *<em>
*<li>Rule 422:  ConditionalAndExpression ::= InclusiveOrExpression
 *</em>
 *<p>
 *<b>
*<li>Rule 423:  ConditionalAndExpression ::= ConditionalAndExpression && InclusiveOrExpression
 *</b>
 */
class ConditionalAndExpression extends Ast implements IConditionalAndExpression
    {
         late IConditionalAndExpression _ConditionalAndExpression;
         late AstToken _AND_AND;
         late IInclusiveOrExpression _InclusiveOrExpression;

         IConditionalAndExpression getConditionalAndExpression(){ return _ConditionalAndExpression; }
         void setConditionalAndExpression(IConditionalAndExpression _ConditionalAndExpression){ this._ConditionalAndExpression = _ConditionalAndExpression; }
         AstToken getAND_AND(){ return _AND_AND; }
         void setAND_AND(AstToken _AND_AND){ this._AND_AND = _AND_AND; }
         IInclusiveOrExpression getInclusiveOrExpression(){ return _InclusiveOrExpression; }
         void setInclusiveOrExpression(IInclusiveOrExpression _InclusiveOrExpression){ this._InclusiveOrExpression = _InclusiveOrExpression; }

        ConditionalAndExpression(IToken leftIToken, IToken rightIToken,
                                 IConditionalAndExpression _ConditionalAndExpression,
                                 AstToken _AND_AND,
                                 IInclusiveOrExpression _InclusiveOrExpression)
            :super(leftIToken, rightIToken)

        {
            this._ConditionalAndExpression = _ConditionalAndExpression;
            (_ConditionalAndExpression as Ast).setParent(this);
            this._AND_AND = _AND_AND;
            (_AND_AND as Ast).setParent(this);
            this._InclusiveOrExpression = _InclusiveOrExpression;
            (_InclusiveOrExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ConditionalAndExpression)  list.add(_ConditionalAndExpression);
            if(null != _AND_AND)  list.add(_AND_AND);
            if(null != _InclusiveOrExpression)  list.add(_InclusiveOrExpression);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitConditionalAndExpression(this);
            if (checkChildren)
            {
                _ConditionalAndExpression.accept(v);
                _AND_AND.accept(v);
                _InclusiveOrExpression.accept(v);
            }
            v.endVisitConditionalAndExpression(this);
        }
    }

/**
 *<em>
*<li>Rule 424:  ConditionalOrExpression ::= ConditionalAndExpression
 *</em>
 *<p>
 *<b>
*<li>Rule 425:  ConditionalOrExpression ::= ConditionalOrExpression || ConditionalAndExpression
 *</b>
 */
class ConditionalOrExpression extends Ast implements IConditionalOrExpression
    {
         late IConditionalOrExpression _ConditionalOrExpression;
         late AstToken _OR_OR;
         late IConditionalAndExpression _ConditionalAndExpression;

         IConditionalOrExpression getConditionalOrExpression(){ return _ConditionalOrExpression; }
         void setConditionalOrExpression(IConditionalOrExpression _ConditionalOrExpression){ this._ConditionalOrExpression = _ConditionalOrExpression; }
         AstToken getOR_OR(){ return _OR_OR; }
         void setOR_OR(AstToken _OR_OR){ this._OR_OR = _OR_OR; }
         IConditionalAndExpression getConditionalAndExpression(){ return _ConditionalAndExpression; }
         void setConditionalAndExpression(IConditionalAndExpression _ConditionalAndExpression){ this._ConditionalAndExpression = _ConditionalAndExpression; }

        ConditionalOrExpression(IToken leftIToken, IToken rightIToken,
                                IConditionalOrExpression _ConditionalOrExpression,
                                AstToken _OR_OR,
                                IConditionalAndExpression _ConditionalAndExpression)
            :super(leftIToken, rightIToken)

        {
            this._ConditionalOrExpression = _ConditionalOrExpression;
            (_ConditionalOrExpression as Ast).setParent(this);
            this._OR_OR = _OR_OR;
            (_OR_OR as Ast).setParent(this);
            this._ConditionalAndExpression = _ConditionalAndExpression;
            (_ConditionalAndExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ConditionalOrExpression)  list.add(_ConditionalOrExpression);
            if(null != _OR_OR)  list.add(_OR_OR);
            if(null != _ConditionalAndExpression)  list.add(_ConditionalAndExpression);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitConditionalOrExpression(this);
            if (checkChildren)
            {
                _ConditionalOrExpression.accept(v);
                _OR_OR.accept(v);
                _ConditionalAndExpression.accept(v);
            }
            v.endVisitConditionalOrExpression(this);
        }
    }

/**
 *<em>
*<li>Rule 426:  ConditionalExpression ::= ConditionalOrExpression
 *</em>
 *<p>
 *<b>
*<li>Rule 427:  ConditionalExpression ::= ConditionalOrExpression ? Expression : ConditionalExpression
 *</b>
 */
class ConditionalExpression extends Ast implements IConditionalExpression
    {
         late IConditionalOrExpression _ConditionalOrExpression;
         late AstToken _QUESTION;
         late IExpression _Expression;
         late AstToken _COLON;
         late IConditionalExpression _ConditionalExpression;

         IConditionalOrExpression getConditionalOrExpression(){ return _ConditionalOrExpression; }
         void setConditionalOrExpression(IConditionalOrExpression _ConditionalOrExpression){ this._ConditionalOrExpression = _ConditionalOrExpression; }
         AstToken getQUESTION(){ return _QUESTION; }
         void setQUESTION(AstToken _QUESTION){ this._QUESTION = _QUESTION; }
         IExpression getExpression(){ return _Expression; }
         void setExpression(IExpression _Expression){ this._Expression = _Expression; }
         AstToken getCOLON(){ return _COLON; }
         void setCOLON(AstToken _COLON){ this._COLON = _COLON; }
         IConditionalExpression getConditionalExpression(){ return _ConditionalExpression; }
         void setConditionalExpression(IConditionalExpression _ConditionalExpression){ this._ConditionalExpression = _ConditionalExpression; }

        ConditionalExpression(IToken leftIToken, IToken rightIToken,
                              IConditionalOrExpression _ConditionalOrExpression,
                              AstToken _QUESTION,
                              IExpression _Expression,
                              AstToken _COLON,
                              IConditionalExpression _ConditionalExpression)
            :super(leftIToken, rightIToken)

        {
            this._ConditionalOrExpression = _ConditionalOrExpression;
            (_ConditionalOrExpression as Ast).setParent(this);
            this._QUESTION = _QUESTION;
            (_QUESTION as Ast).setParent(this);
            this._Expression = _Expression;
            (_Expression as Ast).setParent(this);
            this._COLON = _COLON;
            (_COLON as Ast).setParent(this);
            this._ConditionalExpression = _ConditionalExpression;
            (_ConditionalExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ConditionalOrExpression)  list.add(_ConditionalOrExpression);
            if(null != _QUESTION)  list.add(_QUESTION);
            if(null != _Expression)  list.add(_Expression);
            if(null != _COLON)  list.add(_COLON);
            if(null != _ConditionalExpression)  list.add(_ConditionalExpression);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitConditionalExpression(this);
            if (checkChildren)
            {
                _ConditionalOrExpression.accept(v);
                _QUESTION.accept(v);
                _Expression.accept(v);
                _COLON.accept(v);
                _ConditionalExpression.accept(v);
            }
            v.endVisitConditionalExpression(this);
        }
    }

/**
 *<b>
*<li>Rule 430:  Assignment ::= LeftHandSide AssignmentOperator AssignmentExpression
 *</b>
 */
class Assignment extends Ast implements IAssignment
    {
         late ILeftHandSide _LeftHandSide;
         late IAssignmentOperator _AssignmentOperator;
         late IAssignmentExpression _AssignmentExpression;

         ILeftHandSide getLeftHandSide(){ return _LeftHandSide; }
         void setLeftHandSide(ILeftHandSide _LeftHandSide){ this._LeftHandSide = _LeftHandSide; }
         IAssignmentOperator getAssignmentOperator(){ return _AssignmentOperator; }
         void setAssignmentOperator(IAssignmentOperator _AssignmentOperator){ this._AssignmentOperator = _AssignmentOperator; }
         IAssignmentExpression getAssignmentExpression(){ return _AssignmentExpression; }
         void setAssignmentExpression(IAssignmentExpression _AssignmentExpression){ this._AssignmentExpression = _AssignmentExpression; }

        Assignment(IToken leftIToken, IToken rightIToken,
                   ILeftHandSide _LeftHandSide,
                   IAssignmentOperator _AssignmentOperator,
                   IAssignmentExpression _AssignmentExpression)
            :super(leftIToken, rightIToken)

        {
            this._LeftHandSide = _LeftHandSide;
            (_LeftHandSide as Ast).setParent(this);
            this._AssignmentOperator = _AssignmentOperator;
            (_AssignmentOperator as Ast).setParent(this);
            this._AssignmentExpression = _AssignmentExpression;
            (_AssignmentExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _LeftHandSide)  list.add(_LeftHandSide);
            if(null != _AssignmentOperator)  list.add(_AssignmentOperator);
            if(null != _AssignmentExpression)  list.add(_AssignmentExpression);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitAssignment(this);
            if (checkChildren)
            {
                _LeftHandSide.accept(v);
                _AssignmentOperator.accept(v);
                _AssignmentExpression.accept(v);
            }
            v.endVisitAssignment(this);
        }
    }

/**
 *<em>
*<li>Rule 492:  ,opt ::= %Empty
 *</em>
 *<p>
 *<b>
*<li>Rule 493:  ,opt ::= ,
 *</b>
 */
class Commaopt extends AstToken implements ICommaopt
    {
         IToken getCOMMA(){ return leftIToken; }

    Commaopt(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitCommaopt(this);
            v.endVisitCommaopt(this);
        }
    }

/**
 *<em>
*<li>Rule 504:  ...opt ::= %Empty
 *</em>
 *<p>
 *<b>
*<li>Rule 505:  ...opt ::= ...
 *</b>
 */
class Ellipsisopt extends AstToken implements IEllipsisopt
    {
         IToken getELLIPSIS(){ return leftIToken; }

    Ellipsisopt(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitEllipsisopt(this);
            v.endVisitEllipsisopt(this);
        }
    }

/**
 *<b>
*<li>Rule 5:  LPGUserAction ::= %BeginAction BlockStatementsopt %EndAction
 *</b>
 */
class LPGUserAction0 extends Ast implements ILPGUserAction
    {
         late AstToken _BeginAction;
         late IBlockStatementsopt? _BlockStatementsopt;
         late AstToken _EndAction;

         AstToken getBeginAction(){ return _BeginAction; }
         void setBeginAction(AstToken _BeginAction){ this._BeginAction = _BeginAction; }
        /**
         * The value returned by <b>getBlockStatementsopt</b> may be <b>null</b>
         */
         IBlockStatementsopt ?  getBlockStatementsopt(){ return _BlockStatementsopt; }
         void setBlockStatementsopt(IBlockStatementsopt _BlockStatementsopt){ this._BlockStatementsopt = _BlockStatementsopt; }
         AstToken getEndAction(){ return _EndAction; }
         void setEndAction(AstToken _EndAction){ this._EndAction = _EndAction; }

        LPGUserAction0(IToken leftIToken, IToken rightIToken,
                       AstToken _BeginAction,
                       IBlockStatementsopt? _BlockStatementsopt,
                       AstToken _EndAction)
            :super(leftIToken, rightIToken)

        {
            this._BeginAction = _BeginAction;
            (_BeginAction as Ast).setParent(this);
            this._BlockStatementsopt = _BlockStatementsopt;
            if (null != _BlockStatementsopt) (_BlockStatementsopt as Ast).setParent(this);
            this._EndAction = _EndAction;
            (_EndAction as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _BeginAction)  list.add(_BeginAction);
            if(null != _BlockStatementsopt)  list.add(_BlockStatementsopt);
            if(null != _EndAction)  list.add(_EndAction);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitLPGUserAction0(this);
            if (checkChildren)
            {
                _BeginAction.accept(v);
                if (null != _BlockStatementsopt) _BlockStatementsopt!.accept(v);
                _EndAction.accept(v);
            }
            v.endVisitLPGUserAction0(this);
        }
    }

/**
 *<b>
*<li>Rule 6:  LPGUserAction ::= $BeginJava BlockStatementsopt $EndJava
 *</b>
 */
class LPGUserAction1 extends Ast implements ILPGUserAction
    {
         late AstToken _BeginJava;
         late IBlockStatementsopt? _BlockStatementsopt;
         late AstToken _EndJava;

         AstToken getBeginJava(){ return _BeginJava; }
         void setBeginJava(AstToken _BeginJava){ this._BeginJava = _BeginJava; }
        /**
         * The value returned by <b>getBlockStatementsopt</b> may be <b>null</b>
         */
         IBlockStatementsopt ?  getBlockStatementsopt(){ return _BlockStatementsopt; }
         void setBlockStatementsopt(IBlockStatementsopt _BlockStatementsopt){ this._BlockStatementsopt = _BlockStatementsopt; }
         AstToken getEndJava(){ return _EndJava; }
         void setEndJava(AstToken _EndJava){ this._EndJava = _EndJava; }

        LPGUserAction1(IToken leftIToken, IToken rightIToken,
                       AstToken _BeginJava,
                       IBlockStatementsopt? _BlockStatementsopt,
                       AstToken _EndJava)
            :super(leftIToken, rightIToken)

        {
            this._BeginJava = _BeginJava;
            (_BeginJava as Ast).setParent(this);
            this._BlockStatementsopt = _BlockStatementsopt;
            if (null != _BlockStatementsopt) (_BlockStatementsopt as Ast).setParent(this);
            this._EndJava = _EndJava;
            (_EndJava as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _BeginJava)  list.add(_BeginJava);
            if(null != _BlockStatementsopt)  list.add(_BlockStatementsopt);
            if(null != _EndJava)  list.add(_EndJava);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitLPGUserAction1(this);
            if (checkChildren)
            {
                _BeginJava.accept(v);
                if (null != _BlockStatementsopt) _BlockStatementsopt!.accept(v);
                _EndJava.accept(v);
            }
            v.endVisitLPGUserAction1(this);
        }
    }

/**
 *<b>
*<li>Rule 7:  LPGUserAction ::= $NoAction
 *</b>
 */
class LPGUserAction2 extends AstToken implements ILPGUserAction
    {
         IToken getNoAction(){ return leftIToken; }

    LPGUserAction2(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitLPGUserAction2(this);
            v.endVisitLPGUserAction2(this);
        }
    }

/**
 *<b>
*<li>Rule 8:  LPGUserAction ::= $NullAction
 *</b>
 */
class LPGUserAction3 extends AstToken implements ILPGUserAction
    {
         IToken getNullAction(){ return leftIToken; }

    LPGUserAction3(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitLPGUserAction3(this);
            v.endVisitLPGUserAction3(this);
        }
    }

/**
 *<b>
*<li>Rule 9:  LPGUserAction ::= $BadAction
 *</b>
 */
class LPGUserAction4 extends AstToken implements ILPGUserAction
    {
         IToken getBadAction(){ return leftIToken; }

    LPGUserAction4(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitLPGUserAction4(this);
            v.endVisitLPGUserAction4(this);
        }
    }

/**
 *<b>
*<li>Rule 16:  IntegralType ::= byte
 *</b>
 */
class IntegralType0 extends AstToken implements IIntegralType
    {
         IToken getbyte(){ return leftIToken; }

    IntegralType0(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitIntegralType0(this);
            v.endVisitIntegralType0(this);
        }
    }

/**
 *<b>
*<li>Rule 17:  IntegralType ::= short
 *</b>
 */
class IntegralType1 extends AstToken implements IIntegralType
    {
         IToken getshort(){ return leftIToken; }

    IntegralType1(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitIntegralType1(this);
            v.endVisitIntegralType1(this);
        }
    }

/**
 *<b>
*<li>Rule 18:  IntegralType ::= int
 *</b>
 */
class IntegralType2 extends AstToken implements IIntegralType
    {
         IToken getint(){ return leftIToken; }

    IntegralType2(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitIntegralType2(this);
            v.endVisitIntegralType2(this);
        }
    }

/**
 *<b>
*<li>Rule 19:  IntegralType ::= long
 *</b>
 */
class IntegralType3 extends AstToken implements IIntegralType
    {
         IToken getlong(){ return leftIToken; }

    IntegralType3(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitIntegralType3(this);
            v.endVisitIntegralType3(this);
        }
    }

/**
 *<b>
*<li>Rule 20:  IntegralType ::= char
 *</b>
 */
class IntegralType4 extends AstToken implements IIntegralType
    {
         IToken getchar(){ return leftIToken; }

    IntegralType4(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitIntegralType4(this);
            v.endVisitIntegralType4(this);
        }
    }

/**
 *<b>
*<li>Rule 21:  FloatingPointType ::= float
 *</b>
 */
class FloatingPointType0 extends AstToken implements IFloatingPointType
    {
         IToken getfloat(){ return leftIToken; }

    FloatingPointType0(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitFloatingPointType0(this);
            v.endVisitFloatingPointType0(this);
        }
    }

/**
 *<b>
*<li>Rule 22:  FloatingPointType ::= double
 *</b>
 */
class FloatingPointType1 extends AstToken implements IFloatingPointType
    {
         IToken getdouble(){ return leftIToken; }

    FloatingPointType1(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitFloatingPointType1(this);
            v.endVisitFloatingPointType1(this);
        }
    }

/**
 *<b>
*<li>Rule 45:  WildcardBounds ::= extends ReferenceType
 *</b>
 */
class WildcardBounds0 extends Ast implements IWildcardBounds
    {
         late AstToken _extends;
         late IReferenceType _ReferenceType;

         AstToken getextends(){ return _extends; }
         void setextends(AstToken _extends){ this._extends = _extends; }
         IReferenceType getReferenceType(){ return _ReferenceType; }
         void setReferenceType(IReferenceType _ReferenceType){ this._ReferenceType = _ReferenceType; }

        WildcardBounds0(IToken leftIToken, IToken rightIToken,
                        AstToken _extends,
                        IReferenceType _ReferenceType)
            :super(leftIToken, rightIToken)

        {
            this._extends = _extends;
            (_extends as Ast).setParent(this);
            this._ReferenceType = _ReferenceType;
            (_ReferenceType as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _extends)  list.add(_extends);
            if(null != _ReferenceType)  list.add(_ReferenceType);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitWildcardBounds0(this);
            if (checkChildren)
            {
                _extends.accept(v);
                _ReferenceType.accept(v);
            }
            v.endVisitWildcardBounds0(this);
        }
    }

/**
 *<b>
*<li>Rule 46:  WildcardBounds ::= super ReferenceType
 *</b>
 */
class WildcardBounds1 extends Ast implements IWildcardBounds
    {
         late AstToken _super;
         late IReferenceType _ReferenceType;

         AstToken getsuper(){ return _super; }
         void setsuper(AstToken _super){ this._super = _super; }
         IReferenceType getReferenceType(){ return _ReferenceType; }
         void setReferenceType(IReferenceType _ReferenceType){ this._ReferenceType = _ReferenceType; }

        WildcardBounds1(IToken leftIToken, IToken rightIToken,
                        AstToken _super,
                        IReferenceType _ReferenceType)
            :super(leftIToken, rightIToken)

        {
            this._super = _super;
            (_super as Ast).setParent(this);
            this._ReferenceType = _ReferenceType;
            (_ReferenceType as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _super)  list.add(_super);
            if(null != _ReferenceType)  list.add(_ReferenceType);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitWildcardBounds1(this);
            if (checkChildren)
            {
                _super.accept(v);
                _ReferenceType.accept(v);
            }
            v.endVisitWildcardBounds1(this);
        }
    }

/**
 *<b>
*<li>Rule 80:  ClassModifier ::= public
 *</b>
 */
class ClassModifier0 extends AstToken implements IClassModifier
    {
         IToken getpublic(){ return leftIToken; }

    ClassModifier0(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitClassModifier0(this);
            v.endVisitClassModifier0(this);
        }
    }

/**
 *<b>
*<li>Rule 81:  ClassModifier ::= protected
 *</b>
 */
class ClassModifier1 extends AstToken implements IClassModifier
    {
         IToken getprotected(){ return leftIToken; }

    ClassModifier1(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitClassModifier1(this);
            v.endVisitClassModifier1(this);
        }
    }

/**
 *<b>
*<li>Rule 82:  ClassModifier ::= private
 *</b>
 */
class ClassModifier2 extends AstToken implements IClassModifier
    {
         IToken getprivate(){ return leftIToken; }

    ClassModifier2(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitClassModifier2(this);
            v.endVisitClassModifier2(this);
        }
    }

/**
 *<b>
*<li>Rule 83:  ClassModifier ::= abstract
 *</b>
 */
class ClassModifier3 extends AstToken implements IClassModifier
    {
         IToken getabstract(){ return leftIToken; }

    ClassModifier3(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitClassModifier3(this);
            v.endVisitClassModifier3(this);
        }
    }

/**
 *<b>
*<li>Rule 84:  ClassModifier ::= static
 *</b>
 */
class ClassModifier4 extends AstToken implements IClassModifier
    {
         IToken getstatic(){ return leftIToken; }

    ClassModifier4(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitClassModifier4(this);
            v.endVisitClassModifier4(this);
        }
    }

/**
 *<b>
*<li>Rule 85:  ClassModifier ::= final
 *</b>
 */
class ClassModifier5 extends AstToken implements IClassModifier
    {
         IToken getfinal(){ return leftIToken; }

    ClassModifier5(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitClassModifier5(this);
            v.endVisitClassModifier5(this);
        }
    }

/**
 *<b>
*<li>Rule 86:  ClassModifier ::= strictfp
 *</b>
 */
class ClassModifier6 extends AstToken implements IClassModifier
    {
         IToken getstrictfp(){ return leftIToken; }

    ClassModifier6(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitClassModifier6(this);
            v.endVisitClassModifier6(this);
        }
    }

/**
 *<b>
*<li>Rule 118:  FieldModifier ::= public
 *</b>
 */
class FieldModifier0 extends AstToken implements IFieldModifier
    {
         IToken getpublic(){ return leftIToken; }

    FieldModifier0(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitFieldModifier0(this);
            v.endVisitFieldModifier0(this);
        }
    }

/**
 *<b>
*<li>Rule 119:  FieldModifier ::= protected
 *</b>
 */
class FieldModifier1 extends AstToken implements IFieldModifier
    {
         IToken getprotected(){ return leftIToken; }

    FieldModifier1(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitFieldModifier1(this);
            v.endVisitFieldModifier1(this);
        }
    }

/**
 *<b>
*<li>Rule 120:  FieldModifier ::= private
 *</b>
 */
class FieldModifier2 extends AstToken implements IFieldModifier
    {
         IToken getprivate(){ return leftIToken; }

    FieldModifier2(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitFieldModifier2(this);
            v.endVisitFieldModifier2(this);
        }
    }

/**
 *<b>
*<li>Rule 121:  FieldModifier ::= static
 *</b>
 */
class FieldModifier3 extends AstToken implements IFieldModifier
    {
         IToken getstatic(){ return leftIToken; }

    FieldModifier3(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitFieldModifier3(this);
            v.endVisitFieldModifier3(this);
        }
    }

/**
 *<b>
*<li>Rule 122:  FieldModifier ::= final
 *</b>
 */
class FieldModifier4 extends AstToken implements IFieldModifier
    {
         IToken getfinal(){ return leftIToken; }

    FieldModifier4(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitFieldModifier4(this);
            v.endVisitFieldModifier4(this);
        }
    }

/**
 *<b>
*<li>Rule 123:  FieldModifier ::= transient
 *</b>
 */
class FieldModifier5 extends AstToken implements IFieldModifier
    {
         IToken gettransient(){ return leftIToken; }

    FieldModifier5(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitFieldModifier5(this);
            v.endVisitFieldModifier5(this);
        }
    }

/**
 *<b>
*<li>Rule 124:  FieldModifier ::= volatile
 *</b>
 */
class FieldModifier6 extends AstToken implements IFieldModifier
    {
         IToken getvolatile(){ return leftIToken; }

    FieldModifier6(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitFieldModifier6(this);
            v.endVisitFieldModifier6(this);
        }
    }

/**
 *<b>
*<li>Rule 129:  MethodDeclarator ::= identifier ( FormalParameterListopt )
 *</b>
 */
class MethodDeclarator0 extends Ast implements IMethodDeclarator
    {
         late identifier _identifier;
         late AstToken _LPAREN;
         late IFormalParameterListopt? _FormalParameterListopt;
         late AstToken _RPAREN;

         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
        /**
         * The value returned by <b>getFormalParameterListopt</b> may be <b>null</b>
         */
         IFormalParameterListopt ?  getFormalParameterListopt(){ return _FormalParameterListopt; }
         void setFormalParameterListopt(IFormalParameterListopt _FormalParameterListopt){ this._FormalParameterListopt = _FormalParameterListopt; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }

        MethodDeclarator0(IToken leftIToken, IToken rightIToken,
                          identifier _identifier,
                          AstToken _LPAREN,
                          IFormalParameterListopt? _FormalParameterListopt,
                          AstToken _RPAREN)
            :super(leftIToken, rightIToken)

        {
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._FormalParameterListopt = _FormalParameterListopt;
            if (null != _FormalParameterListopt) (_FormalParameterListopt as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _identifier)  list.add(_identifier);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _FormalParameterListopt)  list.add(_FormalParameterListopt);
            if(null != _RPAREN)  list.add(_RPAREN);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitMethodDeclarator0(this);
            if (checkChildren)
            {
                _identifier.accept(v);
                _LPAREN.accept(v);
                if (null != _FormalParameterListopt) _FormalParameterListopt!.accept(v);
                _RPAREN.accept(v);
            }
            v.endVisitMethodDeclarator0(this);
        }
    }

/**
 *<b>
*<li>Rule 130:  MethodDeclarator ::= MethodDeclarator [ ]
 *</b>
 */
class MethodDeclarator1 extends Ast implements IMethodDeclarator
    {
         late IMethodDeclarator _MethodDeclarator;
         late AstToken _LBRACKET;
         late AstToken _RBRACKET;

         IMethodDeclarator getMethodDeclarator(){ return _MethodDeclarator; }
         void setMethodDeclarator(IMethodDeclarator _MethodDeclarator){ this._MethodDeclarator = _MethodDeclarator; }
         AstToken getLBRACKET(){ return _LBRACKET; }
         void setLBRACKET(AstToken _LBRACKET){ this._LBRACKET = _LBRACKET; }
         AstToken getRBRACKET(){ return _RBRACKET; }
         void setRBRACKET(AstToken _RBRACKET){ this._RBRACKET = _RBRACKET; }

        MethodDeclarator1(IToken leftIToken, IToken rightIToken,
                          IMethodDeclarator _MethodDeclarator,
                          AstToken _LBRACKET,
                          AstToken _RBRACKET)
            :super(leftIToken, rightIToken)

        {
            this._MethodDeclarator = _MethodDeclarator;
            (_MethodDeclarator as Ast).setParent(this);
            this._LBRACKET = _LBRACKET;
            (_LBRACKET as Ast).setParent(this);
            this._RBRACKET = _RBRACKET;
            (_RBRACKET as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _MethodDeclarator)  list.add(_MethodDeclarator);
            if(null != _LBRACKET)  list.add(_LBRACKET);
            if(null != _RBRACKET)  list.add(_RBRACKET);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitMethodDeclarator1(this);
            if (checkChildren)
            {
                _MethodDeclarator.accept(v);
                _LBRACKET.accept(v);
                _RBRACKET.accept(v);
            }
            v.endVisitMethodDeclarator1(this);
        }
    }

/**
 *<b>
*<li>Rule 144:  MethodModifier ::= public
 *</b>
 */
class MethodModifier0 extends AstToken implements IMethodModifier
    {
         IToken getpublic(){ return leftIToken; }

    MethodModifier0(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitMethodModifier0(this);
            v.endVisitMethodModifier0(this);
        }
    }

/**
 *<b>
*<li>Rule 145:  MethodModifier ::= protected
 *</b>
 */
class MethodModifier1 extends AstToken implements IMethodModifier
    {
         IToken getprotected(){ return leftIToken; }

    MethodModifier1(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitMethodModifier1(this);
            v.endVisitMethodModifier1(this);
        }
    }

/**
 *<b>
*<li>Rule 146:  MethodModifier ::= private
 *</b>
 */
class MethodModifier2 extends AstToken implements IMethodModifier
    {
         IToken getprivate(){ return leftIToken; }

    MethodModifier2(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitMethodModifier2(this);
            v.endVisitMethodModifier2(this);
        }
    }

/**
 *<b>
*<li>Rule 147:  MethodModifier ::= abstract
 *</b>
 */
class MethodModifier3 extends AstToken implements IMethodModifier
    {
         IToken getabstract(){ return leftIToken; }

    MethodModifier3(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitMethodModifier3(this);
            v.endVisitMethodModifier3(this);
        }
    }

/**
 *<b>
*<li>Rule 148:  MethodModifier ::= static
 *</b>
 */
class MethodModifier4 extends AstToken implements IMethodModifier
    {
         IToken getstatic(){ return leftIToken; }

    MethodModifier4(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitMethodModifier4(this);
            v.endVisitMethodModifier4(this);
        }
    }

/**
 *<b>
*<li>Rule 149:  MethodModifier ::= final
 *</b>
 */
class MethodModifier5 extends AstToken implements IMethodModifier
    {
         IToken getfinal(){ return leftIToken; }

    MethodModifier5(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitMethodModifier5(this);
            v.endVisitMethodModifier5(this);
        }
    }

/**
 *<b>
*<li>Rule 150:  MethodModifier ::= synchronized
 *</b>
 */
class MethodModifier6 extends AstToken implements IMethodModifier
    {
         IToken getsynchronized(){ return leftIToken; }

    MethodModifier6(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitMethodModifier6(this);
            v.endVisitMethodModifier6(this);
        }
    }

/**
 *<b>
*<li>Rule 151:  MethodModifier ::= native
 *</b>
 */
class MethodModifier7 extends AstToken implements IMethodModifier
    {
         IToken getnative(){ return leftIToken; }

    MethodModifier7(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitMethodModifier7(this);
            v.endVisitMethodModifier7(this);
        }
    }

/**
 *<b>
*<li>Rule 152:  MethodModifier ::= strictfp
 *</b>
 */
class MethodModifier8 extends AstToken implements IMethodModifier
    {
         IToken getstrictfp(){ return leftIToken; }

    MethodModifier8(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitMethodModifier8(this);
            v.endVisitMethodModifier8(this);
        }
    }

/**
 *<b>
*<li>Rule 168:  ConstructorModifier ::= public
 *</b>
 */
class ConstructorModifier0 extends AstToken implements IConstructorModifier
    {
         IToken getpublic(){ return leftIToken; }

    ConstructorModifier0(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitConstructorModifier0(this);
            v.endVisitConstructorModifier0(this);
        }
    }

/**
 *<b>
*<li>Rule 169:  ConstructorModifier ::= protected
 *</b>
 */
class ConstructorModifier1 extends AstToken implements IConstructorModifier
    {
         IToken getprotected(){ return leftIToken; }

    ConstructorModifier1(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitConstructorModifier1(this);
            v.endVisitConstructorModifier1(this);
        }
    }

/**
 *<b>
*<li>Rule 170:  ConstructorModifier ::= private
 *</b>
 */
class ConstructorModifier2 extends AstToken implements IConstructorModifier
    {
         IToken getprivate(){ return leftIToken; }

    ConstructorModifier2(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitConstructorModifier2(this);
            v.endVisitConstructorModifier2(this);
        }
    }

/**
 *<b>
*<li>Rule 172:  ExplicitConstructorInvocation ::= TypeArgumentsopt this ( ArgumentListopt ) ;
 *</b>
 */
class ExplicitConstructorInvocation0 extends Ast implements IExplicitConstructorInvocation
    {
         late TypeArguments? _TypeArgumentsopt;
         late AstToken _this;
         late AstToken _LPAREN;
         late IArgumentListopt? _ArgumentListopt;
         late AstToken _RPAREN;
         late AstToken _SEMICOLON;

        /**
         * The value returned by <b>getTypeArgumentsopt</b> may be <b>null</b>
         */
         TypeArguments ?  getTypeArgumentsopt(){ return _TypeArgumentsopt; }
         void setTypeArgumentsopt(TypeArguments _TypeArgumentsopt){ this._TypeArgumentsopt = _TypeArgumentsopt; }
         AstToken getthis(){ return _this; }
         void setthis(AstToken _this){ this._this = _this; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
        /**
         * The value returned by <b>getArgumentListopt</b> may be <b>null</b>
         */
         IArgumentListopt ?  getArgumentListopt(){ return _ArgumentListopt; }
         void setArgumentListopt(IArgumentListopt _ArgumentListopt){ this._ArgumentListopt = _ArgumentListopt; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        ExplicitConstructorInvocation0(IToken leftIToken, IToken rightIToken,
                                       TypeArguments? _TypeArgumentsopt,
                                       AstToken _this,
                                       AstToken _LPAREN,
                                       IArgumentListopt? _ArgumentListopt,
                                       AstToken _RPAREN,
                                       AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._TypeArgumentsopt = _TypeArgumentsopt;
            if (null != _TypeArgumentsopt) (_TypeArgumentsopt as Ast).setParent(this);
            this._this = _this;
            (_this as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._ArgumentListopt = _ArgumentListopt;
            if (null != _ArgumentListopt) (_ArgumentListopt as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _TypeArgumentsopt)  list.add(_TypeArgumentsopt);
            if(null != _this)  list.add(_this);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _ArgumentListopt)  list.add(_ArgumentListopt);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitExplicitConstructorInvocation0(this);
            if (checkChildren)
            {
                if (null != _TypeArgumentsopt) _TypeArgumentsopt!.accept(v);
                _this.accept(v);
                _LPAREN.accept(v);
                if (null != _ArgumentListopt) _ArgumentListopt!.accept(v);
                _RPAREN.accept(v);
                _SEMICOLON.accept(v);
            }
            v.endVisitExplicitConstructorInvocation0(this);
        }
    }

/**
 *<b>
*<li>Rule 173:  ExplicitConstructorInvocation ::= TypeArgumentsopt super ( ArgumentListopt ) ;
 *</b>
 */
class ExplicitConstructorInvocation1 extends Ast implements IExplicitConstructorInvocation
    {
         late TypeArguments? _TypeArgumentsopt;
         late AstToken _super;
         late AstToken _LPAREN;
         late IArgumentListopt? _ArgumentListopt;
         late AstToken _RPAREN;
         late AstToken _SEMICOLON;

        /**
         * The value returned by <b>getTypeArgumentsopt</b> may be <b>null</b>
         */
         TypeArguments ?  getTypeArgumentsopt(){ return _TypeArgumentsopt; }
         void setTypeArgumentsopt(TypeArguments _TypeArgumentsopt){ this._TypeArgumentsopt = _TypeArgumentsopt; }
         AstToken getsuper(){ return _super; }
         void setsuper(AstToken _super){ this._super = _super; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
        /**
         * The value returned by <b>getArgumentListopt</b> may be <b>null</b>
         */
         IArgumentListopt ?  getArgumentListopt(){ return _ArgumentListopt; }
         void setArgumentListopt(IArgumentListopt _ArgumentListopt){ this._ArgumentListopt = _ArgumentListopt; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        ExplicitConstructorInvocation1(IToken leftIToken, IToken rightIToken,
                                       TypeArguments? _TypeArgumentsopt,
                                       AstToken _super,
                                       AstToken _LPAREN,
                                       IArgumentListopt? _ArgumentListopt,
                                       AstToken _RPAREN,
                                       AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._TypeArgumentsopt = _TypeArgumentsopt;
            if (null != _TypeArgumentsopt) (_TypeArgumentsopt as Ast).setParent(this);
            this._super = _super;
            (_super as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._ArgumentListopt = _ArgumentListopt;
            if (null != _ArgumentListopt) (_ArgumentListopt as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _TypeArgumentsopt)  list.add(_TypeArgumentsopt);
            if(null != _super)  list.add(_super);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _ArgumentListopt)  list.add(_ArgumentListopt);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitExplicitConstructorInvocation1(this);
            if (checkChildren)
            {
                if (null != _TypeArgumentsopt) _TypeArgumentsopt!.accept(v);
                _super.accept(v);
                _LPAREN.accept(v);
                if (null != _ArgumentListopt) _ArgumentListopt!.accept(v);
                _RPAREN.accept(v);
                _SEMICOLON.accept(v);
            }
            v.endVisitExplicitConstructorInvocation1(this);
        }
    }

/**
 *<b>
*<li>Rule 174:  ExplicitConstructorInvocation ::= Primary . TypeArgumentsopt super ( ArgumentListopt ) ;
 *</b>
 */
class ExplicitConstructorInvocation2 extends Ast implements IExplicitConstructorInvocation
    {
         late IPrimary _Primary;
         late AstToken _DOT;
         late TypeArguments? _TypeArgumentsopt;
         late AstToken _super;
         late AstToken _LPAREN;
         late IArgumentListopt? _ArgumentListopt;
         late AstToken _RPAREN;
         late AstToken _SEMICOLON;

         IPrimary getPrimary(){ return _Primary; }
         void setPrimary(IPrimary _Primary){ this._Primary = _Primary; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
        /**
         * The value returned by <b>getTypeArgumentsopt</b> may be <b>null</b>
         */
         TypeArguments ?  getTypeArgumentsopt(){ return _TypeArgumentsopt; }
         void setTypeArgumentsopt(TypeArguments _TypeArgumentsopt){ this._TypeArgumentsopt = _TypeArgumentsopt; }
         AstToken getsuper(){ return _super; }
         void setsuper(AstToken _super){ this._super = _super; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
        /**
         * The value returned by <b>getArgumentListopt</b> may be <b>null</b>
         */
         IArgumentListopt ?  getArgumentListopt(){ return _ArgumentListopt; }
         void setArgumentListopt(IArgumentListopt _ArgumentListopt){ this._ArgumentListopt = _ArgumentListopt; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        ExplicitConstructorInvocation2(IToken leftIToken, IToken rightIToken,
                                       IPrimary _Primary,
                                       AstToken _DOT,
                                       TypeArguments? _TypeArgumentsopt,
                                       AstToken _super,
                                       AstToken _LPAREN,
                                       IArgumentListopt? _ArgumentListopt,
                                       AstToken _RPAREN,
                                       AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._Primary = _Primary;
            (_Primary as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._TypeArgumentsopt = _TypeArgumentsopt;
            if (null != _TypeArgumentsopt) (_TypeArgumentsopt as Ast).setParent(this);
            this._super = _super;
            (_super as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._ArgumentListopt = _ArgumentListopt;
            if (null != _ArgumentListopt) (_ArgumentListopt as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _Primary)  list.add(_Primary);
            if(null != _DOT)  list.add(_DOT);
            if(null != _TypeArgumentsopt)  list.add(_TypeArgumentsopt);
            if(null != _super)  list.add(_super);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _ArgumentListopt)  list.add(_ArgumentListopt);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitExplicitConstructorInvocation2(this);
            if (checkChildren)
            {
                _Primary.accept(v);
                _DOT.accept(v);
                if (null != _TypeArgumentsopt) _TypeArgumentsopt!.accept(v);
                _super.accept(v);
                _LPAREN.accept(v);
                if (null != _ArgumentListopt) _ArgumentListopt!.accept(v);
                _RPAREN.accept(v);
                _SEMICOLON.accept(v);
            }
            v.endVisitExplicitConstructorInvocation2(this);
        }
    }

/**
 *<b>
*<li>Rule 188:  InterfaceModifier ::= public
 *</b>
 */
class InterfaceModifier0 extends AstToken implements IInterfaceModifier
    {
         IToken getpublic(){ return leftIToken; }

    InterfaceModifier0(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitInterfaceModifier0(this);
            v.endVisitInterfaceModifier0(this);
        }
    }

/**
 *<b>
*<li>Rule 189:  InterfaceModifier ::= protected
 *</b>
 */
class InterfaceModifier1 extends AstToken implements IInterfaceModifier
    {
         IToken getprotected(){ return leftIToken; }

    InterfaceModifier1(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitInterfaceModifier1(this);
            v.endVisitInterfaceModifier1(this);
        }
    }

/**
 *<b>
*<li>Rule 190:  InterfaceModifier ::= private
 *</b>
 */
class InterfaceModifier2 extends AstToken implements IInterfaceModifier
    {
         IToken getprivate(){ return leftIToken; }

    InterfaceModifier2(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitInterfaceModifier2(this);
            v.endVisitInterfaceModifier2(this);
        }
    }

/**
 *<b>
*<li>Rule 191:  InterfaceModifier ::= abstract
 *</b>
 */
class InterfaceModifier3 extends AstToken implements IInterfaceModifier
    {
         IToken getabstract(){ return leftIToken; }

    InterfaceModifier3(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitInterfaceModifier3(this);
            v.endVisitInterfaceModifier3(this);
        }
    }

/**
 *<b>
*<li>Rule 192:  InterfaceModifier ::= static
 *</b>
 */
class InterfaceModifier4 extends AstToken implements IInterfaceModifier
    {
         IToken getstatic(){ return leftIToken; }

    InterfaceModifier4(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitInterfaceModifier4(this);
            v.endVisitInterfaceModifier4(this);
        }
    }

/**
 *<b>
*<li>Rule 193:  InterfaceModifier ::= strictfp
 *</b>
 */
class InterfaceModifier5 extends AstToken implements IInterfaceModifier
    {
         IToken getstrictfp(){ return leftIToken; }

    InterfaceModifier5(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitInterfaceModifier5(this);
            v.endVisitInterfaceModifier5(this);
        }
    }

/**
 *<b>
*<li>Rule 194:  ExtendsInterfaces ::= extends InterfaceType
 *</b>
 */
class ExtendsInterfaces0 extends Ast implements IExtendsInterfaces
    {
         late AstToken _extends;
         late InterfaceType _InterfaceType;

         AstToken getextends(){ return _extends; }
         void setextends(AstToken _extends){ this._extends = _extends; }
         InterfaceType getInterfaceType(){ return _InterfaceType; }
         void setInterfaceType(InterfaceType _InterfaceType){ this._InterfaceType = _InterfaceType; }

        ExtendsInterfaces0(IToken leftIToken, IToken rightIToken,
                           AstToken _extends,
                           InterfaceType _InterfaceType)
            :super(leftIToken, rightIToken)

        {
            this._extends = _extends;
            (_extends as Ast).setParent(this);
            this._InterfaceType = _InterfaceType;
            (_InterfaceType as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _extends)  list.add(_extends);
            if(null != _InterfaceType)  list.add(_InterfaceType);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitExtendsInterfaces0(this);
            if (checkChildren)
            {
                _extends.accept(v);
                _InterfaceType.accept(v);
            }
            v.endVisitExtendsInterfaces0(this);
        }
    }

/**
 *<b>
*<li>Rule 195:  ExtendsInterfaces ::= ExtendsInterfaces , InterfaceType
 *</b>
 */
class ExtendsInterfaces1 extends Ast implements IExtendsInterfaces
    {
         late IExtendsInterfaces _ExtendsInterfaces;
         late AstToken _COMMA;
         late InterfaceType _InterfaceType;

         IExtendsInterfaces getExtendsInterfaces(){ return _ExtendsInterfaces; }
         void setExtendsInterfaces(IExtendsInterfaces _ExtendsInterfaces){ this._ExtendsInterfaces = _ExtendsInterfaces; }
         AstToken getCOMMA(){ return _COMMA; }
         void setCOMMA(AstToken _COMMA){ this._COMMA = _COMMA; }
         InterfaceType getInterfaceType(){ return _InterfaceType; }
         void setInterfaceType(InterfaceType _InterfaceType){ this._InterfaceType = _InterfaceType; }

        ExtendsInterfaces1(IToken leftIToken, IToken rightIToken,
                           IExtendsInterfaces _ExtendsInterfaces,
                           AstToken _COMMA,
                           InterfaceType _InterfaceType)
            :super(leftIToken, rightIToken)

        {
            this._ExtendsInterfaces = _ExtendsInterfaces;
            (_ExtendsInterfaces as Ast).setParent(this);
            this._COMMA = _COMMA;
            (_COMMA as Ast).setParent(this);
            this._InterfaceType = _InterfaceType;
            (_InterfaceType as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ExtendsInterfaces)  list.add(_ExtendsInterfaces);
            if(null != _COMMA)  list.add(_COMMA);
            if(null != _InterfaceType)  list.add(_InterfaceType);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitExtendsInterfaces1(this);
            if (checkChildren)
            {
                _ExtendsInterfaces.accept(v);
                _COMMA.accept(v);
                _InterfaceType.accept(v);
            }
            v.endVisitExtendsInterfaces1(this);
        }
    }

/**
 *<b>
*<li>Rule 208:  ConstantModifier ::= public
 *</b>
 */
class ConstantModifier0 extends AstToken implements IConstantModifier
    {
         IToken getpublic(){ return leftIToken; }

    ConstantModifier0(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitConstantModifier0(this);
            v.endVisitConstantModifier0(this);
        }
    }

/**
 *<b>
*<li>Rule 209:  ConstantModifier ::= static
 *</b>
 */
class ConstantModifier1 extends AstToken implements IConstantModifier
    {
         IToken getstatic(){ return leftIToken; }

    ConstantModifier1(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitConstantModifier1(this);
            v.endVisitConstantModifier1(this);
        }
    }

/**
 *<b>
*<li>Rule 210:  ConstantModifier ::= final
 *</b>
 */
class ConstantModifier2 extends AstToken implements IConstantModifier
    {
         IToken getfinal(){ return leftIToken; }

    ConstantModifier2(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitConstantModifier2(this);
            v.endVisitConstantModifier2(this);
        }
    }

/**
 *<b>
*<li>Rule 215:  AbstractMethodModifier ::= public
 *</b>
 */
class AbstractMethodModifier0 extends AstToken implements IAbstractMethodModifier
    {
         IToken getpublic(){ return leftIToken; }

    AbstractMethodModifier0(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitAbstractMethodModifier0(this);
            v.endVisitAbstractMethodModifier0(this);
        }
    }

/**
 *<b>
*<li>Rule 216:  AbstractMethodModifier ::= abstract
 *</b>
 */
class AbstractMethodModifier1 extends AstToken implements IAbstractMethodModifier
    {
         IToken getabstract(){ return leftIToken; }

    AbstractMethodModifier1(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitAbstractMethodModifier1(this);
            v.endVisitAbstractMethodModifier1(this);
        }
    }

/**
 *<b>
*<li>Rule 221:  AnnotationTypeElementDeclaration ::= AbstractMethodModifiersopt Type identifier ( ) DefaultValueopt ;
 *</b>
 */
class AnnotationTypeElementDeclaration0 extends Ast implements IAnnotationTypeElementDeclaration
    {
         late IAbstractMethodModifiersopt? _AbstractMethodModifiersopt;
         late IType _Type;
         late identifier _identifier;
         late AstToken _LPAREN;
         late AstToken _RPAREN;
         late DefaultValue? _DefaultValueopt;
         late AstToken _SEMICOLON;

        /**
         * The value returned by <b>getAbstractMethodModifiersopt</b> may be <b>null</b>
         */
         IAbstractMethodModifiersopt ?  getAbstractMethodModifiersopt(){ return _AbstractMethodModifiersopt; }
         void setAbstractMethodModifiersopt(IAbstractMethodModifiersopt _AbstractMethodModifiersopt){ this._AbstractMethodModifiersopt = _AbstractMethodModifiersopt; }
         IType getType(){ return _Type; }
         void setType(IType _Type){ this._Type = _Type; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
        /**
         * The value returned by <b>getDefaultValueopt</b> may be <b>null</b>
         */
         DefaultValue ?  getDefaultValueopt(){ return _DefaultValueopt; }
         void setDefaultValueopt(DefaultValue _DefaultValueopt){ this._DefaultValueopt = _DefaultValueopt; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        AnnotationTypeElementDeclaration0(IToken leftIToken, IToken rightIToken,
                                          IAbstractMethodModifiersopt? _AbstractMethodModifiersopt,
                                          IType _Type,
                                          identifier _identifier,
                                          AstToken _LPAREN,
                                          AstToken _RPAREN,
                                          DefaultValue? _DefaultValueopt,
                                          AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._AbstractMethodModifiersopt = _AbstractMethodModifiersopt;
            if (null != _AbstractMethodModifiersopt) (_AbstractMethodModifiersopt as Ast).setParent(this);
            this._Type = _Type;
            (_Type as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._DefaultValueopt = _DefaultValueopt;
            if (null != _DefaultValueopt) (_DefaultValueopt as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _AbstractMethodModifiersopt)  list.add(_AbstractMethodModifiersopt);
            if(null != _Type)  list.add(_Type);
            if(null != _identifier)  list.add(_identifier);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _DefaultValueopt)  list.add(_DefaultValueopt);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitAnnotationTypeElementDeclaration0(this);
            if (checkChildren)
            {
                if (null != _AbstractMethodModifiersopt) _AbstractMethodModifiersopt!.accept(v);
                _Type.accept(v);
                _identifier.accept(v);
                _LPAREN.accept(v);
                _RPAREN.accept(v);
                if (null != _DefaultValueopt) _DefaultValueopt!.accept(v);
                _SEMICOLON.accept(v);
            }
            v.endVisitAnnotationTypeElementDeclaration0(this);
        }
    }

/**
 *<b>
*<li>Rule 227:  AnnotationTypeElementDeclaration ::= ;
 *</b>
 */
class AnnotationTypeElementDeclaration1 extends AstToken implements IAnnotationTypeElementDeclaration
    {
         IToken getSEMICOLON(){ return leftIToken; }

    AnnotationTypeElementDeclaration1(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitAnnotationTypeElementDeclaration1(this);
            v.endVisitAnnotationTypeElementDeclaration1(this);
        }
    }

/**
 *<b>
*<li>Rule 295:  AssertStatement ::= assert Expression ;
 *</b>
 */
class AssertStatement0 extends Ast implements IAssertStatement
    {
         late AstToken _assert;
         late IExpression _Expression;
         late AstToken _SEMICOLON;

         AstToken getassert(){ return _assert; }
         void setassert(AstToken _assert){ this._assert = _assert; }
         IExpression getExpression(){ return _Expression; }
         void setExpression(IExpression _Expression){ this._Expression = _Expression; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        AssertStatement0(IToken leftIToken, IToken rightIToken,
                         AstToken _assert,
                         IExpression _Expression,
                         AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._assert = _assert;
            (_assert as Ast).setParent(this);
            this._Expression = _Expression;
            (_Expression as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _assert)  list.add(_assert);
            if(null != _Expression)  list.add(_Expression);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitAssertStatement0(this);
            if (checkChildren)
            {
                _assert.accept(v);
                _Expression.accept(v);
                _SEMICOLON.accept(v);
            }
            v.endVisitAssertStatement0(this);
        }
    }

/**
 *<b>
*<li>Rule 296:  AssertStatement ::= assert Expression : Expression ;
 *</b>
 */
class AssertStatement1 extends Ast implements IAssertStatement
    {
         late AstToken _assert;
         late IExpression _Expression;
         late AstToken _COLON;
         late IExpression _Expression4;
         late AstToken _SEMICOLON;

         AstToken getassert(){ return _assert; }
         void setassert(AstToken _assert){ this._assert = _assert; }
         IExpression getExpression(){ return _Expression; }
         void setExpression(IExpression _Expression){ this._Expression = _Expression; }
         AstToken getCOLON(){ return _COLON; }
         void setCOLON(AstToken _COLON){ this._COLON = _COLON; }
         IExpression getExpression4(){ return _Expression4; }
         void setExpression4(IExpression _Expression4){ this._Expression4 = _Expression4; }
         AstToken getSEMICOLON(){ return _SEMICOLON; }
         void setSEMICOLON(AstToken _SEMICOLON){ this._SEMICOLON = _SEMICOLON; }

        AssertStatement1(IToken leftIToken, IToken rightIToken,
                         AstToken _assert,
                         IExpression _Expression,
                         AstToken _COLON,
                         IExpression _Expression4,
                         AstToken _SEMICOLON)
            :super(leftIToken, rightIToken)

        {
            this._assert = _assert;
            (_assert as Ast).setParent(this);
            this._Expression = _Expression;
            (_Expression as Ast).setParent(this);
            this._COLON = _COLON;
            (_COLON as Ast).setParent(this);
            this._Expression4 = _Expression4;
            (_Expression4 as Ast).setParent(this);
            this._SEMICOLON = _SEMICOLON;
            (_SEMICOLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _assert)  list.add(_assert);
            if(null != _Expression)  list.add(_Expression);
            if(null != _COLON)  list.add(_COLON);
            if(null != _Expression4)  list.add(_Expression4);
            if(null != _SEMICOLON)  list.add(_SEMICOLON);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitAssertStatement1(this);
            if (checkChildren)
            {
                _assert.accept(v);
                _Expression.accept(v);
                _COLON.accept(v);
                _Expression4.accept(v);
                _SEMICOLON.accept(v);
            }
            v.endVisitAssertStatement1(this);
        }
    }

/**
 *<b>
*<li>Rule 304:  SwitchLabel ::= case ConstantExpression :
 *</b>
 */
class SwitchLabel0 extends Ast implements ISwitchLabel
    {
         late AstToken _case;
         late IConstantExpression _ConstantExpression;
         late AstToken _COLON;

         AstToken getcase(){ return _case; }
         void setcase(AstToken _case){ this._case = _case; }
         IConstantExpression getConstantExpression(){ return _ConstantExpression; }
         void setConstantExpression(IConstantExpression _ConstantExpression){ this._ConstantExpression = _ConstantExpression; }
         AstToken getCOLON(){ return _COLON; }
         void setCOLON(AstToken _COLON){ this._COLON = _COLON; }

        SwitchLabel0(IToken leftIToken, IToken rightIToken,
                     AstToken _case,
                     IConstantExpression _ConstantExpression,
                     AstToken _COLON)
            :super(leftIToken, rightIToken)

        {
            this._case = _case;
            (_case as Ast).setParent(this);
            this._ConstantExpression = _ConstantExpression;
            (_ConstantExpression as Ast).setParent(this);
            this._COLON = _COLON;
            (_COLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _case)  list.add(_case);
            if(null != _ConstantExpression)  list.add(_ConstantExpression);
            if(null != _COLON)  list.add(_COLON);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitSwitchLabel0(this);
            if (checkChildren)
            {
                _case.accept(v);
                _ConstantExpression.accept(v);
                _COLON.accept(v);
            }
            v.endVisitSwitchLabel0(this);
        }
    }

/**
 *<b>
*<li>Rule 305:  SwitchLabel ::= case EnumConstant :
 *</b>
 */
class SwitchLabel1 extends Ast implements ISwitchLabel
    {
         late AstToken _case;
         late IEnumConstant _EnumConstant;
         late AstToken _COLON;

         AstToken getcase(){ return _case; }
         void setcase(AstToken _case){ this._case = _case; }
         IEnumConstant getEnumConstant(){ return _EnumConstant; }
         void setEnumConstant(IEnumConstant _EnumConstant){ this._EnumConstant = _EnumConstant; }
         AstToken getCOLON(){ return _COLON; }
         void setCOLON(AstToken _COLON){ this._COLON = _COLON; }

        SwitchLabel1(IToken leftIToken, IToken rightIToken,
                     AstToken _case,
                     IEnumConstant _EnumConstant,
                     AstToken _COLON)
            :super(leftIToken, rightIToken)

        {
            this._case = _case;
            (_case as Ast).setParent(this);
            this._EnumConstant = _EnumConstant;
            (_EnumConstant as Ast).setParent(this);
            this._COLON = _COLON;
            (_COLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _case)  list.add(_case);
            if(null != _EnumConstant)  list.add(_EnumConstant);
            if(null != _COLON)  list.add(_COLON);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitSwitchLabel1(this);
            if (checkChildren)
            {
                _case.accept(v);
                _EnumConstant.accept(v);
                _COLON.accept(v);
            }
            v.endVisitSwitchLabel1(this);
        }
    }

/**
 *<b>
*<li>Rule 306:  SwitchLabel ::= default :
 *</b>
 */
class SwitchLabel2 extends Ast implements ISwitchLabel
    {
         late AstToken _default;
         late AstToken _COLON;

         AstToken getdefault(){ return _default; }
         void setdefault(AstToken _default){ this._default = _default; }
         AstToken getCOLON(){ return _COLON; }
         void setCOLON(AstToken _COLON){ this._COLON = _COLON; }

        SwitchLabel2(IToken leftIToken, IToken rightIToken,
                     AstToken _default,
                     AstToken _COLON)
            :super(leftIToken, rightIToken)

        {
            this._default = _default;
            (_default as Ast).setParent(this);
            this._COLON = _COLON;
            (_COLON as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _default)  list.add(_default);
            if(null != _COLON)  list.add(_COLON);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitSwitchLabel2(this);
            if (checkChildren)
            {
                _default.accept(v);
                _COLON.accept(v);
            }
            v.endVisitSwitchLabel2(this);
        }
    }

/**
 *<b>
*<li>Rule 326:  TryStatement ::= try Block Catches
 *</b>
 */
class TryStatement0 extends Ast implements ITryStatement
    {
         late AstToken _try;
         late Block _Block;
         late ICatches _Catches;

         AstToken gettry(){ return _try; }
         void settry(AstToken _try){ this._try = _try; }
         Block getBlock(){ return _Block; }
         void setBlock(Block _Block){ this._Block = _Block; }
         ICatches getCatches(){ return _Catches; }
         void setCatches(ICatches _Catches){ this._Catches = _Catches; }

        TryStatement0(IToken leftIToken, IToken rightIToken,
                      AstToken _try,
                      Block _Block,
                      ICatches _Catches)
            :super(leftIToken, rightIToken)

        {
            this._try = _try;
            (_try as Ast).setParent(this);
            this._Block = _Block;
            (_Block as Ast).setParent(this);
            this._Catches = _Catches;
            (_Catches as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _try)  list.add(_try);
            if(null != _Block)  list.add(_Block);
            if(null != _Catches)  list.add(_Catches);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitTryStatement0(this);
            if (checkChildren)
            {
                _try.accept(v);
                _Block.accept(v);
                _Catches.accept(v);
            }
            v.endVisitTryStatement0(this);
        }
    }

/**
 *<b>
*<li>Rule 327:  TryStatement ::= try Block Catchesopt Finally
 *</b>
 */
class TryStatement1 extends Ast implements ITryStatement
    {
         late AstToken _try;
         late Block _Block;
         late ICatchesopt? _Catchesopt;
         late Finally _Finally;

         AstToken gettry(){ return _try; }
         void settry(AstToken _try){ this._try = _try; }
         Block getBlock(){ return _Block; }
         void setBlock(Block _Block){ this._Block = _Block; }
        /**
         * The value returned by <b>getCatchesopt</b> may be <b>null</b>
         */
         ICatchesopt ?  getCatchesopt(){ return _Catchesopt; }
         void setCatchesopt(ICatchesopt _Catchesopt){ this._Catchesopt = _Catchesopt; }
         Finally getFinally(){ return _Finally; }
         void setFinally(Finally _Finally){ this._Finally = _Finally; }

        TryStatement1(IToken leftIToken, IToken rightIToken,
                      AstToken _try,
                      Block _Block,
                      ICatchesopt? _Catchesopt,
                      Finally _Finally)
            :super(leftIToken, rightIToken)

        {
            this._try = _try;
            (_try as Ast).setParent(this);
            this._Block = _Block;
            (_Block as Ast).setParent(this);
            this._Catchesopt = _Catchesopt;
            if (null != _Catchesopt) (_Catchesopt as Ast).setParent(this);
            this._Finally = _Finally;
            (_Finally as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _try)  list.add(_try);
            if(null != _Block)  list.add(_Block);
            if(null != _Catchesopt)  list.add(_Catchesopt);
            if(null != _Finally)  list.add(_Finally);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitTryStatement1(this);
            if (checkChildren)
            {
                _try.accept(v);
                _Block.accept(v);
                if (null != _Catchesopt) _Catchesopt!.accept(v);
                _Finally.accept(v);
            }
            v.endVisitTryStatement1(this);
        }
    }

/**
 *<b>
*<li>Rule 335:  PrimaryNoNewArray ::= Type . class
 *</b>
 */
class PrimaryNoNewArray0 extends Ast implements IPrimaryNoNewArray
    {
         late IType _Type;
         late AstToken _DOT;
         late AstToken _class;

         IType getType(){ return _Type; }
         void setType(IType _Type){ this._Type = _Type; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
         AstToken getclass(){ return _class; }
         void setclass(AstToken _class){ this._class = _class; }

        PrimaryNoNewArray0(IToken leftIToken, IToken rightIToken,
                           IType _Type,
                           AstToken _DOT,
                           AstToken _class)
            :super(leftIToken, rightIToken)

        {
            this._Type = _Type;
            (_Type as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._class = _class;
            (_class as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _Type)  list.add(_Type);
            if(null != _DOT)  list.add(_DOT);
            if(null != _class)  list.add(_class);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitPrimaryNoNewArray0(this);
            if (checkChildren)
            {
                _Type.accept(v);
                _DOT.accept(v);
                _class.accept(v);
            }
            v.endVisitPrimaryNoNewArray0(this);
        }
    }

/**
 *<b>
*<li>Rule 336:  PrimaryNoNewArray ::= void . class
 *</b>
 */
class PrimaryNoNewArray1 extends Ast implements IPrimaryNoNewArray
    {
         late AstToken _void;
         late AstToken _DOT;
         late AstToken _class;

         AstToken getvoid(){ return _void; }
         void setvoid(AstToken _void){ this._void = _void; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
         AstToken getclass(){ return _class; }
         void setclass(AstToken _class){ this._class = _class; }

        PrimaryNoNewArray1(IToken leftIToken, IToken rightIToken,
                           AstToken _void,
                           AstToken _DOT,
                           AstToken _class)
            :super(leftIToken, rightIToken)

        {
            this._void = _void;
            (_void as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._class = _class;
            (_class as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _void)  list.add(_void);
            if(null != _DOT)  list.add(_DOT);
            if(null != _class)  list.add(_class);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitPrimaryNoNewArray1(this);
            if (checkChildren)
            {
                _void.accept(v);
                _DOT.accept(v);
                _class.accept(v);
            }
            v.endVisitPrimaryNoNewArray1(this);
        }
    }

/**
 *<b>
*<li>Rule 337:  PrimaryNoNewArray ::= this
 *</b>
 */
class PrimaryNoNewArray2 extends AstToken implements IPrimaryNoNewArray
    {
         IToken getthis(){ return leftIToken; }

    PrimaryNoNewArray2(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitPrimaryNoNewArray2(this);
            v.endVisitPrimaryNoNewArray2(this);
        }
    }

/**
 *<b>
*<li>Rule 338:  PrimaryNoNewArray ::= ClassName . this
 *</b>
 */
class PrimaryNoNewArray3 extends Ast implements IPrimaryNoNewArray
    {
         late IClassName _ClassName;
         late AstToken _DOT;
         late AstToken _this;

         IClassName getClassName(){ return _ClassName; }
         void setClassName(IClassName _ClassName){ this._ClassName = _ClassName; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
         AstToken getthis(){ return _this; }
         void setthis(AstToken _this){ this._this = _this; }

        PrimaryNoNewArray3(IToken leftIToken, IToken rightIToken,
                           IClassName _ClassName,
                           AstToken _DOT,
                           AstToken _this)
            :super(leftIToken, rightIToken)

        {
            this._ClassName = _ClassName;
            (_ClassName as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._this = _this;
            (_this as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ClassName)  list.add(_ClassName);
            if(null != _DOT)  list.add(_DOT);
            if(null != _this)  list.add(_this);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitPrimaryNoNewArray3(this);
            if (checkChildren)
            {
                _ClassName.accept(v);
                _DOT.accept(v);
                _this.accept(v);
            }
            v.endVisitPrimaryNoNewArray3(this);
        }
    }

/**
 *<b>
*<li>Rule 339:  PrimaryNoNewArray ::= ( Expression )
 *</b>
 */
class PrimaryNoNewArray4 extends Ast implements IPrimaryNoNewArray
    {
         late AstToken _LPAREN;
         late IExpression _Expression;
         late AstToken _RPAREN;

         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
         IExpression getExpression(){ return _Expression; }
         void setExpression(IExpression _Expression){ this._Expression = _Expression; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }

        PrimaryNoNewArray4(IToken leftIToken, IToken rightIToken,
                           AstToken _LPAREN,
                           IExpression _Expression,
                           AstToken _RPAREN)
            :super(leftIToken, rightIToken)

        {
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._Expression = _Expression;
            (_Expression as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _Expression)  list.add(_Expression);
            if(null != _RPAREN)  list.add(_RPAREN);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitPrimaryNoNewArray4(this);
            if (checkChildren)
            {
                _LPAREN.accept(v);
                _Expression.accept(v);
                _RPAREN.accept(v);
            }
            v.endVisitPrimaryNoNewArray4(this);
        }
    }

/**
 *<b>
*<li>Rule 344:  Literal ::= IntegerLiteral
 *</b>
 */
class Literal0 extends AstToken implements ILiteral
    {
         IToken getIntegerLiteral(){ return leftIToken; }

    Literal0(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitLiteral0(this);
            v.endVisitLiteral0(this);
        }
    }

/**
 *<b>
*<li>Rule 345:  Literal ::= LongLiteral
 *</b>
 */
class Literal1 extends AstToken implements ILiteral
    {
         IToken getLongLiteral(){ return leftIToken; }

    Literal1(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitLiteral1(this);
            v.endVisitLiteral1(this);
        }
    }

/**
 *<b>
*<li>Rule 346:  Literal ::= FloatingPointLiteral
 *</b>
 */
class Literal2 extends AstToken implements ILiteral
    {
         IToken getFloatingPointLiteral(){ return leftIToken; }

    Literal2(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitLiteral2(this);
            v.endVisitLiteral2(this);
        }
    }

/**
 *<b>
*<li>Rule 347:  Literal ::= DoubleLiteral
 *</b>
 */
class Literal3 extends AstToken implements ILiteral
    {
         IToken getDoubleLiteral(){ return leftIToken; }

    Literal3(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitLiteral3(this);
            v.endVisitLiteral3(this);
        }
    }

/**
 *<b>
*<li>Rule 349:  Literal ::= CharacterLiteral
 *</b>
 */
class Literal4 extends AstToken implements ILiteral
    {
         IToken getCharacterLiteral(){ return leftIToken; }

    Literal4(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitLiteral4(this);
            v.endVisitLiteral4(this);
        }
    }

/**
 *<b>
*<li>Rule 350:  Literal ::= StringLiteral
 *</b>
 */
class Literal5 extends AstToken implements ILiteral
    {
         IToken getStringLiteral(){ return leftIToken; }

    Literal5(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitLiteral5(this);
            v.endVisitLiteral5(this);
        }
    }

/**
 *<b>
*<li>Rule 351:  Literal ::= null
 *</b>
 */
class Literal6 extends AstToken implements ILiteral
    {
         IToken getnull(){ return leftIToken; }

    Literal6(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitLiteral6(this);
            v.endVisitLiteral6(this);
        }
    }

/**
 *<b>
*<li>Rule 352:  BooleanLiteral ::= true
 *</b>
 */
class BooleanLiteral0 extends AstToken implements IBooleanLiteral
    {
         IToken gettrue(){ return leftIToken; }

    BooleanLiteral0(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitBooleanLiteral0(this);
            v.endVisitBooleanLiteral0(this);
        }
    }

/**
 *<b>
*<li>Rule 353:  BooleanLiteral ::= false
 *</b>
 */
class BooleanLiteral1 extends AstToken implements IBooleanLiteral
    {
         IToken getfalse(){ return leftIToken; }

    BooleanLiteral1(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitBooleanLiteral1(this);
            v.endVisitBooleanLiteral1(this);
        }
    }

/**
 *<b>
*<li>Rule 354:  ClassInstanceCreationExpression ::= new TypeArgumentsopt ClassOrInterfaceType TypeArgumentsopt ( ArgumentListopt ) ClassBodyopt
 *</b>
 */
class ClassInstanceCreationExpression0 extends Ast implements IClassInstanceCreationExpression
    {
         late AstToken _new;
         late TypeArguments? _TypeArgumentsopt;
         late ClassType _ClassOrInterfaceType;
         late TypeArguments? _TypeArgumentsopt4;
         late AstToken _LPAREN;
         late IArgumentListopt? _ArgumentListopt;
         late AstToken _RPAREN;
         late ClassBody? _ClassBodyopt;

         AstToken getnew(){ return _new; }
         void setnew(AstToken _new){ this._new = _new; }
        /**
         * The value returned by <b>getTypeArgumentsopt</b> may be <b>null</b>
         */
         TypeArguments ?  getTypeArgumentsopt(){ return _TypeArgumentsopt; }
         void setTypeArgumentsopt(TypeArguments _TypeArgumentsopt){ this._TypeArgumentsopt = _TypeArgumentsopt; }
         ClassType getClassOrInterfaceType(){ return _ClassOrInterfaceType; }
         void setClassOrInterfaceType(ClassType _ClassOrInterfaceType){ this._ClassOrInterfaceType = _ClassOrInterfaceType; }
        /**
         * The value returned by <b>getTypeArgumentsopt4</b> may be <b>null</b>
         */
         TypeArguments ?  getTypeArgumentsopt4(){ return _TypeArgumentsopt4; }
         void setTypeArgumentsopt4(TypeArguments _TypeArgumentsopt4){ this._TypeArgumentsopt4 = _TypeArgumentsopt4; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
        /**
         * The value returned by <b>getArgumentListopt</b> may be <b>null</b>
         */
         IArgumentListopt ?  getArgumentListopt(){ return _ArgumentListopt; }
         void setArgumentListopt(IArgumentListopt _ArgumentListopt){ this._ArgumentListopt = _ArgumentListopt; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
        /**
         * The value returned by <b>getClassBodyopt</b> may be <b>null</b>
         */
         ClassBody ?  getClassBodyopt(){ return _ClassBodyopt; }
         void setClassBodyopt(ClassBody _ClassBodyopt){ this._ClassBodyopt = _ClassBodyopt; }

        ClassInstanceCreationExpression0(IToken leftIToken, IToken rightIToken,
                                         AstToken _new,
                                         TypeArguments? _TypeArgumentsopt,
                                         ClassType _ClassOrInterfaceType,
                                         TypeArguments? _TypeArgumentsopt4,
                                         AstToken _LPAREN,
                                         IArgumentListopt? _ArgumentListopt,
                                         AstToken _RPAREN,
                                         ClassBody? _ClassBodyopt)
            :super(leftIToken, rightIToken)

        {
            this._new = _new;
            (_new as Ast).setParent(this);
            this._TypeArgumentsopt = _TypeArgumentsopt;
            if (null != _TypeArgumentsopt) (_TypeArgumentsopt as Ast).setParent(this);
            this._ClassOrInterfaceType = _ClassOrInterfaceType;
            (_ClassOrInterfaceType as Ast).setParent(this);
            this._TypeArgumentsopt4 = _TypeArgumentsopt4;
            if (null != _TypeArgumentsopt4) (_TypeArgumentsopt4 as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._ArgumentListopt = _ArgumentListopt;
            if (null != _ArgumentListopt) (_ArgumentListopt as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._ClassBodyopt = _ClassBodyopt;
            if (null != _ClassBodyopt) (_ClassBodyopt as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _new)  list.add(_new);
            if(null != _TypeArgumentsopt)  list.add(_TypeArgumentsopt);
            if(null != _ClassOrInterfaceType)  list.add(_ClassOrInterfaceType);
            if(null != _TypeArgumentsopt4)  list.add(_TypeArgumentsopt4);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _ArgumentListopt)  list.add(_ArgumentListopt);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _ClassBodyopt)  list.add(_ClassBodyopt);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitClassInstanceCreationExpression0(this);
            if (checkChildren)
            {
                _new.accept(v);
                if (null != _TypeArgumentsopt) _TypeArgumentsopt!.accept(v);
                _ClassOrInterfaceType.accept(v);
                if (null != _TypeArgumentsopt4) _TypeArgumentsopt4!.accept(v);
                _LPAREN.accept(v);
                if (null != _ArgumentListopt) _ArgumentListopt!.accept(v);
                _RPAREN.accept(v);
                if (null != _ClassBodyopt) _ClassBodyopt!.accept(v);
            }
            v.endVisitClassInstanceCreationExpression0(this);
        }
    }

/**
 *<b>
*<li>Rule 355:  ClassInstanceCreationExpression ::= Primary . new TypeArgumentsopt identifier TypeArgumentsopt ( ArgumentListopt ) ClassBodyopt
 *</b>
 */
class ClassInstanceCreationExpression1 extends Ast implements IClassInstanceCreationExpression
    {
         late IPrimary _Primary;
         late AstToken _DOT;
         late AstToken _new;
         late TypeArguments? _TypeArgumentsopt;
         late identifier _identifier;
         late TypeArguments? _TypeArgumentsopt6;
         late AstToken _LPAREN;
         late IArgumentListopt? _ArgumentListopt;
         late AstToken _RPAREN;
         late ClassBody? _ClassBodyopt;

         IPrimary getPrimary(){ return _Primary; }
         void setPrimary(IPrimary _Primary){ this._Primary = _Primary; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
         AstToken getnew(){ return _new; }
         void setnew(AstToken _new){ this._new = _new; }
        /**
         * The value returned by <b>getTypeArgumentsopt</b> may be <b>null</b>
         */
         TypeArguments ?  getTypeArgumentsopt(){ return _TypeArgumentsopt; }
         void setTypeArgumentsopt(TypeArguments _TypeArgumentsopt){ this._TypeArgumentsopt = _TypeArgumentsopt; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }
        /**
         * The value returned by <b>getTypeArgumentsopt6</b> may be <b>null</b>
         */
         TypeArguments ?  getTypeArgumentsopt6(){ return _TypeArgumentsopt6; }
         void setTypeArgumentsopt6(TypeArguments _TypeArgumentsopt6){ this._TypeArgumentsopt6 = _TypeArgumentsopt6; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
        /**
         * The value returned by <b>getArgumentListopt</b> may be <b>null</b>
         */
         IArgumentListopt ?  getArgumentListopt(){ return _ArgumentListopt; }
         void setArgumentListopt(IArgumentListopt _ArgumentListopt){ this._ArgumentListopt = _ArgumentListopt; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
        /**
         * The value returned by <b>getClassBodyopt</b> may be <b>null</b>
         */
         ClassBody ?  getClassBodyopt(){ return _ClassBodyopt; }
         void setClassBodyopt(ClassBody _ClassBodyopt){ this._ClassBodyopt = _ClassBodyopt; }

        ClassInstanceCreationExpression1(IToken leftIToken, IToken rightIToken,
                                         IPrimary _Primary,
                                         AstToken _DOT,
                                         AstToken _new,
                                         TypeArguments? _TypeArgumentsopt,
                                         identifier _identifier,
                                         TypeArguments? _TypeArgumentsopt6,
                                         AstToken _LPAREN,
                                         IArgumentListopt? _ArgumentListopt,
                                         AstToken _RPAREN,
                                         ClassBody? _ClassBodyopt)
            :super(leftIToken, rightIToken)

        {
            this._Primary = _Primary;
            (_Primary as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._new = _new;
            (_new as Ast).setParent(this);
            this._TypeArgumentsopt = _TypeArgumentsopt;
            if (null != _TypeArgumentsopt) (_TypeArgumentsopt as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            this._TypeArgumentsopt6 = _TypeArgumentsopt6;
            if (null != _TypeArgumentsopt6) (_TypeArgumentsopt6 as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._ArgumentListopt = _ArgumentListopt;
            if (null != _ArgumentListopt) (_ArgumentListopt as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._ClassBodyopt = _ClassBodyopt;
            if (null != _ClassBodyopt) (_ClassBodyopt as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _Primary)  list.add(_Primary);
            if(null != _DOT)  list.add(_DOT);
            if(null != _new)  list.add(_new);
            if(null != _TypeArgumentsopt)  list.add(_TypeArgumentsopt);
            if(null != _identifier)  list.add(_identifier);
            if(null != _TypeArgumentsopt6)  list.add(_TypeArgumentsopt6);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _ArgumentListopt)  list.add(_ArgumentListopt);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _ClassBodyopt)  list.add(_ClassBodyopt);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitClassInstanceCreationExpression1(this);
            if (checkChildren)
            {
                _Primary.accept(v);
                _DOT.accept(v);
                _new.accept(v);
                if (null != _TypeArgumentsopt) _TypeArgumentsopt!.accept(v);
                _identifier.accept(v);
                if (null != _TypeArgumentsopt6) _TypeArgumentsopt6!.accept(v);
                _LPAREN.accept(v);
                if (null != _ArgumentListopt) _ArgumentListopt!.accept(v);
                _RPAREN.accept(v);
                if (null != _ClassBodyopt) _ClassBodyopt!.accept(v);
            }
            v.endVisitClassInstanceCreationExpression1(this);
        }
    }

/**
 *<b>
*<li>Rule 358:  ArrayCreationExpression ::= new PrimitiveType DimExprs Dimsopt
 *</b>
 */
class ArrayCreationExpression0 extends Ast implements IArrayCreationExpression
    {
         late AstToken _new;
         late IPrimitiveType _PrimitiveType;
         late IDimExprs _DimExprs;
         late IDimsopt? _Dimsopt;

         AstToken getnew(){ return _new; }
         void setnew(AstToken _new){ this._new = _new; }
         IPrimitiveType getPrimitiveType(){ return _PrimitiveType; }
         void setPrimitiveType(IPrimitiveType _PrimitiveType){ this._PrimitiveType = _PrimitiveType; }
         IDimExprs getDimExprs(){ return _DimExprs; }
         void setDimExprs(IDimExprs _DimExprs){ this._DimExprs = _DimExprs; }
        /**
         * The value returned by <b>getDimsopt</b> may be <b>null</b>
         */
         IDimsopt ?  getDimsopt(){ return _Dimsopt; }
         void setDimsopt(IDimsopt _Dimsopt){ this._Dimsopt = _Dimsopt; }

        ArrayCreationExpression0(IToken leftIToken, IToken rightIToken,
                                 AstToken _new,
                                 IPrimitiveType _PrimitiveType,
                                 IDimExprs _DimExprs,
                                 IDimsopt? _Dimsopt)
            :super(leftIToken, rightIToken)

        {
            this._new = _new;
            (_new as Ast).setParent(this);
            this._PrimitiveType = _PrimitiveType;
            (_PrimitiveType as Ast).setParent(this);
            this._DimExprs = _DimExprs;
            (_DimExprs as Ast).setParent(this);
            this._Dimsopt = _Dimsopt;
            if (null != _Dimsopt) (_Dimsopt as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _new)  list.add(_new);
            if(null != _PrimitiveType)  list.add(_PrimitiveType);
            if(null != _DimExprs)  list.add(_DimExprs);
            if(null != _Dimsopt)  list.add(_Dimsopt);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitArrayCreationExpression0(this);
            if (checkChildren)
            {
                _new.accept(v);
                _PrimitiveType.accept(v);
                _DimExprs.accept(v);
                if (null != _Dimsopt) _Dimsopt!.accept(v);
            }
            v.endVisitArrayCreationExpression0(this);
        }
    }

/**
 *<b>
*<li>Rule 359:  ArrayCreationExpression ::= new ClassOrInterfaceType DimExprs Dimsopt
 *</b>
 */
class ArrayCreationExpression1 extends Ast implements IArrayCreationExpression
    {
         late AstToken _new;
         late ClassType _ClassOrInterfaceType;
         late IDimExprs _DimExprs;
         late IDimsopt? _Dimsopt;

         AstToken getnew(){ return _new; }
         void setnew(AstToken _new){ this._new = _new; }
         ClassType getClassOrInterfaceType(){ return _ClassOrInterfaceType; }
         void setClassOrInterfaceType(ClassType _ClassOrInterfaceType){ this._ClassOrInterfaceType = _ClassOrInterfaceType; }
         IDimExprs getDimExprs(){ return _DimExprs; }
         void setDimExprs(IDimExprs _DimExprs){ this._DimExprs = _DimExprs; }
        /**
         * The value returned by <b>getDimsopt</b> may be <b>null</b>
         */
         IDimsopt ?  getDimsopt(){ return _Dimsopt; }
         void setDimsopt(IDimsopt _Dimsopt){ this._Dimsopt = _Dimsopt; }

        ArrayCreationExpression1(IToken leftIToken, IToken rightIToken,
                                 AstToken _new,
                                 ClassType _ClassOrInterfaceType,
                                 IDimExprs _DimExprs,
                                 IDimsopt? _Dimsopt)
            :super(leftIToken, rightIToken)

        {
            this._new = _new;
            (_new as Ast).setParent(this);
            this._ClassOrInterfaceType = _ClassOrInterfaceType;
            (_ClassOrInterfaceType as Ast).setParent(this);
            this._DimExprs = _DimExprs;
            (_DimExprs as Ast).setParent(this);
            this._Dimsopt = _Dimsopt;
            if (null != _Dimsopt) (_Dimsopt as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _new)  list.add(_new);
            if(null != _ClassOrInterfaceType)  list.add(_ClassOrInterfaceType);
            if(null != _DimExprs)  list.add(_DimExprs);
            if(null != _Dimsopt)  list.add(_Dimsopt);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitArrayCreationExpression1(this);
            if (checkChildren)
            {
                _new.accept(v);
                _ClassOrInterfaceType.accept(v);
                _DimExprs.accept(v);
                if (null != _Dimsopt) _Dimsopt!.accept(v);
            }
            v.endVisitArrayCreationExpression1(this);
        }
    }

/**
 *<b>
*<li>Rule 360:  ArrayCreationExpression ::= new PrimitiveType Dims ArrayInitializer
 *</b>
 */
class ArrayCreationExpression2 extends Ast implements IArrayCreationExpression
    {
         late AstToken _new;
         late IPrimitiveType _PrimitiveType;
         late IDims _Dims;
         late ArrayInitializer _ArrayInitializer;

         AstToken getnew(){ return _new; }
         void setnew(AstToken _new){ this._new = _new; }
         IPrimitiveType getPrimitiveType(){ return _PrimitiveType; }
         void setPrimitiveType(IPrimitiveType _PrimitiveType){ this._PrimitiveType = _PrimitiveType; }
         IDims getDims(){ return _Dims; }
         void setDims(IDims _Dims){ this._Dims = _Dims; }
         ArrayInitializer getArrayInitializer(){ return _ArrayInitializer; }
         void setArrayInitializer(ArrayInitializer _ArrayInitializer){ this._ArrayInitializer = _ArrayInitializer; }

        ArrayCreationExpression2(IToken leftIToken, IToken rightIToken,
                                 AstToken _new,
                                 IPrimitiveType _PrimitiveType,
                                 IDims _Dims,
                                 ArrayInitializer _ArrayInitializer)
            :super(leftIToken, rightIToken)

        {
            this._new = _new;
            (_new as Ast).setParent(this);
            this._PrimitiveType = _PrimitiveType;
            (_PrimitiveType as Ast).setParent(this);
            this._Dims = _Dims;
            (_Dims as Ast).setParent(this);
            this._ArrayInitializer = _ArrayInitializer;
            (_ArrayInitializer as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _new)  list.add(_new);
            if(null != _PrimitiveType)  list.add(_PrimitiveType);
            if(null != _Dims)  list.add(_Dims);
            if(null != _ArrayInitializer)  list.add(_ArrayInitializer);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitArrayCreationExpression2(this);
            if (checkChildren)
            {
                _new.accept(v);
                _PrimitiveType.accept(v);
                _Dims.accept(v);
                _ArrayInitializer.accept(v);
            }
            v.endVisitArrayCreationExpression2(this);
        }
    }

/**
 *<b>
*<li>Rule 361:  ArrayCreationExpression ::= new ClassOrInterfaceType Dims ArrayInitializer
 *</b>
 */
class ArrayCreationExpression3 extends Ast implements IArrayCreationExpression
    {
         late AstToken _new;
         late ClassType _ClassOrInterfaceType;
         late IDims _Dims;
         late ArrayInitializer _ArrayInitializer;

         AstToken getnew(){ return _new; }
         void setnew(AstToken _new){ this._new = _new; }
         ClassType getClassOrInterfaceType(){ return _ClassOrInterfaceType; }
         void setClassOrInterfaceType(ClassType _ClassOrInterfaceType){ this._ClassOrInterfaceType = _ClassOrInterfaceType; }
         IDims getDims(){ return _Dims; }
         void setDims(IDims _Dims){ this._Dims = _Dims; }
         ArrayInitializer getArrayInitializer(){ return _ArrayInitializer; }
         void setArrayInitializer(ArrayInitializer _ArrayInitializer){ this._ArrayInitializer = _ArrayInitializer; }

        ArrayCreationExpression3(IToken leftIToken, IToken rightIToken,
                                 AstToken _new,
                                 ClassType _ClassOrInterfaceType,
                                 IDims _Dims,
                                 ArrayInitializer _ArrayInitializer)
            :super(leftIToken, rightIToken)

        {
            this._new = _new;
            (_new as Ast).setParent(this);
            this._ClassOrInterfaceType = _ClassOrInterfaceType;
            (_ClassOrInterfaceType as Ast).setParent(this);
            this._Dims = _Dims;
            (_Dims as Ast).setParent(this);
            this._ArrayInitializer = _ArrayInitializer;
            (_ArrayInitializer as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _new)  list.add(_new);
            if(null != _ClassOrInterfaceType)  list.add(_ClassOrInterfaceType);
            if(null != _Dims)  list.add(_Dims);
            if(null != _ArrayInitializer)  list.add(_ArrayInitializer);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitArrayCreationExpression3(this);
            if (checkChildren)
            {
                _new.accept(v);
                _ClassOrInterfaceType.accept(v);
                _Dims.accept(v);
                _ArrayInitializer.accept(v);
            }
            v.endVisitArrayCreationExpression3(this);
        }
    }

/**
 *<b>
*<li>Rule 365:  Dims ::= [ ]
 *</b>
 */
class Dims0 extends Ast implements IDims
    {
         late AstToken _LBRACKET;
         late AstToken _RBRACKET;

         AstToken getLBRACKET(){ return _LBRACKET; }
         void setLBRACKET(AstToken _LBRACKET){ this._LBRACKET = _LBRACKET; }
         AstToken getRBRACKET(){ return _RBRACKET; }
         void setRBRACKET(AstToken _RBRACKET){ this._RBRACKET = _RBRACKET; }

        Dims0(IToken leftIToken, IToken rightIToken,
              AstToken _LBRACKET,
              AstToken _RBRACKET)
            :super(leftIToken, rightIToken)

        {
            this._LBRACKET = _LBRACKET;
            (_LBRACKET as Ast).setParent(this);
            this._RBRACKET = _RBRACKET;
            (_RBRACKET as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _LBRACKET)  list.add(_LBRACKET);
            if(null != _RBRACKET)  list.add(_RBRACKET);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitDims0(this);
            if (checkChildren)
            {
                _LBRACKET.accept(v);
                _RBRACKET.accept(v);
            }
            v.endVisitDims0(this);
        }
    }

/**
 *<b>
*<li>Rule 366:  Dims ::= Dims [ ]
 *</b>
 */
class Dims1 extends Ast implements IDims
    {
         late IDims _Dims;
         late AstToken _LBRACKET;
         late AstToken _RBRACKET;

         IDims getDims(){ return _Dims; }
         void setDims(IDims _Dims){ this._Dims = _Dims; }
         AstToken getLBRACKET(){ return _LBRACKET; }
         void setLBRACKET(AstToken _LBRACKET){ this._LBRACKET = _LBRACKET; }
         AstToken getRBRACKET(){ return _RBRACKET; }
         void setRBRACKET(AstToken _RBRACKET){ this._RBRACKET = _RBRACKET; }

        Dims1(IToken leftIToken, IToken rightIToken,
              IDims _Dims,
              AstToken _LBRACKET,
              AstToken _RBRACKET)
            :super(leftIToken, rightIToken)

        {
            this._Dims = _Dims;
            (_Dims as Ast).setParent(this);
            this._LBRACKET = _LBRACKET;
            (_LBRACKET as Ast).setParent(this);
            this._RBRACKET = _RBRACKET;
            (_RBRACKET as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _Dims)  list.add(_Dims);
            if(null != _LBRACKET)  list.add(_LBRACKET);
            if(null != _RBRACKET)  list.add(_RBRACKET);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitDims1(this);
            if (checkChildren)
            {
                _Dims.accept(v);
                _LBRACKET.accept(v);
                _RBRACKET.accept(v);
            }
            v.endVisitDims1(this);
        }
    }

/**
 *<b>
*<li>Rule 367:  FieldAccess ::= Primary . identifier
 *</b>
 */
class FieldAccess0 extends Ast implements IFieldAccess
    {
         late IPrimary _Primary;
         late AstToken _DOT;
         late identifier _identifier;

         IPrimary getPrimary(){ return _Primary; }
         void setPrimary(IPrimary _Primary){ this._Primary = _Primary; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }

        FieldAccess0(IToken leftIToken, IToken rightIToken,
                     IPrimary _Primary,
                     AstToken _DOT,
                     identifier _identifier)
            :super(leftIToken, rightIToken)

        {
            this._Primary = _Primary;
            (_Primary as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _Primary)  list.add(_Primary);
            if(null != _DOT)  list.add(_DOT);
            if(null != _identifier)  list.add(_identifier);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitFieldAccess0(this);
            if (checkChildren)
            {
                _Primary.accept(v);
                _DOT.accept(v);
                _identifier.accept(v);
            }
            v.endVisitFieldAccess0(this);
        }
    }

/**
 *<b>
*<li>Rule 368:  FieldAccess ::= super . identifier
 *</b>
 */
class FieldAccess1 extends Ast implements IFieldAccess
    {
         late AstToken _super;
         late AstToken _DOT;
         late identifier _identifier;

         AstToken getsuper(){ return _super; }
         void setsuper(AstToken _super){ this._super = _super; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }

        FieldAccess1(IToken leftIToken, IToken rightIToken,
                     AstToken _super,
                     AstToken _DOT,
                     identifier _identifier)
            :super(leftIToken, rightIToken)

        {
            this._super = _super;
            (_super as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _super)  list.add(_super);
            if(null != _DOT)  list.add(_DOT);
            if(null != _identifier)  list.add(_identifier);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitFieldAccess1(this);
            if (checkChildren)
            {
                _super.accept(v);
                _DOT.accept(v);
                _identifier.accept(v);
            }
            v.endVisitFieldAccess1(this);
        }
    }

/**
 *<b>
*<li>Rule 369:  FieldAccess ::= ClassName . super . identifier
 *</b>
 */
class FieldAccess2 extends Ast implements IFieldAccess
    {
         late IClassName _ClassName;
         late AstToken _DOT;
         late AstToken _super;
         late AstToken _DOT4;
         late identifier _identifier;

         IClassName getClassName(){ return _ClassName; }
         void setClassName(IClassName _ClassName){ this._ClassName = _ClassName; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
         AstToken getsuper(){ return _super; }
         void setsuper(AstToken _super){ this._super = _super; }
         AstToken getDOT4(){ return _DOT4; }
         void setDOT4(AstToken _DOT4){ this._DOT4 = _DOT4; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }

        FieldAccess2(IToken leftIToken, IToken rightIToken,
                     IClassName _ClassName,
                     AstToken _DOT,
                     AstToken _super,
                     AstToken _DOT4,
                     identifier _identifier)
            :super(leftIToken, rightIToken)

        {
            this._ClassName = _ClassName;
            (_ClassName as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._super = _super;
            (_super as Ast).setParent(this);
            this._DOT4 = _DOT4;
            (_DOT4 as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ClassName)  list.add(_ClassName);
            if(null != _DOT)  list.add(_DOT);
            if(null != _super)  list.add(_super);
            if(null != _DOT4)  list.add(_DOT4);
            if(null != _identifier)  list.add(_identifier);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitFieldAccess2(this);
            if (checkChildren)
            {
                _ClassName.accept(v);
                _DOT.accept(v);
                _super.accept(v);
                _DOT4.accept(v);
                _identifier.accept(v);
            }
            v.endVisitFieldAccess2(this);
        }
    }

/**
 *<b>
*<li>Rule 370:  MethodInvocation ::= MethodName ( ArgumentListopt )
 *</b>
 */
class MethodInvocation0 extends Ast implements IMethodInvocation
    {
         late IMethodName _MethodName;
         late AstToken _LPAREN;
         late IArgumentListopt? _ArgumentListopt;
         late AstToken _RPAREN;

         IMethodName getMethodName(){ return _MethodName; }
         void setMethodName(IMethodName _MethodName){ this._MethodName = _MethodName; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
        /**
         * The value returned by <b>getArgumentListopt</b> may be <b>null</b>
         */
         IArgumentListopt ?  getArgumentListopt(){ return _ArgumentListopt; }
         void setArgumentListopt(IArgumentListopt _ArgumentListopt){ this._ArgumentListopt = _ArgumentListopt; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }

        MethodInvocation0(IToken leftIToken, IToken rightIToken,
                          IMethodName _MethodName,
                          AstToken _LPAREN,
                          IArgumentListopt? _ArgumentListopt,
                          AstToken _RPAREN)
            :super(leftIToken, rightIToken)

        {
            this._MethodName = _MethodName;
            (_MethodName as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._ArgumentListopt = _ArgumentListopt;
            if (null != _ArgumentListopt) (_ArgumentListopt as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _MethodName)  list.add(_MethodName);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _ArgumentListopt)  list.add(_ArgumentListopt);
            if(null != _RPAREN)  list.add(_RPAREN);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitMethodInvocation0(this);
            if (checkChildren)
            {
                _MethodName.accept(v);
                _LPAREN.accept(v);
                if (null != _ArgumentListopt) _ArgumentListopt!.accept(v);
                _RPAREN.accept(v);
            }
            v.endVisitMethodInvocation0(this);
        }
    }

/**
 *<b>
*<li>Rule 371:  MethodInvocation ::= Primary . TypeArgumentsopt identifier ( ArgumentListopt )
 *</b>
 */
class MethodInvocation1 extends Ast implements IMethodInvocation
    {
         late IPrimary _Primary;
         late AstToken _DOT;
         late TypeArguments? _TypeArgumentsopt;
         late identifier _identifier;
         late AstToken _LPAREN;
         late IArgumentListopt? _ArgumentListopt;
         late AstToken _RPAREN;

         IPrimary getPrimary(){ return _Primary; }
         void setPrimary(IPrimary _Primary){ this._Primary = _Primary; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
        /**
         * The value returned by <b>getTypeArgumentsopt</b> may be <b>null</b>
         */
         TypeArguments ?  getTypeArgumentsopt(){ return _TypeArgumentsopt; }
         void setTypeArgumentsopt(TypeArguments _TypeArgumentsopt){ this._TypeArgumentsopt = _TypeArgumentsopt; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
        /**
         * The value returned by <b>getArgumentListopt</b> may be <b>null</b>
         */
         IArgumentListopt ?  getArgumentListopt(){ return _ArgumentListopt; }
         void setArgumentListopt(IArgumentListopt _ArgumentListopt){ this._ArgumentListopt = _ArgumentListopt; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }

        MethodInvocation1(IToken leftIToken, IToken rightIToken,
                          IPrimary _Primary,
                          AstToken _DOT,
                          TypeArguments? _TypeArgumentsopt,
                          identifier _identifier,
                          AstToken _LPAREN,
                          IArgumentListopt? _ArgumentListopt,
                          AstToken _RPAREN)
            :super(leftIToken, rightIToken)

        {
            this._Primary = _Primary;
            (_Primary as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._TypeArgumentsopt = _TypeArgumentsopt;
            if (null != _TypeArgumentsopt) (_TypeArgumentsopt as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._ArgumentListopt = _ArgumentListopt;
            if (null != _ArgumentListopt) (_ArgumentListopt as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _Primary)  list.add(_Primary);
            if(null != _DOT)  list.add(_DOT);
            if(null != _TypeArgumentsopt)  list.add(_TypeArgumentsopt);
            if(null != _identifier)  list.add(_identifier);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _ArgumentListopt)  list.add(_ArgumentListopt);
            if(null != _RPAREN)  list.add(_RPAREN);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitMethodInvocation1(this);
            if (checkChildren)
            {
                _Primary.accept(v);
                _DOT.accept(v);
                if (null != _TypeArgumentsopt) _TypeArgumentsopt!.accept(v);
                _identifier.accept(v);
                _LPAREN.accept(v);
                if (null != _ArgumentListopt) _ArgumentListopt!.accept(v);
                _RPAREN.accept(v);
            }
            v.endVisitMethodInvocation1(this);
        }
    }

/**
 *<b>
*<li>Rule 372:  MethodInvocation ::= super . TypeArgumentsopt identifier ( ArgumentListopt )
 *</b>
 */
class MethodInvocation2 extends Ast implements IMethodInvocation
    {
         late AstToken _super;
         late AstToken _DOT;
         late TypeArguments? _TypeArgumentsopt;
         late identifier _identifier;
         late AstToken _LPAREN;
         late IArgumentListopt? _ArgumentListopt;
         late AstToken _RPAREN;

         AstToken getsuper(){ return _super; }
         void setsuper(AstToken _super){ this._super = _super; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
        /**
         * The value returned by <b>getTypeArgumentsopt</b> may be <b>null</b>
         */
         TypeArguments ?  getTypeArgumentsopt(){ return _TypeArgumentsopt; }
         void setTypeArgumentsopt(TypeArguments _TypeArgumentsopt){ this._TypeArgumentsopt = _TypeArgumentsopt; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
        /**
         * The value returned by <b>getArgumentListopt</b> may be <b>null</b>
         */
         IArgumentListopt ?  getArgumentListopt(){ return _ArgumentListopt; }
         void setArgumentListopt(IArgumentListopt _ArgumentListopt){ this._ArgumentListopt = _ArgumentListopt; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }

        MethodInvocation2(IToken leftIToken, IToken rightIToken,
                          AstToken _super,
                          AstToken _DOT,
                          TypeArguments? _TypeArgumentsopt,
                          identifier _identifier,
                          AstToken _LPAREN,
                          IArgumentListopt? _ArgumentListopt,
                          AstToken _RPAREN)
            :super(leftIToken, rightIToken)

        {
            this._super = _super;
            (_super as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._TypeArgumentsopt = _TypeArgumentsopt;
            if (null != _TypeArgumentsopt) (_TypeArgumentsopt as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._ArgumentListopt = _ArgumentListopt;
            if (null != _ArgumentListopt) (_ArgumentListopt as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _super)  list.add(_super);
            if(null != _DOT)  list.add(_DOT);
            if(null != _TypeArgumentsopt)  list.add(_TypeArgumentsopt);
            if(null != _identifier)  list.add(_identifier);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _ArgumentListopt)  list.add(_ArgumentListopt);
            if(null != _RPAREN)  list.add(_RPAREN);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitMethodInvocation2(this);
            if (checkChildren)
            {
                _super.accept(v);
                _DOT.accept(v);
                if (null != _TypeArgumentsopt) _TypeArgumentsopt!.accept(v);
                _identifier.accept(v);
                _LPAREN.accept(v);
                if (null != _ArgumentListopt) _ArgumentListopt!.accept(v);
                _RPAREN.accept(v);
            }
            v.endVisitMethodInvocation2(this);
        }
    }

/**
 *<b>
*<li>Rule 373:  MethodInvocation ::= ClassName . super . TypeArgumentsopt identifier ( ArgumentListopt )
 *</b>
 */
class MethodInvocation3 extends Ast implements IMethodInvocation
    {
         late IClassName _ClassName;
         late AstToken _DOT;
         late AstToken _super;
         late AstToken _DOT4;
         late TypeArguments? _TypeArgumentsopt;
         late identifier _identifier;
         late AstToken _LPAREN;
         late IArgumentListopt? _ArgumentListopt;
         late AstToken _RPAREN;

         IClassName getClassName(){ return _ClassName; }
         void setClassName(IClassName _ClassName){ this._ClassName = _ClassName; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
         AstToken getsuper(){ return _super; }
         void setsuper(AstToken _super){ this._super = _super; }
         AstToken getDOT4(){ return _DOT4; }
         void setDOT4(AstToken _DOT4){ this._DOT4 = _DOT4; }
        /**
         * The value returned by <b>getTypeArgumentsopt</b> may be <b>null</b>
         */
         TypeArguments ?  getTypeArgumentsopt(){ return _TypeArgumentsopt; }
         void setTypeArgumentsopt(TypeArguments _TypeArgumentsopt){ this._TypeArgumentsopt = _TypeArgumentsopt; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
        /**
         * The value returned by <b>getArgumentListopt</b> may be <b>null</b>
         */
         IArgumentListopt ?  getArgumentListopt(){ return _ArgumentListopt; }
         void setArgumentListopt(IArgumentListopt _ArgumentListopt){ this._ArgumentListopt = _ArgumentListopt; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }

        MethodInvocation3(IToken leftIToken, IToken rightIToken,
                          IClassName _ClassName,
                          AstToken _DOT,
                          AstToken _super,
                          AstToken _DOT4,
                          TypeArguments? _TypeArgumentsopt,
                          identifier _identifier,
                          AstToken _LPAREN,
                          IArgumentListopt? _ArgumentListopt,
                          AstToken _RPAREN)
            :super(leftIToken, rightIToken)

        {
            this._ClassName = _ClassName;
            (_ClassName as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._super = _super;
            (_super as Ast).setParent(this);
            this._DOT4 = _DOT4;
            (_DOT4 as Ast).setParent(this);
            this._TypeArgumentsopt = _TypeArgumentsopt;
            if (null != _TypeArgumentsopt) (_TypeArgumentsopt as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._ArgumentListopt = _ArgumentListopt;
            if (null != _ArgumentListopt) (_ArgumentListopt as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ClassName)  list.add(_ClassName);
            if(null != _DOT)  list.add(_DOT);
            if(null != _super)  list.add(_super);
            if(null != _DOT4)  list.add(_DOT4);
            if(null != _TypeArgumentsopt)  list.add(_TypeArgumentsopt);
            if(null != _identifier)  list.add(_identifier);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _ArgumentListopt)  list.add(_ArgumentListopt);
            if(null != _RPAREN)  list.add(_RPAREN);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitMethodInvocation3(this);
            if (checkChildren)
            {
                _ClassName.accept(v);
                _DOT.accept(v);
                _super.accept(v);
                _DOT4.accept(v);
                if (null != _TypeArgumentsopt) _TypeArgumentsopt!.accept(v);
                _identifier.accept(v);
                _LPAREN.accept(v);
                if (null != _ArgumentListopt) _ArgumentListopt!.accept(v);
                _RPAREN.accept(v);
            }
            v.endVisitMethodInvocation3(this);
        }
    }

/**
 *<b>
*<li>Rule 374:  MethodInvocation ::= TypeName . TypeArguments identifier ( ArgumentListopt )
 *</b>
 */
class MethodInvocation4 extends Ast implements IMethodInvocation
    {
         late ITypeName _TypeName;
         late AstToken _DOT;
         late TypeArguments _TypeArguments;
         late identifier _identifier;
         late AstToken _LPAREN;
         late IArgumentListopt? _ArgumentListopt;
         late AstToken _RPAREN;

         ITypeName getTypeName(){ return _TypeName; }
         void setTypeName(ITypeName _TypeName){ this._TypeName = _TypeName; }
         AstToken getDOT(){ return _DOT; }
         void setDOT(AstToken _DOT){ this._DOT = _DOT; }
         TypeArguments getTypeArguments(){ return _TypeArguments; }
         void setTypeArguments(TypeArguments _TypeArguments){ this._TypeArguments = _TypeArguments; }
         identifier getidentifier(){ return _identifier; }
         void setidentifier(identifier _identifier){ this._identifier = _identifier; }
         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
        /**
         * The value returned by <b>getArgumentListopt</b> may be <b>null</b>
         */
         IArgumentListopt ?  getArgumentListopt(){ return _ArgumentListopt; }
         void setArgumentListopt(IArgumentListopt _ArgumentListopt){ this._ArgumentListopt = _ArgumentListopt; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }

        MethodInvocation4(IToken leftIToken, IToken rightIToken,
                          ITypeName _TypeName,
                          AstToken _DOT,
                          TypeArguments _TypeArguments,
                          identifier _identifier,
                          AstToken _LPAREN,
                          IArgumentListopt? _ArgumentListopt,
                          AstToken _RPAREN)
            :super(leftIToken, rightIToken)

        {
            this._TypeName = _TypeName;
            (_TypeName as Ast).setParent(this);
            this._DOT = _DOT;
            (_DOT as Ast).setParent(this);
            this._TypeArguments = _TypeArguments;
            (_TypeArguments as Ast).setParent(this);
            this._identifier = _identifier;
            (_identifier as Ast).setParent(this);
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._ArgumentListopt = _ArgumentListopt;
            if (null != _ArgumentListopt) (_ArgumentListopt as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _TypeName)  list.add(_TypeName);
            if(null != _DOT)  list.add(_DOT);
            if(null != _TypeArguments)  list.add(_TypeArguments);
            if(null != _identifier)  list.add(_identifier);
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _ArgumentListopt)  list.add(_ArgumentListopt);
            if(null != _RPAREN)  list.add(_RPAREN);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitMethodInvocation4(this);
            if (checkChildren)
            {
                _TypeName.accept(v);
                _DOT.accept(v);
                _TypeArguments.accept(v);
                _identifier.accept(v);
                _LPAREN.accept(v);
                if (null != _ArgumentListopt) _ArgumentListopt!.accept(v);
                _RPAREN.accept(v);
            }
            v.endVisitMethodInvocation4(this);
        }
    }

/**
 *<b>
*<li>Rule 375:  ArrayAccess ::= ExpressionName [ Expression ]
 *</b>
 */
class ArrayAccess0 extends Ast implements IArrayAccess
    {
         late IExpressionName _ExpressionName;
         late AstToken _LBRACKET;
         late IExpression _Expression;
         late AstToken _RBRACKET;

         IExpressionName getExpressionName(){ return _ExpressionName; }
         void setExpressionName(IExpressionName _ExpressionName){ this._ExpressionName = _ExpressionName; }
         AstToken getLBRACKET(){ return _LBRACKET; }
         void setLBRACKET(AstToken _LBRACKET){ this._LBRACKET = _LBRACKET; }
         IExpression getExpression(){ return _Expression; }
         void setExpression(IExpression _Expression){ this._Expression = _Expression; }
         AstToken getRBRACKET(){ return _RBRACKET; }
         void setRBRACKET(AstToken _RBRACKET){ this._RBRACKET = _RBRACKET; }

        ArrayAccess0(IToken leftIToken, IToken rightIToken,
                     IExpressionName _ExpressionName,
                     AstToken _LBRACKET,
                     IExpression _Expression,
                     AstToken _RBRACKET)
            :super(leftIToken, rightIToken)

        {
            this._ExpressionName = _ExpressionName;
            (_ExpressionName as Ast).setParent(this);
            this._LBRACKET = _LBRACKET;
            (_LBRACKET as Ast).setParent(this);
            this._Expression = _Expression;
            (_Expression as Ast).setParent(this);
            this._RBRACKET = _RBRACKET;
            (_RBRACKET as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ExpressionName)  list.add(_ExpressionName);
            if(null != _LBRACKET)  list.add(_LBRACKET);
            if(null != _Expression)  list.add(_Expression);
            if(null != _RBRACKET)  list.add(_RBRACKET);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitArrayAccess0(this);
            if (checkChildren)
            {
                _ExpressionName.accept(v);
                _LBRACKET.accept(v);
                _Expression.accept(v);
                _RBRACKET.accept(v);
            }
            v.endVisitArrayAccess0(this);
        }
    }

/**
 *<b>
*<li>Rule 376:  ArrayAccess ::= PrimaryNoNewArray [ Expression ]
 *</b>
 */
class ArrayAccess1 extends Ast implements IArrayAccess
    {
         late IPrimaryNoNewArray _PrimaryNoNewArray;
         late AstToken _LBRACKET;
         late IExpression _Expression;
         late AstToken _RBRACKET;

         IPrimaryNoNewArray getPrimaryNoNewArray(){ return _PrimaryNoNewArray; }
         void setPrimaryNoNewArray(IPrimaryNoNewArray _PrimaryNoNewArray){ this._PrimaryNoNewArray = _PrimaryNoNewArray; }
         AstToken getLBRACKET(){ return _LBRACKET; }
         void setLBRACKET(AstToken _LBRACKET){ this._LBRACKET = _LBRACKET; }
         IExpression getExpression(){ return _Expression; }
         void setExpression(IExpression _Expression){ this._Expression = _Expression; }
         AstToken getRBRACKET(){ return _RBRACKET; }
         void setRBRACKET(AstToken _RBRACKET){ this._RBRACKET = _RBRACKET; }

        ArrayAccess1(IToken leftIToken, IToken rightIToken,
                     IPrimaryNoNewArray _PrimaryNoNewArray,
                     AstToken _LBRACKET,
                     IExpression _Expression,
                     AstToken _RBRACKET)
            :super(leftIToken, rightIToken)

        {
            this._PrimaryNoNewArray = _PrimaryNoNewArray;
            (_PrimaryNoNewArray as Ast).setParent(this);
            this._LBRACKET = _LBRACKET;
            (_LBRACKET as Ast).setParent(this);
            this._Expression = _Expression;
            (_Expression as Ast).setParent(this);
            this._RBRACKET = _RBRACKET;
            (_RBRACKET as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _PrimaryNoNewArray)  list.add(_PrimaryNoNewArray);
            if(null != _LBRACKET)  list.add(_LBRACKET);
            if(null != _Expression)  list.add(_Expression);
            if(null != _RBRACKET)  list.add(_RBRACKET);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitArrayAccess1(this);
            if (checkChildren)
            {
                _PrimaryNoNewArray.accept(v);
                _LBRACKET.accept(v);
                _Expression.accept(v);
                _RBRACKET.accept(v);
            }
            v.endVisitArrayAccess1(this);
        }
    }

/**
 *<b>
*<li>Rule 385:  UnaryExpression ::= + UnaryExpression
 *</b>
 */
class UnaryExpression0 extends Ast implements IUnaryExpression
    {
         late AstToken _PLUS;
         late IUnaryExpression _UnaryExpression;

         AstToken getPLUS(){ return _PLUS; }
         void setPLUS(AstToken _PLUS){ this._PLUS = _PLUS; }
         IUnaryExpression getUnaryExpression(){ return _UnaryExpression; }
         void setUnaryExpression(IUnaryExpression _UnaryExpression){ this._UnaryExpression = _UnaryExpression; }

        UnaryExpression0(IToken leftIToken, IToken rightIToken,
                         AstToken _PLUS,
                         IUnaryExpression _UnaryExpression)
            :super(leftIToken, rightIToken)

        {
            this._PLUS = _PLUS;
            (_PLUS as Ast).setParent(this);
            this._UnaryExpression = _UnaryExpression;
            (_UnaryExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _PLUS)  list.add(_PLUS);
            if(null != _UnaryExpression)  list.add(_UnaryExpression);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitUnaryExpression0(this);
            if (checkChildren)
            {
                _PLUS.accept(v);
                _UnaryExpression.accept(v);
            }
            v.endVisitUnaryExpression0(this);
        }
    }

/**
 *<b>
*<li>Rule 386:  UnaryExpression ::= - UnaryExpression
 *</b>
 */
class UnaryExpression1 extends Ast implements IUnaryExpression
    {
         late AstToken _MINUS;
         late IUnaryExpression _UnaryExpression;

         AstToken getMINUS(){ return _MINUS; }
         void setMINUS(AstToken _MINUS){ this._MINUS = _MINUS; }
         IUnaryExpression getUnaryExpression(){ return _UnaryExpression; }
         void setUnaryExpression(IUnaryExpression _UnaryExpression){ this._UnaryExpression = _UnaryExpression; }

        UnaryExpression1(IToken leftIToken, IToken rightIToken,
                         AstToken _MINUS,
                         IUnaryExpression _UnaryExpression)
            :super(leftIToken, rightIToken)

        {
            this._MINUS = _MINUS;
            (_MINUS as Ast).setParent(this);
            this._UnaryExpression = _UnaryExpression;
            (_UnaryExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _MINUS)  list.add(_MINUS);
            if(null != _UnaryExpression)  list.add(_UnaryExpression);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitUnaryExpression1(this);
            if (checkChildren)
            {
                _MINUS.accept(v);
                _UnaryExpression.accept(v);
            }
            v.endVisitUnaryExpression1(this);
        }
    }

/**
 *<b>
*<li>Rule 391:  UnaryExpressionNotPlusMinus ::= ~ UnaryExpression
 *</b>
 */
class UnaryExpressionNotPlusMinus0 extends Ast implements IUnaryExpressionNotPlusMinus
    {
         late AstToken _TWIDDLE;
         late IUnaryExpression _UnaryExpression;

         AstToken getTWIDDLE(){ return _TWIDDLE; }
         void setTWIDDLE(AstToken _TWIDDLE){ this._TWIDDLE = _TWIDDLE; }
         IUnaryExpression getUnaryExpression(){ return _UnaryExpression; }
         void setUnaryExpression(IUnaryExpression _UnaryExpression){ this._UnaryExpression = _UnaryExpression; }

        UnaryExpressionNotPlusMinus0(IToken leftIToken, IToken rightIToken,
                                     AstToken _TWIDDLE,
                                     IUnaryExpression _UnaryExpression)
            :super(leftIToken, rightIToken)

        {
            this._TWIDDLE = _TWIDDLE;
            (_TWIDDLE as Ast).setParent(this);
            this._UnaryExpression = _UnaryExpression;
            (_UnaryExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _TWIDDLE)  list.add(_TWIDDLE);
            if(null != _UnaryExpression)  list.add(_UnaryExpression);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitUnaryExpressionNotPlusMinus0(this);
            if (checkChildren)
            {
                _TWIDDLE.accept(v);
                _UnaryExpression.accept(v);
            }
            v.endVisitUnaryExpressionNotPlusMinus0(this);
        }
    }

/**
 *<b>
*<li>Rule 392:  UnaryExpressionNotPlusMinus ::= ! UnaryExpression
 *</b>
 */
class UnaryExpressionNotPlusMinus1 extends Ast implements IUnaryExpressionNotPlusMinus
    {
         late AstToken _NOT;
         late IUnaryExpression _UnaryExpression;

         AstToken getNOT(){ return _NOT; }
         void setNOT(AstToken _NOT){ this._NOT = _NOT; }
         IUnaryExpression getUnaryExpression(){ return _UnaryExpression; }
         void setUnaryExpression(IUnaryExpression _UnaryExpression){ this._UnaryExpression = _UnaryExpression; }

        UnaryExpressionNotPlusMinus1(IToken leftIToken, IToken rightIToken,
                                     AstToken _NOT,
                                     IUnaryExpression _UnaryExpression)
            :super(leftIToken, rightIToken)

        {
            this._NOT = _NOT;
            (_NOT as Ast).setParent(this);
            this._UnaryExpression = _UnaryExpression;
            (_UnaryExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _NOT)  list.add(_NOT);
            if(null != _UnaryExpression)  list.add(_UnaryExpression);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitUnaryExpressionNotPlusMinus1(this);
            if (checkChildren)
            {
                _NOT.accept(v);
                _UnaryExpression.accept(v);
            }
            v.endVisitUnaryExpressionNotPlusMinus1(this);
        }
    }

/**
 *<b>
*<li>Rule 394:  CastExpression ::= ( PrimitiveType Dimsopt ) UnaryExpression
 *</b>
 */
class CastExpression0 extends Ast implements ICastExpression
    {
         late AstToken _LPAREN;
         late IPrimitiveType _PrimitiveType;
         late IDimsopt? _Dimsopt;
         late AstToken _RPAREN;
         late IUnaryExpression _UnaryExpression;

         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
         IPrimitiveType getPrimitiveType(){ return _PrimitiveType; }
         void setPrimitiveType(IPrimitiveType _PrimitiveType){ this._PrimitiveType = _PrimitiveType; }
        /**
         * The value returned by <b>getDimsopt</b> may be <b>null</b>
         */
         IDimsopt ?  getDimsopt(){ return _Dimsopt; }
         void setDimsopt(IDimsopt _Dimsopt){ this._Dimsopt = _Dimsopt; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
         IUnaryExpression getUnaryExpression(){ return _UnaryExpression; }
         void setUnaryExpression(IUnaryExpression _UnaryExpression){ this._UnaryExpression = _UnaryExpression; }

        CastExpression0(IToken leftIToken, IToken rightIToken,
                        AstToken _LPAREN,
                        IPrimitiveType _PrimitiveType,
                        IDimsopt? _Dimsopt,
                        AstToken _RPAREN,
                        IUnaryExpression _UnaryExpression)
            :super(leftIToken, rightIToken)

        {
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._PrimitiveType = _PrimitiveType;
            (_PrimitiveType as Ast).setParent(this);
            this._Dimsopt = _Dimsopt;
            if (null != _Dimsopt) (_Dimsopt as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._UnaryExpression = _UnaryExpression;
            (_UnaryExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _PrimitiveType)  list.add(_PrimitiveType);
            if(null != _Dimsopt)  list.add(_Dimsopt);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _UnaryExpression)  list.add(_UnaryExpression);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitCastExpression0(this);
            if (checkChildren)
            {
                _LPAREN.accept(v);
                _PrimitiveType.accept(v);
                if (null != _Dimsopt) _Dimsopt!.accept(v);
                _RPAREN.accept(v);
                _UnaryExpression.accept(v);
            }
            v.endVisitCastExpression0(this);
        }
    }

/**
 *<b>
*<li>Rule 395:  CastExpression ::= ( ReferenceType ) UnaryExpressionNotPlusMinus
 *</b>
 */
class CastExpression1 extends Ast implements ICastExpression
    {
         late AstToken _LPAREN;
         late IReferenceType _ReferenceType;
         late AstToken _RPAREN;
         late IUnaryExpressionNotPlusMinus _UnaryExpressionNotPlusMinus;

         AstToken getLPAREN(){ return _LPAREN; }
         void setLPAREN(AstToken _LPAREN){ this._LPAREN = _LPAREN; }
         IReferenceType getReferenceType(){ return _ReferenceType; }
         void setReferenceType(IReferenceType _ReferenceType){ this._ReferenceType = _ReferenceType; }
         AstToken getRPAREN(){ return _RPAREN; }
         void setRPAREN(AstToken _RPAREN){ this._RPAREN = _RPAREN; }
         IUnaryExpressionNotPlusMinus getUnaryExpressionNotPlusMinus(){ return _UnaryExpressionNotPlusMinus; }
         void setUnaryExpressionNotPlusMinus(IUnaryExpressionNotPlusMinus _UnaryExpressionNotPlusMinus){ this._UnaryExpressionNotPlusMinus = _UnaryExpressionNotPlusMinus; }

        CastExpression1(IToken leftIToken, IToken rightIToken,
                        AstToken _LPAREN,
                        IReferenceType _ReferenceType,
                        AstToken _RPAREN,
                        IUnaryExpressionNotPlusMinus _UnaryExpressionNotPlusMinus)
            :super(leftIToken, rightIToken)

        {
            this._LPAREN = _LPAREN;
            (_LPAREN as Ast).setParent(this);
            this._ReferenceType = _ReferenceType;
            (_ReferenceType as Ast).setParent(this);
            this._RPAREN = _RPAREN;
            (_RPAREN as Ast).setParent(this);
            this._UnaryExpressionNotPlusMinus = _UnaryExpressionNotPlusMinus;
            (_UnaryExpressionNotPlusMinus as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _LPAREN)  list.add(_LPAREN);
            if(null != _ReferenceType)  list.add(_ReferenceType);
            if(null != _RPAREN)  list.add(_RPAREN);
            if(null != _UnaryExpressionNotPlusMinus)  list.add(_UnaryExpressionNotPlusMinus);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitCastExpression1(this);
            if (checkChildren)
            {
                _LPAREN.accept(v);
                _ReferenceType.accept(v);
                _RPAREN.accept(v);
                _UnaryExpressionNotPlusMinus.accept(v);
            }
            v.endVisitCastExpression1(this);
        }
    }

/**
 *<b>
*<li>Rule 397:  MultiplicativeExpression ::= MultiplicativeExpression * UnaryExpression
 *</b>
 */
class MultiplicativeExpression0 extends Ast implements IMultiplicativeExpression
    {
         late IMultiplicativeExpression _MultiplicativeExpression;
         late AstToken _MULTIPLY;
         late IUnaryExpression _UnaryExpression;

         IMultiplicativeExpression getMultiplicativeExpression(){ return _MultiplicativeExpression; }
         void setMultiplicativeExpression(IMultiplicativeExpression _MultiplicativeExpression){ this._MultiplicativeExpression = _MultiplicativeExpression; }
         AstToken getMULTIPLY(){ return _MULTIPLY; }
         void setMULTIPLY(AstToken _MULTIPLY){ this._MULTIPLY = _MULTIPLY; }
         IUnaryExpression getUnaryExpression(){ return _UnaryExpression; }
         void setUnaryExpression(IUnaryExpression _UnaryExpression){ this._UnaryExpression = _UnaryExpression; }

        MultiplicativeExpression0(IToken leftIToken, IToken rightIToken,
                                  IMultiplicativeExpression _MultiplicativeExpression,
                                  AstToken _MULTIPLY,
                                  IUnaryExpression _UnaryExpression)
            :super(leftIToken, rightIToken)

        {
            this._MultiplicativeExpression = _MultiplicativeExpression;
            (_MultiplicativeExpression as Ast).setParent(this);
            this._MULTIPLY = _MULTIPLY;
            (_MULTIPLY as Ast).setParent(this);
            this._UnaryExpression = _UnaryExpression;
            (_UnaryExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _MultiplicativeExpression)  list.add(_MultiplicativeExpression);
            if(null != _MULTIPLY)  list.add(_MULTIPLY);
            if(null != _UnaryExpression)  list.add(_UnaryExpression);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitMultiplicativeExpression0(this);
            if (checkChildren)
            {
                _MultiplicativeExpression.accept(v);
                _MULTIPLY.accept(v);
                _UnaryExpression.accept(v);
            }
            v.endVisitMultiplicativeExpression0(this);
        }
    }

/**
 *<b>
*<li>Rule 398:  MultiplicativeExpression ::= MultiplicativeExpression / UnaryExpression
 *</b>
 */
class MultiplicativeExpression1 extends Ast implements IMultiplicativeExpression
    {
         late IMultiplicativeExpression _MultiplicativeExpression;
         late AstToken _DIVIDE;
         late IUnaryExpression _UnaryExpression;

         IMultiplicativeExpression getMultiplicativeExpression(){ return _MultiplicativeExpression; }
         void setMultiplicativeExpression(IMultiplicativeExpression _MultiplicativeExpression){ this._MultiplicativeExpression = _MultiplicativeExpression; }
         AstToken getDIVIDE(){ return _DIVIDE; }
         void setDIVIDE(AstToken _DIVIDE){ this._DIVIDE = _DIVIDE; }
         IUnaryExpression getUnaryExpression(){ return _UnaryExpression; }
         void setUnaryExpression(IUnaryExpression _UnaryExpression){ this._UnaryExpression = _UnaryExpression; }

        MultiplicativeExpression1(IToken leftIToken, IToken rightIToken,
                                  IMultiplicativeExpression _MultiplicativeExpression,
                                  AstToken _DIVIDE,
                                  IUnaryExpression _UnaryExpression)
            :super(leftIToken, rightIToken)

        {
            this._MultiplicativeExpression = _MultiplicativeExpression;
            (_MultiplicativeExpression as Ast).setParent(this);
            this._DIVIDE = _DIVIDE;
            (_DIVIDE as Ast).setParent(this);
            this._UnaryExpression = _UnaryExpression;
            (_UnaryExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _MultiplicativeExpression)  list.add(_MultiplicativeExpression);
            if(null != _DIVIDE)  list.add(_DIVIDE);
            if(null != _UnaryExpression)  list.add(_UnaryExpression);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitMultiplicativeExpression1(this);
            if (checkChildren)
            {
                _MultiplicativeExpression.accept(v);
                _DIVIDE.accept(v);
                _UnaryExpression.accept(v);
            }
            v.endVisitMultiplicativeExpression1(this);
        }
    }

/**
 *<b>
*<li>Rule 399:  MultiplicativeExpression ::= MultiplicativeExpression % UnaryExpression
 *</b>
 */
class MultiplicativeExpression2 extends Ast implements IMultiplicativeExpression
    {
         late IMultiplicativeExpression _MultiplicativeExpression;
         late AstToken _REMAINDER;
         late IUnaryExpression _UnaryExpression;

         IMultiplicativeExpression getMultiplicativeExpression(){ return _MultiplicativeExpression; }
         void setMultiplicativeExpression(IMultiplicativeExpression _MultiplicativeExpression){ this._MultiplicativeExpression = _MultiplicativeExpression; }
         AstToken getREMAINDER(){ return _REMAINDER; }
         void setREMAINDER(AstToken _REMAINDER){ this._REMAINDER = _REMAINDER; }
         IUnaryExpression getUnaryExpression(){ return _UnaryExpression; }
         void setUnaryExpression(IUnaryExpression _UnaryExpression){ this._UnaryExpression = _UnaryExpression; }

        MultiplicativeExpression2(IToken leftIToken, IToken rightIToken,
                                  IMultiplicativeExpression _MultiplicativeExpression,
                                  AstToken _REMAINDER,
                                  IUnaryExpression _UnaryExpression)
            :super(leftIToken, rightIToken)

        {
            this._MultiplicativeExpression = _MultiplicativeExpression;
            (_MultiplicativeExpression as Ast).setParent(this);
            this._REMAINDER = _REMAINDER;
            (_REMAINDER as Ast).setParent(this);
            this._UnaryExpression = _UnaryExpression;
            (_UnaryExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _MultiplicativeExpression)  list.add(_MultiplicativeExpression);
            if(null != _REMAINDER)  list.add(_REMAINDER);
            if(null != _UnaryExpression)  list.add(_UnaryExpression);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitMultiplicativeExpression2(this);
            if (checkChildren)
            {
                _MultiplicativeExpression.accept(v);
                _REMAINDER.accept(v);
                _UnaryExpression.accept(v);
            }
            v.endVisitMultiplicativeExpression2(this);
        }
    }

/**
 *<b>
*<li>Rule 401:  AdditiveExpression ::= AdditiveExpression + MultiplicativeExpression
 *</b>
 */
class AdditiveExpression0 extends Ast implements IAdditiveExpression
    {
         late IAdditiveExpression _AdditiveExpression;
         late AstToken _PLUS;
         late IMultiplicativeExpression _MultiplicativeExpression;

         IAdditiveExpression getAdditiveExpression(){ return _AdditiveExpression; }
         void setAdditiveExpression(IAdditiveExpression _AdditiveExpression){ this._AdditiveExpression = _AdditiveExpression; }
         AstToken getPLUS(){ return _PLUS; }
         void setPLUS(AstToken _PLUS){ this._PLUS = _PLUS; }
         IMultiplicativeExpression getMultiplicativeExpression(){ return _MultiplicativeExpression; }
         void setMultiplicativeExpression(IMultiplicativeExpression _MultiplicativeExpression){ this._MultiplicativeExpression = _MultiplicativeExpression; }

        AdditiveExpression0(IToken leftIToken, IToken rightIToken,
                            IAdditiveExpression _AdditiveExpression,
                            AstToken _PLUS,
                            IMultiplicativeExpression _MultiplicativeExpression)
            :super(leftIToken, rightIToken)

        {
            this._AdditiveExpression = _AdditiveExpression;
            (_AdditiveExpression as Ast).setParent(this);
            this._PLUS = _PLUS;
            (_PLUS as Ast).setParent(this);
            this._MultiplicativeExpression = _MultiplicativeExpression;
            (_MultiplicativeExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _AdditiveExpression)  list.add(_AdditiveExpression);
            if(null != _PLUS)  list.add(_PLUS);
            if(null != _MultiplicativeExpression)  list.add(_MultiplicativeExpression);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitAdditiveExpression0(this);
            if (checkChildren)
            {
                _AdditiveExpression.accept(v);
                _PLUS.accept(v);
                _MultiplicativeExpression.accept(v);
            }
            v.endVisitAdditiveExpression0(this);
        }
    }

/**
 *<b>
*<li>Rule 402:  AdditiveExpression ::= AdditiveExpression - MultiplicativeExpression
 *</b>
 */
class AdditiveExpression1 extends Ast implements IAdditiveExpression
    {
         late IAdditiveExpression _AdditiveExpression;
         late AstToken _MINUS;
         late IMultiplicativeExpression _MultiplicativeExpression;

         IAdditiveExpression getAdditiveExpression(){ return _AdditiveExpression; }
         void setAdditiveExpression(IAdditiveExpression _AdditiveExpression){ this._AdditiveExpression = _AdditiveExpression; }
         AstToken getMINUS(){ return _MINUS; }
         void setMINUS(AstToken _MINUS){ this._MINUS = _MINUS; }
         IMultiplicativeExpression getMultiplicativeExpression(){ return _MultiplicativeExpression; }
         void setMultiplicativeExpression(IMultiplicativeExpression _MultiplicativeExpression){ this._MultiplicativeExpression = _MultiplicativeExpression; }

        AdditiveExpression1(IToken leftIToken, IToken rightIToken,
                            IAdditiveExpression _AdditiveExpression,
                            AstToken _MINUS,
                            IMultiplicativeExpression _MultiplicativeExpression)
            :super(leftIToken, rightIToken)

        {
            this._AdditiveExpression = _AdditiveExpression;
            (_AdditiveExpression as Ast).setParent(this);
            this._MINUS = _MINUS;
            (_MINUS as Ast).setParent(this);
            this._MultiplicativeExpression = _MultiplicativeExpression;
            (_MultiplicativeExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _AdditiveExpression)  list.add(_AdditiveExpression);
            if(null != _MINUS)  list.add(_MINUS);
            if(null != _MultiplicativeExpression)  list.add(_MultiplicativeExpression);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitAdditiveExpression1(this);
            if (checkChildren)
            {
                _AdditiveExpression.accept(v);
                _MINUS.accept(v);
                _MultiplicativeExpression.accept(v);
            }
            v.endVisitAdditiveExpression1(this);
        }
    }

/**
 *<b>
*<li>Rule 404:  ShiftExpression ::= ShiftExpression << AdditiveExpression
 *</b>
 */
class ShiftExpression0 extends Ast implements IShiftExpression
    {
         late IShiftExpression _ShiftExpression;
         late AstToken _LEFT_SHIFT;
         late IAdditiveExpression _AdditiveExpression;

         IShiftExpression getShiftExpression(){ return _ShiftExpression; }
         void setShiftExpression(IShiftExpression _ShiftExpression){ this._ShiftExpression = _ShiftExpression; }
         AstToken getLEFT_SHIFT(){ return _LEFT_SHIFT; }
         void setLEFT_SHIFT(AstToken _LEFT_SHIFT){ this._LEFT_SHIFT = _LEFT_SHIFT; }
         IAdditiveExpression getAdditiveExpression(){ return _AdditiveExpression; }
         void setAdditiveExpression(IAdditiveExpression _AdditiveExpression){ this._AdditiveExpression = _AdditiveExpression; }

        ShiftExpression0(IToken leftIToken, IToken rightIToken,
                         IShiftExpression _ShiftExpression,
                         AstToken _LEFT_SHIFT,
                         IAdditiveExpression _AdditiveExpression)
            :super(leftIToken, rightIToken)

        {
            this._ShiftExpression = _ShiftExpression;
            (_ShiftExpression as Ast).setParent(this);
            this._LEFT_SHIFT = _LEFT_SHIFT;
            (_LEFT_SHIFT as Ast).setParent(this);
            this._AdditiveExpression = _AdditiveExpression;
            (_AdditiveExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ShiftExpression)  list.add(_ShiftExpression);
            if(null != _LEFT_SHIFT)  list.add(_LEFT_SHIFT);
            if(null != _AdditiveExpression)  list.add(_AdditiveExpression);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitShiftExpression0(this);
            if (checkChildren)
            {
                _ShiftExpression.accept(v);
                _LEFT_SHIFT.accept(v);
                _AdditiveExpression.accept(v);
            }
            v.endVisitShiftExpression0(this);
        }
    }

/**
 *<b>
*<li>Rule 405:  ShiftExpression ::= ShiftExpression > > AdditiveExpression
 *</b>
 */
class ShiftExpression1 extends Ast implements IShiftExpression
    {
         late IShiftExpression _ShiftExpression;
         late AstToken _GREATER;
         late AstToken _GREATER3;
         late IAdditiveExpression _AdditiveExpression;

         IShiftExpression getShiftExpression(){ return _ShiftExpression; }
         void setShiftExpression(IShiftExpression _ShiftExpression){ this._ShiftExpression = _ShiftExpression; }
         AstToken getGREATER(){ return _GREATER; }
         void setGREATER(AstToken _GREATER){ this._GREATER = _GREATER; }
         AstToken getGREATER3(){ return _GREATER3; }
         void setGREATER3(AstToken _GREATER3){ this._GREATER3 = _GREATER3; }
         IAdditiveExpression getAdditiveExpression(){ return _AdditiveExpression; }
         void setAdditiveExpression(IAdditiveExpression _AdditiveExpression){ this._AdditiveExpression = _AdditiveExpression; }

        ShiftExpression1(IToken leftIToken, IToken rightIToken,
                         IShiftExpression _ShiftExpression,
                         AstToken _GREATER,
                         AstToken _GREATER3,
                         IAdditiveExpression _AdditiveExpression)
            :super(leftIToken, rightIToken)

        {
            this._ShiftExpression = _ShiftExpression;
            (_ShiftExpression as Ast).setParent(this);
            this._GREATER = _GREATER;
            (_GREATER as Ast).setParent(this);
            this._GREATER3 = _GREATER3;
            (_GREATER3 as Ast).setParent(this);
            this._AdditiveExpression = _AdditiveExpression;
            (_AdditiveExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ShiftExpression)  list.add(_ShiftExpression);
            if(null != _GREATER)  list.add(_GREATER);
            if(null != _GREATER3)  list.add(_GREATER3);
            if(null != _AdditiveExpression)  list.add(_AdditiveExpression);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitShiftExpression1(this);
            if (checkChildren)
            {
                _ShiftExpression.accept(v);
                _GREATER.accept(v);
                _GREATER3.accept(v);
                _AdditiveExpression.accept(v);
            }
            v.endVisitShiftExpression1(this);
        }
    }

/**
 *<b>
*<li>Rule 406:  ShiftExpression ::= ShiftExpression > > > AdditiveExpression
 *</b>
 */
class ShiftExpression2 extends Ast implements IShiftExpression
    {
         late IShiftExpression _ShiftExpression;
         late AstToken _GREATER;
         late AstToken _GREATER3;
         late AstToken _GREATER4;
         late IAdditiveExpression _AdditiveExpression;

         IShiftExpression getShiftExpression(){ return _ShiftExpression; }
         void setShiftExpression(IShiftExpression _ShiftExpression){ this._ShiftExpression = _ShiftExpression; }
         AstToken getGREATER(){ return _GREATER; }
         void setGREATER(AstToken _GREATER){ this._GREATER = _GREATER; }
         AstToken getGREATER3(){ return _GREATER3; }
         void setGREATER3(AstToken _GREATER3){ this._GREATER3 = _GREATER3; }
         AstToken getGREATER4(){ return _GREATER4; }
         void setGREATER4(AstToken _GREATER4){ this._GREATER4 = _GREATER4; }
         IAdditiveExpression getAdditiveExpression(){ return _AdditiveExpression; }
         void setAdditiveExpression(IAdditiveExpression _AdditiveExpression){ this._AdditiveExpression = _AdditiveExpression; }

        ShiftExpression2(IToken leftIToken, IToken rightIToken,
                         IShiftExpression _ShiftExpression,
                         AstToken _GREATER,
                         AstToken _GREATER3,
                         AstToken _GREATER4,
                         IAdditiveExpression _AdditiveExpression)
            :super(leftIToken, rightIToken)

        {
            this._ShiftExpression = _ShiftExpression;
            (_ShiftExpression as Ast).setParent(this);
            this._GREATER = _GREATER;
            (_GREATER as Ast).setParent(this);
            this._GREATER3 = _GREATER3;
            (_GREATER3 as Ast).setParent(this);
            this._GREATER4 = _GREATER4;
            (_GREATER4 as Ast).setParent(this);
            this._AdditiveExpression = _AdditiveExpression;
            (_AdditiveExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _ShiftExpression)  list.add(_ShiftExpression);
            if(null != _GREATER)  list.add(_GREATER);
            if(null != _GREATER3)  list.add(_GREATER3);
            if(null != _GREATER4)  list.add(_GREATER4);
            if(null != _AdditiveExpression)  list.add(_AdditiveExpression);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitShiftExpression2(this);
            if (checkChildren)
            {
                _ShiftExpression.accept(v);
                _GREATER.accept(v);
                _GREATER3.accept(v);
                _GREATER4.accept(v);
                _AdditiveExpression.accept(v);
            }
            v.endVisitShiftExpression2(this);
        }
    }

/**
 *<b>
*<li>Rule 408:  RelationalExpression ::= RelationalExpression < ShiftExpression
 *</b>
 */
class RelationalExpression0 extends Ast implements IRelationalExpression
    {
         late IRelationalExpression _RelationalExpression;
         late AstToken _LESS;
         late IShiftExpression _ShiftExpression;

         IRelationalExpression getRelationalExpression(){ return _RelationalExpression; }
         void setRelationalExpression(IRelationalExpression _RelationalExpression){ this._RelationalExpression = _RelationalExpression; }
         AstToken getLESS(){ return _LESS; }
         void setLESS(AstToken _LESS){ this._LESS = _LESS; }
         IShiftExpression getShiftExpression(){ return _ShiftExpression; }
         void setShiftExpression(IShiftExpression _ShiftExpression){ this._ShiftExpression = _ShiftExpression; }

        RelationalExpression0(IToken leftIToken, IToken rightIToken,
                              IRelationalExpression _RelationalExpression,
                              AstToken _LESS,
                              IShiftExpression _ShiftExpression)
            :super(leftIToken, rightIToken)

        {
            this._RelationalExpression = _RelationalExpression;
            (_RelationalExpression as Ast).setParent(this);
            this._LESS = _LESS;
            (_LESS as Ast).setParent(this);
            this._ShiftExpression = _ShiftExpression;
            (_ShiftExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _RelationalExpression)  list.add(_RelationalExpression);
            if(null != _LESS)  list.add(_LESS);
            if(null != _ShiftExpression)  list.add(_ShiftExpression);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitRelationalExpression0(this);
            if (checkChildren)
            {
                _RelationalExpression.accept(v);
                _LESS.accept(v);
                _ShiftExpression.accept(v);
            }
            v.endVisitRelationalExpression0(this);
        }
    }

/**
 *<b>
*<li>Rule 409:  RelationalExpression ::= RelationalExpression > ShiftExpression
 *</b>
 */
class RelationalExpression1 extends Ast implements IRelationalExpression
    {
         late IRelationalExpression _RelationalExpression;
         late AstToken _GREATER;
         late IShiftExpression _ShiftExpression;

         IRelationalExpression getRelationalExpression(){ return _RelationalExpression; }
         void setRelationalExpression(IRelationalExpression _RelationalExpression){ this._RelationalExpression = _RelationalExpression; }
         AstToken getGREATER(){ return _GREATER; }
         void setGREATER(AstToken _GREATER){ this._GREATER = _GREATER; }
         IShiftExpression getShiftExpression(){ return _ShiftExpression; }
         void setShiftExpression(IShiftExpression _ShiftExpression){ this._ShiftExpression = _ShiftExpression; }

        RelationalExpression1(IToken leftIToken, IToken rightIToken,
                              IRelationalExpression _RelationalExpression,
                              AstToken _GREATER,
                              IShiftExpression _ShiftExpression)
            :super(leftIToken, rightIToken)

        {
            this._RelationalExpression = _RelationalExpression;
            (_RelationalExpression as Ast).setParent(this);
            this._GREATER = _GREATER;
            (_GREATER as Ast).setParent(this);
            this._ShiftExpression = _ShiftExpression;
            (_ShiftExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _RelationalExpression)  list.add(_RelationalExpression);
            if(null != _GREATER)  list.add(_GREATER);
            if(null != _ShiftExpression)  list.add(_ShiftExpression);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitRelationalExpression1(this);
            if (checkChildren)
            {
                _RelationalExpression.accept(v);
                _GREATER.accept(v);
                _ShiftExpression.accept(v);
            }
            v.endVisitRelationalExpression1(this);
        }
    }

/**
 *<b>
*<li>Rule 410:  RelationalExpression ::= RelationalExpression <= ShiftExpression
 *</b>
 */
class RelationalExpression2 extends Ast implements IRelationalExpression
    {
         late IRelationalExpression _RelationalExpression;
         late AstToken _LESS_EQUAL;
         late IShiftExpression _ShiftExpression;

         IRelationalExpression getRelationalExpression(){ return _RelationalExpression; }
         void setRelationalExpression(IRelationalExpression _RelationalExpression){ this._RelationalExpression = _RelationalExpression; }
         AstToken getLESS_EQUAL(){ return _LESS_EQUAL; }
         void setLESS_EQUAL(AstToken _LESS_EQUAL){ this._LESS_EQUAL = _LESS_EQUAL; }
         IShiftExpression getShiftExpression(){ return _ShiftExpression; }
         void setShiftExpression(IShiftExpression _ShiftExpression){ this._ShiftExpression = _ShiftExpression; }

        RelationalExpression2(IToken leftIToken, IToken rightIToken,
                              IRelationalExpression _RelationalExpression,
                              AstToken _LESS_EQUAL,
                              IShiftExpression _ShiftExpression)
            :super(leftIToken, rightIToken)

        {
            this._RelationalExpression = _RelationalExpression;
            (_RelationalExpression as Ast).setParent(this);
            this._LESS_EQUAL = _LESS_EQUAL;
            (_LESS_EQUAL as Ast).setParent(this);
            this._ShiftExpression = _ShiftExpression;
            (_ShiftExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _RelationalExpression)  list.add(_RelationalExpression);
            if(null != _LESS_EQUAL)  list.add(_LESS_EQUAL);
            if(null != _ShiftExpression)  list.add(_ShiftExpression);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitRelationalExpression2(this);
            if (checkChildren)
            {
                _RelationalExpression.accept(v);
                _LESS_EQUAL.accept(v);
                _ShiftExpression.accept(v);
            }
            v.endVisitRelationalExpression2(this);
        }
    }

/**
 *<b>
*<li>Rule 411:  RelationalExpression ::= RelationalExpression > = ShiftExpression
 *</b>
 */
class RelationalExpression3 extends Ast implements IRelationalExpression
    {
         late IRelationalExpression _RelationalExpression;
         late AstToken _GREATER;
         late AstToken _EQUAL;
         late IShiftExpression _ShiftExpression;

         IRelationalExpression getRelationalExpression(){ return _RelationalExpression; }
         void setRelationalExpression(IRelationalExpression _RelationalExpression){ this._RelationalExpression = _RelationalExpression; }
         AstToken getGREATER(){ return _GREATER; }
         void setGREATER(AstToken _GREATER){ this._GREATER = _GREATER; }
         AstToken getEQUAL(){ return _EQUAL; }
         void setEQUAL(AstToken _EQUAL){ this._EQUAL = _EQUAL; }
         IShiftExpression getShiftExpression(){ return _ShiftExpression; }
         void setShiftExpression(IShiftExpression _ShiftExpression){ this._ShiftExpression = _ShiftExpression; }

        RelationalExpression3(IToken leftIToken, IToken rightIToken,
                              IRelationalExpression _RelationalExpression,
                              AstToken _GREATER,
                              AstToken _EQUAL,
                              IShiftExpression _ShiftExpression)
            :super(leftIToken, rightIToken)

        {
            this._RelationalExpression = _RelationalExpression;
            (_RelationalExpression as Ast).setParent(this);
            this._GREATER = _GREATER;
            (_GREATER as Ast).setParent(this);
            this._EQUAL = _EQUAL;
            (_EQUAL as Ast).setParent(this);
            this._ShiftExpression = _ShiftExpression;
            (_ShiftExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _RelationalExpression)  list.add(_RelationalExpression);
            if(null != _GREATER)  list.add(_GREATER);
            if(null != _EQUAL)  list.add(_EQUAL);
            if(null != _ShiftExpression)  list.add(_ShiftExpression);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitRelationalExpression3(this);
            if (checkChildren)
            {
                _RelationalExpression.accept(v);
                _GREATER.accept(v);
                _EQUAL.accept(v);
                _ShiftExpression.accept(v);
            }
            v.endVisitRelationalExpression3(this);
        }
    }

/**
 *<b>
*<li>Rule 412:  RelationalExpression ::= RelationalExpression instanceof ReferenceType
 *</b>
 */
class RelationalExpression4 extends Ast implements IRelationalExpression
    {
         late IRelationalExpression _RelationalExpression;
         late AstToken _instanceof;
         late IReferenceType _ReferenceType;

         IRelationalExpression getRelationalExpression(){ return _RelationalExpression; }
         void setRelationalExpression(IRelationalExpression _RelationalExpression){ this._RelationalExpression = _RelationalExpression; }
         AstToken getinstanceof(){ return _instanceof; }
         void setinstanceof(AstToken _instanceof){ this._instanceof = _instanceof; }
         IReferenceType getReferenceType(){ return _ReferenceType; }
         void setReferenceType(IReferenceType _ReferenceType){ this._ReferenceType = _ReferenceType; }

        RelationalExpression4(IToken leftIToken, IToken rightIToken,
                              IRelationalExpression _RelationalExpression,
                              AstToken _instanceof,
                              IReferenceType _ReferenceType)
            :super(leftIToken, rightIToken)

        {
            this._RelationalExpression = _RelationalExpression;
            (_RelationalExpression as Ast).setParent(this);
            this._instanceof = _instanceof;
            (_instanceof as Ast).setParent(this);
            this._ReferenceType = _ReferenceType;
            (_ReferenceType as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _RelationalExpression)  list.add(_RelationalExpression);
            if(null != _instanceof)  list.add(_instanceof);
            if(null != _ReferenceType)  list.add(_ReferenceType);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitRelationalExpression4(this);
            if (checkChildren)
            {
                _RelationalExpression.accept(v);
                _instanceof.accept(v);
                _ReferenceType.accept(v);
            }
            v.endVisitRelationalExpression4(this);
        }
    }

/**
 *<b>
*<li>Rule 414:  EqualityExpression ::= EqualityExpression == RelationalExpression
 *</b>
 */
class EqualityExpression0 extends Ast implements IEqualityExpression
    {
         late IEqualityExpression _EqualityExpression;
         late AstToken _EQUAL_EQUAL;
         late IRelationalExpression _RelationalExpression;

         IEqualityExpression getEqualityExpression(){ return _EqualityExpression; }
         void setEqualityExpression(IEqualityExpression _EqualityExpression){ this._EqualityExpression = _EqualityExpression; }
         AstToken getEQUAL_EQUAL(){ return _EQUAL_EQUAL; }
         void setEQUAL_EQUAL(AstToken _EQUAL_EQUAL){ this._EQUAL_EQUAL = _EQUAL_EQUAL; }
         IRelationalExpression getRelationalExpression(){ return _RelationalExpression; }
         void setRelationalExpression(IRelationalExpression _RelationalExpression){ this._RelationalExpression = _RelationalExpression; }

        EqualityExpression0(IToken leftIToken, IToken rightIToken,
                            IEqualityExpression _EqualityExpression,
                            AstToken _EQUAL_EQUAL,
                            IRelationalExpression _RelationalExpression)
            :super(leftIToken, rightIToken)

        {
            this._EqualityExpression = _EqualityExpression;
            (_EqualityExpression as Ast).setParent(this);
            this._EQUAL_EQUAL = _EQUAL_EQUAL;
            (_EQUAL_EQUAL as Ast).setParent(this);
            this._RelationalExpression = _RelationalExpression;
            (_RelationalExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _EqualityExpression)  list.add(_EqualityExpression);
            if(null != _EQUAL_EQUAL)  list.add(_EQUAL_EQUAL);
            if(null != _RelationalExpression)  list.add(_RelationalExpression);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitEqualityExpression0(this);
            if (checkChildren)
            {
                _EqualityExpression.accept(v);
                _EQUAL_EQUAL.accept(v);
                _RelationalExpression.accept(v);
            }
            v.endVisitEqualityExpression0(this);
        }
    }

/**
 *<b>
*<li>Rule 415:  EqualityExpression ::= EqualityExpression != RelationalExpression
 *</b>
 */
class EqualityExpression1 extends Ast implements IEqualityExpression
    {
         late IEqualityExpression _EqualityExpression;
         late AstToken _NOT_EQUAL;
         late IRelationalExpression _RelationalExpression;

         IEqualityExpression getEqualityExpression(){ return _EqualityExpression; }
         void setEqualityExpression(IEqualityExpression _EqualityExpression){ this._EqualityExpression = _EqualityExpression; }
         AstToken getNOT_EQUAL(){ return _NOT_EQUAL; }
         void setNOT_EQUAL(AstToken _NOT_EQUAL){ this._NOT_EQUAL = _NOT_EQUAL; }
         IRelationalExpression getRelationalExpression(){ return _RelationalExpression; }
         void setRelationalExpression(IRelationalExpression _RelationalExpression){ this._RelationalExpression = _RelationalExpression; }

        EqualityExpression1(IToken leftIToken, IToken rightIToken,
                            IEqualityExpression _EqualityExpression,
                            AstToken _NOT_EQUAL,
                            IRelationalExpression _RelationalExpression)
            :super(leftIToken, rightIToken)

        {
            this._EqualityExpression = _EqualityExpression;
            (_EqualityExpression as Ast).setParent(this);
            this._NOT_EQUAL = _NOT_EQUAL;
            (_NOT_EQUAL as Ast).setParent(this);
            this._RelationalExpression = _RelationalExpression;
            (_RelationalExpression as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _EqualityExpression)  list.add(_EqualityExpression);
            if(null != _NOT_EQUAL)  list.add(_NOT_EQUAL);
            if(null != _RelationalExpression)  list.add(_RelationalExpression);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitEqualityExpression1(this);
            if (checkChildren)
            {
                _EqualityExpression.accept(v);
                _NOT_EQUAL.accept(v);
                _RelationalExpression.accept(v);
            }
            v.endVisitEqualityExpression1(this);
        }
    }

/**
 *<b>
*<li>Rule 434:  AssignmentOperator ::= =
 *</b>
 */
class AssignmentOperator0 extends AstToken implements IAssignmentOperator
    {
         IToken getEQUAL(){ return leftIToken; }

    AssignmentOperator0(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitAssignmentOperator0(this);
            v.endVisitAssignmentOperator0(this);
        }
    }

/**
 *<b>
*<li>Rule 435:  AssignmentOperator ::= *=
 *</b>
 */
class AssignmentOperator1 extends AstToken implements IAssignmentOperator
    {
         IToken getMULTIPLY_EQUAL(){ return leftIToken; }

    AssignmentOperator1(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitAssignmentOperator1(this);
            v.endVisitAssignmentOperator1(this);
        }
    }

/**
 *<b>
*<li>Rule 436:  AssignmentOperator ::= /=
 *</b>
 */
class AssignmentOperator2 extends AstToken implements IAssignmentOperator
    {
         IToken getDIVIDE_EQUAL(){ return leftIToken; }

    AssignmentOperator2(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitAssignmentOperator2(this);
            v.endVisitAssignmentOperator2(this);
        }
    }

/**
 *<b>
*<li>Rule 437:  AssignmentOperator ::= %=
 *</b>
 */
class AssignmentOperator3 extends AstToken implements IAssignmentOperator
    {
         IToken getREMAINDER_EQUAL(){ return leftIToken; }

    AssignmentOperator3(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitAssignmentOperator3(this);
            v.endVisitAssignmentOperator3(this);
        }
    }

/**
 *<b>
*<li>Rule 438:  AssignmentOperator ::= +=
 *</b>
 */
class AssignmentOperator4 extends AstToken implements IAssignmentOperator
    {
         IToken getPLUS_EQUAL(){ return leftIToken; }

    AssignmentOperator4(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitAssignmentOperator4(this);
            v.endVisitAssignmentOperator4(this);
        }
    }

/**
 *<b>
*<li>Rule 439:  AssignmentOperator ::= -=
 *</b>
 */
class AssignmentOperator5 extends AstToken implements IAssignmentOperator
    {
         IToken getMINUS_EQUAL(){ return leftIToken; }

    AssignmentOperator5(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitAssignmentOperator5(this);
            v.endVisitAssignmentOperator5(this);
        }
    }

/**
 *<b>
*<li>Rule 440:  AssignmentOperator ::= <<=
 *</b>
 */
class AssignmentOperator6 extends AstToken implements IAssignmentOperator
    {
         IToken getLEFT_SHIFT_EQUAL(){ return leftIToken; }

    AssignmentOperator6(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitAssignmentOperator6(this);
            v.endVisitAssignmentOperator6(this);
        }
    }

/**
 *<b>
*<li>Rule 441:  AssignmentOperator ::= > > =
 *</b>
 */
class AssignmentOperator7 extends Ast implements IAssignmentOperator
    {
         late AstToken _GREATER;
         late AstToken _GREATER2;
         late AstToken _EQUAL;

         AstToken getGREATER(){ return _GREATER; }
         void setGREATER(AstToken _GREATER){ this._GREATER = _GREATER; }
         AstToken getGREATER2(){ return _GREATER2; }
         void setGREATER2(AstToken _GREATER2){ this._GREATER2 = _GREATER2; }
         AstToken getEQUAL(){ return _EQUAL; }
         void setEQUAL(AstToken _EQUAL){ this._EQUAL = _EQUAL; }

        AssignmentOperator7(IToken leftIToken, IToken rightIToken,
                            AstToken _GREATER,
                            AstToken _GREATER2,
                            AstToken _EQUAL)
            :super(leftIToken, rightIToken)

        {
            this._GREATER = _GREATER;
            (_GREATER as Ast).setParent(this);
            this._GREATER2 = _GREATER2;
            (_GREATER2 as Ast).setParent(this);
            this._EQUAL = _EQUAL;
            (_EQUAL as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _GREATER)  list.add(_GREATER);
            if(null != _GREATER2)  list.add(_GREATER2);
            if(null != _EQUAL)  list.add(_EQUAL);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitAssignmentOperator7(this);
            if (checkChildren)
            {
                _GREATER.accept(v);
                _GREATER2.accept(v);
                _EQUAL.accept(v);
            }
            v.endVisitAssignmentOperator7(this);
        }
    }

/**
 *<b>
*<li>Rule 442:  AssignmentOperator ::= > > > =
 *</b>
 */
class AssignmentOperator8 extends Ast implements IAssignmentOperator
    {
         late AstToken _GREATER;
         late AstToken _GREATER2;
         late AstToken _GREATER3;
         late AstToken _EQUAL;

         AstToken getGREATER(){ return _GREATER; }
         void setGREATER(AstToken _GREATER){ this._GREATER = _GREATER; }
         AstToken getGREATER2(){ return _GREATER2; }
         void setGREATER2(AstToken _GREATER2){ this._GREATER2 = _GREATER2; }
         AstToken getGREATER3(){ return _GREATER3; }
         void setGREATER3(AstToken _GREATER3){ this._GREATER3 = _GREATER3; }
         AstToken getEQUAL(){ return _EQUAL; }
         void setEQUAL(AstToken _EQUAL){ this._EQUAL = _EQUAL; }

        AssignmentOperator8(IToken leftIToken, IToken rightIToken,
                            AstToken _GREATER,
                            AstToken _GREATER2,
                            AstToken _GREATER3,
                            AstToken _EQUAL)
            :super(leftIToken, rightIToken)

        {
            this._GREATER = _GREATER;
            (_GREATER as Ast).setParent(this);
            this._GREATER2 = _GREATER2;
            (_GREATER2 as Ast).setParent(this);
            this._GREATER3 = _GREATER3;
            (_GREATER3 as Ast).setParent(this);
            this._EQUAL = _EQUAL;
            (_EQUAL as Ast).setParent(this);
            initialize();
        }

        /**
         * A list of all children of this node, don't including the null ones.
         */
            ArrayList getAllChildren() 
        {
            var list = new ArrayList();
            if(null != _GREATER)  list.add(_GREATER);
            if(null != _GREATER2)  list.add(_GREATER2);
            if(null != _GREATER3)  list.add(_GREATER3);
            if(null != _EQUAL)  list.add(_EQUAL);
            return list;
        }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            var checkChildren = v.visitAssignmentOperator8(this);
            if (checkChildren)
            {
                _GREATER.accept(v);
                _GREATER2.accept(v);
                _GREATER3.accept(v);
                _EQUAL.accept(v);
            }
            v.endVisitAssignmentOperator8(this);
        }
    }

/**
 *<b>
*<li>Rule 443:  AssignmentOperator ::= &=
 *</b>
 */
class AssignmentOperator9 extends AstToken implements IAssignmentOperator
    {
         IToken getAND_EQUAL(){ return leftIToken; }

    AssignmentOperator9(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitAssignmentOperator9(this);
            v.endVisitAssignmentOperator9(this);
        }
    }

/**
 *<b>
*<li>Rule 444:  AssignmentOperator ::= ^=
 *</b>
 */
class AssignmentOperator10 extends AstToken implements IAssignmentOperator
    {
         IToken getXOR_EQUAL(){ return leftIToken; }

    AssignmentOperator10(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitAssignmentOperator10(this);
            v.endVisitAssignmentOperator10(this);
        }
    }

/**
 *<b>
*<li>Rule 445:  AssignmentOperator ::= |=
 *</b>
 */
class AssignmentOperator11 extends AstToken implements IAssignmentOperator
    {
         IToken getOR_EQUAL(){ return leftIToken; }

    AssignmentOperator11(IToken token) :super(token){ initialize(); }

         void  accept(IAstVisitor v )
        {
            if (! v.preVisit(this)) return;
            enter(v as Visitor);
            v.postVisit(this);
        }

          void enter(Visitor v)
        {
            v.visitAssignmentOperator11(this);
            v.endVisitAssignmentOperator11(this);
        }
    }

abstract class Visitor implements IAstVisitor
    {
       bool visit(Ast n);
       void endVisit(Ast n);

       bool visitAstToken(AstToken n);
       void endVisitAstToken(AstToken n);

       bool visitidentifier(identifier n);
       void endVisitidentifier(identifier n);

       bool visitPrimitiveType(PrimitiveType n);
       void endVisitPrimitiveType(PrimitiveType n);

       bool visitClassType(ClassType n);
       void endVisitClassType(ClassType n);

       bool visitInterfaceType(InterfaceType n);
       void endVisitInterfaceType(InterfaceType n);

       bool visitTypeName(TypeName n);
       void endVisitTypeName(TypeName n);

       bool visitArrayType(ArrayType n);
       void endVisitArrayType(ArrayType n);

       bool visitTypeParameter(TypeParameter n);
       void endVisitTypeParameter(TypeParameter n);

       bool visitTypeBound(TypeBound n);
       void endVisitTypeBound(TypeBound n);

       bool visitAdditionalBoundList(AdditionalBoundList n);
       void endVisitAdditionalBoundList(AdditionalBoundList n);

       bool visitAdditionalBound(AdditionalBound n);
       void endVisitAdditionalBound(AdditionalBound n);

       bool visitTypeArguments(TypeArguments n);
       void endVisitTypeArguments(TypeArguments n);

       bool visitActualTypeArgumentList(ActualTypeArgumentList n);
       void endVisitActualTypeArgumentList(ActualTypeArgumentList n);

       bool visitWildcard(Wildcard n);
       void endVisitWildcard(Wildcard n);

       bool visitPackageName(PackageName n);
       void endVisitPackageName(PackageName n);

       bool visitExpressionName(ExpressionName n);
       void endVisitExpressionName(ExpressionName n);

       bool visitMethodName(MethodName n);
       void endVisitMethodName(MethodName n);

       bool visitPackageOrTypeName(PackageOrTypeName n);
       void endVisitPackageOrTypeName(PackageOrTypeName n);

       bool visitAmbiguousName(AmbiguousName n);
       void endVisitAmbiguousName(AmbiguousName n);

       bool visitCompilationUnit(CompilationUnit n);
       void endVisitCompilationUnit(CompilationUnit n);

       bool visitImportDeclarations(ImportDeclarations n);
       void endVisitImportDeclarations(ImportDeclarations n);

       bool visitTypeDeclarations(TypeDeclarations n);
       void endVisitTypeDeclarations(TypeDeclarations n);

       bool visitPackageDeclaration(PackageDeclaration n);
       void endVisitPackageDeclaration(PackageDeclaration n);

       bool visitSingleTypeImportDeclaration(SingleTypeImportDeclaration n);
       void endVisitSingleTypeImportDeclaration(SingleTypeImportDeclaration n);

       bool visitTypeImportOnDemandDeclaration(TypeImportOnDemandDeclaration n);
       void endVisitTypeImportOnDemandDeclaration(TypeImportOnDemandDeclaration n);

       bool visitSingleStaticImportDeclaration(SingleStaticImportDeclaration n);
       void endVisitSingleStaticImportDeclaration(SingleStaticImportDeclaration n);

       bool visitStaticImportOnDemandDeclaration(StaticImportOnDemandDeclaration n);
       void endVisitStaticImportOnDemandDeclaration(StaticImportOnDemandDeclaration n);

       bool visitTypeDeclaration(TypeDeclaration n);
       void endVisitTypeDeclaration(TypeDeclaration n);

       bool visitNormalClassDeclaration(NormalClassDeclaration n);
       void endVisitNormalClassDeclaration(NormalClassDeclaration n);

       bool visitClassModifiers(ClassModifiers n);
       void endVisitClassModifiers(ClassModifiers n);

       bool visitTypeParameters(TypeParameters n);
       void endVisitTypeParameters(TypeParameters n);

       bool visitTypeParameterList(TypeParameterList n);
       void endVisitTypeParameterList(TypeParameterList n);

       bool visitSuper(Super n);
       void endVisitSuper(Super n);

       bool visitInterfaces(Interfaces n);
       void endVisitInterfaces(Interfaces n);

       bool visitInterfaceTypeList(InterfaceTypeList n);
       void endVisitInterfaceTypeList(InterfaceTypeList n);

       bool visitClassBody(ClassBody n);
       void endVisitClassBody(ClassBody n);

       bool visitClassBodyDeclarations(ClassBodyDeclarations n);
       void endVisitClassBodyDeclarations(ClassBodyDeclarations n);

       bool visitClassMemberDeclaration(ClassMemberDeclaration n);
       void endVisitClassMemberDeclaration(ClassMemberDeclaration n);

       bool visitFieldDeclaration(FieldDeclaration n);
       void endVisitFieldDeclaration(FieldDeclaration n);

       bool visitVariableDeclarators(VariableDeclarators n);
       void endVisitVariableDeclarators(VariableDeclarators n);

       bool visitVariableDeclarator(VariableDeclarator n);
       void endVisitVariableDeclarator(VariableDeclarator n);

       bool visitVariableDeclaratorId(VariableDeclaratorId n);
       void endVisitVariableDeclaratorId(VariableDeclaratorId n);

       bool visitFieldModifiers(FieldModifiers n);
       void endVisitFieldModifiers(FieldModifiers n);

       bool visitMethodDeclaration(MethodDeclaration n);
       void endVisitMethodDeclaration(MethodDeclaration n);

       bool visitMethodHeader(MethodHeader n);
       void endVisitMethodHeader(MethodHeader n);

       bool visitResultType(ResultType n);
       void endVisitResultType(ResultType n);

       bool visitFormalParameterList(FormalParameterList n);
       void endVisitFormalParameterList(FormalParameterList n);

       bool visitFormalParameters(FormalParameters n);
       void endVisitFormalParameters(FormalParameters n);

       bool visitFormalParameter(FormalParameter n);
       void endVisitFormalParameter(FormalParameter n);

       bool visitVariableModifiers(VariableModifiers n);
       void endVisitVariableModifiers(VariableModifiers n);

       bool visitVariableModifier(VariableModifier n);
       void endVisitVariableModifier(VariableModifier n);

       bool visitLastFormalParameter(LastFormalParameter n);
       void endVisitLastFormalParameter(LastFormalParameter n);

       bool visitMethodModifiers(MethodModifiers n);
       void endVisitMethodModifiers(MethodModifiers n);

       bool visitThrows(Throws n);
       void endVisitThrows(Throws n);

       bool visitExceptionTypeList(ExceptionTypeList n);
       void endVisitExceptionTypeList(ExceptionTypeList n);

       bool visitMethodBody(MethodBody n);
       void endVisitMethodBody(MethodBody n);

       bool visitStaticInitializer(StaticInitializer n);
       void endVisitStaticInitializer(StaticInitializer n);

       bool visitConstructorDeclaration(ConstructorDeclaration n);
       void endVisitConstructorDeclaration(ConstructorDeclaration n);

       bool visitConstructorDeclarator(ConstructorDeclarator n);
       void endVisitConstructorDeclarator(ConstructorDeclarator n);

       bool visitConstructorModifiers(ConstructorModifiers n);
       void endVisitConstructorModifiers(ConstructorModifiers n);

       bool visitConstructorBody(ConstructorBody n);
       void endVisitConstructorBody(ConstructorBody n);

       bool visitEnumDeclaration(EnumDeclaration n);
       void endVisitEnumDeclaration(EnumDeclaration n);

       bool visitEnumBody(EnumBody n);
       void endVisitEnumBody(EnumBody n);

       bool visitEnumConstants(EnumConstants n);
       void endVisitEnumConstants(EnumConstants n);

       bool visitEnumConstant(EnumConstant n);
       void endVisitEnumConstant(EnumConstant n);

       bool visitArguments(Arguments n);
       void endVisitArguments(Arguments n);

       bool visitEnumBodyDeclarations(EnumBodyDeclarations n);
       void endVisitEnumBodyDeclarations(EnumBodyDeclarations n);

       bool visitNormalInterfaceDeclaration(NormalInterfaceDeclaration n);
       void endVisitNormalInterfaceDeclaration(NormalInterfaceDeclaration n);

       bool visitInterfaceModifiers(InterfaceModifiers n);
       void endVisitInterfaceModifiers(InterfaceModifiers n);

       bool visitInterfaceBody(InterfaceBody n);
       void endVisitInterfaceBody(InterfaceBody n);

       bool visitInterfaceMemberDeclarations(InterfaceMemberDeclarations n);
       void endVisitInterfaceMemberDeclarations(InterfaceMemberDeclarations n);

       bool visitInterfaceMemberDeclaration(InterfaceMemberDeclaration n);
       void endVisitInterfaceMemberDeclaration(InterfaceMemberDeclaration n);

       bool visitConstantDeclaration(ConstantDeclaration n);
       void endVisitConstantDeclaration(ConstantDeclaration n);

       bool visitConstantModifiers(ConstantModifiers n);
       void endVisitConstantModifiers(ConstantModifiers n);

       bool visitAbstractMethodDeclaration(AbstractMethodDeclaration n);
       void endVisitAbstractMethodDeclaration(AbstractMethodDeclaration n);

       bool visitAbstractMethodModifiers(AbstractMethodModifiers n);
       void endVisitAbstractMethodModifiers(AbstractMethodModifiers n);

       bool visitAnnotationTypeDeclaration(AnnotationTypeDeclaration n);
       void endVisitAnnotationTypeDeclaration(AnnotationTypeDeclaration n);

       bool visitAnnotationTypeBody(AnnotationTypeBody n);
       void endVisitAnnotationTypeBody(AnnotationTypeBody n);

       bool visitAnnotationTypeElementDeclarations(AnnotationTypeElementDeclarations n);
       void endVisitAnnotationTypeElementDeclarations(AnnotationTypeElementDeclarations n);

       bool visitDefaultValue(DefaultValue n);
       void endVisitDefaultValue(DefaultValue n);

       bool visitAnnotations(Annotations n);
       void endVisitAnnotations(Annotations n);

       bool visitNormalAnnotation(NormalAnnotation n);
       void endVisitNormalAnnotation(NormalAnnotation n);

       bool visitElementValuePairs(ElementValuePairs n);
       void endVisitElementValuePairs(ElementValuePairs n);

       bool visitElementValuePair(ElementValuePair n);
       void endVisitElementValuePair(ElementValuePair n);

       bool visitElementValueArrayInitializer(ElementValueArrayInitializer n);
       void endVisitElementValueArrayInitializer(ElementValueArrayInitializer n);

       bool visitElementValues(ElementValues n);
       void endVisitElementValues(ElementValues n);

       bool visitMarkerAnnotation(MarkerAnnotation n);
       void endVisitMarkerAnnotation(MarkerAnnotation n);

       bool visitSingleElementAnnotation(SingleElementAnnotation n);
       void endVisitSingleElementAnnotation(SingleElementAnnotation n);

       bool visitArrayInitializer(ArrayInitializer n);
       void endVisitArrayInitializer(ArrayInitializer n);

       bool visitVariableInitializers(VariableInitializers n);
       void endVisitVariableInitializers(VariableInitializers n);

       bool visitBlock(Block n);
       void endVisitBlock(Block n);

       bool visitBlockStatements(BlockStatements n);
       void endVisitBlockStatements(BlockStatements n);

       bool visitLocalVariableDeclarationStatement(LocalVariableDeclarationStatement n);
       void endVisitLocalVariableDeclarationStatement(LocalVariableDeclarationStatement n);

       bool visitLocalVariableDeclaration(LocalVariableDeclaration n);
       void endVisitLocalVariableDeclaration(LocalVariableDeclaration n);

       bool visitIfThenStatement(IfThenStatement n);
       void endVisitIfThenStatement(IfThenStatement n);

       bool visitIfThenElseStatement(IfThenElseStatement n);
       void endVisitIfThenElseStatement(IfThenElseStatement n);

       bool visitIfThenElseStatementNoShortIf(IfThenElseStatementNoShortIf n);
       void endVisitIfThenElseStatementNoShortIf(IfThenElseStatementNoShortIf n);

       bool visitEmptyStatement(EmptyStatement n);
       void endVisitEmptyStatement(EmptyStatement n);

       bool visitLabeledStatement(LabeledStatement n);
       void endVisitLabeledStatement(LabeledStatement n);

       bool visitLabeledStatementNoShortIf(LabeledStatementNoShortIf n);
       void endVisitLabeledStatementNoShortIf(LabeledStatementNoShortIf n);

       bool visitExpressionStatement(ExpressionStatement n);
       void endVisitExpressionStatement(ExpressionStatement n);

       bool visitSwitchStatement(SwitchStatement n);
       void endVisitSwitchStatement(SwitchStatement n);

       bool visitSwitchBlock(SwitchBlock n);
       void endVisitSwitchBlock(SwitchBlock n);

       bool visitSwitchBlockStatementGroups(SwitchBlockStatementGroups n);
       void endVisitSwitchBlockStatementGroups(SwitchBlockStatementGroups n);

       bool visitSwitchBlockStatementGroup(SwitchBlockStatementGroup n);
       void endVisitSwitchBlockStatementGroup(SwitchBlockStatementGroup n);

       bool visitSwitchLabels(SwitchLabels n);
       void endVisitSwitchLabels(SwitchLabels n);

       bool visitWhileStatement(WhileStatement n);
       void endVisitWhileStatement(WhileStatement n);

       bool visitWhileStatementNoShortIf(WhileStatementNoShortIf n);
       void endVisitWhileStatementNoShortIf(WhileStatementNoShortIf n);

       bool visitDoStatement(DoStatement n);
       void endVisitDoStatement(DoStatement n);

       bool visitBasicForStatement(BasicForStatement n);
       void endVisitBasicForStatement(BasicForStatement n);

       bool visitForStatementNoShortIf(ForStatementNoShortIf n);
       void endVisitForStatementNoShortIf(ForStatementNoShortIf n);

       bool visitStatementExpressionList(StatementExpressionList n);
       void endVisitStatementExpressionList(StatementExpressionList n);

       bool visitEnhancedForStatement(EnhancedForStatement n);
       void endVisitEnhancedForStatement(EnhancedForStatement n);

       bool visitBreakStatement(BreakStatement n);
       void endVisitBreakStatement(BreakStatement n);

       bool visitContinueStatement(ContinueStatement n);
       void endVisitContinueStatement(ContinueStatement n);

       bool visitReturnStatement(ReturnStatement n);
       void endVisitReturnStatement(ReturnStatement n);

       bool visitThrowStatement(ThrowStatement n);
       void endVisitThrowStatement(ThrowStatement n);

       bool visitSynchronizedStatement(SynchronizedStatement n);
       void endVisitSynchronizedStatement(SynchronizedStatement n);

       bool visitCatches(Catches n);
       void endVisitCatches(Catches n);

       bool visitCatchClause(CatchClause n);
       void endVisitCatchClause(CatchClause n);

       bool visitFinally(Finally n);
       void endVisitFinally(Finally n);

       bool visitArgumentList(ArgumentList n);
       void endVisitArgumentList(ArgumentList n);

       bool visitDimExprs(DimExprs n);
       void endVisitDimExprs(DimExprs n);

       bool visitDimExpr(DimExpr n);
       void endVisitDimExpr(DimExpr n);

       bool visitPostIncrementExpression(PostIncrementExpression n);
       void endVisitPostIncrementExpression(PostIncrementExpression n);

       bool visitPostDecrementExpression(PostDecrementExpression n);
       void endVisitPostDecrementExpression(PostDecrementExpression n);

       bool visitPreIncrementExpression(PreIncrementExpression n);
       void endVisitPreIncrementExpression(PreIncrementExpression n);

       bool visitPreDecrementExpression(PreDecrementExpression n);
       void endVisitPreDecrementExpression(PreDecrementExpression n);

       bool visitAndExpression(AndExpression n);
       void endVisitAndExpression(AndExpression n);

       bool visitExclusiveOrExpression(ExclusiveOrExpression n);
       void endVisitExclusiveOrExpression(ExclusiveOrExpression n);

       bool visitInclusiveOrExpression(InclusiveOrExpression n);
       void endVisitInclusiveOrExpression(InclusiveOrExpression n);

       bool visitConditionalAndExpression(ConditionalAndExpression n);
       void endVisitConditionalAndExpression(ConditionalAndExpression n);

       bool visitConditionalOrExpression(ConditionalOrExpression n);
       void endVisitConditionalOrExpression(ConditionalOrExpression n);

       bool visitConditionalExpression(ConditionalExpression n);
       void endVisitConditionalExpression(ConditionalExpression n);

       bool visitAssignment(Assignment n);
       void endVisitAssignment(Assignment n);

       bool visitCommaopt(Commaopt n);
       void endVisitCommaopt(Commaopt n);

       bool visitEllipsisopt(Ellipsisopt n);
       void endVisitEllipsisopt(Ellipsisopt n);

       bool visitLPGUserAction0(LPGUserAction0 n);
       void endVisitLPGUserAction0(LPGUserAction0 n);

       bool visitLPGUserAction1(LPGUserAction1 n);
       void endVisitLPGUserAction1(LPGUserAction1 n);

       bool visitLPGUserAction2(LPGUserAction2 n);
       void endVisitLPGUserAction2(LPGUserAction2 n);

       bool visitLPGUserAction3(LPGUserAction3 n);
       void endVisitLPGUserAction3(LPGUserAction3 n);

       bool visitLPGUserAction4(LPGUserAction4 n);
       void endVisitLPGUserAction4(LPGUserAction4 n);

       bool visitIntegralType0(IntegralType0 n);
       void endVisitIntegralType0(IntegralType0 n);

       bool visitIntegralType1(IntegralType1 n);
       void endVisitIntegralType1(IntegralType1 n);

       bool visitIntegralType2(IntegralType2 n);
       void endVisitIntegralType2(IntegralType2 n);

       bool visitIntegralType3(IntegralType3 n);
       void endVisitIntegralType3(IntegralType3 n);

       bool visitIntegralType4(IntegralType4 n);
       void endVisitIntegralType4(IntegralType4 n);

       bool visitFloatingPointType0(FloatingPointType0 n);
       void endVisitFloatingPointType0(FloatingPointType0 n);

       bool visitFloatingPointType1(FloatingPointType1 n);
       void endVisitFloatingPointType1(FloatingPointType1 n);

       bool visitWildcardBounds0(WildcardBounds0 n);
       void endVisitWildcardBounds0(WildcardBounds0 n);

       bool visitWildcardBounds1(WildcardBounds1 n);
       void endVisitWildcardBounds1(WildcardBounds1 n);

       bool visitClassModifier0(ClassModifier0 n);
       void endVisitClassModifier0(ClassModifier0 n);

       bool visitClassModifier1(ClassModifier1 n);
       void endVisitClassModifier1(ClassModifier1 n);

       bool visitClassModifier2(ClassModifier2 n);
       void endVisitClassModifier2(ClassModifier2 n);

       bool visitClassModifier3(ClassModifier3 n);
       void endVisitClassModifier3(ClassModifier3 n);

       bool visitClassModifier4(ClassModifier4 n);
       void endVisitClassModifier4(ClassModifier4 n);

       bool visitClassModifier5(ClassModifier5 n);
       void endVisitClassModifier5(ClassModifier5 n);

       bool visitClassModifier6(ClassModifier6 n);
       void endVisitClassModifier6(ClassModifier6 n);

       bool visitFieldModifier0(FieldModifier0 n);
       void endVisitFieldModifier0(FieldModifier0 n);

       bool visitFieldModifier1(FieldModifier1 n);
       void endVisitFieldModifier1(FieldModifier1 n);

       bool visitFieldModifier2(FieldModifier2 n);
       void endVisitFieldModifier2(FieldModifier2 n);

       bool visitFieldModifier3(FieldModifier3 n);
       void endVisitFieldModifier3(FieldModifier3 n);

       bool visitFieldModifier4(FieldModifier4 n);
       void endVisitFieldModifier4(FieldModifier4 n);

       bool visitFieldModifier5(FieldModifier5 n);
       void endVisitFieldModifier5(FieldModifier5 n);

       bool visitFieldModifier6(FieldModifier6 n);
       void endVisitFieldModifier6(FieldModifier6 n);

       bool visitMethodDeclarator0(MethodDeclarator0 n);
       void endVisitMethodDeclarator0(MethodDeclarator0 n);

       bool visitMethodDeclarator1(MethodDeclarator1 n);
       void endVisitMethodDeclarator1(MethodDeclarator1 n);

       bool visitMethodModifier0(MethodModifier0 n);
       void endVisitMethodModifier0(MethodModifier0 n);

       bool visitMethodModifier1(MethodModifier1 n);
       void endVisitMethodModifier1(MethodModifier1 n);

       bool visitMethodModifier2(MethodModifier2 n);
       void endVisitMethodModifier2(MethodModifier2 n);

       bool visitMethodModifier3(MethodModifier3 n);
       void endVisitMethodModifier3(MethodModifier3 n);

       bool visitMethodModifier4(MethodModifier4 n);
       void endVisitMethodModifier4(MethodModifier4 n);

       bool visitMethodModifier5(MethodModifier5 n);
       void endVisitMethodModifier5(MethodModifier5 n);

       bool visitMethodModifier6(MethodModifier6 n);
       void endVisitMethodModifier6(MethodModifier6 n);

       bool visitMethodModifier7(MethodModifier7 n);
       void endVisitMethodModifier7(MethodModifier7 n);

       bool visitMethodModifier8(MethodModifier8 n);
       void endVisitMethodModifier8(MethodModifier8 n);

       bool visitConstructorModifier0(ConstructorModifier0 n);
       void endVisitConstructorModifier0(ConstructorModifier0 n);

       bool visitConstructorModifier1(ConstructorModifier1 n);
       void endVisitConstructorModifier1(ConstructorModifier1 n);

       bool visitConstructorModifier2(ConstructorModifier2 n);
       void endVisitConstructorModifier2(ConstructorModifier2 n);

       bool visitExplicitConstructorInvocation0(ExplicitConstructorInvocation0 n);
       void endVisitExplicitConstructorInvocation0(ExplicitConstructorInvocation0 n);

       bool visitExplicitConstructorInvocation1(ExplicitConstructorInvocation1 n);
       void endVisitExplicitConstructorInvocation1(ExplicitConstructorInvocation1 n);

       bool visitExplicitConstructorInvocation2(ExplicitConstructorInvocation2 n);
       void endVisitExplicitConstructorInvocation2(ExplicitConstructorInvocation2 n);

       bool visitInterfaceModifier0(InterfaceModifier0 n);
       void endVisitInterfaceModifier0(InterfaceModifier0 n);

       bool visitInterfaceModifier1(InterfaceModifier1 n);
       void endVisitInterfaceModifier1(InterfaceModifier1 n);

       bool visitInterfaceModifier2(InterfaceModifier2 n);
       void endVisitInterfaceModifier2(InterfaceModifier2 n);

       bool visitInterfaceModifier3(InterfaceModifier3 n);
       void endVisitInterfaceModifier3(InterfaceModifier3 n);

       bool visitInterfaceModifier4(InterfaceModifier4 n);
       void endVisitInterfaceModifier4(InterfaceModifier4 n);

       bool visitInterfaceModifier5(InterfaceModifier5 n);
       void endVisitInterfaceModifier5(InterfaceModifier5 n);

       bool visitExtendsInterfaces0(ExtendsInterfaces0 n);
       void endVisitExtendsInterfaces0(ExtendsInterfaces0 n);

       bool visitExtendsInterfaces1(ExtendsInterfaces1 n);
       void endVisitExtendsInterfaces1(ExtendsInterfaces1 n);

       bool visitConstantModifier0(ConstantModifier0 n);
       void endVisitConstantModifier0(ConstantModifier0 n);

       bool visitConstantModifier1(ConstantModifier1 n);
       void endVisitConstantModifier1(ConstantModifier1 n);

       bool visitConstantModifier2(ConstantModifier2 n);
       void endVisitConstantModifier2(ConstantModifier2 n);

       bool visitAbstractMethodModifier0(AbstractMethodModifier0 n);
       void endVisitAbstractMethodModifier0(AbstractMethodModifier0 n);

       bool visitAbstractMethodModifier1(AbstractMethodModifier1 n);
       void endVisitAbstractMethodModifier1(AbstractMethodModifier1 n);

       bool visitAnnotationTypeElementDeclaration0(AnnotationTypeElementDeclaration0 n);
       void endVisitAnnotationTypeElementDeclaration0(AnnotationTypeElementDeclaration0 n);

       bool visitAnnotationTypeElementDeclaration1(AnnotationTypeElementDeclaration1 n);
       void endVisitAnnotationTypeElementDeclaration1(AnnotationTypeElementDeclaration1 n);

       bool visitAssertStatement0(AssertStatement0 n);
       void endVisitAssertStatement0(AssertStatement0 n);

       bool visitAssertStatement1(AssertStatement1 n);
       void endVisitAssertStatement1(AssertStatement1 n);

       bool visitSwitchLabel0(SwitchLabel0 n);
       void endVisitSwitchLabel0(SwitchLabel0 n);

       bool visitSwitchLabel1(SwitchLabel1 n);
       void endVisitSwitchLabel1(SwitchLabel1 n);

       bool visitSwitchLabel2(SwitchLabel2 n);
       void endVisitSwitchLabel2(SwitchLabel2 n);

       bool visitTryStatement0(TryStatement0 n);
       void endVisitTryStatement0(TryStatement0 n);

       bool visitTryStatement1(TryStatement1 n);
       void endVisitTryStatement1(TryStatement1 n);

       bool visitPrimaryNoNewArray0(PrimaryNoNewArray0 n);
       void endVisitPrimaryNoNewArray0(PrimaryNoNewArray0 n);

       bool visitPrimaryNoNewArray1(PrimaryNoNewArray1 n);
       void endVisitPrimaryNoNewArray1(PrimaryNoNewArray1 n);

       bool visitPrimaryNoNewArray2(PrimaryNoNewArray2 n);
       void endVisitPrimaryNoNewArray2(PrimaryNoNewArray2 n);

       bool visitPrimaryNoNewArray3(PrimaryNoNewArray3 n);
       void endVisitPrimaryNoNewArray3(PrimaryNoNewArray3 n);

       bool visitPrimaryNoNewArray4(PrimaryNoNewArray4 n);
       void endVisitPrimaryNoNewArray4(PrimaryNoNewArray4 n);

       bool visitLiteral0(Literal0 n);
       void endVisitLiteral0(Literal0 n);

       bool visitLiteral1(Literal1 n);
       void endVisitLiteral1(Literal1 n);

       bool visitLiteral2(Literal2 n);
       void endVisitLiteral2(Literal2 n);

       bool visitLiteral3(Literal3 n);
       void endVisitLiteral3(Literal3 n);

       bool visitLiteral4(Literal4 n);
       void endVisitLiteral4(Literal4 n);

       bool visitLiteral5(Literal5 n);
       void endVisitLiteral5(Literal5 n);

       bool visitLiteral6(Literal6 n);
       void endVisitLiteral6(Literal6 n);

       bool visitBooleanLiteral0(BooleanLiteral0 n);
       void endVisitBooleanLiteral0(BooleanLiteral0 n);

       bool visitBooleanLiteral1(BooleanLiteral1 n);
       void endVisitBooleanLiteral1(BooleanLiteral1 n);

       bool visitClassInstanceCreationExpression0(ClassInstanceCreationExpression0 n);
       void endVisitClassInstanceCreationExpression0(ClassInstanceCreationExpression0 n);

       bool visitClassInstanceCreationExpression1(ClassInstanceCreationExpression1 n);
       void endVisitClassInstanceCreationExpression1(ClassInstanceCreationExpression1 n);

       bool visitArrayCreationExpression0(ArrayCreationExpression0 n);
       void endVisitArrayCreationExpression0(ArrayCreationExpression0 n);

       bool visitArrayCreationExpression1(ArrayCreationExpression1 n);
       void endVisitArrayCreationExpression1(ArrayCreationExpression1 n);

       bool visitArrayCreationExpression2(ArrayCreationExpression2 n);
       void endVisitArrayCreationExpression2(ArrayCreationExpression2 n);

       bool visitArrayCreationExpression3(ArrayCreationExpression3 n);
       void endVisitArrayCreationExpression3(ArrayCreationExpression3 n);

       bool visitDims0(Dims0 n);
       void endVisitDims0(Dims0 n);

       bool visitDims1(Dims1 n);
       void endVisitDims1(Dims1 n);

       bool visitFieldAccess0(FieldAccess0 n);
       void endVisitFieldAccess0(FieldAccess0 n);

       bool visitFieldAccess1(FieldAccess1 n);
       void endVisitFieldAccess1(FieldAccess1 n);

       bool visitFieldAccess2(FieldAccess2 n);
       void endVisitFieldAccess2(FieldAccess2 n);

       bool visitMethodInvocation0(MethodInvocation0 n);
       void endVisitMethodInvocation0(MethodInvocation0 n);

       bool visitMethodInvocation1(MethodInvocation1 n);
       void endVisitMethodInvocation1(MethodInvocation1 n);

       bool visitMethodInvocation2(MethodInvocation2 n);
       void endVisitMethodInvocation2(MethodInvocation2 n);

       bool visitMethodInvocation3(MethodInvocation3 n);
       void endVisitMethodInvocation3(MethodInvocation3 n);

       bool visitMethodInvocation4(MethodInvocation4 n);
       void endVisitMethodInvocation4(MethodInvocation4 n);

       bool visitArrayAccess0(ArrayAccess0 n);
       void endVisitArrayAccess0(ArrayAccess0 n);

       bool visitArrayAccess1(ArrayAccess1 n);
       void endVisitArrayAccess1(ArrayAccess1 n);

       bool visitUnaryExpression0(UnaryExpression0 n);
       void endVisitUnaryExpression0(UnaryExpression0 n);

       bool visitUnaryExpression1(UnaryExpression1 n);
       void endVisitUnaryExpression1(UnaryExpression1 n);

       bool visitUnaryExpressionNotPlusMinus0(UnaryExpressionNotPlusMinus0 n);
       void endVisitUnaryExpressionNotPlusMinus0(UnaryExpressionNotPlusMinus0 n);

       bool visitUnaryExpressionNotPlusMinus1(UnaryExpressionNotPlusMinus1 n);
       void endVisitUnaryExpressionNotPlusMinus1(UnaryExpressionNotPlusMinus1 n);

       bool visitCastExpression0(CastExpression0 n);
       void endVisitCastExpression0(CastExpression0 n);

       bool visitCastExpression1(CastExpression1 n);
       void endVisitCastExpression1(CastExpression1 n);

       bool visitMultiplicativeExpression0(MultiplicativeExpression0 n);
       void endVisitMultiplicativeExpression0(MultiplicativeExpression0 n);

       bool visitMultiplicativeExpression1(MultiplicativeExpression1 n);
       void endVisitMultiplicativeExpression1(MultiplicativeExpression1 n);

       bool visitMultiplicativeExpression2(MultiplicativeExpression2 n);
       void endVisitMultiplicativeExpression2(MultiplicativeExpression2 n);

       bool visitAdditiveExpression0(AdditiveExpression0 n);
       void endVisitAdditiveExpression0(AdditiveExpression0 n);

       bool visitAdditiveExpression1(AdditiveExpression1 n);
       void endVisitAdditiveExpression1(AdditiveExpression1 n);

       bool visitShiftExpression0(ShiftExpression0 n);
       void endVisitShiftExpression0(ShiftExpression0 n);

       bool visitShiftExpression1(ShiftExpression1 n);
       void endVisitShiftExpression1(ShiftExpression1 n);

       bool visitShiftExpression2(ShiftExpression2 n);
       void endVisitShiftExpression2(ShiftExpression2 n);

       bool visitRelationalExpression0(RelationalExpression0 n);
       void endVisitRelationalExpression0(RelationalExpression0 n);

       bool visitRelationalExpression1(RelationalExpression1 n);
       void endVisitRelationalExpression1(RelationalExpression1 n);

       bool visitRelationalExpression2(RelationalExpression2 n);
       void endVisitRelationalExpression2(RelationalExpression2 n);

       bool visitRelationalExpression3(RelationalExpression3 n);
       void endVisitRelationalExpression3(RelationalExpression3 n);

       bool visitRelationalExpression4(RelationalExpression4 n);
       void endVisitRelationalExpression4(RelationalExpression4 n);

       bool visitEqualityExpression0(EqualityExpression0 n);
       void endVisitEqualityExpression0(EqualityExpression0 n);

       bool visitEqualityExpression1(EqualityExpression1 n);
       void endVisitEqualityExpression1(EqualityExpression1 n);

       bool visitAssignmentOperator0(AssignmentOperator0 n);
       void endVisitAssignmentOperator0(AssignmentOperator0 n);

       bool visitAssignmentOperator1(AssignmentOperator1 n);
       void endVisitAssignmentOperator1(AssignmentOperator1 n);

       bool visitAssignmentOperator2(AssignmentOperator2 n);
       void endVisitAssignmentOperator2(AssignmentOperator2 n);

       bool visitAssignmentOperator3(AssignmentOperator3 n);
       void endVisitAssignmentOperator3(AssignmentOperator3 n);

       bool visitAssignmentOperator4(AssignmentOperator4 n);
       void endVisitAssignmentOperator4(AssignmentOperator4 n);

       bool visitAssignmentOperator5(AssignmentOperator5 n);
       void endVisitAssignmentOperator5(AssignmentOperator5 n);

       bool visitAssignmentOperator6(AssignmentOperator6 n);
       void endVisitAssignmentOperator6(AssignmentOperator6 n);

       bool visitAssignmentOperator7(AssignmentOperator7 n);
       void endVisitAssignmentOperator7(AssignmentOperator7 n);

       bool visitAssignmentOperator8(AssignmentOperator8 n);
       void endVisitAssignmentOperator8(AssignmentOperator8 n);

       bool visitAssignmentOperator9(AssignmentOperator9 n);
       void endVisitAssignmentOperator9(AssignmentOperator9 n);

       bool visitAssignmentOperator10(AssignmentOperator10 n);
       void endVisitAssignmentOperator10(AssignmentOperator10 n);

       bool visitAssignmentOperator11(AssignmentOperator11 n);
       void endVisitAssignmentOperator11(AssignmentOperator11 n);

    }

abstract class AbstractVisitor implements Visitor
    {
         void unimplementedVisitor(String s)  ;

         bool preVisit(IAst element) { return true; }

         void postVisit(IAst element) {}

        bool visitAstToken(AstToken n){ unimplementedVisitor("visit(AstToken)"); return true; }
        void endVisitAstToken(AstToken n)  { unimplementedVisitor("endVisit(AstToken)"); }

        bool visitidentifier(identifier n){ unimplementedVisitor("visit(identifier)"); return true; }
        void endVisitidentifier(identifier n)  { unimplementedVisitor("endVisit(identifier)"); }

        bool visitPrimitiveType(PrimitiveType n){ unimplementedVisitor("visit(PrimitiveType)"); return true; }
        void endVisitPrimitiveType(PrimitiveType n)  { unimplementedVisitor("endVisit(PrimitiveType)"); }

        bool visitClassType(ClassType n){ unimplementedVisitor("visit(ClassType)"); return true; }
        void endVisitClassType(ClassType n)  { unimplementedVisitor("endVisit(ClassType)"); }

        bool visitInterfaceType(InterfaceType n){ unimplementedVisitor("visit(InterfaceType)"); return true; }
        void endVisitInterfaceType(InterfaceType n)  { unimplementedVisitor("endVisit(InterfaceType)"); }

        bool visitTypeName(TypeName n){ unimplementedVisitor("visit(TypeName)"); return true; }
        void endVisitTypeName(TypeName n)  { unimplementedVisitor("endVisit(TypeName)"); }

        bool visitArrayType(ArrayType n){ unimplementedVisitor("visit(ArrayType)"); return true; }
        void endVisitArrayType(ArrayType n)  { unimplementedVisitor("endVisit(ArrayType)"); }

        bool visitTypeParameter(TypeParameter n){ unimplementedVisitor("visit(TypeParameter)"); return true; }
        void endVisitTypeParameter(TypeParameter n)  { unimplementedVisitor("endVisit(TypeParameter)"); }

        bool visitTypeBound(TypeBound n){ unimplementedVisitor("visit(TypeBound)"); return true; }
        void endVisitTypeBound(TypeBound n)  { unimplementedVisitor("endVisit(TypeBound)"); }

        bool visitAdditionalBoundList(AdditionalBoundList n){ unimplementedVisitor("visit(AdditionalBoundList)"); return true; }
        void endVisitAdditionalBoundList(AdditionalBoundList n)  { unimplementedVisitor("endVisit(AdditionalBoundList)"); }

        bool visitAdditionalBound(AdditionalBound n){ unimplementedVisitor("visit(AdditionalBound)"); return true; }
        void endVisitAdditionalBound(AdditionalBound n)  { unimplementedVisitor("endVisit(AdditionalBound)"); }

        bool visitTypeArguments(TypeArguments n){ unimplementedVisitor("visit(TypeArguments)"); return true; }
        void endVisitTypeArguments(TypeArguments n)  { unimplementedVisitor("endVisit(TypeArguments)"); }

        bool visitActualTypeArgumentList(ActualTypeArgumentList n){ unimplementedVisitor("visit(ActualTypeArgumentList)"); return true; }
        void endVisitActualTypeArgumentList(ActualTypeArgumentList n)  { unimplementedVisitor("endVisit(ActualTypeArgumentList)"); }

        bool visitWildcard(Wildcard n){ unimplementedVisitor("visit(Wildcard)"); return true; }
        void endVisitWildcard(Wildcard n)  { unimplementedVisitor("endVisit(Wildcard)"); }

        bool visitPackageName(PackageName n){ unimplementedVisitor("visit(PackageName)"); return true; }
        void endVisitPackageName(PackageName n)  { unimplementedVisitor("endVisit(PackageName)"); }

        bool visitExpressionName(ExpressionName n){ unimplementedVisitor("visit(ExpressionName)"); return true; }
        void endVisitExpressionName(ExpressionName n)  { unimplementedVisitor("endVisit(ExpressionName)"); }

        bool visitMethodName(MethodName n){ unimplementedVisitor("visit(MethodName)"); return true; }
        void endVisitMethodName(MethodName n)  { unimplementedVisitor("endVisit(MethodName)"); }

        bool visitPackageOrTypeName(PackageOrTypeName n){ unimplementedVisitor("visit(PackageOrTypeName)"); return true; }
        void endVisitPackageOrTypeName(PackageOrTypeName n)  { unimplementedVisitor("endVisit(PackageOrTypeName)"); }

        bool visitAmbiguousName(AmbiguousName n){ unimplementedVisitor("visit(AmbiguousName)"); return true; }
        void endVisitAmbiguousName(AmbiguousName n)  { unimplementedVisitor("endVisit(AmbiguousName)"); }

        bool visitCompilationUnit(CompilationUnit n){ unimplementedVisitor("visit(CompilationUnit)"); return true; }
        void endVisitCompilationUnit(CompilationUnit n)  { unimplementedVisitor("endVisit(CompilationUnit)"); }

        bool visitImportDeclarations(ImportDeclarations n){ unimplementedVisitor("visit(ImportDeclarations)"); return true; }
        void endVisitImportDeclarations(ImportDeclarations n)  { unimplementedVisitor("endVisit(ImportDeclarations)"); }

        bool visitTypeDeclarations(TypeDeclarations n){ unimplementedVisitor("visit(TypeDeclarations)"); return true; }
        void endVisitTypeDeclarations(TypeDeclarations n)  { unimplementedVisitor("endVisit(TypeDeclarations)"); }

        bool visitPackageDeclaration(PackageDeclaration n){ unimplementedVisitor("visit(PackageDeclaration)"); return true; }
        void endVisitPackageDeclaration(PackageDeclaration n)  { unimplementedVisitor("endVisit(PackageDeclaration)"); }

        bool visitSingleTypeImportDeclaration(SingleTypeImportDeclaration n){ unimplementedVisitor("visit(SingleTypeImportDeclaration)"); return true; }
        void endVisitSingleTypeImportDeclaration(SingleTypeImportDeclaration n)  { unimplementedVisitor("endVisit(SingleTypeImportDeclaration)"); }

        bool visitTypeImportOnDemandDeclaration(TypeImportOnDemandDeclaration n){ unimplementedVisitor("visit(TypeImportOnDemandDeclaration)"); return true; }
        void endVisitTypeImportOnDemandDeclaration(TypeImportOnDemandDeclaration n)  { unimplementedVisitor("endVisit(TypeImportOnDemandDeclaration)"); }

        bool visitSingleStaticImportDeclaration(SingleStaticImportDeclaration n){ unimplementedVisitor("visit(SingleStaticImportDeclaration)"); return true; }
        void endVisitSingleStaticImportDeclaration(SingleStaticImportDeclaration n)  { unimplementedVisitor("endVisit(SingleStaticImportDeclaration)"); }

        bool visitStaticImportOnDemandDeclaration(StaticImportOnDemandDeclaration n){ unimplementedVisitor("visit(StaticImportOnDemandDeclaration)"); return true; }
        void endVisitStaticImportOnDemandDeclaration(StaticImportOnDemandDeclaration n)  { unimplementedVisitor("endVisit(StaticImportOnDemandDeclaration)"); }

        bool visitTypeDeclaration(TypeDeclaration n){ unimplementedVisitor("visit(TypeDeclaration)"); return true; }
        void endVisitTypeDeclaration(TypeDeclaration n)  { unimplementedVisitor("endVisit(TypeDeclaration)"); }

        bool visitNormalClassDeclaration(NormalClassDeclaration n){ unimplementedVisitor("visit(NormalClassDeclaration)"); return true; }
        void endVisitNormalClassDeclaration(NormalClassDeclaration n)  { unimplementedVisitor("endVisit(NormalClassDeclaration)"); }

        bool visitClassModifiers(ClassModifiers n){ unimplementedVisitor("visit(ClassModifiers)"); return true; }
        void endVisitClassModifiers(ClassModifiers n)  { unimplementedVisitor("endVisit(ClassModifiers)"); }

        bool visitTypeParameters(TypeParameters n){ unimplementedVisitor("visit(TypeParameters)"); return true; }
        void endVisitTypeParameters(TypeParameters n)  { unimplementedVisitor("endVisit(TypeParameters)"); }

        bool visitTypeParameterList(TypeParameterList n){ unimplementedVisitor("visit(TypeParameterList)"); return true; }
        void endVisitTypeParameterList(TypeParameterList n)  { unimplementedVisitor("endVisit(TypeParameterList)"); }

        bool visitSuper(Super n){ unimplementedVisitor("visit(Super)"); return true; }
        void endVisitSuper(Super n)  { unimplementedVisitor("endVisit(Super)"); }

        bool visitInterfaces(Interfaces n){ unimplementedVisitor("visit(Interfaces)"); return true; }
        void endVisitInterfaces(Interfaces n)  { unimplementedVisitor("endVisit(Interfaces)"); }

        bool visitInterfaceTypeList(InterfaceTypeList n){ unimplementedVisitor("visit(InterfaceTypeList)"); return true; }
        void endVisitInterfaceTypeList(InterfaceTypeList n)  { unimplementedVisitor("endVisit(InterfaceTypeList)"); }

        bool visitClassBody(ClassBody n){ unimplementedVisitor("visit(ClassBody)"); return true; }
        void endVisitClassBody(ClassBody n)  { unimplementedVisitor("endVisit(ClassBody)"); }

        bool visitClassBodyDeclarations(ClassBodyDeclarations n){ unimplementedVisitor("visit(ClassBodyDeclarations)"); return true; }
        void endVisitClassBodyDeclarations(ClassBodyDeclarations n)  { unimplementedVisitor("endVisit(ClassBodyDeclarations)"); }

        bool visitClassMemberDeclaration(ClassMemberDeclaration n){ unimplementedVisitor("visit(ClassMemberDeclaration)"); return true; }
        void endVisitClassMemberDeclaration(ClassMemberDeclaration n)  { unimplementedVisitor("endVisit(ClassMemberDeclaration)"); }

        bool visitFieldDeclaration(FieldDeclaration n){ unimplementedVisitor("visit(FieldDeclaration)"); return true; }
        void endVisitFieldDeclaration(FieldDeclaration n)  { unimplementedVisitor("endVisit(FieldDeclaration)"); }

        bool visitVariableDeclarators(VariableDeclarators n){ unimplementedVisitor("visit(VariableDeclarators)"); return true; }
        void endVisitVariableDeclarators(VariableDeclarators n)  { unimplementedVisitor("endVisit(VariableDeclarators)"); }

        bool visitVariableDeclarator(VariableDeclarator n){ unimplementedVisitor("visit(VariableDeclarator)"); return true; }
        void endVisitVariableDeclarator(VariableDeclarator n)  { unimplementedVisitor("endVisit(VariableDeclarator)"); }

        bool visitVariableDeclaratorId(VariableDeclaratorId n){ unimplementedVisitor("visit(VariableDeclaratorId)"); return true; }
        void endVisitVariableDeclaratorId(VariableDeclaratorId n)  { unimplementedVisitor("endVisit(VariableDeclaratorId)"); }

        bool visitFieldModifiers(FieldModifiers n){ unimplementedVisitor("visit(FieldModifiers)"); return true; }
        void endVisitFieldModifiers(FieldModifiers n)  { unimplementedVisitor("endVisit(FieldModifiers)"); }

        bool visitMethodDeclaration(MethodDeclaration n){ unimplementedVisitor("visit(MethodDeclaration)"); return true; }
        void endVisitMethodDeclaration(MethodDeclaration n)  { unimplementedVisitor("endVisit(MethodDeclaration)"); }

        bool visitMethodHeader(MethodHeader n){ unimplementedVisitor("visit(MethodHeader)"); return true; }
        void endVisitMethodHeader(MethodHeader n)  { unimplementedVisitor("endVisit(MethodHeader)"); }

        bool visitResultType(ResultType n){ unimplementedVisitor("visit(ResultType)"); return true; }
        void endVisitResultType(ResultType n)  { unimplementedVisitor("endVisit(ResultType)"); }

        bool visitFormalParameterList(FormalParameterList n){ unimplementedVisitor("visit(FormalParameterList)"); return true; }
        void endVisitFormalParameterList(FormalParameterList n)  { unimplementedVisitor("endVisit(FormalParameterList)"); }

        bool visitFormalParameters(FormalParameters n){ unimplementedVisitor("visit(FormalParameters)"); return true; }
        void endVisitFormalParameters(FormalParameters n)  { unimplementedVisitor("endVisit(FormalParameters)"); }

        bool visitFormalParameter(FormalParameter n){ unimplementedVisitor("visit(FormalParameter)"); return true; }
        void endVisitFormalParameter(FormalParameter n)  { unimplementedVisitor("endVisit(FormalParameter)"); }

        bool visitVariableModifiers(VariableModifiers n){ unimplementedVisitor("visit(VariableModifiers)"); return true; }
        void endVisitVariableModifiers(VariableModifiers n)  { unimplementedVisitor("endVisit(VariableModifiers)"); }

        bool visitVariableModifier(VariableModifier n){ unimplementedVisitor("visit(VariableModifier)"); return true; }
        void endVisitVariableModifier(VariableModifier n)  { unimplementedVisitor("endVisit(VariableModifier)"); }

        bool visitLastFormalParameter(LastFormalParameter n){ unimplementedVisitor("visit(LastFormalParameter)"); return true; }
        void endVisitLastFormalParameter(LastFormalParameter n)  { unimplementedVisitor("endVisit(LastFormalParameter)"); }

        bool visitMethodModifiers(MethodModifiers n){ unimplementedVisitor("visit(MethodModifiers)"); return true; }
        void endVisitMethodModifiers(MethodModifiers n)  { unimplementedVisitor("endVisit(MethodModifiers)"); }

        bool visitThrows(Throws n){ unimplementedVisitor("visit(Throws)"); return true; }
        void endVisitThrows(Throws n)  { unimplementedVisitor("endVisit(Throws)"); }

        bool visitExceptionTypeList(ExceptionTypeList n){ unimplementedVisitor("visit(ExceptionTypeList)"); return true; }
        void endVisitExceptionTypeList(ExceptionTypeList n)  { unimplementedVisitor("endVisit(ExceptionTypeList)"); }

        bool visitMethodBody(MethodBody n){ unimplementedVisitor("visit(MethodBody)"); return true; }
        void endVisitMethodBody(MethodBody n)  { unimplementedVisitor("endVisit(MethodBody)"); }

        bool visitStaticInitializer(StaticInitializer n){ unimplementedVisitor("visit(StaticInitializer)"); return true; }
        void endVisitStaticInitializer(StaticInitializer n)  { unimplementedVisitor("endVisit(StaticInitializer)"); }

        bool visitConstructorDeclaration(ConstructorDeclaration n){ unimplementedVisitor("visit(ConstructorDeclaration)"); return true; }
        void endVisitConstructorDeclaration(ConstructorDeclaration n)  { unimplementedVisitor("endVisit(ConstructorDeclaration)"); }

        bool visitConstructorDeclarator(ConstructorDeclarator n){ unimplementedVisitor("visit(ConstructorDeclarator)"); return true; }
        void endVisitConstructorDeclarator(ConstructorDeclarator n)  { unimplementedVisitor("endVisit(ConstructorDeclarator)"); }

        bool visitConstructorModifiers(ConstructorModifiers n){ unimplementedVisitor("visit(ConstructorModifiers)"); return true; }
        void endVisitConstructorModifiers(ConstructorModifiers n)  { unimplementedVisitor("endVisit(ConstructorModifiers)"); }

        bool visitConstructorBody(ConstructorBody n){ unimplementedVisitor("visit(ConstructorBody)"); return true; }
        void endVisitConstructorBody(ConstructorBody n)  { unimplementedVisitor("endVisit(ConstructorBody)"); }

        bool visitEnumDeclaration(EnumDeclaration n){ unimplementedVisitor("visit(EnumDeclaration)"); return true; }
        void endVisitEnumDeclaration(EnumDeclaration n)  { unimplementedVisitor("endVisit(EnumDeclaration)"); }

        bool visitEnumBody(EnumBody n){ unimplementedVisitor("visit(EnumBody)"); return true; }
        void endVisitEnumBody(EnumBody n)  { unimplementedVisitor("endVisit(EnumBody)"); }

        bool visitEnumConstants(EnumConstants n){ unimplementedVisitor("visit(EnumConstants)"); return true; }
        void endVisitEnumConstants(EnumConstants n)  { unimplementedVisitor("endVisit(EnumConstants)"); }

        bool visitEnumConstant(EnumConstant n){ unimplementedVisitor("visit(EnumConstant)"); return true; }
        void endVisitEnumConstant(EnumConstant n)  { unimplementedVisitor("endVisit(EnumConstant)"); }

        bool visitArguments(Arguments n){ unimplementedVisitor("visit(Arguments)"); return true; }
        void endVisitArguments(Arguments n)  { unimplementedVisitor("endVisit(Arguments)"); }

        bool visitEnumBodyDeclarations(EnumBodyDeclarations n){ unimplementedVisitor("visit(EnumBodyDeclarations)"); return true; }
        void endVisitEnumBodyDeclarations(EnumBodyDeclarations n)  { unimplementedVisitor("endVisit(EnumBodyDeclarations)"); }

        bool visitNormalInterfaceDeclaration(NormalInterfaceDeclaration n){ unimplementedVisitor("visit(NormalInterfaceDeclaration)"); return true; }
        void endVisitNormalInterfaceDeclaration(NormalInterfaceDeclaration n)  { unimplementedVisitor("endVisit(NormalInterfaceDeclaration)"); }

        bool visitInterfaceModifiers(InterfaceModifiers n){ unimplementedVisitor("visit(InterfaceModifiers)"); return true; }
        void endVisitInterfaceModifiers(InterfaceModifiers n)  { unimplementedVisitor("endVisit(InterfaceModifiers)"); }

        bool visitInterfaceBody(InterfaceBody n){ unimplementedVisitor("visit(InterfaceBody)"); return true; }
        void endVisitInterfaceBody(InterfaceBody n)  { unimplementedVisitor("endVisit(InterfaceBody)"); }

        bool visitInterfaceMemberDeclarations(InterfaceMemberDeclarations n){ unimplementedVisitor("visit(InterfaceMemberDeclarations)"); return true; }
        void endVisitInterfaceMemberDeclarations(InterfaceMemberDeclarations n)  { unimplementedVisitor("endVisit(InterfaceMemberDeclarations)"); }

        bool visitInterfaceMemberDeclaration(InterfaceMemberDeclaration n){ unimplementedVisitor("visit(InterfaceMemberDeclaration)"); return true; }
        void endVisitInterfaceMemberDeclaration(InterfaceMemberDeclaration n)  { unimplementedVisitor("endVisit(InterfaceMemberDeclaration)"); }

        bool visitConstantDeclaration(ConstantDeclaration n){ unimplementedVisitor("visit(ConstantDeclaration)"); return true; }
        void endVisitConstantDeclaration(ConstantDeclaration n)  { unimplementedVisitor("endVisit(ConstantDeclaration)"); }

        bool visitConstantModifiers(ConstantModifiers n){ unimplementedVisitor("visit(ConstantModifiers)"); return true; }
        void endVisitConstantModifiers(ConstantModifiers n)  { unimplementedVisitor("endVisit(ConstantModifiers)"); }

        bool visitAbstractMethodDeclaration(AbstractMethodDeclaration n){ unimplementedVisitor("visit(AbstractMethodDeclaration)"); return true; }
        void endVisitAbstractMethodDeclaration(AbstractMethodDeclaration n)  { unimplementedVisitor("endVisit(AbstractMethodDeclaration)"); }

        bool visitAbstractMethodModifiers(AbstractMethodModifiers n){ unimplementedVisitor("visit(AbstractMethodModifiers)"); return true; }
        void endVisitAbstractMethodModifiers(AbstractMethodModifiers n)  { unimplementedVisitor("endVisit(AbstractMethodModifiers)"); }

        bool visitAnnotationTypeDeclaration(AnnotationTypeDeclaration n){ unimplementedVisitor("visit(AnnotationTypeDeclaration)"); return true; }
        void endVisitAnnotationTypeDeclaration(AnnotationTypeDeclaration n)  { unimplementedVisitor("endVisit(AnnotationTypeDeclaration)"); }

        bool visitAnnotationTypeBody(AnnotationTypeBody n){ unimplementedVisitor("visit(AnnotationTypeBody)"); return true; }
        void endVisitAnnotationTypeBody(AnnotationTypeBody n)  { unimplementedVisitor("endVisit(AnnotationTypeBody)"); }

        bool visitAnnotationTypeElementDeclarations(AnnotationTypeElementDeclarations n){ unimplementedVisitor("visit(AnnotationTypeElementDeclarations)"); return true; }
        void endVisitAnnotationTypeElementDeclarations(AnnotationTypeElementDeclarations n)  { unimplementedVisitor("endVisit(AnnotationTypeElementDeclarations)"); }

        bool visitDefaultValue(DefaultValue n){ unimplementedVisitor("visit(DefaultValue)"); return true; }
        void endVisitDefaultValue(DefaultValue n)  { unimplementedVisitor("endVisit(DefaultValue)"); }

        bool visitAnnotations(Annotations n){ unimplementedVisitor("visit(Annotations)"); return true; }
        void endVisitAnnotations(Annotations n)  { unimplementedVisitor("endVisit(Annotations)"); }

        bool visitNormalAnnotation(NormalAnnotation n){ unimplementedVisitor("visit(NormalAnnotation)"); return true; }
        void endVisitNormalAnnotation(NormalAnnotation n)  { unimplementedVisitor("endVisit(NormalAnnotation)"); }

        bool visitElementValuePairs(ElementValuePairs n){ unimplementedVisitor("visit(ElementValuePairs)"); return true; }
        void endVisitElementValuePairs(ElementValuePairs n)  { unimplementedVisitor("endVisit(ElementValuePairs)"); }

        bool visitElementValuePair(ElementValuePair n){ unimplementedVisitor("visit(ElementValuePair)"); return true; }
        void endVisitElementValuePair(ElementValuePair n)  { unimplementedVisitor("endVisit(ElementValuePair)"); }

        bool visitElementValueArrayInitializer(ElementValueArrayInitializer n){ unimplementedVisitor("visit(ElementValueArrayInitializer)"); return true; }
        void endVisitElementValueArrayInitializer(ElementValueArrayInitializer n)  { unimplementedVisitor("endVisit(ElementValueArrayInitializer)"); }

        bool visitElementValues(ElementValues n){ unimplementedVisitor("visit(ElementValues)"); return true; }
        void endVisitElementValues(ElementValues n)  { unimplementedVisitor("endVisit(ElementValues)"); }

        bool visitMarkerAnnotation(MarkerAnnotation n){ unimplementedVisitor("visit(MarkerAnnotation)"); return true; }
        void endVisitMarkerAnnotation(MarkerAnnotation n)  { unimplementedVisitor("endVisit(MarkerAnnotation)"); }

        bool visitSingleElementAnnotation(SingleElementAnnotation n){ unimplementedVisitor("visit(SingleElementAnnotation)"); return true; }
        void endVisitSingleElementAnnotation(SingleElementAnnotation n)  { unimplementedVisitor("endVisit(SingleElementAnnotation)"); }

        bool visitArrayInitializer(ArrayInitializer n){ unimplementedVisitor("visit(ArrayInitializer)"); return true; }
        void endVisitArrayInitializer(ArrayInitializer n)  { unimplementedVisitor("endVisit(ArrayInitializer)"); }

        bool visitVariableInitializers(VariableInitializers n){ unimplementedVisitor("visit(VariableInitializers)"); return true; }
        void endVisitVariableInitializers(VariableInitializers n)  { unimplementedVisitor("endVisit(VariableInitializers)"); }

        bool visitBlock(Block n){ unimplementedVisitor("visit(Block)"); return true; }
        void endVisitBlock(Block n)  { unimplementedVisitor("endVisit(Block)"); }

        bool visitBlockStatements(BlockStatements n){ unimplementedVisitor("visit(BlockStatements)"); return true; }
        void endVisitBlockStatements(BlockStatements n)  { unimplementedVisitor("endVisit(BlockStatements)"); }

        bool visitLocalVariableDeclarationStatement(LocalVariableDeclarationStatement n){ unimplementedVisitor("visit(LocalVariableDeclarationStatement)"); return true; }
        void endVisitLocalVariableDeclarationStatement(LocalVariableDeclarationStatement n)  { unimplementedVisitor("endVisit(LocalVariableDeclarationStatement)"); }

        bool visitLocalVariableDeclaration(LocalVariableDeclaration n){ unimplementedVisitor("visit(LocalVariableDeclaration)"); return true; }
        void endVisitLocalVariableDeclaration(LocalVariableDeclaration n)  { unimplementedVisitor("endVisit(LocalVariableDeclaration)"); }

        bool visitIfThenStatement(IfThenStatement n){ unimplementedVisitor("visit(IfThenStatement)"); return true; }
        void endVisitIfThenStatement(IfThenStatement n)  { unimplementedVisitor("endVisit(IfThenStatement)"); }

        bool visitIfThenElseStatement(IfThenElseStatement n){ unimplementedVisitor("visit(IfThenElseStatement)"); return true; }
        void endVisitIfThenElseStatement(IfThenElseStatement n)  { unimplementedVisitor("endVisit(IfThenElseStatement)"); }

        bool visitIfThenElseStatementNoShortIf(IfThenElseStatementNoShortIf n){ unimplementedVisitor("visit(IfThenElseStatementNoShortIf)"); return true; }
        void endVisitIfThenElseStatementNoShortIf(IfThenElseStatementNoShortIf n)  { unimplementedVisitor("endVisit(IfThenElseStatementNoShortIf)"); }

        bool visitEmptyStatement(EmptyStatement n){ unimplementedVisitor("visit(EmptyStatement)"); return true; }
        void endVisitEmptyStatement(EmptyStatement n)  { unimplementedVisitor("endVisit(EmptyStatement)"); }

        bool visitLabeledStatement(LabeledStatement n){ unimplementedVisitor("visit(LabeledStatement)"); return true; }
        void endVisitLabeledStatement(LabeledStatement n)  { unimplementedVisitor("endVisit(LabeledStatement)"); }

        bool visitLabeledStatementNoShortIf(LabeledStatementNoShortIf n){ unimplementedVisitor("visit(LabeledStatementNoShortIf)"); return true; }
        void endVisitLabeledStatementNoShortIf(LabeledStatementNoShortIf n)  { unimplementedVisitor("endVisit(LabeledStatementNoShortIf)"); }

        bool visitExpressionStatement(ExpressionStatement n){ unimplementedVisitor("visit(ExpressionStatement)"); return true; }
        void endVisitExpressionStatement(ExpressionStatement n)  { unimplementedVisitor("endVisit(ExpressionStatement)"); }

        bool visitSwitchStatement(SwitchStatement n){ unimplementedVisitor("visit(SwitchStatement)"); return true; }
        void endVisitSwitchStatement(SwitchStatement n)  { unimplementedVisitor("endVisit(SwitchStatement)"); }

        bool visitSwitchBlock(SwitchBlock n){ unimplementedVisitor("visit(SwitchBlock)"); return true; }
        void endVisitSwitchBlock(SwitchBlock n)  { unimplementedVisitor("endVisit(SwitchBlock)"); }

        bool visitSwitchBlockStatementGroups(SwitchBlockStatementGroups n){ unimplementedVisitor("visit(SwitchBlockStatementGroups)"); return true; }
        void endVisitSwitchBlockStatementGroups(SwitchBlockStatementGroups n)  { unimplementedVisitor("endVisit(SwitchBlockStatementGroups)"); }

        bool visitSwitchBlockStatementGroup(SwitchBlockStatementGroup n){ unimplementedVisitor("visit(SwitchBlockStatementGroup)"); return true; }
        void endVisitSwitchBlockStatementGroup(SwitchBlockStatementGroup n)  { unimplementedVisitor("endVisit(SwitchBlockStatementGroup)"); }

        bool visitSwitchLabels(SwitchLabels n){ unimplementedVisitor("visit(SwitchLabels)"); return true; }
        void endVisitSwitchLabels(SwitchLabels n)  { unimplementedVisitor("endVisit(SwitchLabels)"); }

        bool visitWhileStatement(WhileStatement n){ unimplementedVisitor("visit(WhileStatement)"); return true; }
        void endVisitWhileStatement(WhileStatement n)  { unimplementedVisitor("endVisit(WhileStatement)"); }

        bool visitWhileStatementNoShortIf(WhileStatementNoShortIf n){ unimplementedVisitor("visit(WhileStatementNoShortIf)"); return true; }
        void endVisitWhileStatementNoShortIf(WhileStatementNoShortIf n)  { unimplementedVisitor("endVisit(WhileStatementNoShortIf)"); }

        bool visitDoStatement(DoStatement n){ unimplementedVisitor("visit(DoStatement)"); return true; }
        void endVisitDoStatement(DoStatement n)  { unimplementedVisitor("endVisit(DoStatement)"); }

        bool visitBasicForStatement(BasicForStatement n){ unimplementedVisitor("visit(BasicForStatement)"); return true; }
        void endVisitBasicForStatement(BasicForStatement n)  { unimplementedVisitor("endVisit(BasicForStatement)"); }

        bool visitForStatementNoShortIf(ForStatementNoShortIf n){ unimplementedVisitor("visit(ForStatementNoShortIf)"); return true; }
        void endVisitForStatementNoShortIf(ForStatementNoShortIf n)  { unimplementedVisitor("endVisit(ForStatementNoShortIf)"); }

        bool visitStatementExpressionList(StatementExpressionList n){ unimplementedVisitor("visit(StatementExpressionList)"); return true; }
        void endVisitStatementExpressionList(StatementExpressionList n)  { unimplementedVisitor("endVisit(StatementExpressionList)"); }

        bool visitEnhancedForStatement(EnhancedForStatement n){ unimplementedVisitor("visit(EnhancedForStatement)"); return true; }
        void endVisitEnhancedForStatement(EnhancedForStatement n)  { unimplementedVisitor("endVisit(EnhancedForStatement)"); }

        bool visitBreakStatement(BreakStatement n){ unimplementedVisitor("visit(BreakStatement)"); return true; }
        void endVisitBreakStatement(BreakStatement n)  { unimplementedVisitor("endVisit(BreakStatement)"); }

        bool visitContinueStatement(ContinueStatement n){ unimplementedVisitor("visit(ContinueStatement)"); return true; }
        void endVisitContinueStatement(ContinueStatement n)  { unimplementedVisitor("endVisit(ContinueStatement)"); }

        bool visitReturnStatement(ReturnStatement n){ unimplementedVisitor("visit(ReturnStatement)"); return true; }
        void endVisitReturnStatement(ReturnStatement n)  { unimplementedVisitor("endVisit(ReturnStatement)"); }

        bool visitThrowStatement(ThrowStatement n){ unimplementedVisitor("visit(ThrowStatement)"); return true; }
        void endVisitThrowStatement(ThrowStatement n)  { unimplementedVisitor("endVisit(ThrowStatement)"); }

        bool visitSynchronizedStatement(SynchronizedStatement n){ unimplementedVisitor("visit(SynchronizedStatement)"); return true; }
        void endVisitSynchronizedStatement(SynchronizedStatement n)  { unimplementedVisitor("endVisit(SynchronizedStatement)"); }

        bool visitCatches(Catches n){ unimplementedVisitor("visit(Catches)"); return true; }
        void endVisitCatches(Catches n)  { unimplementedVisitor("endVisit(Catches)"); }

        bool visitCatchClause(CatchClause n){ unimplementedVisitor("visit(CatchClause)"); return true; }
        void endVisitCatchClause(CatchClause n)  { unimplementedVisitor("endVisit(CatchClause)"); }

        bool visitFinally(Finally n){ unimplementedVisitor("visit(Finally)"); return true; }
        void endVisitFinally(Finally n)  { unimplementedVisitor("endVisit(Finally)"); }

        bool visitArgumentList(ArgumentList n){ unimplementedVisitor("visit(ArgumentList)"); return true; }
        void endVisitArgumentList(ArgumentList n)  { unimplementedVisitor("endVisit(ArgumentList)"); }

        bool visitDimExprs(DimExprs n){ unimplementedVisitor("visit(DimExprs)"); return true; }
        void endVisitDimExprs(DimExprs n)  { unimplementedVisitor("endVisit(DimExprs)"); }

        bool visitDimExpr(DimExpr n){ unimplementedVisitor("visit(DimExpr)"); return true; }
        void endVisitDimExpr(DimExpr n)  { unimplementedVisitor("endVisit(DimExpr)"); }

        bool visitPostIncrementExpression(PostIncrementExpression n){ unimplementedVisitor("visit(PostIncrementExpression)"); return true; }
        void endVisitPostIncrementExpression(PostIncrementExpression n)  { unimplementedVisitor("endVisit(PostIncrementExpression)"); }

        bool visitPostDecrementExpression(PostDecrementExpression n){ unimplementedVisitor("visit(PostDecrementExpression)"); return true; }
        void endVisitPostDecrementExpression(PostDecrementExpression n)  { unimplementedVisitor("endVisit(PostDecrementExpression)"); }

        bool visitPreIncrementExpression(PreIncrementExpression n){ unimplementedVisitor("visit(PreIncrementExpression)"); return true; }
        void endVisitPreIncrementExpression(PreIncrementExpression n)  { unimplementedVisitor("endVisit(PreIncrementExpression)"); }

        bool visitPreDecrementExpression(PreDecrementExpression n){ unimplementedVisitor("visit(PreDecrementExpression)"); return true; }
        void endVisitPreDecrementExpression(PreDecrementExpression n)  { unimplementedVisitor("endVisit(PreDecrementExpression)"); }

        bool visitAndExpression(AndExpression n){ unimplementedVisitor("visit(AndExpression)"); return true; }
        void endVisitAndExpression(AndExpression n)  { unimplementedVisitor("endVisit(AndExpression)"); }

        bool visitExclusiveOrExpression(ExclusiveOrExpression n){ unimplementedVisitor("visit(ExclusiveOrExpression)"); return true; }
        void endVisitExclusiveOrExpression(ExclusiveOrExpression n)  { unimplementedVisitor("endVisit(ExclusiveOrExpression)"); }

        bool visitInclusiveOrExpression(InclusiveOrExpression n){ unimplementedVisitor("visit(InclusiveOrExpression)"); return true; }
        void endVisitInclusiveOrExpression(InclusiveOrExpression n)  { unimplementedVisitor("endVisit(InclusiveOrExpression)"); }

        bool visitConditionalAndExpression(ConditionalAndExpression n){ unimplementedVisitor("visit(ConditionalAndExpression)"); return true; }
        void endVisitConditionalAndExpression(ConditionalAndExpression n)  { unimplementedVisitor("endVisit(ConditionalAndExpression)"); }

        bool visitConditionalOrExpression(ConditionalOrExpression n){ unimplementedVisitor("visit(ConditionalOrExpression)"); return true; }
        void endVisitConditionalOrExpression(ConditionalOrExpression n)  { unimplementedVisitor("endVisit(ConditionalOrExpression)"); }

        bool visitConditionalExpression(ConditionalExpression n){ unimplementedVisitor("visit(ConditionalExpression)"); return true; }
        void endVisitConditionalExpression(ConditionalExpression n)  { unimplementedVisitor("endVisit(ConditionalExpression)"); }

        bool visitAssignment(Assignment n){ unimplementedVisitor("visit(Assignment)"); return true; }
        void endVisitAssignment(Assignment n)  { unimplementedVisitor("endVisit(Assignment)"); }

        bool visitCommaopt(Commaopt n){ unimplementedVisitor("visit(Commaopt)"); return true; }
        void endVisitCommaopt(Commaopt n)  { unimplementedVisitor("endVisit(Commaopt)"); }

        bool visitEllipsisopt(Ellipsisopt n){ unimplementedVisitor("visit(Ellipsisopt)"); return true; }
        void endVisitEllipsisopt(Ellipsisopt n)  { unimplementedVisitor("endVisit(Ellipsisopt)"); }

        bool visitLPGUserAction0(LPGUserAction0 n){ unimplementedVisitor("visit(LPGUserAction0)"); return true; }
        void endVisitLPGUserAction0(LPGUserAction0 n)  { unimplementedVisitor("endVisit(LPGUserAction0)"); }

        bool visitLPGUserAction1(LPGUserAction1 n){ unimplementedVisitor("visit(LPGUserAction1)"); return true; }
        void endVisitLPGUserAction1(LPGUserAction1 n)  { unimplementedVisitor("endVisit(LPGUserAction1)"); }

        bool visitLPGUserAction2(LPGUserAction2 n){ unimplementedVisitor("visit(LPGUserAction2)"); return true; }
        void endVisitLPGUserAction2(LPGUserAction2 n)  { unimplementedVisitor("endVisit(LPGUserAction2)"); }

        bool visitLPGUserAction3(LPGUserAction3 n){ unimplementedVisitor("visit(LPGUserAction3)"); return true; }
        void endVisitLPGUserAction3(LPGUserAction3 n)  { unimplementedVisitor("endVisit(LPGUserAction3)"); }

        bool visitLPGUserAction4(LPGUserAction4 n){ unimplementedVisitor("visit(LPGUserAction4)"); return true; }
        void endVisitLPGUserAction4(LPGUserAction4 n)  { unimplementedVisitor("endVisit(LPGUserAction4)"); }

        bool visitIntegralType0(IntegralType0 n){ unimplementedVisitor("visit(IntegralType0)"); return true; }
        void endVisitIntegralType0(IntegralType0 n)  { unimplementedVisitor("endVisit(IntegralType0)"); }

        bool visitIntegralType1(IntegralType1 n){ unimplementedVisitor("visit(IntegralType1)"); return true; }
        void endVisitIntegralType1(IntegralType1 n)  { unimplementedVisitor("endVisit(IntegralType1)"); }

        bool visitIntegralType2(IntegralType2 n){ unimplementedVisitor("visit(IntegralType2)"); return true; }
        void endVisitIntegralType2(IntegralType2 n)  { unimplementedVisitor("endVisit(IntegralType2)"); }

        bool visitIntegralType3(IntegralType3 n){ unimplementedVisitor("visit(IntegralType3)"); return true; }
        void endVisitIntegralType3(IntegralType3 n)  { unimplementedVisitor("endVisit(IntegralType3)"); }

        bool visitIntegralType4(IntegralType4 n){ unimplementedVisitor("visit(IntegralType4)"); return true; }
        void endVisitIntegralType4(IntegralType4 n)  { unimplementedVisitor("endVisit(IntegralType4)"); }

        bool visitFloatingPointType0(FloatingPointType0 n){ unimplementedVisitor("visit(FloatingPointType0)"); return true; }
        void endVisitFloatingPointType0(FloatingPointType0 n)  { unimplementedVisitor("endVisit(FloatingPointType0)"); }

        bool visitFloatingPointType1(FloatingPointType1 n){ unimplementedVisitor("visit(FloatingPointType1)"); return true; }
        void endVisitFloatingPointType1(FloatingPointType1 n)  { unimplementedVisitor("endVisit(FloatingPointType1)"); }

        bool visitWildcardBounds0(WildcardBounds0 n){ unimplementedVisitor("visit(WildcardBounds0)"); return true; }
        void endVisitWildcardBounds0(WildcardBounds0 n)  { unimplementedVisitor("endVisit(WildcardBounds0)"); }

        bool visitWildcardBounds1(WildcardBounds1 n){ unimplementedVisitor("visit(WildcardBounds1)"); return true; }
        void endVisitWildcardBounds1(WildcardBounds1 n)  { unimplementedVisitor("endVisit(WildcardBounds1)"); }

        bool visitClassModifier0(ClassModifier0 n){ unimplementedVisitor("visit(ClassModifier0)"); return true; }
        void endVisitClassModifier0(ClassModifier0 n)  { unimplementedVisitor("endVisit(ClassModifier0)"); }

        bool visitClassModifier1(ClassModifier1 n){ unimplementedVisitor("visit(ClassModifier1)"); return true; }
        void endVisitClassModifier1(ClassModifier1 n)  { unimplementedVisitor("endVisit(ClassModifier1)"); }

        bool visitClassModifier2(ClassModifier2 n){ unimplementedVisitor("visit(ClassModifier2)"); return true; }
        void endVisitClassModifier2(ClassModifier2 n)  { unimplementedVisitor("endVisit(ClassModifier2)"); }

        bool visitClassModifier3(ClassModifier3 n){ unimplementedVisitor("visit(ClassModifier3)"); return true; }
        void endVisitClassModifier3(ClassModifier3 n)  { unimplementedVisitor("endVisit(ClassModifier3)"); }

        bool visitClassModifier4(ClassModifier4 n){ unimplementedVisitor("visit(ClassModifier4)"); return true; }
        void endVisitClassModifier4(ClassModifier4 n)  { unimplementedVisitor("endVisit(ClassModifier4)"); }

        bool visitClassModifier5(ClassModifier5 n){ unimplementedVisitor("visit(ClassModifier5)"); return true; }
        void endVisitClassModifier5(ClassModifier5 n)  { unimplementedVisitor("endVisit(ClassModifier5)"); }

        bool visitClassModifier6(ClassModifier6 n){ unimplementedVisitor("visit(ClassModifier6)"); return true; }
        void endVisitClassModifier6(ClassModifier6 n)  { unimplementedVisitor("endVisit(ClassModifier6)"); }

        bool visitFieldModifier0(FieldModifier0 n){ unimplementedVisitor("visit(FieldModifier0)"); return true; }
        void endVisitFieldModifier0(FieldModifier0 n)  { unimplementedVisitor("endVisit(FieldModifier0)"); }

        bool visitFieldModifier1(FieldModifier1 n){ unimplementedVisitor("visit(FieldModifier1)"); return true; }
        void endVisitFieldModifier1(FieldModifier1 n)  { unimplementedVisitor("endVisit(FieldModifier1)"); }

        bool visitFieldModifier2(FieldModifier2 n){ unimplementedVisitor("visit(FieldModifier2)"); return true; }
        void endVisitFieldModifier2(FieldModifier2 n)  { unimplementedVisitor("endVisit(FieldModifier2)"); }

        bool visitFieldModifier3(FieldModifier3 n){ unimplementedVisitor("visit(FieldModifier3)"); return true; }
        void endVisitFieldModifier3(FieldModifier3 n)  { unimplementedVisitor("endVisit(FieldModifier3)"); }

        bool visitFieldModifier4(FieldModifier4 n){ unimplementedVisitor("visit(FieldModifier4)"); return true; }
        void endVisitFieldModifier4(FieldModifier4 n)  { unimplementedVisitor("endVisit(FieldModifier4)"); }

        bool visitFieldModifier5(FieldModifier5 n){ unimplementedVisitor("visit(FieldModifier5)"); return true; }
        void endVisitFieldModifier5(FieldModifier5 n)  { unimplementedVisitor("endVisit(FieldModifier5)"); }

        bool visitFieldModifier6(FieldModifier6 n){ unimplementedVisitor("visit(FieldModifier6)"); return true; }
        void endVisitFieldModifier6(FieldModifier6 n)  { unimplementedVisitor("endVisit(FieldModifier6)"); }

        bool visitMethodDeclarator0(MethodDeclarator0 n){ unimplementedVisitor("visit(MethodDeclarator0)"); return true; }
        void endVisitMethodDeclarator0(MethodDeclarator0 n)  { unimplementedVisitor("endVisit(MethodDeclarator0)"); }

        bool visitMethodDeclarator1(MethodDeclarator1 n){ unimplementedVisitor("visit(MethodDeclarator1)"); return true; }
        void endVisitMethodDeclarator1(MethodDeclarator1 n)  { unimplementedVisitor("endVisit(MethodDeclarator1)"); }

        bool visitMethodModifier0(MethodModifier0 n){ unimplementedVisitor("visit(MethodModifier0)"); return true; }
        void endVisitMethodModifier0(MethodModifier0 n)  { unimplementedVisitor("endVisit(MethodModifier0)"); }

        bool visitMethodModifier1(MethodModifier1 n){ unimplementedVisitor("visit(MethodModifier1)"); return true; }
        void endVisitMethodModifier1(MethodModifier1 n)  { unimplementedVisitor("endVisit(MethodModifier1)"); }

        bool visitMethodModifier2(MethodModifier2 n){ unimplementedVisitor("visit(MethodModifier2)"); return true; }
        void endVisitMethodModifier2(MethodModifier2 n)  { unimplementedVisitor("endVisit(MethodModifier2)"); }

        bool visitMethodModifier3(MethodModifier3 n){ unimplementedVisitor("visit(MethodModifier3)"); return true; }
        void endVisitMethodModifier3(MethodModifier3 n)  { unimplementedVisitor("endVisit(MethodModifier3)"); }

        bool visitMethodModifier4(MethodModifier4 n){ unimplementedVisitor("visit(MethodModifier4)"); return true; }
        void endVisitMethodModifier4(MethodModifier4 n)  { unimplementedVisitor("endVisit(MethodModifier4)"); }

        bool visitMethodModifier5(MethodModifier5 n){ unimplementedVisitor("visit(MethodModifier5)"); return true; }
        void endVisitMethodModifier5(MethodModifier5 n)  { unimplementedVisitor("endVisit(MethodModifier5)"); }

        bool visitMethodModifier6(MethodModifier6 n){ unimplementedVisitor("visit(MethodModifier6)"); return true; }
        void endVisitMethodModifier6(MethodModifier6 n)  { unimplementedVisitor("endVisit(MethodModifier6)"); }

        bool visitMethodModifier7(MethodModifier7 n){ unimplementedVisitor("visit(MethodModifier7)"); return true; }
        void endVisitMethodModifier7(MethodModifier7 n)  { unimplementedVisitor("endVisit(MethodModifier7)"); }

        bool visitMethodModifier8(MethodModifier8 n){ unimplementedVisitor("visit(MethodModifier8)"); return true; }
        void endVisitMethodModifier8(MethodModifier8 n)  { unimplementedVisitor("endVisit(MethodModifier8)"); }

        bool visitConstructorModifier0(ConstructorModifier0 n){ unimplementedVisitor("visit(ConstructorModifier0)"); return true; }
        void endVisitConstructorModifier0(ConstructorModifier0 n)  { unimplementedVisitor("endVisit(ConstructorModifier0)"); }

        bool visitConstructorModifier1(ConstructorModifier1 n){ unimplementedVisitor("visit(ConstructorModifier1)"); return true; }
        void endVisitConstructorModifier1(ConstructorModifier1 n)  { unimplementedVisitor("endVisit(ConstructorModifier1)"); }

        bool visitConstructorModifier2(ConstructorModifier2 n){ unimplementedVisitor("visit(ConstructorModifier2)"); return true; }
        void endVisitConstructorModifier2(ConstructorModifier2 n)  { unimplementedVisitor("endVisit(ConstructorModifier2)"); }

        bool visitExplicitConstructorInvocation0(ExplicitConstructorInvocation0 n){ unimplementedVisitor("visit(ExplicitConstructorInvocation0)"); return true; }
        void endVisitExplicitConstructorInvocation0(ExplicitConstructorInvocation0 n)  { unimplementedVisitor("endVisit(ExplicitConstructorInvocation0)"); }

        bool visitExplicitConstructorInvocation1(ExplicitConstructorInvocation1 n){ unimplementedVisitor("visit(ExplicitConstructorInvocation1)"); return true; }
        void endVisitExplicitConstructorInvocation1(ExplicitConstructorInvocation1 n)  { unimplementedVisitor("endVisit(ExplicitConstructorInvocation1)"); }

        bool visitExplicitConstructorInvocation2(ExplicitConstructorInvocation2 n){ unimplementedVisitor("visit(ExplicitConstructorInvocation2)"); return true; }
        void endVisitExplicitConstructorInvocation2(ExplicitConstructorInvocation2 n)  { unimplementedVisitor("endVisit(ExplicitConstructorInvocation2)"); }

        bool visitInterfaceModifier0(InterfaceModifier0 n){ unimplementedVisitor("visit(InterfaceModifier0)"); return true; }
        void endVisitInterfaceModifier0(InterfaceModifier0 n)  { unimplementedVisitor("endVisit(InterfaceModifier0)"); }

        bool visitInterfaceModifier1(InterfaceModifier1 n){ unimplementedVisitor("visit(InterfaceModifier1)"); return true; }
        void endVisitInterfaceModifier1(InterfaceModifier1 n)  { unimplementedVisitor("endVisit(InterfaceModifier1)"); }

        bool visitInterfaceModifier2(InterfaceModifier2 n){ unimplementedVisitor("visit(InterfaceModifier2)"); return true; }
        void endVisitInterfaceModifier2(InterfaceModifier2 n)  { unimplementedVisitor("endVisit(InterfaceModifier2)"); }

        bool visitInterfaceModifier3(InterfaceModifier3 n){ unimplementedVisitor("visit(InterfaceModifier3)"); return true; }
        void endVisitInterfaceModifier3(InterfaceModifier3 n)  { unimplementedVisitor("endVisit(InterfaceModifier3)"); }

        bool visitInterfaceModifier4(InterfaceModifier4 n){ unimplementedVisitor("visit(InterfaceModifier4)"); return true; }
        void endVisitInterfaceModifier4(InterfaceModifier4 n)  { unimplementedVisitor("endVisit(InterfaceModifier4)"); }

        bool visitInterfaceModifier5(InterfaceModifier5 n){ unimplementedVisitor("visit(InterfaceModifier5)"); return true; }
        void endVisitInterfaceModifier5(InterfaceModifier5 n)  { unimplementedVisitor("endVisit(InterfaceModifier5)"); }

        bool visitExtendsInterfaces0(ExtendsInterfaces0 n){ unimplementedVisitor("visit(ExtendsInterfaces0)"); return true; }
        void endVisitExtendsInterfaces0(ExtendsInterfaces0 n)  { unimplementedVisitor("endVisit(ExtendsInterfaces0)"); }

        bool visitExtendsInterfaces1(ExtendsInterfaces1 n){ unimplementedVisitor("visit(ExtendsInterfaces1)"); return true; }
        void endVisitExtendsInterfaces1(ExtendsInterfaces1 n)  { unimplementedVisitor("endVisit(ExtendsInterfaces1)"); }

        bool visitConstantModifier0(ConstantModifier0 n){ unimplementedVisitor("visit(ConstantModifier0)"); return true; }
        void endVisitConstantModifier0(ConstantModifier0 n)  { unimplementedVisitor("endVisit(ConstantModifier0)"); }

        bool visitConstantModifier1(ConstantModifier1 n){ unimplementedVisitor("visit(ConstantModifier1)"); return true; }
        void endVisitConstantModifier1(ConstantModifier1 n)  { unimplementedVisitor("endVisit(ConstantModifier1)"); }

        bool visitConstantModifier2(ConstantModifier2 n){ unimplementedVisitor("visit(ConstantModifier2)"); return true; }
        void endVisitConstantModifier2(ConstantModifier2 n)  { unimplementedVisitor("endVisit(ConstantModifier2)"); }

        bool visitAbstractMethodModifier0(AbstractMethodModifier0 n){ unimplementedVisitor("visit(AbstractMethodModifier0)"); return true; }
        void endVisitAbstractMethodModifier0(AbstractMethodModifier0 n)  { unimplementedVisitor("endVisit(AbstractMethodModifier0)"); }

        bool visitAbstractMethodModifier1(AbstractMethodModifier1 n){ unimplementedVisitor("visit(AbstractMethodModifier1)"); return true; }
        void endVisitAbstractMethodModifier1(AbstractMethodModifier1 n)  { unimplementedVisitor("endVisit(AbstractMethodModifier1)"); }

        bool visitAnnotationTypeElementDeclaration0(AnnotationTypeElementDeclaration0 n){ unimplementedVisitor("visit(AnnotationTypeElementDeclaration0)"); return true; }
        void endVisitAnnotationTypeElementDeclaration0(AnnotationTypeElementDeclaration0 n)  { unimplementedVisitor("endVisit(AnnotationTypeElementDeclaration0)"); }

        bool visitAnnotationTypeElementDeclaration1(AnnotationTypeElementDeclaration1 n){ unimplementedVisitor("visit(AnnotationTypeElementDeclaration1)"); return true; }
        void endVisitAnnotationTypeElementDeclaration1(AnnotationTypeElementDeclaration1 n)  { unimplementedVisitor("endVisit(AnnotationTypeElementDeclaration1)"); }

        bool visitAssertStatement0(AssertStatement0 n){ unimplementedVisitor("visit(AssertStatement0)"); return true; }
        void endVisitAssertStatement0(AssertStatement0 n)  { unimplementedVisitor("endVisit(AssertStatement0)"); }

        bool visitAssertStatement1(AssertStatement1 n){ unimplementedVisitor("visit(AssertStatement1)"); return true; }
        void endVisitAssertStatement1(AssertStatement1 n)  { unimplementedVisitor("endVisit(AssertStatement1)"); }

        bool visitSwitchLabel0(SwitchLabel0 n){ unimplementedVisitor("visit(SwitchLabel0)"); return true; }
        void endVisitSwitchLabel0(SwitchLabel0 n)  { unimplementedVisitor("endVisit(SwitchLabel0)"); }

        bool visitSwitchLabel1(SwitchLabel1 n){ unimplementedVisitor("visit(SwitchLabel1)"); return true; }
        void endVisitSwitchLabel1(SwitchLabel1 n)  { unimplementedVisitor("endVisit(SwitchLabel1)"); }

        bool visitSwitchLabel2(SwitchLabel2 n){ unimplementedVisitor("visit(SwitchLabel2)"); return true; }
        void endVisitSwitchLabel2(SwitchLabel2 n)  { unimplementedVisitor("endVisit(SwitchLabel2)"); }

        bool visitTryStatement0(TryStatement0 n){ unimplementedVisitor("visit(TryStatement0)"); return true; }
        void endVisitTryStatement0(TryStatement0 n)  { unimplementedVisitor("endVisit(TryStatement0)"); }

        bool visitTryStatement1(TryStatement1 n){ unimplementedVisitor("visit(TryStatement1)"); return true; }
        void endVisitTryStatement1(TryStatement1 n)  { unimplementedVisitor("endVisit(TryStatement1)"); }

        bool visitPrimaryNoNewArray0(PrimaryNoNewArray0 n){ unimplementedVisitor("visit(PrimaryNoNewArray0)"); return true; }
        void endVisitPrimaryNoNewArray0(PrimaryNoNewArray0 n)  { unimplementedVisitor("endVisit(PrimaryNoNewArray0)"); }

        bool visitPrimaryNoNewArray1(PrimaryNoNewArray1 n){ unimplementedVisitor("visit(PrimaryNoNewArray1)"); return true; }
        void endVisitPrimaryNoNewArray1(PrimaryNoNewArray1 n)  { unimplementedVisitor("endVisit(PrimaryNoNewArray1)"); }

        bool visitPrimaryNoNewArray2(PrimaryNoNewArray2 n){ unimplementedVisitor("visit(PrimaryNoNewArray2)"); return true; }
        void endVisitPrimaryNoNewArray2(PrimaryNoNewArray2 n)  { unimplementedVisitor("endVisit(PrimaryNoNewArray2)"); }

        bool visitPrimaryNoNewArray3(PrimaryNoNewArray3 n){ unimplementedVisitor("visit(PrimaryNoNewArray3)"); return true; }
        void endVisitPrimaryNoNewArray3(PrimaryNoNewArray3 n)  { unimplementedVisitor("endVisit(PrimaryNoNewArray3)"); }

        bool visitPrimaryNoNewArray4(PrimaryNoNewArray4 n){ unimplementedVisitor("visit(PrimaryNoNewArray4)"); return true; }
        void endVisitPrimaryNoNewArray4(PrimaryNoNewArray4 n)  { unimplementedVisitor("endVisit(PrimaryNoNewArray4)"); }

        bool visitLiteral0(Literal0 n){ unimplementedVisitor("visit(Literal0)"); return true; }
        void endVisitLiteral0(Literal0 n)  { unimplementedVisitor("endVisit(Literal0)"); }

        bool visitLiteral1(Literal1 n){ unimplementedVisitor("visit(Literal1)"); return true; }
        void endVisitLiteral1(Literal1 n)  { unimplementedVisitor("endVisit(Literal1)"); }

        bool visitLiteral2(Literal2 n){ unimplementedVisitor("visit(Literal2)"); return true; }
        void endVisitLiteral2(Literal2 n)  { unimplementedVisitor("endVisit(Literal2)"); }

        bool visitLiteral3(Literal3 n){ unimplementedVisitor("visit(Literal3)"); return true; }
        void endVisitLiteral3(Literal3 n)  { unimplementedVisitor("endVisit(Literal3)"); }

        bool visitLiteral4(Literal4 n){ unimplementedVisitor("visit(Literal4)"); return true; }
        void endVisitLiteral4(Literal4 n)  { unimplementedVisitor("endVisit(Literal4)"); }

        bool visitLiteral5(Literal5 n){ unimplementedVisitor("visit(Literal5)"); return true; }
        void endVisitLiteral5(Literal5 n)  { unimplementedVisitor("endVisit(Literal5)"); }

        bool visitLiteral6(Literal6 n){ unimplementedVisitor("visit(Literal6)"); return true; }
        void endVisitLiteral6(Literal6 n)  { unimplementedVisitor("endVisit(Literal6)"); }

        bool visitBooleanLiteral0(BooleanLiteral0 n){ unimplementedVisitor("visit(BooleanLiteral0)"); return true; }
        void endVisitBooleanLiteral0(BooleanLiteral0 n)  { unimplementedVisitor("endVisit(BooleanLiteral0)"); }

        bool visitBooleanLiteral1(BooleanLiteral1 n){ unimplementedVisitor("visit(BooleanLiteral1)"); return true; }
        void endVisitBooleanLiteral1(BooleanLiteral1 n)  { unimplementedVisitor("endVisit(BooleanLiteral1)"); }

        bool visitClassInstanceCreationExpression0(ClassInstanceCreationExpression0 n){ unimplementedVisitor("visit(ClassInstanceCreationExpression0)"); return true; }
        void endVisitClassInstanceCreationExpression0(ClassInstanceCreationExpression0 n)  { unimplementedVisitor("endVisit(ClassInstanceCreationExpression0)"); }

        bool visitClassInstanceCreationExpression1(ClassInstanceCreationExpression1 n){ unimplementedVisitor("visit(ClassInstanceCreationExpression1)"); return true; }
        void endVisitClassInstanceCreationExpression1(ClassInstanceCreationExpression1 n)  { unimplementedVisitor("endVisit(ClassInstanceCreationExpression1)"); }

        bool visitArrayCreationExpression0(ArrayCreationExpression0 n){ unimplementedVisitor("visit(ArrayCreationExpression0)"); return true; }
        void endVisitArrayCreationExpression0(ArrayCreationExpression0 n)  { unimplementedVisitor("endVisit(ArrayCreationExpression0)"); }

        bool visitArrayCreationExpression1(ArrayCreationExpression1 n){ unimplementedVisitor("visit(ArrayCreationExpression1)"); return true; }
        void endVisitArrayCreationExpression1(ArrayCreationExpression1 n)  { unimplementedVisitor("endVisit(ArrayCreationExpression1)"); }

        bool visitArrayCreationExpression2(ArrayCreationExpression2 n){ unimplementedVisitor("visit(ArrayCreationExpression2)"); return true; }
        void endVisitArrayCreationExpression2(ArrayCreationExpression2 n)  { unimplementedVisitor("endVisit(ArrayCreationExpression2)"); }

        bool visitArrayCreationExpression3(ArrayCreationExpression3 n){ unimplementedVisitor("visit(ArrayCreationExpression3)"); return true; }
        void endVisitArrayCreationExpression3(ArrayCreationExpression3 n)  { unimplementedVisitor("endVisit(ArrayCreationExpression3)"); }

        bool visitDims0(Dims0 n){ unimplementedVisitor("visit(Dims0)"); return true; }
        void endVisitDims0(Dims0 n)  { unimplementedVisitor("endVisit(Dims0)"); }

        bool visitDims1(Dims1 n){ unimplementedVisitor("visit(Dims1)"); return true; }
        void endVisitDims1(Dims1 n)  { unimplementedVisitor("endVisit(Dims1)"); }

        bool visitFieldAccess0(FieldAccess0 n){ unimplementedVisitor("visit(FieldAccess0)"); return true; }
        void endVisitFieldAccess0(FieldAccess0 n)  { unimplementedVisitor("endVisit(FieldAccess0)"); }

        bool visitFieldAccess1(FieldAccess1 n){ unimplementedVisitor("visit(FieldAccess1)"); return true; }
        void endVisitFieldAccess1(FieldAccess1 n)  { unimplementedVisitor("endVisit(FieldAccess1)"); }

        bool visitFieldAccess2(FieldAccess2 n){ unimplementedVisitor("visit(FieldAccess2)"); return true; }
        void endVisitFieldAccess2(FieldAccess2 n)  { unimplementedVisitor("endVisit(FieldAccess2)"); }

        bool visitMethodInvocation0(MethodInvocation0 n){ unimplementedVisitor("visit(MethodInvocation0)"); return true; }
        void endVisitMethodInvocation0(MethodInvocation0 n)  { unimplementedVisitor("endVisit(MethodInvocation0)"); }

        bool visitMethodInvocation1(MethodInvocation1 n){ unimplementedVisitor("visit(MethodInvocation1)"); return true; }
        void endVisitMethodInvocation1(MethodInvocation1 n)  { unimplementedVisitor("endVisit(MethodInvocation1)"); }

        bool visitMethodInvocation2(MethodInvocation2 n){ unimplementedVisitor("visit(MethodInvocation2)"); return true; }
        void endVisitMethodInvocation2(MethodInvocation2 n)  { unimplementedVisitor("endVisit(MethodInvocation2)"); }

        bool visitMethodInvocation3(MethodInvocation3 n){ unimplementedVisitor("visit(MethodInvocation3)"); return true; }
        void endVisitMethodInvocation3(MethodInvocation3 n)  { unimplementedVisitor("endVisit(MethodInvocation3)"); }

        bool visitMethodInvocation4(MethodInvocation4 n){ unimplementedVisitor("visit(MethodInvocation4)"); return true; }
        void endVisitMethodInvocation4(MethodInvocation4 n)  { unimplementedVisitor("endVisit(MethodInvocation4)"); }

        bool visitArrayAccess0(ArrayAccess0 n){ unimplementedVisitor("visit(ArrayAccess0)"); return true; }
        void endVisitArrayAccess0(ArrayAccess0 n)  { unimplementedVisitor("endVisit(ArrayAccess0)"); }

        bool visitArrayAccess1(ArrayAccess1 n){ unimplementedVisitor("visit(ArrayAccess1)"); return true; }
        void endVisitArrayAccess1(ArrayAccess1 n)  { unimplementedVisitor("endVisit(ArrayAccess1)"); }

        bool visitUnaryExpression0(UnaryExpression0 n){ unimplementedVisitor("visit(UnaryExpression0)"); return true; }
        void endVisitUnaryExpression0(UnaryExpression0 n)  { unimplementedVisitor("endVisit(UnaryExpression0)"); }

        bool visitUnaryExpression1(UnaryExpression1 n){ unimplementedVisitor("visit(UnaryExpression1)"); return true; }
        void endVisitUnaryExpression1(UnaryExpression1 n)  { unimplementedVisitor("endVisit(UnaryExpression1)"); }

        bool visitUnaryExpressionNotPlusMinus0(UnaryExpressionNotPlusMinus0 n){ unimplementedVisitor("visit(UnaryExpressionNotPlusMinus0)"); return true; }
        void endVisitUnaryExpressionNotPlusMinus0(UnaryExpressionNotPlusMinus0 n)  { unimplementedVisitor("endVisit(UnaryExpressionNotPlusMinus0)"); }

        bool visitUnaryExpressionNotPlusMinus1(UnaryExpressionNotPlusMinus1 n){ unimplementedVisitor("visit(UnaryExpressionNotPlusMinus1)"); return true; }
        void endVisitUnaryExpressionNotPlusMinus1(UnaryExpressionNotPlusMinus1 n)  { unimplementedVisitor("endVisit(UnaryExpressionNotPlusMinus1)"); }

        bool visitCastExpression0(CastExpression0 n){ unimplementedVisitor("visit(CastExpression0)"); return true; }
        void endVisitCastExpression0(CastExpression0 n)  { unimplementedVisitor("endVisit(CastExpression0)"); }

        bool visitCastExpression1(CastExpression1 n){ unimplementedVisitor("visit(CastExpression1)"); return true; }
        void endVisitCastExpression1(CastExpression1 n)  { unimplementedVisitor("endVisit(CastExpression1)"); }

        bool visitMultiplicativeExpression0(MultiplicativeExpression0 n){ unimplementedVisitor("visit(MultiplicativeExpression0)"); return true; }
        void endVisitMultiplicativeExpression0(MultiplicativeExpression0 n)  { unimplementedVisitor("endVisit(MultiplicativeExpression0)"); }

        bool visitMultiplicativeExpression1(MultiplicativeExpression1 n){ unimplementedVisitor("visit(MultiplicativeExpression1)"); return true; }
        void endVisitMultiplicativeExpression1(MultiplicativeExpression1 n)  { unimplementedVisitor("endVisit(MultiplicativeExpression1)"); }

        bool visitMultiplicativeExpression2(MultiplicativeExpression2 n){ unimplementedVisitor("visit(MultiplicativeExpression2)"); return true; }
        void endVisitMultiplicativeExpression2(MultiplicativeExpression2 n)  { unimplementedVisitor("endVisit(MultiplicativeExpression2)"); }

        bool visitAdditiveExpression0(AdditiveExpression0 n){ unimplementedVisitor("visit(AdditiveExpression0)"); return true; }
        void endVisitAdditiveExpression0(AdditiveExpression0 n)  { unimplementedVisitor("endVisit(AdditiveExpression0)"); }

        bool visitAdditiveExpression1(AdditiveExpression1 n){ unimplementedVisitor("visit(AdditiveExpression1)"); return true; }
        void endVisitAdditiveExpression1(AdditiveExpression1 n)  { unimplementedVisitor("endVisit(AdditiveExpression1)"); }

        bool visitShiftExpression0(ShiftExpression0 n){ unimplementedVisitor("visit(ShiftExpression0)"); return true; }
        void endVisitShiftExpression0(ShiftExpression0 n)  { unimplementedVisitor("endVisit(ShiftExpression0)"); }

        bool visitShiftExpression1(ShiftExpression1 n){ unimplementedVisitor("visit(ShiftExpression1)"); return true; }
        void endVisitShiftExpression1(ShiftExpression1 n)  { unimplementedVisitor("endVisit(ShiftExpression1)"); }

        bool visitShiftExpression2(ShiftExpression2 n){ unimplementedVisitor("visit(ShiftExpression2)"); return true; }
        void endVisitShiftExpression2(ShiftExpression2 n)  { unimplementedVisitor("endVisit(ShiftExpression2)"); }

        bool visitRelationalExpression0(RelationalExpression0 n){ unimplementedVisitor("visit(RelationalExpression0)"); return true; }
        void endVisitRelationalExpression0(RelationalExpression0 n)  { unimplementedVisitor("endVisit(RelationalExpression0)"); }

        bool visitRelationalExpression1(RelationalExpression1 n){ unimplementedVisitor("visit(RelationalExpression1)"); return true; }
        void endVisitRelationalExpression1(RelationalExpression1 n)  { unimplementedVisitor("endVisit(RelationalExpression1)"); }

        bool visitRelationalExpression2(RelationalExpression2 n){ unimplementedVisitor("visit(RelationalExpression2)"); return true; }
        void endVisitRelationalExpression2(RelationalExpression2 n)  { unimplementedVisitor("endVisit(RelationalExpression2)"); }

        bool visitRelationalExpression3(RelationalExpression3 n){ unimplementedVisitor("visit(RelationalExpression3)"); return true; }
        void endVisitRelationalExpression3(RelationalExpression3 n)  { unimplementedVisitor("endVisit(RelationalExpression3)"); }

        bool visitRelationalExpression4(RelationalExpression4 n){ unimplementedVisitor("visit(RelationalExpression4)"); return true; }
        void endVisitRelationalExpression4(RelationalExpression4 n)  { unimplementedVisitor("endVisit(RelationalExpression4)"); }

        bool visitEqualityExpression0(EqualityExpression0 n){ unimplementedVisitor("visit(EqualityExpression0)"); return true; }
        void endVisitEqualityExpression0(EqualityExpression0 n)  { unimplementedVisitor("endVisit(EqualityExpression0)"); }

        bool visitEqualityExpression1(EqualityExpression1 n){ unimplementedVisitor("visit(EqualityExpression1)"); return true; }
        void endVisitEqualityExpression1(EqualityExpression1 n)  { unimplementedVisitor("endVisit(EqualityExpression1)"); }

        bool visitAssignmentOperator0(AssignmentOperator0 n){ unimplementedVisitor("visit(AssignmentOperator0)"); return true; }
        void endVisitAssignmentOperator0(AssignmentOperator0 n)  { unimplementedVisitor("endVisit(AssignmentOperator0)"); }

        bool visitAssignmentOperator1(AssignmentOperator1 n){ unimplementedVisitor("visit(AssignmentOperator1)"); return true; }
        void endVisitAssignmentOperator1(AssignmentOperator1 n)  { unimplementedVisitor("endVisit(AssignmentOperator1)"); }

        bool visitAssignmentOperator2(AssignmentOperator2 n){ unimplementedVisitor("visit(AssignmentOperator2)"); return true; }
        void endVisitAssignmentOperator2(AssignmentOperator2 n)  { unimplementedVisitor("endVisit(AssignmentOperator2)"); }

        bool visitAssignmentOperator3(AssignmentOperator3 n){ unimplementedVisitor("visit(AssignmentOperator3)"); return true; }
        void endVisitAssignmentOperator3(AssignmentOperator3 n)  { unimplementedVisitor("endVisit(AssignmentOperator3)"); }

        bool visitAssignmentOperator4(AssignmentOperator4 n){ unimplementedVisitor("visit(AssignmentOperator4)"); return true; }
        void endVisitAssignmentOperator4(AssignmentOperator4 n)  { unimplementedVisitor("endVisit(AssignmentOperator4)"); }

        bool visitAssignmentOperator5(AssignmentOperator5 n){ unimplementedVisitor("visit(AssignmentOperator5)"); return true; }
        void endVisitAssignmentOperator5(AssignmentOperator5 n)  { unimplementedVisitor("endVisit(AssignmentOperator5)"); }

        bool visitAssignmentOperator6(AssignmentOperator6 n){ unimplementedVisitor("visit(AssignmentOperator6)"); return true; }
        void endVisitAssignmentOperator6(AssignmentOperator6 n)  { unimplementedVisitor("endVisit(AssignmentOperator6)"); }

        bool visitAssignmentOperator7(AssignmentOperator7 n){ unimplementedVisitor("visit(AssignmentOperator7)"); return true; }
        void endVisitAssignmentOperator7(AssignmentOperator7 n)  { unimplementedVisitor("endVisit(AssignmentOperator7)"); }

        bool visitAssignmentOperator8(AssignmentOperator8 n){ unimplementedVisitor("visit(AssignmentOperator8)"); return true; }
        void endVisitAssignmentOperator8(AssignmentOperator8 n)  { unimplementedVisitor("endVisit(AssignmentOperator8)"); }

        bool visitAssignmentOperator9(AssignmentOperator9 n){ unimplementedVisitor("visit(AssignmentOperator9)"); return true; }
        void endVisitAssignmentOperator9(AssignmentOperator9 n)  { unimplementedVisitor("endVisit(AssignmentOperator9)"); }

        bool visitAssignmentOperator10(AssignmentOperator10 n){ unimplementedVisitor("visit(AssignmentOperator10)"); return true; }
        void endVisitAssignmentOperator10(AssignmentOperator10 n)  { unimplementedVisitor("endVisit(AssignmentOperator10)"); }

        bool visitAssignmentOperator11(AssignmentOperator11 n){ unimplementedVisitor("visit(AssignmentOperator11)"); return true; }
        void endVisitAssignmentOperator11(AssignmentOperator11 n)  { unimplementedVisitor("endVisit(AssignmentOperator11)"); }


        bool visit(Ast n)
        {
            if (n is AstToken) return visitAstToken( n);
            else if (n is identifier) return visitidentifier( n);
            else if (n is PrimitiveType) return visitPrimitiveType( n);
            else if (n is ClassType) return visitClassType( n);
            else if (n is InterfaceType) return visitInterfaceType( n);
            else if (n is TypeName) return visitTypeName( n);
            else if (n is ArrayType) return visitArrayType( n);
            else if (n is TypeParameter) return visitTypeParameter( n);
            else if (n is TypeBound) return visitTypeBound( n);
            else if (n is AdditionalBoundList) return visitAdditionalBoundList( n);
            else if (n is AdditionalBound) return visitAdditionalBound( n);
            else if (n is TypeArguments) return visitTypeArguments( n);
            else if (n is ActualTypeArgumentList) return visitActualTypeArgumentList( n);
            else if (n is Wildcard) return visitWildcard( n);
            else if (n is PackageName) return visitPackageName( n);
            else if (n is ExpressionName) return visitExpressionName( n);
            else if (n is MethodName) return visitMethodName( n);
            else if (n is PackageOrTypeName) return visitPackageOrTypeName( n);
            else if (n is AmbiguousName) return visitAmbiguousName( n);
            else if (n is CompilationUnit) return visitCompilationUnit( n);
            else if (n is ImportDeclarations) return visitImportDeclarations( n);
            else if (n is TypeDeclarations) return visitTypeDeclarations( n);
            else if (n is PackageDeclaration) return visitPackageDeclaration( n);
            else if (n is SingleTypeImportDeclaration) return visitSingleTypeImportDeclaration( n);
            else if (n is TypeImportOnDemandDeclaration) return visitTypeImportOnDemandDeclaration( n);
            else if (n is SingleStaticImportDeclaration) return visitSingleStaticImportDeclaration( n);
            else if (n is StaticImportOnDemandDeclaration) return visitStaticImportOnDemandDeclaration( n);
            else if (n is TypeDeclaration) return visitTypeDeclaration( n);
            else if (n is NormalClassDeclaration) return visitNormalClassDeclaration( n);
            else if (n is ClassModifiers) return visitClassModifiers( n);
            else if (n is TypeParameters) return visitTypeParameters( n);
            else if (n is TypeParameterList) return visitTypeParameterList( n);
            else if (n is Super) return visitSuper( n);
            else if (n is Interfaces) return visitInterfaces( n);
            else if (n is InterfaceTypeList) return visitInterfaceTypeList( n);
            else if (n is ClassBody) return visitClassBody( n);
            else if (n is ClassBodyDeclarations) return visitClassBodyDeclarations( n);
            else if (n is ClassMemberDeclaration) return visitClassMemberDeclaration( n);
            else if (n is FieldDeclaration) return visitFieldDeclaration( n);
            else if (n is VariableDeclarators) return visitVariableDeclarators( n);
            else if (n is VariableDeclarator) return visitVariableDeclarator( n);
            else if (n is VariableDeclaratorId) return visitVariableDeclaratorId( n);
            else if (n is FieldModifiers) return visitFieldModifiers( n);
            else if (n is MethodDeclaration) return visitMethodDeclaration( n);
            else if (n is MethodHeader) return visitMethodHeader( n);
            else if (n is ResultType) return visitResultType( n);
            else if (n is FormalParameterList) return visitFormalParameterList( n);
            else if (n is FormalParameters) return visitFormalParameters( n);
            else if (n is FormalParameter) return visitFormalParameter( n);
            else if (n is VariableModifiers) return visitVariableModifiers( n);
            else if (n is VariableModifier) return visitVariableModifier( n);
            else if (n is LastFormalParameter) return visitLastFormalParameter( n);
            else if (n is MethodModifiers) return visitMethodModifiers( n);
            else if (n is Throws) return visitThrows( n);
            else if (n is ExceptionTypeList) return visitExceptionTypeList( n);
            else if (n is MethodBody) return visitMethodBody( n);
            else if (n is StaticInitializer) return visitStaticInitializer( n);
            else if (n is ConstructorDeclaration) return visitConstructorDeclaration( n);
            else if (n is ConstructorDeclarator) return visitConstructorDeclarator( n);
            else if (n is ConstructorModifiers) return visitConstructorModifiers( n);
            else if (n is ConstructorBody) return visitConstructorBody( n);
            else if (n is EnumDeclaration) return visitEnumDeclaration( n);
            else if (n is EnumBody) return visitEnumBody( n);
            else if (n is EnumConstants) return visitEnumConstants( n);
            else if (n is EnumConstant) return visitEnumConstant( n);
            else if (n is Arguments) return visitArguments( n);
            else if (n is EnumBodyDeclarations) return visitEnumBodyDeclarations( n);
            else if (n is NormalInterfaceDeclaration) return visitNormalInterfaceDeclaration( n);
            else if (n is InterfaceModifiers) return visitInterfaceModifiers( n);
            else if (n is InterfaceBody) return visitInterfaceBody( n);
            else if (n is InterfaceMemberDeclarations) return visitInterfaceMemberDeclarations( n);
            else if (n is InterfaceMemberDeclaration) return visitInterfaceMemberDeclaration( n);
            else if (n is ConstantDeclaration) return visitConstantDeclaration( n);
            else if (n is ConstantModifiers) return visitConstantModifiers( n);
            else if (n is AbstractMethodDeclaration) return visitAbstractMethodDeclaration( n);
            else if (n is AbstractMethodModifiers) return visitAbstractMethodModifiers( n);
            else if (n is AnnotationTypeDeclaration) return visitAnnotationTypeDeclaration( n);
            else if (n is AnnotationTypeBody) return visitAnnotationTypeBody( n);
            else if (n is AnnotationTypeElementDeclarations) return visitAnnotationTypeElementDeclarations( n);
            else if (n is DefaultValue) return visitDefaultValue( n);
            else if (n is Annotations) return visitAnnotations( n);
            else if (n is NormalAnnotation) return visitNormalAnnotation( n);
            else if (n is ElementValuePairs) return visitElementValuePairs( n);
            else if (n is ElementValuePair) return visitElementValuePair( n);
            else if (n is ElementValueArrayInitializer) return visitElementValueArrayInitializer( n);
            else if (n is ElementValues) return visitElementValues( n);
            else if (n is MarkerAnnotation) return visitMarkerAnnotation( n);
            else if (n is SingleElementAnnotation) return visitSingleElementAnnotation( n);
            else if (n is ArrayInitializer) return visitArrayInitializer( n);
            else if (n is VariableInitializers) return visitVariableInitializers( n);
            else if (n is Block) return visitBlock( n);
            else if (n is BlockStatements) return visitBlockStatements( n);
            else if (n is LocalVariableDeclarationStatement) return visitLocalVariableDeclarationStatement( n);
            else if (n is LocalVariableDeclaration) return visitLocalVariableDeclaration( n);
            else if (n is IfThenStatement) return visitIfThenStatement( n);
            else if (n is IfThenElseStatement) return visitIfThenElseStatement( n);
            else if (n is IfThenElseStatementNoShortIf) return visitIfThenElseStatementNoShortIf( n);
            else if (n is EmptyStatement) return visitEmptyStatement( n);
            else if (n is LabeledStatement) return visitLabeledStatement( n);
            else if (n is LabeledStatementNoShortIf) return visitLabeledStatementNoShortIf( n);
            else if (n is ExpressionStatement) return visitExpressionStatement( n);
            else if (n is SwitchStatement) return visitSwitchStatement( n);
            else if (n is SwitchBlock) return visitSwitchBlock( n);
            else if (n is SwitchBlockStatementGroups) return visitSwitchBlockStatementGroups( n);
            else if (n is SwitchBlockStatementGroup) return visitSwitchBlockStatementGroup( n);
            else if (n is SwitchLabels) return visitSwitchLabels( n);
            else if (n is WhileStatement) return visitWhileStatement( n);
            else if (n is WhileStatementNoShortIf) return visitWhileStatementNoShortIf( n);
            else if (n is DoStatement) return visitDoStatement( n);
            else if (n is BasicForStatement) return visitBasicForStatement( n);
            else if (n is ForStatementNoShortIf) return visitForStatementNoShortIf( n);
            else if (n is StatementExpressionList) return visitStatementExpressionList( n);
            else if (n is EnhancedForStatement) return visitEnhancedForStatement( n);
            else if (n is BreakStatement) return visitBreakStatement( n);
            else if (n is ContinueStatement) return visitContinueStatement( n);
            else if (n is ReturnStatement) return visitReturnStatement( n);
            else if (n is ThrowStatement) return visitThrowStatement( n);
            else if (n is SynchronizedStatement) return visitSynchronizedStatement( n);
            else if (n is Catches) return visitCatches( n);
            else if (n is CatchClause) return visitCatchClause( n);
            else if (n is Finally) return visitFinally( n);
            else if (n is ArgumentList) return visitArgumentList( n);
            else if (n is DimExprs) return visitDimExprs( n);
            else if (n is DimExpr) return visitDimExpr( n);
            else if (n is PostIncrementExpression) return visitPostIncrementExpression( n);
            else if (n is PostDecrementExpression) return visitPostDecrementExpression( n);
            else if (n is PreIncrementExpression) return visitPreIncrementExpression( n);
            else if (n is PreDecrementExpression) return visitPreDecrementExpression( n);
            else if (n is AndExpression) return visitAndExpression( n);
            else if (n is ExclusiveOrExpression) return visitExclusiveOrExpression( n);
            else if (n is InclusiveOrExpression) return visitInclusiveOrExpression( n);
            else if (n is ConditionalAndExpression) return visitConditionalAndExpression( n);
            else if (n is ConditionalOrExpression) return visitConditionalOrExpression( n);
            else if (n is ConditionalExpression) return visitConditionalExpression( n);
            else if (n is Assignment) return visitAssignment( n);
            else if (n is Commaopt) return visitCommaopt( n);
            else if (n is Ellipsisopt) return visitEllipsisopt( n);
            else if (n is LPGUserAction0) return visitLPGUserAction0( n);
            else if (n is LPGUserAction1) return visitLPGUserAction1( n);
            else if (n is LPGUserAction2) return visitLPGUserAction2( n);
            else if (n is LPGUserAction3) return visitLPGUserAction3( n);
            else if (n is LPGUserAction4) return visitLPGUserAction4( n);
            else if (n is IntegralType0) return visitIntegralType0( n);
            else if (n is IntegralType1) return visitIntegralType1( n);
            else if (n is IntegralType2) return visitIntegralType2( n);
            else if (n is IntegralType3) return visitIntegralType3( n);
            else if (n is IntegralType4) return visitIntegralType4( n);
            else if (n is FloatingPointType0) return visitFloatingPointType0( n);
            else if (n is FloatingPointType1) return visitFloatingPointType1( n);
            else if (n is WildcardBounds0) return visitWildcardBounds0( n);
            else if (n is WildcardBounds1) return visitWildcardBounds1( n);
            else if (n is ClassModifier0) return visitClassModifier0( n);
            else if (n is ClassModifier1) return visitClassModifier1( n);
            else if (n is ClassModifier2) return visitClassModifier2( n);
            else if (n is ClassModifier3) return visitClassModifier3( n);
            else if (n is ClassModifier4) return visitClassModifier4( n);
            else if (n is ClassModifier5) return visitClassModifier5( n);
            else if (n is ClassModifier6) return visitClassModifier6( n);
            else if (n is FieldModifier0) return visitFieldModifier0( n);
            else if (n is FieldModifier1) return visitFieldModifier1( n);
            else if (n is FieldModifier2) return visitFieldModifier2( n);
            else if (n is FieldModifier3) return visitFieldModifier3( n);
            else if (n is FieldModifier4) return visitFieldModifier4( n);
            else if (n is FieldModifier5) return visitFieldModifier5( n);
            else if (n is FieldModifier6) return visitFieldModifier6( n);
            else if (n is MethodDeclarator0) return visitMethodDeclarator0( n);
            else if (n is MethodDeclarator1) return visitMethodDeclarator1( n);
            else if (n is MethodModifier0) return visitMethodModifier0( n);
            else if (n is MethodModifier1) return visitMethodModifier1( n);
            else if (n is MethodModifier2) return visitMethodModifier2( n);
            else if (n is MethodModifier3) return visitMethodModifier3( n);
            else if (n is MethodModifier4) return visitMethodModifier4( n);
            else if (n is MethodModifier5) return visitMethodModifier5( n);
            else if (n is MethodModifier6) return visitMethodModifier6( n);
            else if (n is MethodModifier7) return visitMethodModifier7( n);
            else if (n is MethodModifier8) return visitMethodModifier8( n);
            else if (n is ConstructorModifier0) return visitConstructorModifier0( n);
            else if (n is ConstructorModifier1) return visitConstructorModifier1( n);
            else if (n is ConstructorModifier2) return visitConstructorModifier2( n);
            else if (n is ExplicitConstructorInvocation0) return visitExplicitConstructorInvocation0( n);
            else if (n is ExplicitConstructorInvocation1) return visitExplicitConstructorInvocation1( n);
            else if (n is ExplicitConstructorInvocation2) return visitExplicitConstructorInvocation2( n);
            else if (n is InterfaceModifier0) return visitInterfaceModifier0( n);
            else if (n is InterfaceModifier1) return visitInterfaceModifier1( n);
            else if (n is InterfaceModifier2) return visitInterfaceModifier2( n);
            else if (n is InterfaceModifier3) return visitInterfaceModifier3( n);
            else if (n is InterfaceModifier4) return visitInterfaceModifier4( n);
            else if (n is InterfaceModifier5) return visitInterfaceModifier5( n);
            else if (n is ExtendsInterfaces0) return visitExtendsInterfaces0( n);
            else if (n is ExtendsInterfaces1) return visitExtendsInterfaces1( n);
            else if (n is ConstantModifier0) return visitConstantModifier0( n);
            else if (n is ConstantModifier1) return visitConstantModifier1( n);
            else if (n is ConstantModifier2) return visitConstantModifier2( n);
            else if (n is AbstractMethodModifier0) return visitAbstractMethodModifier0( n);
            else if (n is AbstractMethodModifier1) return visitAbstractMethodModifier1( n);
            else if (n is AnnotationTypeElementDeclaration0) return visitAnnotationTypeElementDeclaration0( n);
            else if (n is AnnotationTypeElementDeclaration1) return visitAnnotationTypeElementDeclaration1( n);
            else if (n is AssertStatement0) return visitAssertStatement0( n);
            else if (n is AssertStatement1) return visitAssertStatement1( n);
            else if (n is SwitchLabel0) return visitSwitchLabel0( n);
            else if (n is SwitchLabel1) return visitSwitchLabel1( n);
            else if (n is SwitchLabel2) return visitSwitchLabel2( n);
            else if (n is TryStatement0) return visitTryStatement0( n);
            else if (n is TryStatement1) return visitTryStatement1( n);
            else if (n is PrimaryNoNewArray0) return visitPrimaryNoNewArray0( n);
            else if (n is PrimaryNoNewArray1) return visitPrimaryNoNewArray1( n);
            else if (n is PrimaryNoNewArray2) return visitPrimaryNoNewArray2( n);
            else if (n is PrimaryNoNewArray3) return visitPrimaryNoNewArray3( n);
            else if (n is PrimaryNoNewArray4) return visitPrimaryNoNewArray4( n);
            else if (n is Literal0) return visitLiteral0( n);
            else if (n is Literal1) return visitLiteral1( n);
            else if (n is Literal2) return visitLiteral2( n);
            else if (n is Literal3) return visitLiteral3( n);
            else if (n is Literal4) return visitLiteral4( n);
            else if (n is Literal5) return visitLiteral5( n);
            else if (n is Literal6) return visitLiteral6( n);
            else if (n is BooleanLiteral0) return visitBooleanLiteral0( n);
            else if (n is BooleanLiteral1) return visitBooleanLiteral1( n);
            else if (n is ClassInstanceCreationExpression0) return visitClassInstanceCreationExpression0( n);
            else if (n is ClassInstanceCreationExpression1) return visitClassInstanceCreationExpression1( n);
            else if (n is ArrayCreationExpression0) return visitArrayCreationExpression0( n);
            else if (n is ArrayCreationExpression1) return visitArrayCreationExpression1( n);
            else if (n is ArrayCreationExpression2) return visitArrayCreationExpression2( n);
            else if (n is ArrayCreationExpression3) return visitArrayCreationExpression3( n);
            else if (n is Dims0) return visitDims0( n);
            else if (n is Dims1) return visitDims1( n);
            else if (n is FieldAccess0) return visitFieldAccess0( n);
            else if (n is FieldAccess1) return visitFieldAccess1( n);
            else if (n is FieldAccess2) return visitFieldAccess2( n);
            else if (n is MethodInvocation0) return visitMethodInvocation0( n);
            else if (n is MethodInvocation1) return visitMethodInvocation1( n);
            else if (n is MethodInvocation2) return visitMethodInvocation2( n);
            else if (n is MethodInvocation3) return visitMethodInvocation3( n);
            else if (n is MethodInvocation4) return visitMethodInvocation4( n);
            else if (n is ArrayAccess0) return visitArrayAccess0( n);
            else if (n is ArrayAccess1) return visitArrayAccess1( n);
            else if (n is UnaryExpression0) return visitUnaryExpression0( n);
            else if (n is UnaryExpression1) return visitUnaryExpression1( n);
            else if (n is UnaryExpressionNotPlusMinus0) return visitUnaryExpressionNotPlusMinus0( n);
            else if (n is UnaryExpressionNotPlusMinus1) return visitUnaryExpressionNotPlusMinus1( n);
            else if (n is CastExpression0) return visitCastExpression0( n);
            else if (n is CastExpression1) return visitCastExpression1( n);
            else if (n is MultiplicativeExpression0) return visitMultiplicativeExpression0( n);
            else if (n is MultiplicativeExpression1) return visitMultiplicativeExpression1( n);
            else if (n is MultiplicativeExpression2) return visitMultiplicativeExpression2( n);
            else if (n is AdditiveExpression0) return visitAdditiveExpression0( n);
            else if (n is AdditiveExpression1) return visitAdditiveExpression1( n);
            else if (n is ShiftExpression0) return visitShiftExpression0( n);
            else if (n is ShiftExpression1) return visitShiftExpression1( n);
            else if (n is ShiftExpression2) return visitShiftExpression2( n);
            else if (n is RelationalExpression0) return visitRelationalExpression0( n);
            else if (n is RelationalExpression1) return visitRelationalExpression1( n);
            else if (n is RelationalExpression2) return visitRelationalExpression2( n);
            else if (n is RelationalExpression3) return visitRelationalExpression3( n);
            else if (n is RelationalExpression4) return visitRelationalExpression4( n);
            else if (n is EqualityExpression0) return visitEqualityExpression0( n);
            else if (n is EqualityExpression1) return visitEqualityExpression1( n);
            else if (n is AssignmentOperator0) return visitAssignmentOperator0( n);
            else if (n is AssignmentOperator1) return visitAssignmentOperator1( n);
            else if (n is AssignmentOperator2) return visitAssignmentOperator2( n);
            else if (n is AssignmentOperator3) return visitAssignmentOperator3( n);
            else if (n is AssignmentOperator4) return visitAssignmentOperator4( n);
            else if (n is AssignmentOperator5) return visitAssignmentOperator5( n);
            else if (n is AssignmentOperator6) return visitAssignmentOperator6( n);
            else if (n is AssignmentOperator7) return visitAssignmentOperator7( n);
            else if (n is AssignmentOperator8) return visitAssignmentOperator8( n);
            else if (n is AssignmentOperator9) return visitAssignmentOperator9( n);
            else if (n is AssignmentOperator10) return visitAssignmentOperator10( n);
            else if (n is AssignmentOperator11) return visitAssignmentOperator11( n);
            throw  ArgumentError("visit(" + n.toString() + ")");
        }
       void endVisit(Ast n)
        {
            if (n is AstToken) endVisitAstToken(n);
            else if (n is identifier) endVisitidentifier(n);
            else if (n is PrimitiveType) endVisitPrimitiveType(n);
            else if (n is ClassType) endVisitClassType(n);
            else if (n is InterfaceType) endVisitInterfaceType(n);
            else if (n is TypeName) endVisitTypeName(n);
            else if (n is ArrayType) endVisitArrayType(n);
            else if (n is TypeParameter) endVisitTypeParameter(n);
            else if (n is TypeBound) endVisitTypeBound(n);
            else if (n is AdditionalBoundList) endVisitAdditionalBoundList(n);
            else if (n is AdditionalBound) endVisitAdditionalBound(n);
            else if (n is TypeArguments) endVisitTypeArguments(n);
            else if (n is ActualTypeArgumentList) endVisitActualTypeArgumentList(n);
            else if (n is Wildcard) endVisitWildcard(n);
            else if (n is PackageName) endVisitPackageName(n);
            else if (n is ExpressionName) endVisitExpressionName(n);
            else if (n is MethodName) endVisitMethodName(n);
            else if (n is PackageOrTypeName) endVisitPackageOrTypeName(n);
            else if (n is AmbiguousName) endVisitAmbiguousName(n);
            else if (n is CompilationUnit) endVisitCompilationUnit(n);
            else if (n is ImportDeclarations) endVisitImportDeclarations(n);
            else if (n is TypeDeclarations) endVisitTypeDeclarations(n);
            else if (n is PackageDeclaration) endVisitPackageDeclaration(n);
            else if (n is SingleTypeImportDeclaration) endVisitSingleTypeImportDeclaration(n);
            else if (n is TypeImportOnDemandDeclaration) endVisitTypeImportOnDemandDeclaration(n);
            else if (n is SingleStaticImportDeclaration) endVisitSingleStaticImportDeclaration(n);
            else if (n is StaticImportOnDemandDeclaration) endVisitStaticImportOnDemandDeclaration(n);
            else if (n is TypeDeclaration) endVisitTypeDeclaration(n);
            else if (n is NormalClassDeclaration) endVisitNormalClassDeclaration(n);
            else if (n is ClassModifiers) endVisitClassModifiers(n);
            else if (n is TypeParameters) endVisitTypeParameters(n);
            else if (n is TypeParameterList) endVisitTypeParameterList(n);
            else if (n is Super) endVisitSuper(n);
            else if (n is Interfaces) endVisitInterfaces(n);
            else if (n is InterfaceTypeList) endVisitInterfaceTypeList(n);
            else if (n is ClassBody) endVisitClassBody(n);
            else if (n is ClassBodyDeclarations) endVisitClassBodyDeclarations(n);
            else if (n is ClassMemberDeclaration) endVisitClassMemberDeclaration(n);
            else if (n is FieldDeclaration) endVisitFieldDeclaration(n);
            else if (n is VariableDeclarators) endVisitVariableDeclarators(n);
            else if (n is VariableDeclarator) endVisitVariableDeclarator(n);
            else if (n is VariableDeclaratorId) endVisitVariableDeclaratorId(n);
            else if (n is FieldModifiers) endVisitFieldModifiers(n);
            else if (n is MethodDeclaration) endVisitMethodDeclaration(n);
            else if (n is MethodHeader) endVisitMethodHeader(n);
            else if (n is ResultType) endVisitResultType(n);
            else if (n is FormalParameterList) endVisitFormalParameterList(n);
            else if (n is FormalParameters) endVisitFormalParameters(n);
            else if (n is FormalParameter) endVisitFormalParameter(n);
            else if (n is VariableModifiers) endVisitVariableModifiers(n);
            else if (n is VariableModifier) endVisitVariableModifier(n);
            else if (n is LastFormalParameter) endVisitLastFormalParameter(n);
            else if (n is MethodModifiers) endVisitMethodModifiers(n);
            else if (n is Throws) endVisitThrows(n);
            else if (n is ExceptionTypeList) endVisitExceptionTypeList(n);
            else if (n is MethodBody) endVisitMethodBody(n);
            else if (n is StaticInitializer) endVisitStaticInitializer(n);
            else if (n is ConstructorDeclaration) endVisitConstructorDeclaration(n);
            else if (n is ConstructorDeclarator) endVisitConstructorDeclarator(n);
            else if (n is ConstructorModifiers) endVisitConstructorModifiers(n);
            else if (n is ConstructorBody) endVisitConstructorBody(n);
            else if (n is EnumDeclaration) endVisitEnumDeclaration(n);
            else if (n is EnumBody) endVisitEnumBody(n);
            else if (n is EnumConstants) endVisitEnumConstants(n);
            else if (n is EnumConstant) endVisitEnumConstant(n);
            else if (n is Arguments) endVisitArguments(n);
            else if (n is EnumBodyDeclarations) endVisitEnumBodyDeclarations(n);
            else if (n is NormalInterfaceDeclaration) endVisitNormalInterfaceDeclaration(n);
            else if (n is InterfaceModifiers) endVisitInterfaceModifiers(n);
            else if (n is InterfaceBody) endVisitInterfaceBody(n);
            else if (n is InterfaceMemberDeclarations) endVisitInterfaceMemberDeclarations(n);
            else if (n is InterfaceMemberDeclaration) endVisitInterfaceMemberDeclaration(n);
            else if (n is ConstantDeclaration) endVisitConstantDeclaration(n);
            else if (n is ConstantModifiers) endVisitConstantModifiers(n);
            else if (n is AbstractMethodDeclaration) endVisitAbstractMethodDeclaration(n);
            else if (n is AbstractMethodModifiers) endVisitAbstractMethodModifiers(n);
            else if (n is AnnotationTypeDeclaration) endVisitAnnotationTypeDeclaration(n);
            else if (n is AnnotationTypeBody) endVisitAnnotationTypeBody(n);
            else if (n is AnnotationTypeElementDeclarations) endVisitAnnotationTypeElementDeclarations(n);
            else if (n is DefaultValue) endVisitDefaultValue(n);
            else if (n is Annotations) endVisitAnnotations(n);
            else if (n is NormalAnnotation) endVisitNormalAnnotation(n);
            else if (n is ElementValuePairs) endVisitElementValuePairs(n);
            else if (n is ElementValuePair) endVisitElementValuePair(n);
            else if (n is ElementValueArrayInitializer) endVisitElementValueArrayInitializer(n);
            else if (n is ElementValues) endVisitElementValues(n);
            else if (n is MarkerAnnotation) endVisitMarkerAnnotation(n);
            else if (n is SingleElementAnnotation) endVisitSingleElementAnnotation(n);
            else if (n is ArrayInitializer) endVisitArrayInitializer(n);
            else if (n is VariableInitializers) endVisitVariableInitializers(n);
            else if (n is Block) endVisitBlock(n);
            else if (n is BlockStatements) endVisitBlockStatements(n);
            else if (n is LocalVariableDeclarationStatement) endVisitLocalVariableDeclarationStatement(n);
            else if (n is LocalVariableDeclaration) endVisitLocalVariableDeclaration(n);
            else if (n is IfThenStatement) endVisitIfThenStatement(n);
            else if (n is IfThenElseStatement) endVisitIfThenElseStatement(n);
            else if (n is IfThenElseStatementNoShortIf) endVisitIfThenElseStatementNoShortIf(n);
            else if (n is EmptyStatement) endVisitEmptyStatement(n);
            else if (n is LabeledStatement) endVisitLabeledStatement(n);
            else if (n is LabeledStatementNoShortIf) endVisitLabeledStatementNoShortIf(n);
            else if (n is ExpressionStatement) endVisitExpressionStatement(n);
            else if (n is SwitchStatement) endVisitSwitchStatement(n);
            else if (n is SwitchBlock) endVisitSwitchBlock(n);
            else if (n is SwitchBlockStatementGroups) endVisitSwitchBlockStatementGroups(n);
            else if (n is SwitchBlockStatementGroup) endVisitSwitchBlockStatementGroup(n);
            else if (n is SwitchLabels) endVisitSwitchLabels(n);
            else if (n is WhileStatement) endVisitWhileStatement(n);
            else if (n is WhileStatementNoShortIf) endVisitWhileStatementNoShortIf(n);
            else if (n is DoStatement) endVisitDoStatement(n);
            else if (n is BasicForStatement) endVisitBasicForStatement(n);
            else if (n is ForStatementNoShortIf) endVisitForStatementNoShortIf(n);
            else if (n is StatementExpressionList) endVisitStatementExpressionList(n);
            else if (n is EnhancedForStatement) endVisitEnhancedForStatement(n);
            else if (n is BreakStatement) endVisitBreakStatement(n);
            else if (n is ContinueStatement) endVisitContinueStatement(n);
            else if (n is ReturnStatement) endVisitReturnStatement(n);
            else if (n is ThrowStatement) endVisitThrowStatement(n);
            else if (n is SynchronizedStatement) endVisitSynchronizedStatement(n);
            else if (n is Catches) endVisitCatches(n);
            else if (n is CatchClause) endVisitCatchClause(n);
            else if (n is Finally) endVisitFinally(n);
            else if (n is ArgumentList) endVisitArgumentList(n);
            else if (n is DimExprs) endVisitDimExprs(n);
            else if (n is DimExpr) endVisitDimExpr(n);
            else if (n is PostIncrementExpression) endVisitPostIncrementExpression(n);
            else if (n is PostDecrementExpression) endVisitPostDecrementExpression(n);
            else if (n is PreIncrementExpression) endVisitPreIncrementExpression(n);
            else if (n is PreDecrementExpression) endVisitPreDecrementExpression(n);
            else if (n is AndExpression) endVisitAndExpression(n);
            else if (n is ExclusiveOrExpression) endVisitExclusiveOrExpression(n);
            else if (n is InclusiveOrExpression) endVisitInclusiveOrExpression(n);
            else if (n is ConditionalAndExpression) endVisitConditionalAndExpression(n);
            else if (n is ConditionalOrExpression) endVisitConditionalOrExpression(n);
            else if (n is ConditionalExpression) endVisitConditionalExpression(n);
            else if (n is Assignment) endVisitAssignment(n);
            else if (n is Commaopt) endVisitCommaopt(n);
            else if (n is Ellipsisopt) endVisitEllipsisopt(n);
            else if (n is LPGUserAction0) endVisitLPGUserAction0(n);
            else if (n is LPGUserAction1) endVisitLPGUserAction1(n);
            else if (n is LPGUserAction2) endVisitLPGUserAction2(n);
            else if (n is LPGUserAction3) endVisitLPGUserAction3(n);
            else if (n is LPGUserAction4) endVisitLPGUserAction4(n);
            else if (n is IntegralType0) endVisitIntegralType0(n);
            else if (n is IntegralType1) endVisitIntegralType1(n);
            else if (n is IntegralType2) endVisitIntegralType2(n);
            else if (n is IntegralType3) endVisitIntegralType3(n);
            else if (n is IntegralType4) endVisitIntegralType4(n);
            else if (n is FloatingPointType0) endVisitFloatingPointType0(n);
            else if (n is FloatingPointType1) endVisitFloatingPointType1(n);
            else if (n is WildcardBounds0) endVisitWildcardBounds0(n);
            else if (n is WildcardBounds1) endVisitWildcardBounds1(n);
            else if (n is ClassModifier0) endVisitClassModifier0(n);
            else if (n is ClassModifier1) endVisitClassModifier1(n);
            else if (n is ClassModifier2) endVisitClassModifier2(n);
            else if (n is ClassModifier3) endVisitClassModifier3(n);
            else if (n is ClassModifier4) endVisitClassModifier4(n);
            else if (n is ClassModifier5) endVisitClassModifier5(n);
            else if (n is ClassModifier6) endVisitClassModifier6(n);
            else if (n is FieldModifier0) endVisitFieldModifier0(n);
            else if (n is FieldModifier1) endVisitFieldModifier1(n);
            else if (n is FieldModifier2) endVisitFieldModifier2(n);
            else if (n is FieldModifier3) endVisitFieldModifier3(n);
            else if (n is FieldModifier4) endVisitFieldModifier4(n);
            else if (n is FieldModifier5) endVisitFieldModifier5(n);
            else if (n is FieldModifier6) endVisitFieldModifier6(n);
            else if (n is MethodDeclarator0) endVisitMethodDeclarator0(n);
            else if (n is MethodDeclarator1) endVisitMethodDeclarator1(n);
            else if (n is MethodModifier0) endVisitMethodModifier0(n);
            else if (n is MethodModifier1) endVisitMethodModifier1(n);
            else if (n is MethodModifier2) endVisitMethodModifier2(n);
            else if (n is MethodModifier3) endVisitMethodModifier3(n);
            else if (n is MethodModifier4) endVisitMethodModifier4(n);
            else if (n is MethodModifier5) endVisitMethodModifier5(n);
            else if (n is MethodModifier6) endVisitMethodModifier6(n);
            else if (n is MethodModifier7) endVisitMethodModifier7(n);
            else if (n is MethodModifier8) endVisitMethodModifier8(n);
            else if (n is ConstructorModifier0) endVisitConstructorModifier0(n);
            else if (n is ConstructorModifier1) endVisitConstructorModifier1(n);
            else if (n is ConstructorModifier2) endVisitConstructorModifier2(n);
            else if (n is ExplicitConstructorInvocation0) endVisitExplicitConstructorInvocation0(n);
            else if (n is ExplicitConstructorInvocation1) endVisitExplicitConstructorInvocation1(n);
            else if (n is ExplicitConstructorInvocation2) endVisitExplicitConstructorInvocation2(n);
            else if (n is InterfaceModifier0) endVisitInterfaceModifier0(n);
            else if (n is InterfaceModifier1) endVisitInterfaceModifier1(n);
            else if (n is InterfaceModifier2) endVisitInterfaceModifier2(n);
            else if (n is InterfaceModifier3) endVisitInterfaceModifier3(n);
            else if (n is InterfaceModifier4) endVisitInterfaceModifier4(n);
            else if (n is InterfaceModifier5) endVisitInterfaceModifier5(n);
            else if (n is ExtendsInterfaces0) endVisitExtendsInterfaces0(n);
            else if (n is ExtendsInterfaces1) endVisitExtendsInterfaces1(n);
            else if (n is ConstantModifier0) endVisitConstantModifier0(n);
            else if (n is ConstantModifier1) endVisitConstantModifier1(n);
            else if (n is ConstantModifier2) endVisitConstantModifier2(n);
            else if (n is AbstractMethodModifier0) endVisitAbstractMethodModifier0(n);
            else if (n is AbstractMethodModifier1) endVisitAbstractMethodModifier1(n);
            else if (n is AnnotationTypeElementDeclaration0) endVisitAnnotationTypeElementDeclaration0(n);
            else if (n is AnnotationTypeElementDeclaration1) endVisitAnnotationTypeElementDeclaration1(n);
            else if (n is AssertStatement0) endVisitAssertStatement0(n);
            else if (n is AssertStatement1) endVisitAssertStatement1(n);
            else if (n is SwitchLabel0) endVisitSwitchLabel0(n);
            else if (n is SwitchLabel1) endVisitSwitchLabel1(n);
            else if (n is SwitchLabel2) endVisitSwitchLabel2(n);
            else if (n is TryStatement0) endVisitTryStatement0(n);
            else if (n is TryStatement1) endVisitTryStatement1(n);
            else if (n is PrimaryNoNewArray0) endVisitPrimaryNoNewArray0(n);
            else if (n is PrimaryNoNewArray1) endVisitPrimaryNoNewArray1(n);
            else if (n is PrimaryNoNewArray2) endVisitPrimaryNoNewArray2(n);
            else if (n is PrimaryNoNewArray3) endVisitPrimaryNoNewArray3(n);
            else if (n is PrimaryNoNewArray4) endVisitPrimaryNoNewArray4(n);
            else if (n is Literal0) endVisitLiteral0(n);
            else if (n is Literal1) endVisitLiteral1(n);
            else if (n is Literal2) endVisitLiteral2(n);
            else if (n is Literal3) endVisitLiteral3(n);
            else if (n is Literal4) endVisitLiteral4(n);
            else if (n is Literal5) endVisitLiteral5(n);
            else if (n is Literal6) endVisitLiteral6(n);
            else if (n is BooleanLiteral0) endVisitBooleanLiteral0(n);
            else if (n is BooleanLiteral1) endVisitBooleanLiteral1(n);
            else if (n is ClassInstanceCreationExpression0) endVisitClassInstanceCreationExpression0(n);
            else if (n is ClassInstanceCreationExpression1) endVisitClassInstanceCreationExpression1(n);
            else if (n is ArrayCreationExpression0) endVisitArrayCreationExpression0(n);
            else if (n is ArrayCreationExpression1) endVisitArrayCreationExpression1(n);
            else if (n is ArrayCreationExpression2) endVisitArrayCreationExpression2(n);
            else if (n is ArrayCreationExpression3) endVisitArrayCreationExpression3(n);
            else if (n is Dims0) endVisitDims0(n);
            else if (n is Dims1) endVisitDims1(n);
            else if (n is FieldAccess0) endVisitFieldAccess0(n);
            else if (n is FieldAccess1) endVisitFieldAccess1(n);
            else if (n is FieldAccess2) endVisitFieldAccess2(n);
            else if (n is MethodInvocation0) endVisitMethodInvocation0(n);
            else if (n is MethodInvocation1) endVisitMethodInvocation1(n);
            else if (n is MethodInvocation2) endVisitMethodInvocation2(n);
            else if (n is MethodInvocation3) endVisitMethodInvocation3(n);
            else if (n is MethodInvocation4) endVisitMethodInvocation4(n);
            else if (n is ArrayAccess0) endVisitArrayAccess0(n);
            else if (n is ArrayAccess1) endVisitArrayAccess1(n);
            else if (n is UnaryExpression0) endVisitUnaryExpression0(n);
            else if (n is UnaryExpression1) endVisitUnaryExpression1(n);
            else if (n is UnaryExpressionNotPlusMinus0) endVisitUnaryExpressionNotPlusMinus0(n);
            else if (n is UnaryExpressionNotPlusMinus1) endVisitUnaryExpressionNotPlusMinus1(n);
            else if (n is CastExpression0) endVisitCastExpression0(n);
            else if (n is CastExpression1) endVisitCastExpression1(n);
            else if (n is MultiplicativeExpression0) endVisitMultiplicativeExpression0(n);
            else if (n is MultiplicativeExpression1) endVisitMultiplicativeExpression1(n);
            else if (n is MultiplicativeExpression2) endVisitMultiplicativeExpression2(n);
            else if (n is AdditiveExpression0) endVisitAdditiveExpression0(n);
            else if (n is AdditiveExpression1) endVisitAdditiveExpression1(n);
            else if (n is ShiftExpression0) endVisitShiftExpression0(n);
            else if (n is ShiftExpression1) endVisitShiftExpression1(n);
            else if (n is ShiftExpression2) endVisitShiftExpression2(n);
            else if (n is RelationalExpression0) endVisitRelationalExpression0(n);
            else if (n is RelationalExpression1) endVisitRelationalExpression1(n);
            else if (n is RelationalExpression2) endVisitRelationalExpression2(n);
            else if (n is RelationalExpression3) endVisitRelationalExpression3(n);
            else if (n is RelationalExpression4) endVisitRelationalExpression4(n);
            else if (n is EqualityExpression0) endVisitEqualityExpression0(n);
            else if (n is EqualityExpression1) endVisitEqualityExpression1(n);
            else if (n is AssignmentOperator0) endVisitAssignmentOperator0(n);
            else if (n is AssignmentOperator1) endVisitAssignmentOperator1(n);
            else if (n is AssignmentOperator2) endVisitAssignmentOperator2(n);
            else if (n is AssignmentOperator3) endVisitAssignmentOperator3(n);
            else if (n is AssignmentOperator4) endVisitAssignmentOperator4(n);
            else if (n is AssignmentOperator5) endVisitAssignmentOperator5(n);
            else if (n is AssignmentOperator6) endVisitAssignmentOperator6(n);
            else if (n is AssignmentOperator7) endVisitAssignmentOperator7(n);
            else if (n is AssignmentOperator8) endVisitAssignmentOperator8(n);
            else if (n is AssignmentOperator9) endVisitAssignmentOperator9(n);
            else if (n is AssignmentOperator10) endVisitAssignmentOperator10(n);
            else if (n is AssignmentOperator11) endVisitAssignmentOperator11(n);
            throw  ArgumentError("visit(" + n.toString() + ")");
        }
    }

